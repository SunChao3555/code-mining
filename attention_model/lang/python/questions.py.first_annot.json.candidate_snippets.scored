(dp0
I3061761
(dp1
S'a[1, 0]'
p2
(F-2.1341657638549805
F-3.3648956298828123
tp3
sS'import numpy as np\na = np.array([[1, 2], [3, 4]])'
p4
(F-0.7892083768491391
F-2.8158363342285155
tp5
sS'a = [[1, 2], [1, 2]]'
p6
(F-1.3366650974049288
F-3.296415328979492
tp7
sS'a.ndim'
p8
(F-2.6619491577148438
F-2.0650283813476564
tp9
sS'a = np.array([[1, 2], [3, 4]])'
p10
(F-0.910902283408425
F-2.757518005371094
tp11
sS'a = [[1, 2], [1, 2]]\nN.shape(a)'
p12
(F-1.6194883982340496
F-2.6090871810913088
tp13
sS'a.shape'
p14
(F-1.8959112167358398
F-2.7743396759033203
tp15
sS'import numpy as np'
p16
(F-1.5752007166544597
F-3.2827079772949217
tp17
sS'N.shape(a)'
p18
(F-2.553666591644287
F-2.4145111083984374
tp19
ssI379906
(dp20
S'def num(s):\n    pass'
p21
(F-1.8797130584716797
F-3.0945210456848145
tp22
sS'return False'
p23
(F-3.1849377155303955
F-3.904925584793091
tp24
sS'return float(s)'
p25
(F-2.136578151157924
F-2.6986641883850098
tp26
sS"a = '545.2222'"
p27
(F-1.9251846313476562
F-3.4509613513946533
tp28
sS'float(value)'
p29
(F-1.9919122060139973
F-2.745225191116333
tp30
sS"a = '545.2222'\nfloat(a)\nint(float(a))"
p31
(F-1.7244370778401692
F-2.6723341941833496
tp32
sS'return True'
p33
(F-3.0883045196533203
F-3.818767786026001
tp34
sS'float(a)\nint(float(a))'
p35
(F-2.012090274265834
F-2.7849550247192383
tp36
sS'float(a)'
p37
(F-1.7741634051005046
F-2.844658851623535
tp38
sS"a = '545.2222'\nfloat(a)"
p39
(F-1.6513748168945312
F-2.7595510482788086
tp40
sS'return int(s)'
p41
(F-2.0127793720790317
F-2.7150635719299316
tp42
sS'int(float(a))'
p43
(F-1.7392483817206488
F-2.693215847015381
tp44
sS'def isfloat(value):\n    pass'
p45
(F-1.329414923985799
F-3.6613781452178955
tp46
ssI3437059
(dp47
S"if s.find('is') == -1:\n    pass\n"
p48
(F-1.5527859856100643
F-3.7752532958984375
tp49
sS'print "Found \'is\' in the string."'
p50
(F-2.0441951751708984
F-3.650509227405895
tp51
sS'continue'
p52
(F-3.597015062967936
F-4.0337371826171875
tp53
sS's = \'This be a string\'\nif s.find(\'is\') == -1:\n    print "No \'is\' here!"\nelse:\n    pass'
p54
(F-1.0293372581745017
F-3.693566755814986
tp55
sS'if s.find(\'is\') == -1:\n    print "No \'is\' here!"\nelse:\n    pass'
p56
(F-1.1047915649414062
F-3.72416860407049
tp57
sS'if s.find(\'is\') == -1:\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p58
(F-0.9215456155630258
F-3.710039658979936
tp59
sS"s = 'This be a string'\nif s.find('is') == -1:\n    pass"
p60
(F-1.3680076599121094
F-3.7350678877397017
tp61
sS'print "No \'is\' here!"'
p62
(F-2.0441951751708984
F-3.650509227405895
tp63
sS"if 'blah' not in somestring:\n    pass"
p64
(F-1.9667867024739583
F-3.5986848310990767
tp65
sS"s = 'This be a string'\nif s.find('is') == -1:\n    pass\n"
p66
(F-1.3680076599121094
F-3.7350678877397017
tp67
sS"if s.find('is') == -1:\n    pass"
p68
(F-1.5527859856100643
F-3.7752532958984375
tp69
sS's = \'This be a string\'\nif s.find(\'is\') == -1:\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p70
(F-0.8902812957763672
F-3.6822100552645596
tp71
sS"s = 'This be a string'"
p72
(F-1.7557212829589843
F-3.6330524791370737
tp73
sS"if 'blah' not in somestring:\n    continue"
p74
(F-2.168436050415039
F-3.6395763050426138
tp75
ssI4265988
(dp76
S'R = max(i for r in [random.random()] for i, c in cdf if c <= r)'
p77
(F-3.528940200805664
F-3.4117091496785483
tp78
sS'for item, prob in l:\n    s += prob\nif s >= r:\n    return item\nreturn item'
p79
(F-3.0954858187971444
F-3.6265430450439453
tp80
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor item, prob in l:\n    s += prob\nif s >= r:\n    return item\nreturn item'
p81
(F-2.19473349831321
F-3.2428709665934243
tp82
sS'numpy.random.choice(numpy.arange(1, 7), p=[0.1, 0.05, 0.05, 0.2, 0.4, 0.2])'
p83
(F-2.274221015698982
F-3.493292490641276
tp84
sS's = 0\nfor item, prob in l:\n    s += prob\nif s >= r:\n    return item\nreturn item'
p85
(F-2.8752120046904595
F-3.6364529927571616
tp86
sS'if s >= r:\n    return item'
p87
(F-3.1993497212727866
F-4.111822128295898
tp88
sS'if s >= r:\n    return item\nreturn item'
p89
(F-3.1559549967447915
F-4.122482617696126
tp90
sS'cdf = [(i, sum(p for j, p in pdf if j < i)) for i, _ in pdf]'
p91
(F-3.119769918507543
F-3.48880926767985
tp92
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum(p for j, p in pdf if j < i)) for i, _ in pdf]'
p93
(F-2.3360611183055933
F-3.5610173543294272
tp94
sS'sorted(max(i for r in [random.random()] for i, c in cdf if c <= r) for _ in\n    range(1000))'
p95
(F-3.8047082689073353
F-3.643803914388021
tp96
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]'
p97
(F-1.9529428249452172
F-3.741025924682617
tp98
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor item, prob in l:\n    s += prob'
p99
(F-2.0768961092320883
F-3.170565923055013
tp100
sS'for item, prob in l:\n    s += prob'
p101
(F-3.375724283854167
F-3.566591262817383
tp102
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor item, prob in l:\n    s += prob\nif s >= r:\n    return item'
p103
(F-2.1758094200721154
F-3.2241910298665366
tp104
sS's = 0\nfor item, prob in l:\n    s += prob\nif s >= r:\n    pass'
p105
(F-2.864943668760102
F-3.6279354095458984
tp106
sS'if s >= r:\n    pass'
p107
(F-2.809233058582653
F-4.185555775960286
tp108
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0'
p109
(F-1.653625770851418
F-3.120187759399414
tp110
sS'for item, prob in l:\n    pass'
p111
(F-2.970906477708083
F-3.7743504842122397
tp112
sS'return item'
p113
(F-3.9090654850006104
F-4.487557411193848
tp114
sS'for item, prob in l:\n    s += prob\nif s >= r:\n    pass'
p115
(F-3.0877346801757812
F-3.612659772237142
tp116
sS's = 0'
p117
(F-3.4313892364501952
F-4.273521741231282
tp118
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor item, prob in l:\n    s += prob\nif s >= r:\n    pass'
p119
(F-2.1251754760742188
F-3.23232364654541
tp120
sS's = 0\nfor item, prob in l:\n    s += prob\nif s >= r:\n    return item'
p121
(F-2.9246724446614585
F-3.6191794077555337
tp122
sS'r = random.uniform(0, 1)'
p123
(F-1.7356362342834473
F-3.1452306111653647
tp124
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor item, prob in l:\n    pass'
p125
(F-1.9252886649889824
F-3.160424550374349
tp126
sS'def random_distr(l):\n    r = random.uniform(0, 1)'
p127
(F-1.3924646792204485
F-3.10191281636556
tp128
sS'def random_distr(l):\n    pass'
p129
(F-1.661490031651088
F-3.455766042073568
tp130
sS's = 0\nfor item, prob in l:\n    pass'
p131
(F-2.945213991052964
F-3.743342081705729
tp132
sS'cdf = [(i, sum(p for j, p in pdf if j < i)) for i, _ in pdf]\nR = max(i for r in [random.random()] for i, c in cdf if c <= r)'
p133
(F-3.325591496058873
F-3.4715789159139
tp134
sS's += prob'
p135
(F-4.908156204223633
F-3.7371107737223306
tp136
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum(p for j, p in pdf if j < i)) for i, _ in pdf]\nR = max(i for r in [random.random()] for i, c in cdf if c <= r)'
p137
(F-2.6675259272257485
F-3.5091689427693686
tp138
sS's = 0\nfor item, prob in l:\n    s += prob'
p139
(F-3.1809162340666117
F-3.573582649230957
tp140
sS'for item, prob in l:\n    s += prob\nif s >= r:\n    return item'
p141
(F-3.1171596233661356
F-3.6050427754720054
tp142
ssI843277
(dp143
S'my_variable = None'
p144
(F-2.9261507306780135
F-1.484789414839311
tp145
sS"if 'myVar' in globals():\n    pass"
p146
(F-1.2680524679330678
F-1.3427881761030718
tp147
sS'my_variable = None\n\ndef InitMyVariable():\n    pass'
p148
(F-2.8806962966918945
F-1.6481912786310369
tp149
sS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable\nif my_variable is None:\n    pass'
p150
(F-2.577606419154576
F-1.5001655925403943
tp151
sS'try:\n    myVar\nexcept NameError:\n    myVar = None'
p152
(F-2.420788356236049
F-1.3208725669167258
tp153
sS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable'
p154
(F-2.944829526154891
F-1.5908076546408914
tp155
sS'def InitMyVariable():\n    pass'
p156
(F-3.257132603571965
F-1.7671945745294744
tp157
sS'myVar = None'
p158
(F-3.5085531870524087
F-1.4927298805930398
tp159
sS'if my_variable is None:\n    pass'
p160
(F-1.7270425649789662
F-1.3453594554554333
tp161
sS"if hasattr(obj, 'attr_name'):\n    pass"
p162
(F-1.0345313889639718
F-1.381892984563654
tp163
sS'global my_variable'
p164
(F-3.223841985066732
F-1.3758792877197266
tp165
sS'pass'
p166
(F-2.7576707204182944
F-1.4730654629794033
tp167
sS'myVar'
p168
(F-5.141397953033447
F-1.4456860802390359
tp169
sS'def InitMyVariable():\n    global my_variable\nif my_variable is None:\n    pass'
p170
(F-2.9056407383510043
F-1.5137913443825461
tp171
sS'def InitMyVariable():\n    global my_variable'
p172
(F-3.617995262145996
F-1.6427399028431287
tp173
sS'try:\n    myVar\nexcept NameError:\n    pass'
p174
(F-1.9383405049641926
F-1.301599762656472
tp175
sS"if 'myVar' in locals():\n    pass"
p176
(F-1.1909523010253906
F-1.471257816661488
tp177
ssI546321
(dp178
S'import datetime'
p179
(F-2.1114449501037598
F-2.835702896118164
tp180
sS'from datetime import date'
p181
(F-1.5441166559855144
F-2.7736812591552735
tp182
sS'from datetime import date\nfrom dateutil.relativedelta import relativedelta\nsix_months = date.today() + relativedelta(months=+6)'
p183
(F-2.0273009269468245
F-2.586750030517578
tp184
sS'date += datetime.timedelta(6 * 30)'
p185
(F-2.7958199183146157
F-2.7460964202880858
tp186
sS'print (datetime.date.today() + datetime.timedelta(6 * 365 / 12)).isoformat()'
p187
(F-1.7480234216760706
F-2.7724241256713866
tp188
sS'date(2010, 12, 31) + relativedelta(months=+1)'
p189
(F-2.880740271674262
F-2.7836803436279296
tp190
sS'six_months = date.today() + relativedelta(months=+6)'
p191
(F-2.9833084909539473
F-2.957713317871094
tp192
sS'from datetime import date\nfrom dateutil.relativedelta import relativedelta'
p193
(F-1.251642080453726
F-2.6296976089477537
tp194
sS'from dateutil.relativedelta import relativedelta\nsix_months = date.today() + relativedelta(months=+6)'
p195
(F-2.262228305523212
F-2.670953369140625
tp196
sS'day, month, year = day, (month + 6) % 12, year + (month + 6) / 12'
p197
(F-3.225194295247396
F-2.8415679931640625
tp198
sS'import datetime\nprint (datetime.date.today() + datetime.timedelta(6 * 365 / 12)).isoformat()'
p199
(F-1.529523213704427
F-2.6622549057006837
tp200
sS'date(2010, 12, 31) + relativedelta(months=+2)'
p201
(F-2.9979436662462025
F-2.782400703430176
tp202
sS'date(2010, 12, 31) + relativedelta(months=+1)\ndate(2010, 12, 31) + relativedelta(months=+2)'
p203
(F-2.9427858625139507
F-2.7686651229858397
tp204
sS'from dateutil.relativedelta import relativedelta'
p205
(F-1.5380449295043945
F-2.7003326416015625
tp206
ssI237079
(dp207
S'def modification_date(filename):\n    pass'
p208
(F-1.6896866389683314
F-4.085059611002604
tp209
sS'import datetime'
p210
(F-2.26352596282959
F-4.315620930989583
tp211
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p212
(F-1.6276358710394965
F-4.150559743245442
tp213
sS'import platform\n\ndef creation_date(path_to_file):\n    pass'
p214
(F-2.0639143857088955
F-4.239694976806641
tp215
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p216
(F-1.6447953849003232
F-4.261880493164062
tp217
sS"if platform.system() == 'Windows':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)"
p218
(F-1.6018673366970486
F-4.257321166992187
tp219
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p220
(F-1.725198685495477
F-4.119842020670573
tp221
sS'def creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    pass'
p222
(F-2.1438040733337402
F-4.272215779622396
tp223
sS'return datetime.datetime.fromtimestamp(t)'
p224
(F-1.9408212141557173
F-4.083964538574219
tp225
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)'
p226
(F-1.8120449290556067
F-4.260749816894531
tp227
sS'print repr(d)'
p228
(F-3.0714173998151506
F-4.181915791829427
tp229
sS"d = modification_date('/var/log/syslog')"
p230
(F-2.7868247985839845
F-4.321047465006511
tp231
sS"import os, time\nmode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime = os.stat(file)\nprint 'last modified: %s' % time.ctime(mtime)"
p232
(F-2.6927429908929867
F-4.040845235188802
tp233
sS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p234
(F-1.361494528280722
F-3.8842091878255207
tp235
sS"if platform.system() == 'Windows':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass"
p236
(F-1.5453072750207149
F-4.190535481770834
tp237
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    pass'
p238
(F-1.8212135314941407
F-4.189527130126953
tp239
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p240
(F-1.2697956085205078
F-3.8640513102213543
tp241
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p242
(F-1.3144416809082031
F-3.843706512451172
tp243
sS'import os, time'
p244
(F-2.0386575063069663
F-4.1867426554361975
tp245
sS'stat = os.stat(path_to_file)'
p246
(F-2.276899610246931
F-4.026323191324869
tp247
sS'import os, time\nmode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime = os.stat(file)'
p248
(F-2.8493157589074336
F-4.1105290730794275
tp249
sS'print d'
p250
(F-4.4441914558410645
F-4.207593282063802
tp251
sS'import platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p252
(F-1.6935079289578843
F-4.153855387369791
tp253
sS'return stat.st_birthtime'
p254
(F-3.1549572944641113
F-4.064456685384115
tp255
sS"print 'created: %s' % time.ctime(os.path.getctime(file))"
p256
(F-1.9862795935736761
F-3.870030466715495
tp257
sS'mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime = os.stat(file)'
p258
(F-3.1616126469203403
F-4.16937484741211
tp259
sS'import datetime\n\ndef modification_date(filename):\n    pass'
p260
(F-1.390337626139323
F-4.060758972167969
tp261
sS"print 'last modified: %s' % time.ctime(os.path.getmtime(file))"
p262
(F-1.6597607930501301
F-3.7963854471842446
tp263
sS'import os\nimport datetime'
p264
(F-1.6698331832885742
F-4.194867451985677
tp265
sS"if platform.system() == 'Windows':\n    pass"
p266
(F-1.6039744059244792
F-4.563516743977865
tp267
sS'def modification_date(filename):\n    t = os.path.getmtime(filename)'
p268
(F-1.6207303586213484
F-3.858636983235677
tp269
sS"if platform.system() == 'Windows':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime"
p270
(F-1.6841486541318222
F-4.151174163818359
tp271
sS"print 'last modified: %s' % time.ctime(mtime)"
p272
(F-2.7379608154296875
F-4.010827128092448
tp273
sS"import os.path, time\nprint 'last modified: %s' % time.ctime(os.path.getmtime(file))"
p274
(F-1.6091709899902344
F-3.847612508138021
tp275
sS'import platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """'
p276
(F-2.096500049937855
F-4.24547602335612
tp277
sS'def creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p278
(F-1.8314653284409468
F-4.173726145426432
tp279
sS'import os.path, time'
p280
(F-2.254535436630249
F-4.181465403238932
tp281
sS'def creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)'
p282
(F-2.02208796414462
F-4.170356241861979
tp283
sS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p284
(F-1.4550511395489727
F-3.8660873413085937
tp285
sS"if platform.system() == 'Windows':\n    return os.path.getctime(path_to_file)\nelse:\n    pass"
p286
(F-1.4727301878087662
F-4.37552235921224
tp287
sS'def creation_date(path_to_file):\n    pass'
p288
(F-2.2760259840223522
F-4.139090220133464
tp289
sS'def creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """'
p290
(F-2.351131863064236
F-4.154468027750651
tp291
sS'import platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)'
p292
(F-1.9221978187561035
F-4.267273457845052
tp293
sS'import os'
p294
(F-1.9791780710220337
F-4.179221852620443
tp295
sS'def creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p296
(F-1.8507427092521422
F-4.118029276529948
tp297
sS'import platform'
p298
(F-2.7409987449645996
F-4.5607655843098955
tp299
sS'def modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p300
(F-1.4825760812470408
F-3.855780283610026
tp301
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    pass'
p302
(F-1.2241483415876115
F-3.992315419514974
tp303
sS't = os.path.getmtime(filename)'
p304
(F-1.8858478864034016
F-3.839299519856771
tp305
sS'return os.path.getctime(path_to_file)'
p306
(F-1.9342318216959635
F-3.9150680541992187
tp307
sS"import os.path, time\nprint 'last modified: %s' % time.ctime(os.path.getmtime(file))\nprint 'created: %s' % time.ctime(os.path.getctime(file))"
p308
(F-1.717893509637742
F-3.80960693359375
tp309
sS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p310
(F-1.635449149391868
F-4.2478185017903645
tp311
sS'def creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p312
(F-1.7487167909920933
F-4.100229899088542
tp313
sS'print d\nprint repr(d)'
p314
(F-3.239071273803711
F-4.237585194905599
tp315
sS'def creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p316
(F-1.848457163030451
F-4.076253000895182
tp317
sS"print 'last modified: %s' % time.ctime(os.path.getmtime(file))\nprint 'created: %s' % time.ctime(os.path.getctime(file))"
p318
(F-1.7962203979492188
F-3.784972381591797
tp319
sS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p320
(F-1.977243494104456
F-4.153099568684896
tp321
sS'import platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p322
(F-1.7800231702399976
F-4.193214670817057
tp323
sS'import platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p324
(F-1.741129511052912
F-4.268556213378906
tp325
sS"d = modification_date('/var/log/syslog')\nprint d\nprint repr(d)"
p326
(F-2.3929324902986226
F-4.170990753173828
tp327
sS'import platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    pass'
p328
(F-1.9790363311767578
F-4.370001729329427
tp329
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    pass'
p330
(F-1.8305090879782653
F-4.361696879069011
tp331
sS'import platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p332
(F-1.7929206516431726
F-4.121710459391276
tp333
sS"d = modification_date('/var/log/syslog')\nprint d"
p334
(F-2.567775139441857
F-4.289813741048177
tp335
sS'import os\nimport platform'
p336
(F-1.9657249450683594
F-4.451030985514323
tp337
sS'return stat.st_mtime'
p338
(F-2.9015088081359863
F-4.022149149576823
tp339
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """\nif platform.system() == \'Windows\':\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p340
(F-1.6986170229704485
F-4.189557139078776
tp341
sS"mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime = os.stat(file)\nprint 'last modified: %s' % time.ctime(mtime)"
p342
(F-2.941624691611842
F-4.094305674235026
tp343
sS"if platform.system() == 'Windows':\n    return os.path.getctime(path_to_file)"
p344
(F-1.7258711920844183
F-4.380403645833334
tp345
sS'"""\nTry to get the date that a file was created, falling back to when it was\nlast modified if that isn\'t possible.\nSee http://stackoverflow.com/a/39501288/1709587 for explanation.\n"""'
p346
(F-2.607715288798014
F-4.16837412516276
tp347
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    """\n    Try to get the date that a file was created, falling back to when it was\n    last modified if that isn\'t possible.\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\n    """'
p348
(F-1.8397294616699218
F-4.194519297281901
tp349
ssI6159900
(dp350
S"f.write('hi there\\n')\nf.write('hi there' + os.linesep)"
p351
(F-1.3220375462582237
F-2.2113413377241655
tp352
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.close()"
p353
(F-0.2239590935085131
F-2.204571984030984
tp354
sS"with open('somefile.txt', 'a') as the_file:\n    pass"
p355
(F-1.0351204342312283
F-2.298642245205966
tp356
sS'f.close()'
p357
(F-0.8657341003417969
F-2.2735727483575996
tp358
sS"the_file.write('Hello\\n')"
p359
(F-1.2876627922058106
F-2.226263393055309
tp360
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)\nf.close()"
p361
(F-0.6102730246151195
F-2.199424050071023
tp362
sS'os.linesep'
p363
(F-3.180838394165039
F-2.618540503761985
tp364
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p365
(F-1.217074984595889
F-2.2208355990323154
tp366
sS"f = open('myfile', 'w')"
p367
(F-0.6175072669982911
F-2.262291127985174
tp368
sS"f.close()\nopen('myfile', 'rb').read()"
p369
(F-1.231443723042806
F-2.270176800814542
tp370
sS"f = open('myfile', 'w')\nf.write('hi there\\n')"
p371
(F-0.4137738732730641
F-2.213313016024503
tp372
sS"with open('somefile.txt', 'a') as the_file:\n    the_file.write('Hello\\n')"
p373
(F-0.8253143310546875
F-2.251991098577326
tp374
sS"open('myfile', 'rb').read()"
p375
(F-0.8737297058105469
F-2.290555953979492
tp376
sS"os.linesep\nf = open('myfile', 'w')"
p377
(F-1.7409702028547014
F-2.2721174413507637
tp378
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)"
p379
(F-0.8023039954049247
F-2.203248630870472
tp380
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p381
(F-1.0792839527130127
F-2.220864035866477
tp382
sS"import os\nos.linesep\nf = open('myfile', 'w')"
p383
(F-1.4652997185202206
F-2.285585056651722
tp384
sS"f.write('hi there' + os.linesep)\nf.close()\nopen('myfile', 'rb').read()"
p385
(F-1.2744399761331493
F-2.229450225830078
tp386
sS"f.write('hi there' + os.linesep)\nf.close()"
p387
(F-1.1615121629503038
F-2.2211449363014917
tp388
sS"f.write('hi there\\n')\nf.write('hi there' + os.linesep)\nf.close()\nopen('myfile', 'rb').read()"
p389
(F-1.1629538006252713
F-2.2184798500754614
tp390
sS"from __future__ import print_function\nprint('hi there', file=f)"
p391
(F-1.4525769886217619
F-2.7045752785422583
tp392
sS'import os'
p393
(F-2.7916955947875977
F-2.693315852772106
tp394
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)\nf.close()"
p395
(F-1.059920260780736
F-2.204469333995472
tp396
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)"
p397
(F-1.1994491577148438
F-2.20785834572532
tp398
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)\nf.close()"
p399
(F-1.002216432152725
F-2.2016112587668677
tp400
sS"f.write('hi there\\n')\nf.close()"
p401
(F-0.5957919529506138
F-2.210141962224787
tp402
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)\nf.close()\nopen('myfile', 'rb').read()"
p403
(F-1.103386585529034
F-2.222828604958274
tp404
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)\nf.close()\nopen('myfile', 'rb').read()"
p405
(F-1.153696176957111
F-2.227777134288441
tp406
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)\nf.close()\nopen('myfile', 'rb').read()"
p407
(F-0.8132015652126736
F-2.2220693068070845
tp408
sS'from __future__ import print_function'
p409
(F-1.0950369834899902
F-2.889015891335227
tp410
sS"f.write('hi there\\n')"
p411
(F-0.8909542560577393
F-2.2236468575217505
tp412
sS"f.write('hi there\\n')\nf.write('hi there' + os.linesep)\nf.close()"
p413
(F-1.0266085815429689
F-2.2065074227072974
tp414
sS'import os\nos.linesep'
p415
(F-2.2718818187713623
F-2.6609217903830786
tp416
sS"f.write('hi there' + os.linesep)"
p417
(F-1.631257692972819
F-2.232934431596236
tp418
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write('hi there' + os.linesep)"
p419
(F-1.2952970266342163
F-2.2088293595747515
tp420
ssI899103
(dp421
S'pickle.dump(itemlist, outfile)'
p422
(F-2.881376838684082
F-1.8244562149047852
tp423
sS'for item in thelist:\n    pass\n'
p424
(F-2.171052239157937
F-2.125139045715332
tp425
sS'print  >> thefile, item'
p426
(F-4.950895036969866
F-1.867856788635254
tp427
sS'itemlist = pickle.load(infile)'
p428
(F-3.5808902740478517
F-1.662255096435547
tp429
sS"for item in thelist:\n    thefile.write('%s\\n' % item)"
p430
(F-1.775490230984158
F-1.434061050415039
tp431
sS"thefile.write('%s\\n' % item)"
p432
(F-1.9614627838134766
F-1.471290397644043
tp433
sS'for item in thelist:\n    pass'
p434
(F-2.171052239157937
F-2.125139045715332
tp435
sS'import pickle'
p436
(F-3.643925666809082
F-1.670689010620117
tp437
sS"outfile.write('\\n'.join(itemlist))"
p438
(F-1.8127781794621394
F-1.766143226623535
tp439
sS'import pickle\npickle.dump(itemlist, outfile)'
p440
(F-2.652510716364934
F-1.7249143600463868
tp441
ssI3939361
(dp442
S"string = 'ab1cd1ef'"
p443
(F-2.110516166687012
F-1.459059715270996
tp444
sS"line = 'abc#@!?efg12;:?'"
p445
(F-2.232899856567383
F-1.5902262687683106
tp446
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p447
(F-1.2089437757219588
F-1.3410131454467773
tp448
sS"string.replace('1', '')"
p449
(F-0.9405929565429687
F-1.4030424118041993
tp450
sS"b = '!@#$'"
p451
(F-2.538133239746094
F-1.5395063400268554
tp452
sS"a = 'a!b@c#d$'"
p453
(F-2.252808952331543
F-1.512653923034668
tp454
sS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)"
p455
(F-3.228962546900699
F-1.9071826934814453
tp456
sS"b = '!@#$'\nfor char in b:\n    pass"
p457
(F-1.7880933125813803
F-1.3392362594604492
tp458
sS"import string\nline = line.translate(string.maketrans('', ''), '!@#$')"
p459
(F-1.9470922296697444
F-1.3725990295410155
tp460
sS'"""""".join(c for c in line if c not in \'?:!/;\')'
p461
(F-1.6971470327938305
F-1.3799675941467284
tp462
sS"for char in b:\n    a = a.replace(char, '')\nprint a"
p463
(F-1.513506847879161
F-1.3279895782470703
tp464
sS'import re'
p465
(F-2.4367759227752686
F-1.459739875793457
tp466
sS"line = line.translate(string.maketrans('', ''), '!@#$')"
p467
(F-1.9026834588301809
F-1.362747573852539
tp468
sS"import re\nline = re.sub('[!@#$]', '', line)"
p469
(F-0.7977941737455481
F-1.3020999908447266
tp470
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    pass"
p471
(F-1.4394744069952714
F-1.338172721862793
tp472
sS'print a'
p473
(F-3.514619827270508
F-1.7088235855102538
tp474
sS"string = 'ab1cd1ef'\nstring.replace('1', '')"
p475
(F-1.0802771704537528
F-1.4064998626708984
tp476
sS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p477
(F-1.4288075764973958
F-1.3377849578857421
tp478
sS'import string'
p479
(F-2.871457576751709
F-1.507864761352539
tp480
sS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)\nunicode_line = unicode_line.translate(translation_table)"
p481
(F-3.2253615435431984
F-1.40795955657959
tp482
sS'for char in b:\n    pass'
p483
(F-2.0230581110174004
F-1.3718415260314942
tp484
sS'line = \'abc#@!?efg12;:?\'\n"""""".join(c for c in line if c not in \'?:!/;\')'
p485
(F-1.8489132835751487
F-1.3639608383178712
tp486
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p487
(F-1.1587125716670867
F-1.3239665985107423
tp488
sS"line = re.sub('[!@#$]', '', line)"
p489
(F-0.8302704266139439
F-1.3280792236328125
tp490
sS"for char in b:\n    a = a.replace(char, '')"
p491
(F-1.560917568206787
F-1.3424458503723145
tp492
sS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p493
(F-1.3660334834346064
F-1.321908664703369
tp494
sS"unicode_line = unicode_line.translate({ord(c): None for c in '!@#$'})"
p495
(F-2.7898403930664064
F-1.497346782684326
tp496
sS'unicode_line = unicode_line.translate(translation_table)'
p497
(F-3.2335598468780518
F-1.4403291702270509
tp498
sS"a = 'a!b@c#d$'\nb = '!@#$'"
p499
(F-1.5047465430365667
F-1.5111412048339843
tp500
sS"a = a.replace(char, '')"
p501
(F-1.7699158986409504
F-1.3855295181274414
tp502
sS"line = line.translate(None, '!@#$')"
p503
(F-2.114622433980306
F-1.3192930221557617
tp504
ssI9001509
(dp505
S"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}"
p506
(F-1.0385237194242931
F-2.1817602677778765
tp507
sS'od[1]'
p508
(F-3.437314987182617
F-2.392392938787287
tp509
sS'for k, v in od.iteritems():\n    pass'
p510
(F-1.3029327392578125
F-1.8972582383589311
tp511
sS'od'
p512
(F-5.724627176920573
F-2.477456873113459
tp513
sS'print k, v'
p514
(F-2.974337895711263
F-2.1881141662597656
tp515
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3}\nfor key in sorted(mydict):\n    pass\n"
p516
(F-1.3099733240464155
F-1.432857340032404
tp517
sS'for key in sorted(mydict):\n    pass'
p518
(F-1.450096811567034
F-1.4704849936745383
tp519
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\nOrderedDict(sorted(d.items(), key=lambda t: t[0]))\nOrderedDict(sorted(d.items(), key=lambda t: t[1]))"
p520
(F-1.1098480224609375
F-1.5017984563654119
tp521
sS'import collections\nd = {(2): 3, (1): 89, (4): 5, (3): 0}\nod = collections.OrderedDict(sorted(d.items()))'
p522
(F-1.888904805086097
F-1.462617353959517
tp523
sS'OrderedDict(sorted(d.items(), key=lambda t: t[1]))'
p524
(F-1.132055441538493
F-1.3832510167902166
tp525
sS'print (k, v)'
p526
(F-1.991248369216919
F-2.282462726939808
tp527
sS'for key in keylist:\n    pass'
p528
(F-1.8417098305442117
F-2.433279037475586
tp529
sS'import collections'
p530
(F-2.0952775478363037
F-1.9216835715553977
tp531
sS'keylist = mydict.keys()\nkeylist.sort()'
p532
(F-2.4876869201660154
F-1.6404809084805576
tp533
sS'for key in sorted(mydict):\n    pass\n'
p534
(F-1.450096811567034
F-1.470484820279208
tp535
sS'keylist.sort()\nfor key in keylist:\n    pass'
p536
(F-2.163870194379021
F-2.016738544810902
tp537
sS'od[1]\nod[3]\nfor k, v in od.iteritems():\n    pass'
p538
(F-2.1565235279224537
F-2.024757732044567
tp539
sS'od[1]\nod[3]'
p540
(F-3.3055475408380683
F-2.386847062544389
tp541
sS'od = collections.OrderedDict(sorted(d.items()))\nod'
p542
(F-1.7914981842041016
F-1.4942951202392578
tp543
sS'keylist = mydict.keys()'
p544
(F-2.6852035522460938
F-2.3756269975142046
tp545
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\nOrderedDict(sorted(d.items(), key=lambda t: t[0]))\nOrderedDict(sorted(d.items(), key=lambda t: t[1]))\nOrderedDict(sorted(d.items(), key=lambda t: len(t[0])))"
p546
(F-1.1874763734879032
F-1.520598671653054
tp547
sS'OrderedDict(sorted(d.items(), key=lambda t: t[0]))\nOrderedDict(sorted(d.items(), key=lambda t: t[1]))'
p548
(F-1.2803458355842752
F-1.4134339419278232
tp549
sS'import collections\nd = {(2): 3, (1): 89, (4): 5, (3): 0}'
p550
(F-2.35422682762146
F-1.905652479691939
tp551
sS'od[3]\nfor k, v in od.iteritems():\n    pass\n'
p552
(F-2.0332990126176314
F-1.9736915935169568
tp553
sS'from collections import OrderedDict'
p554
(F-1.0418662343706404
F-1.594566518610174
tp555
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3}"
p556
(F-1.3618910653250558
F-1.8916393626819958
tp557
sS'OrderedDict(sorted(d.items(), key=lambda t: t[1]))\nOrderedDict(sorted(d.items(), key=lambda t: len(t[0])))'
p558
(F-1.267765350341797
F-1.4199393879283557
tp559
sS'for k, v in od.items():\n    pass\n'
p560
(F-1.159543430103975
F-1.9314890774813565
tp561
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\nOrderedDict(sorted(d.items(), key=lambda t: t[0]))"
p562
(F-0.9618373107910156
F-1.4525260925292969
tp563
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3}\nfor key in sorted(mydict):\n    pass"
p564
(F-1.3099733240464155
F-1.432857340032404
tp565
sS'od[1]\nod[3]\nfor k, v in od.iteritems():\n    pass\n'
p566
(F-2.1565235279224537
F-2.024757732044567
tp567
sS"print '%s: %s' % (key, mydict[key])"
p568
(F-1.6859571016751802
F-2.269304102117365
tp569
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\nOrderedDict(sorted(d.items(), key=lambda t: t[0]))\nOrderedDict(sorted(d.items(), key=lambda t: t[1]))\nOrderedDict(sorted(d.items(), key=lambda t: len(t[0])))"
p570
(F-1.1309424506293402
F-1.4774012132124468
tp571
sS'keylist.sort()\nfor key in keylist:\n    pass\n'
p572
(F-2.163870194379021
F-2.016738544810902
tp573
sS'keylist = mydict.keys()\nkeylist.sort()\nfor key in keylist:\n    pass'
p574
(F-2.217249450683594
F-1.692164507779208
tp575
sS'OrderedDict(sorted(d.items(), key=lambda t: t[0]))'
p576
(F-1.168042262395223
F-1.3854130831631748
tp577
sS'for k, v in od.iteritems():\n    pass\n'
p578
(F-1.3029327392578125
F-1.8972582383589311
tp579
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\nOrderedDict(sorted(d.items(), key=lambda t: t[0]))\nOrderedDict(sorted(d.items(), key=lambda t: t[1]))"
p580
(F-1.050600339288581
F-1.4556222395463423
tp581
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}"
p582
(F-0.9643679018373843
F-1.5565379749644885
tp583
sS'OrderedDict(sorted(d.items(), key=lambda t: len(t[0])))'
p584
(F-1.1079673767089844
F-1.3963110663674094
tp585
sS'od[3]'
p586
(F-3.805379549662272
F-2.38705097545277
tp587
sS'd = {(2): 3, (1): 89, (4): 5, (3): 0}'
p588
(F-2.4582656334186423
F-2.1153026927601206
tp589
sS'keylist = mydict.keys()\nkeylist.sort()\nfor key in keylist:\n    pass\n'
p590
(F-2.217249450683594
F-1.692164507779208
tp591
sS'keylist.sort()'
p592
(F-2.2461227689470564
F-2.27248833396218
tp593
sS'OrderedDict(sorted(d.items(), key=lambda t: t[0]))\nOrderedDict(sorted(d.items(), key=lambda t: t[1]))\nOrderedDict(sorted(d.items(), key=lambda t: len(t[0])))'
p594
(F-1.3469979273129815
F-1.4458261836658826
tp595
sS'for key in keylist:\n    pass\n'
p596
(F-1.8417098305442117
F-2.433279037475586
tp597
sS'd = {(2): 3, (1): 89, (4): 5, (3): 0}\nod = collections.OrderedDict(sorted(d.items()))\nod'
p598
(F-2.1105852127075195
F-1.4718395579944958
tp599
sS'for k, v in od.items():\n    pass'
p600
(F-1.159543430103975
F-1.9314890774813565
tp601
sS'd = {(2): 3, (1): 89, (4): 5, (3): 0}\nod = collections.OrderedDict(sorted(d.items()))'
p602
(F-1.982409435769786
F-1.4682499278675427
tp603
sS'import collections\nd = {(2): 3, (1): 89, (4): 5, (3): 0}\nod = collections.OrderedDict(sorted(d.items()))\nod'
p604
(F-1.9969305898628982
F-1.4660252657803623
tp605
sS'od[3]\nfor k, v in od.iteritems():\n    pass'
p606
(F-2.0332990126176314
F-1.9736915935169568
tp607
sS'od = collections.OrderedDict(sorted(d.items()))'
p608
(F-1.3893828921847873
F-1.4872745167125354
tp609
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2}\nOrderedDict(sorted(d.items(), key=lambda t: t[0]))"
p610
(F-1.0170229131525212
F-1.495518771084872
tp611
ssI2990121
(dp612
S'args = [iter(iterable)] * n'
p613
(F-2.526000658671061
F-2.0795514033390927
tp614
sS'for i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass\n'
p615
(F-1.5151340260225183
F-2.0020470252403846
tp616
sS'for i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p617
(F-1.5151340260225183
F-2.0020470252403846
tp618
sS'pass'
p619
(F-3.2747875849405923
F-2.119335027841421
tp620
sS'return izip_longest(fillvalue=fillvalue, *args)'
p621
(F-1.8926454271589006
F-2.2498638446514425
tp622
sS'def grouper(n, iterable, fillvalue=None):\n    """grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"""\nargs = [iter(iterable)] * n'
p623
(F-1.7214776400862069
F-2.2222276834341197
tp624
sS'for i in mylist[1::2]:\n    pass\n'
p625
(F-1.5786251741297104
F-1.9848624009352465
tp626
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    """grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"""\nargs = [iter(iterable)] * n'
p627
(F-1.4837805258261192
F-2.1295248178335338
tp628
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    """grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"""\nargs = [iter(iterable)] * n\nreturn izip_longest(fillvalue=fillvalue, *args)'
p629
(F-1.30345458984375
F-2.1645132211538463
tp630
sS'for item1, item2 in grouper(2, l):\n    pass'
p631
(F-2.334824244181315
F-2.150029109074519
tp632
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'
p633
(F-0.9581024169921875
F-2.0532889732947717
tp634
sS'print i,'
p635
(F-3.216495895385742
F-2.121598170353816
tp636
sS'args = [iter(iterable)] * n\nreturn izip_longest(fillvalue=fillvalue, *args)'
p637
(F-1.8073521423339844
F-2.078425480769231
tp638
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass\n'
p639
(F-1.3080817913186962
F-2.0308148310734677
tp640
sS'print i'
p641
(F-3.2015743255615234
F-2.1189311100886417
tp642
sS'for i in xrange(0, 10, 2):\n    pass'
p643
(F-1.3675492604573567
F-1.9613163287823017
tp644
sS'def grouper(n, iterable, fillvalue=None):\n    """grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"""'
p645
(F-1.3526687622070312
F-2.250506180983323
tp646
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    pass'
p647
(F-1.1736268997192383
F-2.0342953021709738
tp648
sS'"""grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"""'
p649
(F-3.1242281595865884
F-2.4215479630690355
tp650
sS'def grouper(n, iterable, fillvalue=None):\n    pass'
p651
(F-1.3648125330607097
F-2.2088017096886268
tp652
sS'for i in mylist[::2]:\n    pass'
p653
(F-1.5422513484954834
F-1.9855910081129808
tp654
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p655
(F-1.3080817913186962
F-2.0308148310734677
tp656
sS'from itertools import izip_longest'
p657
(F-1.3796534538269043
F-2.083261930025541
tp658
sS'for i in xrange(0, 10, 2):\n    pass\n'
p659
(F-1.3675492604573567
F-1.9613163287823017
tp660
sS'for i in mylist[1::2]:\n    pass'
p661
(F-1.5786251741297104
F-1.9848626943734975
tp662
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    """grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"""'
p663
(F-1.1521487602820764
F-2.156201876126803
tp664
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    pass'
p665
(F-1.1433534622192383
F-2.1282618596003604
tp666
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    pass\n'
p667
(F-1.1736268997192383
F-2.0342953021709738
tp668
sS'def grouper(n, iterable, fillvalue=None):\n    """grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"""\nargs = [iter(iterable)] * n\nreturn izip_longest(fillvalue=fillvalue, *args)'
p669
(F-1.4352773030598958
F-2.220050518329327
tp670
sS'for i in mylist[::2]:\n    pass\n'
p671
(F-1.5422513484954834
F-1.9855910081129808
tp672
sS'for i in range(0, 10, 2):\n    pass\n'
p673
(F-1.2602678934733074
F-1.9450453244722807
tp674
sS'for i in range(0, 10, 2):\n    pass'
p675
(F-1.2602678934733074
F-1.9450453244722807
tp676
ssI26443308
(dp677
S'"""abcd}def}""".rfind(\'}\')'
p678
(F-2.01729154586792
F-2.6215583801269533
tp679
ssI4174941
(dp680
S'sorted(l, key=lambda x: x[2])'
p681
(F-0.8113360404968262
F-1.7362359364827473
tp682
sS'l.sort(key=lambda x: x[2])'
p683
(F-0.7665504217147827
F-1.7272794511583116
tp684
sS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p685
(F-1.5027477915694074
F-1.6684095594618056
tp686
sS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p687
(F-1.590460415544181
F-2.0504417419433594
tp688
sS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p689
(F-1.5916880439309513
F-1.991898430718316
tp690
sS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p691
(F-1.4095648060674253
F-1.6501024034288194
tp692
sS'sorted(L, key=itemgetter(2))'
p693
(F-1.1556491118211012
F-1.7100989023844402
tp694
sS'from operator import itemgetter'
p695
(F-1.7964455286661785
F-2.096007876925998
tp696
sS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p697
(F-1.6844231178020608
F-1.9544633229573567
tp698
sS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nl.sort(key=lambda x: x[2])"
p699
(F-1.2374449643221768
F-1.7047475179036458
tp700
sS'sorted_list = sorted(list_to_sort, key=itemgetter(2, 0, 1))'
p701
(F-1.6765966796875
F-1.7005605697631836
tp702
ssI3207219
(dp703
S"os.listdir('somedirectory')"
p704
(F-1.2284462451934814
F-1.8557650248209636
tp705
sS'onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p706
(F-1.821075439453125
F-1.9884920120239258
tp707
sS"print glob.glob('/home/adam/*.txt')"
p708
(F-1.3484443028767903
F-1.918554464975993
tp709
sS'for dirpath, dirnames, filenames in walk(mypath):\n    f.extend(filenames)\nbreak'
p710
(F-2.034338073730469
F-1.840451717376709
tp711
sS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = q + w\nq'
p712
(F-2.3821858373181573
F-2.944499969482422
tp713
sS'w = [4, 5, 6]\nq = q + w\nq'
p714
(F-3.4055171765779195
F-2.8540528615315757
tp715
sS'from os.path import isfile, join'
p716
(F-1.3506105422973633
F-1.8860969543457031
tp717
sS'from os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p718
(F-1.443680965539181
F-1.8547115325927734
tp719
sS'from os import listdir'
p720
(F-1.4482558568318684
F-1.8420483271280925
tp721
sS'from os import walk\nf = []\nfor dirpath, dirnames, filenames in walk(mypath):\n    f.extend(filenames)\nbreak'
p722
(F-1.966131591796875
F-1.8216724395751953
tp723
sS'w = [4, 5, 6]'
p724
(F-2.4989887584339487
F-2.7780863444010415
tp725
sS'from os import walk'
p726
(F-1.439034144083659
F-1.8816250165303547
tp727
sS"import glob\nprint glob.glob('/home/adam/*.txt')"
p728
(F-1.0580508708953857
F-1.864639441172282
tp729
sS'from os import listdir\nfrom os.path import isfile, join'
p730
(F-1.124901835123698
F-1.8198870023091633
tp731
sS'for dirpath, dirnames, filenames in walk(mypath):\n    pass'
p732
(F-1.775059700012207
F-1.8497400283813477
tp733
sS'f = []\nfor dirpath, dirnames, filenames in walk(mypath):\n    f.extend(filenames)'
p734
(F-1.922980853489467
F-1.8361787796020508
tp735
sS'f = []\nfor dirpath, dirnames, filenames in walk(mypath):\n    f.extend(filenames)\nbreak'
p736
(F-2.0849127451578777
F-1.8516731262207031
tp737
sS"import os\nos.listdir('somedirectory')"
p738
(F-1.0530331351540305
F-1.8795334498087566
tp739
sS'q = [1, 2, 3]\nw = [4, 5, 6]'
p740
(F-1.7315909976050967
F-2.906193415323893
tp741
sS'break'
p742
(F-3.7237021128336587
F-2.590216954549154
tp743
sS'import glob'
p744
(F-2.787177801132202
F-1.8808763821919758
tp745
sS'import os'
p746
(F-2.023460865020752
F-2.137751579284668
tp747
sS'f = []'
p748
(F-3.0251779556274414
F-2.766338348388672
tp749
sS'from os import walk\nf = []\nfor dirpath, dirnames, filenames in walk(mypath):\n    pass'
p750
(F-1.7883599145071847
F-1.82331116994222
tp751
sS'for dirpath, dirnames, filenames in walk(mypath):\n    f.extend(filenames)'
p752
(F-1.7983584196671196
F-1.8197712898254395
tp753
sS'from os import walk\nf = []\nfor dirpath, dirnames, filenames in walk(mypath):\n    f.extend(filenames)'
p754
(F-1.8118524262399385
F-1.7980519930521648
tp755
sS'q = q + w\nq'
p756
(F-4.967593722873264
F-3.082063357035319
tp757
sS'from os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p758
(F-1.327191202264083
F-1.8270875612894695
tp759
sS'f.extend(filenames)'
p760
(F-3.155409812927246
F-1.9504361152648926
tp761
sS'q'
p762
(F-6.807419459025065
F-2.944007237752279
tp763
sS'from os import walk\nf = []'
p764
(F-2.2305152199485083
F-1.9688789049784343
tp765
sS'q = [1, 2, 3]'
p766
(F-2.00004751032049
F-2.9681030909220376
tp767
sS'q = q + w'
p768
(F-4.737810952322824
F-3.0366605122884116
tp769
sS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = q + w'
p770
(F-2.1870009810836226
F-2.9374237060546875
tp771
sS'w = [4, 5, 6]\nq = q + w'
p772
(F-3.123638153076172
F-2.8472089767456055
tp773
sS'f = []\nfor dirpath, dirnames, filenames in walk(mypath):\n    pass'
p774
(F-1.9116184400475544
F-1.8665215174357097
tp775
ssI3964681
(dp776
S"import glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p777
(F-0.8816091673714774
F-2.852651155911959
tp778
sS"for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass\n"
p779
(F-0.7838699905960648
F-2.8223172701322117
tp780
sS"for root, dirs, files in os.walk('/mydir'):\n    pass"
p781
(F-0.8435420989990234
F-2.836682833158053
tp782
sS'import glob, os'
p783
(F-2.247013886769613
F-3.0599453265850363
tp784
sS"for file in glob.glob('*.txt'):\n    pass\n"
p785
(F-0.9988712072372437
F-2.859239724966196
tp786
sS"for root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p787
(F-0.568160912929437
F-2.7416375967172475
tp788
sS"for file in os.listdir('/mydir'):\n    pass"
p789
(F-1.1205568313598633
F-2.854999835674579
tp790
sS"for file in glob.glob('*.txt'):\n    pass"
p791
(F-0.9988712072372437
F-2.859239724966196
tp792
sS"import glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass\n"
p793
(F-0.8816090992518834
F-2.852651155911959
tp794
sS"import glob\nglob.glob('./*.txt')"
p795
(F-1.059012152931907
F-2.881849142221304
tp796
sS"import os\nfor root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass\n"
p797
(F-0.5231908616565523
F-2.7695224468524637
tp798
sS"os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass\n"
p799
(F-0.8749106033988621
F-2.8290560795710635
tp800
sS"if file.endswith('.txt'):\n    pass\n"
p801
(F-1.2747211456298828
F-3.332173860990084
tp802
sS'print os.path.join(root, file)'
p803
(F-1.0189711497380183
F-3.0450298602764425
tp804
sS"for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p805
(F-0.7838699905960648
F-2.8223172701322117
tp806
sS"import os\nfor file in os.listdir('/mydir'):\n    pass"
p807
(F-0.887716996042352
F-2.896296867957482
tp808
sS"import os\nfor root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p809
(F-0.5231908616565523
F-2.7695224468524637
tp810
sS"import os\nfor root, dirs, files in os.walk('/mydir'):\n    pass"
p811
(F-0.7053825544274371
F-2.884293482853816
tp812
sS'import os'
p813
(F-2.0284266471862793
F-3.3090667724609375
tp814
sS"for root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        pass"
p815
(F-0.6500243459429059
F-2.7713837256798377
tp816
sS"for file in files:\n    if file.endswith('.txt'):\n        pass"
p817
(F-0.9339400204745206
F-2.881069770226112
tp818
sS"import os\nfor root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        pass"
p819
(F-0.5771816622826361
F-2.8104620713454027
tp820
sS"for file in files:\n    if file.endswith('.txt'):\n        pass\n"
p821
(F-0.9339399337768555
F-2.881069770226112
tp822
sS"os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p823
(F-0.8749105204706606
F-2.8290560795710635
tp824
sS"if file.endswith('.txt'):\n    pass"
p825
(F-1.2747211456298828
F-3.332173860990084
tp826
sS'print file'
p827
(F-3.4700658321380615
F-3.404077383188101
tp828
sS"glob.glob('./*.txt')"
p829
(F-0.9094499349594116
F-2.907659677358774
tp830
sS"import os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p831
(F-0.6909159342447917
F-2.8496316763070912
tp832
sS"for root, dirs, files in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass\n"
p833
(F-0.568160912929437
F-2.7416375967172475
tp834
sS"import os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass\n"
p835
(F-0.6909159342447917
F-2.8496316763070912
tp836
sS'import glob'
p837
(F-2.944420576095581
F-3.063036111684946
tp838
sS"os.chdir('/mydir')"
p839
(F-0.6166053414344788
F-3.149217752309946
tp840
sS'for file in files:\n    pass'
p841
(F-1.3949832916259766
F-2.95533693753756
tp842
sS"import glob, os\nos.chdir('/mydir')"
p843
(F-0.8655239985539362
F-3.0319413405198317
tp844
ssI1514553
(dp845
S'f = []\nfor i in range(30):\n    pass'
p846
(F-1.4329992595471834
F-1.3789894104003906
tp847
sS'for i in range(30):\n    f.append(0)'
p848
(F-1.403609326011256
F-1.3929149627685546
tp849
sS'for i in range(30):\n    pass'
p850
(F-1.4000500270298548
F-1.3985286712646485
tp851
sS"intarray = array('i')"
p852
(F-2.2237141132354736
F-1.314657211303711
tp853
sS'f = []\nfor i in range(30):\n    f.append(0)'
p854
(F-1.3592324256896973
F-1.3770197868347167
tp855
sS'f = []'
p856
(F-2.330073833465576
F-1.3235523223876953
tp857
sS'from array import array'
p858
(F-2.869534492492676
F-1.2831796646118163
tp859
sS'variable = []'
p860
(F-2.574655850728353
F-1.417550277709961
tp861
sS"from array import array\nintarray = array('i')"
p862
(F-2.183001444889949
F-1.3517006874084472
tp863
sS'f.append(0)'
p864
(F-2.3881630897521973
F-1.397965908050537
tp865
ssI21887754
(dp866
S'import numpy as np\na = np.array([1, 2, 3])'
p867
(F-0.7083043597993397
F-3.7697653089250838
tp868
sS'print concatenate((a, b), axis=1)'
p869
(F-1.83543701171875
F-4.062221527099609
tp870
sS'np.array([[1, 2, 3], [4, 5, 6]])'
p871
(F-0.8715130488077799
F-3.7521424974714006
tp872
sS'b = np.array([4, 5, 6])\nc = np.r_[a[(None), :], b[(None), :]]\nprint c'
p873
(F-2.319727749294705
F-3.780840737479074
tp874
sS'vstack((a, b))'
p875
(F-1.7832355499267578
F-3.9417871747698103
tp876
sS'a = a.reshape(1, 3)\nb = b.reshape(1, 3)'
p877
(F-1.2003209487251614
F-3.7123069763183594
tp878
sS'a = a.reshape(1, 3)'
p879
(F-1.379360516866048
F-3.729138510567801
tp880
sS'a = a.reshape(1, 3)\nb = b.reshape(1, 3)\nprint concatenate((a, b))'
p881
(F-1.3483840479995266
F-3.718059539794922
tp882
sS'a = np.array([1, 2, 3])'
p883
(F-0.8899513483047485
F-3.857501983642578
tp884
sS'c = np.r_[a[(None), :], b[(None), :]]'
p885
(F-3.21879803692853
F-3.8076425279889787
tp886
sS'a = np.array([[1, 5, 9], [2, 6, 10]])\nb = np.array([[3, 7, 11], [4, 8, 12]])'
p887
(F-1.1235424116546033
F-3.759070260184152
tp888
sS'b = np.array([4, 5, 6])'
p889
(F-1.2531259059906006
F-3.8337710244315013
tp890
sS'print concatenate((a, b), axis=0)\narray([[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]])'
p891
(F-1.5737774188701923
F-4.005002702985491
tp892
sS'b = np.array([4, 5, 6])\nc = np.r_[a[(None), :], b[(None), :]]'
p893
(F-2.3561383201962425
F-3.7578626360212053
tp894
sS'import numpy as np\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nc = np.r_[a[(None), :], b[(None), :]]'
p895
(F-1.6396696029170867
F-3.6816117422921315
tp896
sS'a = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nc = np.r_[a[(None), :], b[(None), :]]\nprint c'
p897
(F-1.7873222351074218
F-3.74713625226702
tp898
sS'print concatenate((a, b), axis=1)\narray([[1, 5, 9, 3, 7, 11], [2, 6, 10, 4, 8, 12]])'
p899
(F-1.793474515279134
F-3.996095929827009
tp900
sS'a = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nvstack((a, b))'
p901
(F-0.9890082359313965
F-3.730408259800502
tp902
sS'print c'
p903
(F-3.6669626235961914
F-5.062117985316685
tp904
sS'array([[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]])'
p905
(F-1.440798006559673
F-3.772712162562779
tp906
sS'b = np.array([4, 5, 6])\nnp.array((a, b))'
p907
(F-1.1571344446252894
F-3.779040745326451
tp908
sS'import numpy as np\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])'
p909
(F-0.6729325188530816
F-3.714360918317522
tp910
sS'array([[1, 5, 9, 3, 7, 11], [2, 6, 10, 4, 8, 12]])'
p911
(F-1.7368848464068245
F-3.8042703356061662
tp912
sS'a = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nc = np.r_[a[(None), :], b[(None), :]]'
p913
(F-1.7902138693290843
F-3.7284673963274275
tp914
sS'c = np.r_[a[(None), :], b[(None), :]]\nprint c'
p915
(F-3.102044932047526
F-3.8445399148123607
tp916
sS'a = np.array([1, 2, 3])\nb = np.array([4, 5, 6])'
p917
(F-0.7915095052411479
F-3.767383575439453
tp918
sS'import numpy as np\na = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nc = np.r_[a[(None), :], b[(None), :]]\nprint c'
p919
(F-1.648107675405649
F-3.696629660470145
tp920
sS'b = np.array([4, 5, 6])\nvstack((a, b))'
p921
(F-1.392930908203125
F-3.7548506600516185
tp922
sS'b = b.reshape(1, 3)'
p923
(F-1.6068836847941081
F-3.805553981236049
tp924
sS'print concatenate((a, b), axis=0)'
p925
(F-1.9001322428385417
F-4.070281982421875
tp926
sS'a = np.array([1, 2, 3])\nb = np.array([4, 5, 6])\nnp.array((a, b))'
p927
(F-0.8366007123674665
F-3.75326783316476
tp928
sS'print concatenate((a, b))'
p929
(F-2.1399973089044746
F-4.20146724155971
tp930
sS'a = np.array([[1, 5, 9], [2, 6, 10]])'
p931
(F-1.1148076424231896
F-3.7767977033342635
tp932
sS'b = np.array([[3, 7, 11], [4, 8, 12]])'
p933
(F-1.3868905580960786
F-3.8183212280273438
tp934
sS'return _nx.concatenate([atleast_2d(_m) for _m in tup], 0)'
p935
(F-3.433450872247869
F-4.392489297049386
tp936
sS'np.array((a, b))'
p937
(F-1.2052419185638428
F-3.758456366402762
tp938
sS'import numpy as np'
p939
(F-1.6336499849955242
F-4.05579103742327
tp940
sS'b = b.reshape(1, 3)\nprint concatenate((a, b))'
p941
(F-1.6286165064031428
F-3.805454799107143
tp942
ssI13571134
(dp943
S"for root, subFolders, files in os.walk(rootdir):\n    if 'data.txt' in files:\n        pass"
p944
(F-1.2987723514951508
F-2.7443783099834738
tp945
sS'for lines in fin:\n    pass'
p946
(F-2.205991571599787
F-3.5962286729079027
tp947
sS"with open('output.txt', 'w') as fout:\n    for root, subFolders, files in os.walk(rootdir):\n        if 'data.txt' in files:\n            with open(os.path.join(root, 'data.txt'), 'r') as fin:\n                for lines in fin:\n                    dosomething()"
p948
(F-1.2162578685863599
F-2.909879831167368
tp949
sS"with open('output.txt', 'w') as fout:\n    for root, subFolders, files in os.walk(rootdir):\n        if 'data.txt' in files:\n            pass"
p950
(F-1.1744815281459264
F-2.9936036330003004
tp951
sS"with open('output.txt', 'w') as fout:\n    for root, subFolders, files in os.walk(rootdir):\n        if 'data.txt' in files:\n            with open(os.path.join(root, 'data.txt'), 'r') as fin:\n                for lines in fin:\n                    pass"
p952
(F-1.095927980211046
F-2.9222420912522535
tp953
sS"for root, subFolders, files in os.walk(rootdir):\n    if 'data.txt' in files:\n        with open(os.path.join(root, 'data.txt'), 'r') as fin:\n            for lines in fin:\n                pass"
p954
(F-1.1372304366806807
F-2.8407070453350363
tp955
sS"with open('output.txt', 'w') as fout:\n    for root, subFolders, files in os.walk(rootdir):\n        if 'data.txt' in files:\n            with open(os.path.join(root, 'data.txt'), 'r') as fin:\n                pass"
p956
(F-1.0709419250488281
F-2.9515680166391225
tp957
sS"with open(os.path.join(root, 'data.txt'), 'r') as fin:\n    for lines in fin:\n        pass"
p958
(F-1.020599943218809
F-3.365846487192007
tp959
sS"if 'data.txt' in files:\n    with open(os.path.join(root, 'data.txt'), 'r') as fin:\n        for lines in fin:\n            dosomething()"
p960
(F-1.239478443944177
F-3.134775895338792
tp961
sS"with open('output.txt', 'w') as fout:\n    for root, subFolders, files in os.walk(rootdir):\n        pass"
p962
(F-1.306414996876436
F-3.0615879939152646
tp963
sS'for lines in fin:\n    dosomething()'
p964
(F-2.6770412738506613
F-3.720623309795673
tp965
sS"with open(os.path.join(root, 'data.txt'), 'r') as fin:\n    pass"
p966
(F-1.0591995239257812
F-3.554887918325571
tp967
sS'dosomething()'
p968
(F-3.8157630920410157
F-4.503199650691106
tp969
sS"for root, subFolders, files in os.walk(rootdir):\n    if 'data.txt' in files:\n        with open(os.path.join(root, 'data.txt'), 'r') as fin:\n            for lines in fin:\n                dosomething()"
p970
(F-1.2733670844406377
F-2.857141348031851
tp971
sS"if 'data.txt' in files:\n    with open(os.path.join(root, 'data.txt'), 'r') as fin:\n        pass"
p972
(F-1.0543669498328008
F-3.273427229661208
tp973
sS'for root, subFolders, files in os.walk(rootdir):\n    pass'
p974
(F-1.5850016276041667
F-2.7624112642728367
tp975
sS"with open('output.txt', 'w') as fout:\n    pass"
p976
(F-1.2502782344818115
F-3.835347982553335
tp977
sS"if 'data.txt' in files:\n    pass"
p978
(F-1.4900873357599431
F-3.2753160916841946
tp979
sS"if 'data.txt' in files:\n    with open(os.path.join(root, 'data.txt'), 'r') as fin:\n        for lines in fin:\n            pass"
p980
(F-1.0466939414419778
F-3.1553127582256613
tp981
sS"with open(os.path.join(root, 'data.txt'), 'r') as fin:\n    for lines in fin:\n        dosomething()"
p982
(F-1.258506338936942
F-3.353463099553035
tp983
sS"for root, subFolders, files in os.walk(rootdir):\n    if 'data.txt' in files:\n        with open(os.path.join(root, 'data.txt'), 'r') as fin:\n            pass"
p984
(F-1.1255711574180454
F-2.827496748704177
tp985
ssI2612802
(dp986
S"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p987
(F-2.577442303825827
F-3.263253402709961
tp988
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p989
(F-2.623073844022529
F-3.23529052734375
tp990
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        pass"
p991
(F-2.215526150581532
F-2.967476463317871
tp992
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p993
(F-2.7527302220924614
F-3.274808883666992
tp994
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p995
(F-2.684383316343999
F-3.2685352325439454
tp996
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True\nobj = list(obj)"
p997
(F-2.4891097042538703
F-2.9972185134887694
tp998
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p999
(F-1.7278118133544922
F-3.1426164627075197
tp1000
sS"a = ['foo', foo]"
p1001
(F-2.5582042270236545
F-3.0520843505859374
tp1002
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1003
(F-2.558952510636737
F-3.2939163208007813
tp1004
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1005
(F-2.645485370019867
F-3.230584716796875
tp1006
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1007
(F-2.522453452056309
F-3.242972183227539
tp1008
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1009
(F-2.9024680352980092
F-3.304494857788086
tp1010
sS't = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p1011
(F-3.1180498676915325
F-3.165468215942383
tp1012
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1013
(F-2.4344152333785076
F-3.262337493896484
tp1014
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1015
(F-2.507352556501116
F-3.2284877777099608
tp1016
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1017
(F-2.5414533293649053
F-3.2420017242431642
tp1018
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1019
(F-2.6253756009615383
F-3.2262893676757813
tp1020
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1021
(F-2.729593194699755
F-3.2348976135253906
tp1022
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1023
(F-2.6034685500124666
F-3.3183837890625
tp1024
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1025
(F-2.524245086888425
F-3.3010772705078124
tp1026
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1027
(F-2.8002738259055397
F-3.181039237976074
tp1028
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1029
(F-2.3706242225689595
F-3.270730209350586
tp1030
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1031
(F-2.6982459551022377
F-3.241852569580078
tp1032
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p1033
(F-3.0563426298253678
F-3.1780021667480467
tp1034
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1035
(F-2.506716186813391
F-3.245084762573242
tp1036
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1037
(F-2.6598618182350187
F-3.23461799621582
tp1038
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p1039
(F-2.680846683562748
F-3.1537246704101562
tp1040
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1041
(F-2.4071807861328125
F-3.259787368774414
tp1042
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1043
(F-2.4963005737937176
F-3.2529163360595703
tp1044
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p1045
(F-2.8090288280385787
F-3.104665184020996
tp1046
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1047
(F-2.7600322050206803
F-3.1840171813964844
tp1048
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p1049
(F-2.7080855736365685
F-3.2175666809082033
tp1050
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p1051
(F-2.915645269700039
F-3.1741605758666993
tp1052
sS'a.append(y)'
p1053
(F-2.4630556106567383
F-2.9454071044921877
tp1054
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000"
p1055
(F-3.358635493687221
F-3.2606121063232423
tp1056
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p1057
(F-2.7503274418253754
F-3.2207530975341796
tp1058
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = [\'foo\', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p1059
(F-1.6352994404141865
F-3.1760353088378905
tp1060
sS'L[:]'
p1061
(F-2.761266072591146
F-3.074319076538086
tp1062
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1063
(F-2.680766296386719
F-3.1769569396972654
tp1064
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1065
(F-2.5663178542564653
F-3.2202327728271483
tp1066
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1067
(F-2.2580940136011094
F-3.230721664428711
tp1068
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1069
(F-2.335955728620491
F-3.2742061614990234
tp1070
sS'a = [\'foo\', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p1071
(F-1.881668962751116
F-3.1714452743530273
tp1072
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1073
(F-2.614524374202806
F-3.205936050415039
tp1074
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1075
(F-2.5079627403846154
F-3.269786071777344
tp1076
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1077
(F-2.525861016635237
F-3.2351078033447265
tp1078
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()"
p1079
(F-2.9312907374182413
F-3.244284439086914
tp1080
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1081
(F-2.6809346816119026
F-3.326771545410156
tp1082
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1083
(F-2.5280358099168345
F-3.209056854248047
tp1084
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1085
(F-2.6285971734756814
F-3.2309104919433596
tp1086
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}"
p1087
(F-2.0052062611521024
F-3.0878982543945312
tp1088
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p1089
(F-2.859967476981027
F-3.1326152801513674
tp1090
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1091
(F-2.470296123240254
F-3.277825927734375
tp1092
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p1093
(F-2.449867757161458
F-3.103345489501953
tp1094
sS'class old_class:\n\n    def __init__(self):\n        pass'
p1095
(F-1.8775823841924253
F-3.031967353820801
tp1096
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1097
(F-2.5055425307329964
F-3.2131763458251954
tp1098
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1099
(F-2.5270944271447524
F-3.2420680999755858
tp1100
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1101
(F-2.348493229259144
F-3.2828712463378906
tp1102
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1103
(F-2.3584930419921877
F-3.245452880859375
tp1104
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1105
(F-2.6278708681415015
F-3.253631591796875
tp1106
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1107
(F-2.5696341620551215
F-3.2185646057128907
tp1108
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1109
(F-2.526396912413758
F-3.2311965942382814
tp1110
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1111
(F-2.6858903083248413
F-3.1868013381958007
tp1112
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p1113
(F-2.759340962404927
F-3.207821273803711
tp1114
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1115
(F-2.6559536095821494
F-3.1924257278442383
tp1116
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1117
(F-2.5771291764056095
F-3.2711788177490235
tp1118
sS"print 'list(L):', time() - t"
p1119
(F-4.365764999389649
F-3.440268707275391
tp1120
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1121
(F-2.6420134837493237
F-3.2134761810302734
tp1122
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1123
(F-2.2854370513519684
F-3.305013656616211
tp1124
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p1125
(F-2.7524757385253906
F-3.1639400482177735
tp1126
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]"
p1127
(F-2.8786987891564
F-3.272531509399414
tp1128
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1129
(F-2.550380762072577
F-3.258240509033203
tp1130
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1131
(F-2.442349776480962
F-3.2815399169921875
tp1132
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p1133
(F-2.6640084688780736
F-3.137299728393555
tp1134
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1135
(F-2.4113755097260348
F-3.3084842681884767
tp1136
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1137
(F-2.8346298680160986
F-3.1956769943237306
tp1138
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1139
(F-2.76614262507512
F-3.1120277404785157
tp1140
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1141
(F-2.4652022458194347
F-3.2474033355712892
tp1142
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1143
(F-2.556961471970017
F-3.236268997192383
tp1144
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1145
(F-2.7430728888659743
F-3.167275047302246
tp1146
sS'pass'
p1147
(F-3.1966123580932617
F-3.25562744140625
tp1148
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1149
(F-2.648400236430921
F-3.175577735900879
tp1150
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1151
(F-2.383281278892382
F-3.253978729248047
tp1152
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1153
(F-2.419409608004386
F-3.280927276611328
tp1154
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1155
(F-2.598477559694102
F-3.2786041259765626
tp1156
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1157
(F-2.4034998113458808
F-3.2032779693603515
tp1158
sS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1159
(F-2.3782745029615318
F-3.082736778259277
tp1160
sS'class new_class(object):\n    pass'
p1161
(F-2.1978056771414622
F-3.008205032348633
tp1162
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True\nobj = list(obj)"
p1163
(F-2.2879451556797443
F-2.999785804748535
tp1164
sS'if is_tuple:\n    pass'
p1165
(F-2.501096552068537
F-3.063120651245117
tp1166
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1167
(F-2.4658432006835938
F-3.269807815551758
tp1168
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1169
(F-2.6586987571994753
F-3.265616607666016
tp1170
sS"for i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1171
(F-2.4736566788110976
F-3.1888198852539062
tp1172
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1173
(F-3.360102081298828
F-3.1734996795654298
tp1174
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1175
(F-2.4638292585100445
F-3.1707731246948243
tp1176
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1177
(F-2.6496162833748285
F-3.241158294677734
tp1178
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1179
(F-2.404359584901391
F-3.2431350708007813
tp1180
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1181
(F-2.537742860855595
F-3.286294937133789
tp1182
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1183
(F-2.125777287269706
F-3.2424415588378905
tp1184
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1185
(F-2.5091418390688687
F-3.287972259521484
tp1186
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1187
(F-2.45884130859375
F-3.2621509552001955
tp1188
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1189
(F-2.5288238525390625
F-3.2269943237304686
tp1190
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1191
(F-2.7686646607545047
F-3.209096145629883
tp1192
sS"return obj\nif __name__ == '__main__':\n    import copy"
p1193
(F-2.440639047061696
F-3.0686019897460937
tp1194
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1195
(F-2.597266648343937
F-3.2419769287109377
tp1196
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1197
(F-2.670170783996582
F-3.2034706115722655
tp1198
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()"
p1199
(F-3.032209000497494
F-3.301149368286133
tp1200
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    pass'
p1201
(F-2.4071435083316852
F-3.033119773864746
tp1202
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1203
(F-2.664951058321221
F-3.213926315307617
tp1204
sS"print 'list extend:', time() - t"
p1205
(F-4.365764999389649
F-3.440268707275391
tp1206
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000"
p1207
(F-3.035921630859375
F-3.2799251556396483
tp1208
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1209
(F-2.4830938601026347
F-3.2049335479736327
tp1210
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1211
(F-2.6798932475428425
F-3.227896881103516
tp1212
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p1213
(F-3.189795902797154
F-2.9965553283691406
tp1214
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p1215
(F-2.8521655538807744
F-3.1442550659179687
tp1216
sS'if type(obj[x]) in dignore:\n    continue'
p1217
(F-2.616156409768497
F-3.133724021911621
tp1218
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1219
(F-2.5651891240270146
F-3.2399826049804688
tp1220
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1221
(F-2.5260285064057038
F-3.2809833526611327
tp1222
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1223
(F-2.277695491396148
F-3.2653839111328127
tp1224
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p1225
(F-1.1459241231282553
F-3.1386932373046874
tp1226
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p1227
(F-2.817211606967374
F-3.195212745666504
tp1228
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1229
(F-2.396589660644531
F-3.227116012573242
tp1230
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1231
(F-2.4983582549042755
F-3.2730236053466797
tp1232
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1233
(F-2.5450654296875
F-3.2597911834716795
tp1234
sS't = time()\nfor i in xrange(num_times):\n    L[:]'
p1235
(F-2.7475051879882812
F-3.2413093566894533
tp1236
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1237
(F-2.614477817549905
F-3.245098876953125
tp1238
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1239
(F-2.5194986155956465
F-3.2556137084960937
tp1240
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1241
(F-2.4221317351810514
F-3.2719181060791014
tp1242
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p1243
(F-1.555890368176745
F-3.1387256622314452
tp1244
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1245
(F-2.877513828562267
F-3.2752281188964845
tp1246
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1247
(F-2.543182373046875
F-3.25306396484375
tp1248
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p1249
(F-2.710948650653546
F-3.1488536834716796
tp1250
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1251
(F-2.7418487903683686
F-3.2388858795166016
tp1252
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]"
p1253
(F-2.461047474930926
F-2.9779403686523436
tp1254
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1255
(F-2.763323523781516
F-3.1895206451416014
tp1256
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1257
(F-2.658445085797991
F-3.214280700683594
tp1258
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1259
(F-2.703904614006121
F-3.26782341003418
tp1260
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1261
(F-2.6075890280983667
F-3.231368637084961
tp1262
sS'def __init__(self, val):\n    pass'
p1263
(F-1.6695802211761475
F-3.2100372314453125
tp1264
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1265
(F-2.6586896788399175
F-3.2207889556884766
tp1266
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        pass'
p1267
(F-1.3442468950825353
F-3.043252944946289
tp1268
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1269
(F-2.652283087009337
F-3.2056156158447267
tp1270
sS'Copy(L, use_deepcopy=False)'
p1271
(F-3.7740068435668945
F-3.1234458923339843
tp1272
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1273
(F-2.499744839138455
F-3.2785690307617186
tp1274
sS'obj[k] = Copy(obj[k], use_deepcopy)'
p1275
(F-3.248556137084961
F-3.0267271041870116
tp1276
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1277
(F-2.338370420078543
F-3.309101104736328
tp1278
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1279
(F-2.5517001414862204
F-3.3101261138916014
tp1280
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1281
(F-2.589021281452922
F-3.256583404541016
tp1282
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1283
(F-2.9931750297546387
F-3.1958892822265623
tp1284
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1285
(F-2.7402031852285242
F-3.209969329833984
tp1286
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p1287
(F-1.5217098781040737
F-3.118918609619141
tp1288
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1289
(F-2.372050048828125
F-3.239483642578125
tp1290
sS'e = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p1291
(F-2.1564246935722156
F-3.188538932800293
tp1292
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1293
(F-2.354994573512999
F-3.237474822998047
tp1294
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1295
(F-2.4529853195440574
F-3.305435562133789
tp1296
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1297
(F-2.555138449067051
F-3.270090866088867
tp1298
sS'b = a[:]\nc = list(a)'
p1299
(F-1.8851250966389974
F-3.0696475982666014
tp1300
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1301
(F-2.4420394332320603
F-3.255267333984375
tp1302
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1303
(F-2.574264012025983
F-3.2456588745117188
tp1304
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1305
(F-2.586047045757316
F-3.2453643798828127
tp1306
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1307
(F-2.5337148813100963
F-3.2392818450927736
tp1308
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1309
(F-2.6049519856770833
F-3.256306838989258
tp1310
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1311
(F-2.559569476401969
F-3.2562313079833984
tp1312
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1313
(F-2.285902062240912
F-3.181228828430176
tp1314
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1315
(F-2.408567934620137
F-3.2562030792236327
tp1316
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1317
(F-2.556779479980469
F-3.2650604248046875
tp1318
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1319
(F-2.7526168823242188
F-3.165635681152344
tp1320
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1321
(F-2.6671342849731445
F-3.2147701263427733
tp1322
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1323
(F-2.708937731656161
F-3.20264892578125
tp1324
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p1325
(F-3.1755008697509766
F-3.1630905151367186
tp1326
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1327
(F-2.989781012901893
F-3.242000198364258
tp1328
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1329
(F-2.560491260729338
F-3.2416881561279296
tp1330
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p1331
(F-2.780239884141852
F-3.2146675109863283
tp1332
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1333
(F-2.270112164252627
F-3.259368896484375
tp1334
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1335
(F-2.6975083222260348
F-3.2251487731933595
tp1336
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True'
p1337
(F-2.91748638542331
F-2.8926929473876952
tp1338
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1339
(F-2.6105282523415307
F-3.2597049713134765
tp1340
sS'return obj'
p1341
(F-4.667501926422119
F-3.239166259765625
tp1342
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        pass'
p1343
(F-2.2136850619534836
F-3.054782676696777
tp1344
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1345
(F-2.6742721778759058
F-3.249540328979492
tp1346
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1347
(F-2.6480198238784842
F-3.2858322143554686
tp1348
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1349
(F-2.4537160366396362
F-3.230865478515625
tp1350
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1351
(F-2.7795025003367457
F-3.223232650756836
tp1352
sS'def __repr__(self):\n    pass'
p1353
(F-1.2959307261875697
F-3.133353424072266
tp1354
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1355
(F-2.7607033673454735
F-3.2693626403808596
tp1356
sS'class old_class:\n    pass'
p1357
(F-3.2552479830655185
F-3.0565649032592774
tp1358
sS"if __name__ == '__main__':\n    import copy\nfrom time import time"
p1359
(F-2.6022395083778784
F-3.19152946472168
tp1360
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1361
(F-2.4910768156598326
F-3.253511428833008
tp1362
sS't = time()\nfor i in xrange(num_times):\n    a = []'
p1363
(F-2.2866336059570314
F-3.250726318359375
tp1364
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1365
(F-2.4978306935932824
F-3.3024147033691404
tp1366
sS'b = a[:]'
p1367
(F-2.3174078464508057
F-2.962819290161133
tp1368
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1369
(F-2.4915150168413174
F-3.2436168670654295
tp1370
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1371
(F-2.610095375462582
F-3.252933883666992
tp1372
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1373
(F-2.736471176147461
F-3.246892547607422
tp1374
sS'from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        pass'
p1375
(F-1.7923674265543619
F-2.9585006713867186
tp1376
sS'dignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    pass'
p1377
(F-3.333678472609747
F-3.0521757125854494
tp1378
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1379
(F-2.490245445101869
F-3.2748016357421874
tp1380
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1381
(F-2.429730765427215
F-3.2682025909423826
tp1382
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p1383
(F-2.737587881270953
F-3.244393157958984
tp1384
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1385
(F-2.875086784362793
F-3.279126739501953
tp1386
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1387
(F-2.6851392892690806
F-3.2360626220703126
tp1388
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1389
(F-2.6990945218789455
F-3.215989685058594
tp1390
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p1391
(F-2.7571148681640625
F-3.1992471694946287
tp1392
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1393
(F-2.4121379505504263
F-3.322264862060547
tp1394
sS'for i in xrange(num_times):\n    [i for i in L]'
p1395
(F-1.9096006913618608
F-3.256825256347656
tp1396
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1397
(F-2.7816638946533203
F-3.267170715332031
tp1398
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1399
(F-2.3028214888139202
F-3.2422119140625
tp1400
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()'
p1401
(F-2.312825460994945
F-3.039166259765625
tp1402
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1403
(F-2.7125980543053667
F-3.182062530517578
tp1404
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1405
(F-2.428017605556531
F-3.1880359649658203
tp1406
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1407
(F-2.5155600614325944
F-3.292453384399414
tp1408
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p1409
(F-2.8876407020970394
F-3.188836860656738
tp1410
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1411
(F-2.4554570614140925
F-3.2782470703125
tp1412
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1413
(F-2.771605323342716
F-3.1880172729492187
tp1414
sS'class new_class(object):\n\n    def __init__(self):\n        pass'
p1415
(F-1.5076901362492487
F-3.002800941467285
tp1416
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1417
(F-2.6893738422197164
F-3.2468421936035154
tp1418
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1419
(F-2.688385614074103
F-3.183637809753418
tp1420
sS'if is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1421
(F-2.2762227515651756
F-3.012085723876953
tp1422
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1423
(F-2.5561949157714845
F-3.2078388214111326
tp1424
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1425
(F-2.5839461904441197
F-3.256783294677734
tp1426
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1427
(F-2.763224103809458
F-3.201752471923828
tp1428
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1429
(F-2.5581342450849287
F-3.2219940185546876
tp1430
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1431
(F-2.490535960477941
F-3.2792739868164062
tp1432
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1433
(F-2.6618413510529892
F-3.2192127227783205
tp1434
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1435
(F-2.709161000709011
F-3.220731735229492
tp1436
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1437
(F-2.49389919303578
F-3.2946929931640625
tp1438
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p1439
(F-3.031327966141374
F-3.1888668060302736
tp1440
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1441
(F-2.5694232434516584
F-3.226981353759766
tp1442
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1443
(F-2.4611154607429357
F-3.246307373046875
tp1444
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1445
(F-2.479543178896361
F-3.279037094116211
tp1446
sS"print 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1447
(F-2.7607033673454735
F-3.2693626403808596
tp1448
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]"
p1449
(F-2.8922213290600065
F-3.2970340728759764
tp1450
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1451
(F-2.4416465276404273
F-3.253850555419922
tp1452
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1453
(F-2.4384752356487773
F-3.260222625732422
tp1454
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1455
(F-2.5587928455096844
F-3.245465087890625
tp1456
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1457
(F-2.6261483365473364
F-3.181981658935547
tp1458
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1459
(F-1.7504561453154592
F-3.145290184020996
tp1460
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1461
(F-2.612702607392549
F-3.2144119262695314
tp1462
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1463
(F-2.6434109871847586
F-3.226206588745117
tp1464
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1465
(F-2.537625769412879
F-3.244589996337891
tp1466
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1467
(F-2.4765256798785664
F-3.2086055755615233
tp1468
sS't = time()\nfor i in xrange(num_times):\n    Copy(L)'
p1469
(F-2.831543273925781
F-3.203736114501953
tp1470
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1471
(F-2.986273193359375
F-3.175914001464844
tp1472
sS'e = copy.deepcopy(a)'
p1473
(F-2.187095832824707
F-3.012751007080078
tp1474
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1475
(F-2.6691804224131057
F-3.205126953125
tp1476
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()"
p1477
(F-2.754404801588792
F-3.1561378479003905
tp1478
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p1479
(F-2.6662462022569446
F-3.1564794540405274
tp1480
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p1481
(F-2.7718011318108973
F-3.221308135986328
tp1482
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue'
p1483
(F-1.9749302219700169
F-3.151989555358887
tp1484
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1485
(F-2.790756032436709
F-3.2394264221191404
tp1486
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1487
(F-2.6324252424568964
F-3.1643924713134766
tp1488
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1489
(F-2.6829092614937826
F-3.204090881347656
tp1490
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1491
(F-2.5936315703810306
F-3.258069610595703
tp1492
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1493
(F-2.770241897170608
F-3.2023529052734374
tp1494
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1495
(F-2.519895499093192
F-3.2445716857910156
tp1496
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1497
(F-2.5153917100694443
F-2.9948434829711914
tp1498
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p1499
(F-1.4380162556966145
F-2.9931158065795898
tp1500
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1501
(F-2.2765033428485575
F-3.236267852783203
tp1502
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1503
(F-2.6331232439007675
F-3.21956787109375
tp1504
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1505
(F-2.4120191819596997
F-3.305171585083008
tp1506
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1507
(F-2.522465961735423
F-3.28641357421875
tp1508
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1509
(F-2.5056540136179213
F-3.285767364501953
tp1510
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1511
(F-2.6581918302379894
F-3.2365238189697267
tp1512
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1513
(F-2.9024680352980092
F-3.304494857788086
tp1514
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1515
(F-2.5163127406362142
F-3.2268638610839844
tp1516
sS'def __init__(self, val):\n    self.val = val'
p1517
(F-1.4589170455932616
F-3.390191650390625
tp1518
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1519
(F-2.652075277792441
F-3.2193504333496095
tp1520
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1521
(F-2.7607033673454735
F-3.2693626403808596
tp1522
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1523
(F-2.5931495460304053
F-3.241883087158203
tp1524
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1525
(F-2.4843387888438664
F-3.2318363189697266
tp1526
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1527
(F-2.5689040753019956
F-3.22864990234375
tp1528
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}"
p1529
(F-1.963452772660689
F-3.0309307098388674
tp1530
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1531
(F-2.639497471316425
F-3.19871826171875
tp1532
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1533
(F-2.4974780525128866
F-3.251346969604492
tp1534
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1535
(F-2.651117808783232
F-3.227451705932617
tp1536
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p1537
(F-1.5194869222520273
F-3.1825096130371096
tp1538
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1539
(F-2.592477509469697
F-3.2171966552734377
tp1540
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]"
p1541
(F-2.8220365187701058
F-3.1349628448486326
tp1542
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p1543
(F-2.6679270946196394
F-3.233959197998047
tp1544
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1545
(F-2.571995439200566
F-3.2565704345703126
tp1546
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1547
(F-2.44709824070786
F-3.250144195556641
tp1548
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1549
(F-2.626393067770164
F-3.215991973876953
tp1550
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1551
(F-3.0191729409354076
F-3.1956048965454102
tp1552
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1553
(F-2.367565275493421
F-3.277140808105469
tp1554
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p1555
(F-2.7616840231007544
F-3.174999237060547
tp1556
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1557
(F-2.5145529287832753
F-3.2097824096679686
tp1558
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1559
(F-2.7343713586980645
F-3.2476211547851563
tp1560
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1561
(F-2.536074574102931
F-3.229533004760742
tp1562
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1563
(F-2.562237108762735
F-3.2489810943603517
tp1564
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1565
(F-2.492790767124721
F-3.223296356201172
tp1566
sS'for i in xrange(num_times):\n    pass'
p1567
(F-1.9242053031921387
F-3.2005481719970703
tp1568
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1569
(F-2.294980582544359
F-3.240447998046875
tp1570
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1571
(F-2.411103455916695
F-3.2582202911376954
tp1572
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p1573
(F-2.9183251014122598
F-3.2081367492675783
tp1574
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1575
(F-2.6676593711990084
F-3.248796844482422
tp1576
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1577
(F-2.479348171962781
F-3.257793426513672
tp1578
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1579
(F-2.5900897216796874
F-3.230466842651367
tp1580
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1581
(F-2.6879578882334183
F-3.220871353149414
tp1582
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1583
(F-2.52325439453125
F-3.254977798461914
tp1584
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1585
(F-2.9556904668393345
F-3.2202072143554688
tp1586
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1587
(F-2.617164975120908
F-3.2292758941650392
tp1588
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p1589
(F-2.6615479787190757
F-3.1302021026611326
tp1590
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1591
(F-2.528820126555687
F-3.184895324707031
tp1592
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1593
(F-2.676788178249378
F-3.18090934753418
tp1594
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p1595
(F-1.3980923314248361
F-3.1201812744140627
tp1596
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1597
(F-2.523316389359768
F-3.258545684814453
tp1598
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1599
(F-2.4678696576286763
F-3.2432884216308593
tp1600
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1601
(F-2.528854494172383
F-3.2756626129150392
tp1602
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1603
(F-2.458299311507107
F-3.253540802001953
tp1604
sS"print 'list(L):', time() - t\nt = time()"
p1605
(F-4.046972751617432
F-3.501752471923828
tp1606
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1607
(F-2.5397363611169763
F-3.219371795654297
tp1608
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1609
(F-2.47026943153059
F-3.226541519165039
tp1610
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1611
(F-2.6311968485514323
F-3.2253696441650392
tp1612
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p1613
(F-1.6986315178148674
F-3.123973083496094
tp1614
sS'c = list(a)'
p1615
(F-2.0271551609039307
F-3.020513725280762
tp1616
sS't = time()\nfor i in xrange(num_times):\n    copy.copy(L)'
p1617
(F-2.510006374782986
F-3.193040466308594
tp1618
sS"foo = Foo(1)\na = ['foo', foo]"
p1619
(F-2.9276723861694336
F-3.131322479248047
tp1620
sS'd = copy.copy(a)'
p1621
(F-2.2839992523193358
F-3.231382369995117
tp1622
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1623
(F-2.6600814232459435
F-3.2086418151855467
tp1624
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1625
(F-2.299698066711426
F-3.3034942626953123
tp1626
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p1627
(F-2.6512975056966144
F-3.1539993286132812
tp1628
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p1629
(F-2.6491258648079885
F-3.1873823165893556
tp1630
sS'for i in xrange(num_times):\n    L[:]'
p1631
(F-2.3772085089432564
F-3.2368953704833983
tp1632
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p1633
(F-1.1119028986716757
F-3.0767292022705077
tp1634
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p1635
(F-2.671231857000613
F-3.1889713287353514
tp1636
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1637
(F-2.3950115803101055
F-3.30709228515625
tp1638
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p1639
(F-2.9486340434611344
F-3.201588439941406
tp1640
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p1641
(F-2.771457605194627
F-3.2353519439697265
tp1642
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p1643
(F-2.7750729647549717
F-3.1957733154296877
tp1644
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1645
(F-2.52550902953735
F-3.262281799316406
tp1646
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1647
(F-2.6304100337421596
F-3.2154800415039064
tp1648
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1649
(F-2.5809681768002717
F-3.2483386993408203
tp1650
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1651
(F-2.6613423910485694
F-3.177188491821289
tp1652
sS'from time import time\nnum_times = 100000'
p1653
(F-4.326631228129069
F-3.461286163330078
tp1654
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1655
(F-2.6298716451843456
F-3.246500015258789
tp1656
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)'
p1657
(F-1.7166188557942708
F-3.1562103271484374
tp1658
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1659
(F-2.6883588193067864
F-3.2216278076171876
tp1660
sS'if is_tuple:\n    obj = tuple(obj)'
p1661
(F-2.3894004821777344
F-3.0940879821777343
tp1662
sS'if t == tuple:\n    pass'
p1663
(F-2.8363364826549184
F-3.0399795532226563
tp1664
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1665
(F-2.4250315457689293
F-3.278273010253906
tp1666
sS"for y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1667
(F-2.5202718541242075
F-3.17165584564209
tp1668
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1669
(F-2.627747746824308
F-3.1883787155151366
tp1670
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p1671
(F-2.766979652763213
F-3.199692726135254
tp1672
sS"if __name__ == '__main__':\n    import copy"
p1673
(F-1.6366149357386999
F-3.0556983947753906
tp1674
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1675
(F-2.480071061812107
F-3.2577224731445313
tp1676
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1677
(F-2.3346165248325894
F-3.2665550231933596
tp1678
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1679
(F-2.6989212504193825
F-3.179784393310547
tp1680
sS"for y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1681
(F-2.3400836866729113
F-3.1728488922119142
tp1682
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1683
(F-2.471403450801455
F-3.2556808471679686
tp1684
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1685
(F-2.369722223006232
F-3.264826202392578
tp1686
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1687
(F-2.4977335509485203
F-3.2401145935058593
tp1688
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1689
(F-2.70449101159332
F-3.282821273803711
tp1690
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1691
(F-2.5342038830222986
F-3.231763458251953
tp1692
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1693
(F-2.524477277483259
F-3.2495090484619142
tp1694
sS'c = list(a)\nd = copy.copy(a)'
p1695
(F-1.8049748364616842
F-3.165699768066406
tp1696
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1697
(F-2.5741719891948085
F-3.29534912109375
tp1698
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1699
(F-2.5552824213263694
F-3.2433971405029296
tp1700
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}"
p1701
(F-2.2779755502376915
F-3.049261283874512
tp1702
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1703
(F-2.6366229290728804
F-3.2732078552246096
tp1704
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p1705
(F-2.7706544249207825
F-3.176569938659668
tp1706
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1707
(F-2.3743403155104557
F-3.274363708496094
tp1708
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1709
(F-2.1703567504882812
F-3.169136810302734
tp1710
sS'for k in obj:\n    if type(obj[k]) in dignore:\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1711
(F-2.40311522710891
F-3.0608642578125
tp1712
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1713
(F-2.581529940778052
F-3.273681640625
tp1714
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1715
(F-2.4396354861375764
F-3.25972900390625
tp1716
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p1717
(F-2.5849229079026443
F-3.1028989791870116
tp1718
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1719
(F-2.8071040562220984
F-3.232413101196289
tp1720
sS'class Foo(object):\n    pass'
p1721
(F-1.6790974934895833
F-3.078058052062988
tp1722
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p1723
(F-1.5007500402706186
F-3.1357566833496096
tp1724
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1725
(F-2.64541015625
F-3.263531494140625
tp1726
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1727
(F-2.3300243457714163
F-3.2708709716796873
tp1728
sS'copy.deepcopy(L)'
p1729
(F-1.8508161306381226
F-2.940976142883301
tp1730
sS't = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)'
p1731
(F-2.360179477267795
F-3.1424848556518556
tp1732
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1733
(F-2.459281239611037
F-3.31602783203125
tp1734
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1735
(F-2.840242479668289
F-3.237043762207031
tp1736
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1737
(F-2.6700534645570526
F-3.2298255920410157
tp1738
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1739
(F-2.5313859550873814
F-3.2755447387695313
tp1740
sS'for i in xrange(num_times):\n    list(L)'
p1741
(F-1.9790304083573191
F-3.2270545959472656
tp1742
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1743
(F-2.5337000066583806
F-3.2451396942138673
tp1744
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1745
(F-2.559099057605644
F-3.2540916442871093
tp1746
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1747
(F-2.6634560442985373
F-3.300592041015625
tp1748
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1749
(F-2.6387960766989087
F-3.2130565643310547
tp1750
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1751
(F-2.9024680352980092
F-3.304494857788086
tp1752
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1753
(F-2.5951476537880778
F-3.1742753982543945
tp1754
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]"
p1755
(F-2.6865513728215142
F-3.14282341003418
tp1756
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p1757
(F-2.817531961790273
F-3.273574447631836
tp1758
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1759
(F-2.6907041179600046
F-3.1462400436401365
tp1760
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1761
(F-2.509253299597538
F-3.296955871582031
tp1762
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1763
(F-2.158385151564473
F-3.0396909713745117
tp1764
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p1765
(F-1.708983648390997
F-3.0556308746337892
tp1766
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1767
(F-2.5260162353515625
F-3.214072036743164
tp1768
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p1769
(F-3.246902110964753
F-3.225310516357422
tp1770
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p1771
(F-2.3357041953266533
F-3.057651329040527
tp1772
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1773
(F-2.5305826025071485
F-3.249332046508789
tp1774
sS"print 'list slicing [:]:', time() - t"
p1775
(F-4.365764999389649
F-3.440268707275391
tp1776
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True\nobj = list(obj)"
p1777
(F-2.248414569430881
F-2.9944568634033204
tp1778
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1779
(F-2.492664810878779
F-3.2710235595703123
tp1780
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p1781
(F-2.8944077555338543
F-3.160239028930664
tp1782
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1783
(F-2.5815446094800065
F-3.2577892303466798
tp1784
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1785
(F-2.64822640503652
F-3.159997749328613
tp1786
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True"
p1787
(F-2.2679385442803377
F-2.9489471435546877
tp1788
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1789
(F-2.615354265485491
F-3.206103515625
tp1790
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1791
(F-2.5275459983132103
F-3.2701507568359376
tp1792
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1793
(F-2.6753525390625
F-3.2519630432128905
tp1794
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p1795
(F-2.3557347898130065
F-3.0361961364746093
tp1796
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1797
(F-2.5848689756828085
F-3.2193233489990236
tp1798
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1799
(F-2.7980618234408103
F-3.2778041839599608
tp1800
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1801
(F-2.692575991732403
F-3.2216529846191406
tp1802
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1803
(F-2.7333877711620147
F-3.2757965087890626
tp1804
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p1805
(F-3.077110481262207
F-3.241017150878906
tp1806
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1807
(F-2.633111895936908
F-3.237461471557617
tp1808
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1809
(F-2.3999056134905135
F-3.1413360595703126
tp1810
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)"
p1811
(F-1.921992592189623
F-3.1267696380615235
tp1812
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1813
(F-2.6736866719013936
F-3.234010696411133
tp1814
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    pass"
p1815
(F-2.491957092285156
F-2.985006904602051
tp1816
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1817
(F-2.532383039885876
F-3.2699615478515627
tp1818
sS't = time()\nfor i in xrange(num_times):\n    list(L)'
p1819
(F-2.478102264404297
F-3.225998306274414
tp1820
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1821
(F-2.5762409676026197
F-3.2491668701171874
tp1822
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1823
(F-2.4960308890057425
F-3.2613555908203127
tp1824
sS"a.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1825
(F-3.1836489722842263
F-3.036996269226074
tp1826
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1827
(F-2.4534654339540354
F-3.2668636322021483
tp1828
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1829
(F-2.5320827289816523
F-3.2039169311523437
tp1830
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p1831
(F-3.0759066413430607
F-3.133461761474609
tp1832
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1833
(F-1.6045157692649148
F-3.1169149398803713
tp1834
sS'import copy\nnew_list = copy.copy(old_list)'
p1835
(F-1.3731173347024357
F-3.0659088134765624
tp1836
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p1837
(F-4.365764999389649
F-3.440268707275391
tp1838
sS'for x in xrange(len(obj)):\n    pass'
p1839
(F-1.6683894886690027
F-3.1243850708007814
tp1840
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1841
(F-2.393836144173499
F-3.2788719177246093
tp1842
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1843
(F-2.4639935788855087
F-3.2669673919677735
tp1844
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1845
(F-2.5876237457873774
F-3.2081451416015625
tp1846
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        pass"
p1847
(F-2.2568775964161705
F-2.9752817153930664
tp1848
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1849
(F-2.4449826841001157
F-3.3044898986816404
tp1850
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1851
(F-2.570461757063514
F-3.234056091308594
tp1852
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1853
(F-2.6530030132973033
F-3.305381011962891
tp1854
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1855
(F-2.5389464198752485
F-3.232891082763672
tp1856
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p1857
(F-2.7483061085576597
F-3.16817626953125
tp1858
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1859
(F-2.42766937007749
F-3.269703674316406
tp1860
sS'if t in (list, tuple):\n    if t == tuple:\n        is_tuple = True'
p1861
(F-2.866522047254774
F-3.070709800720215
tp1862
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p1863
(F-2.6894401840016813
F-3.27098388671875
tp1864
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1865
(F-2.489718029846498
F-3.2603450775146485
tp1866
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p1867
(F-2.6691171746504936
F-3.2545181274414063
tp1868
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1869
(F-2.571767686288568
F-3.2564712524414063
tp1870
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1871
(F-2.4282824091550683
F-3.235382843017578
tp1872
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1873
(F-2.5332353210449217
F-3.2586761474609376
tp1874
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1875
(F-3.1244239807128906
F-3.236786651611328
tp1876
sS"a = ['foo', foo]\nb = a[:]"
p1877
(F-2.1514980792999268
F-3.076395606994629
tp1878
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1879
(F-2.702452493370126
F-3.246776580810547
tp1880
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1881
(F-2.1130042885834315
F-2.9968584060668944
tp1882
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1883
(F-2.8165094903174865
F-3.223054885864258
tp1884
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p1885
(F-2.7242004695197046
F-3.1971431732177735
tp1886
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p1887
(F-2.184355727187148
F-3.015223503112793
tp1888
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p1889
(F-2.3908313999514608
F-3.295975112915039
tp1890
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p1891
(F-2.8012744318829834
F-3.137144088745117
tp1892
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1893
(F-2.6006709080116424
F-3.163639450073242
tp1894
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1895
(F-2.7621285915374756
F-3.1467432022094726
tp1896
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1897
(F-1.8681851091056034
F-3.1387542724609374
tp1898
sS"def __init__(self):\n    self.blah = 'blah'"
p1899
(F-1.4724032084147136
F-3.142288589477539
tp1900
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1901
(F-2.4294918127227247
F-3.1780170440673827
tp1902
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1903
(F-2.6162596615878018
F-3.2046768188476564
tp1904
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t"
p1905
(F-2.817634204826733
F-3.1298797607421873
tp1906
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1907
(F-2.8104377952781885
F-3.242563247680664
tp1908
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    pass"
p1909
(F-2.2113134765625
F-2.984984588623047
tp1910
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1911
(F-2.4513690087103073
F-3.0919593811035155
tp1912
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1913
(F-2.827462931625716
F-3.1423194885253904
tp1914
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p1915
(F-2.56768285619604
F-3.230049896240234
tp1916
sS'foo = Foo(1)\na = [\'foo\', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p1917
(F-2.0093132118126014
F-3.1653205871582033
tp1918
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1919
(F-2.501735014073989
F-3.298261260986328
tp1920
sS'if type(obj[x]) in dignore:\n    pass'
p1921
(F-2.514015422147863
F-3.0413036346435547
tp1922
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p1923
(F-2.8277902314157197
F-3.20709342956543
tp1924
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1925
(F-1.9620921795184796
F-3.1962915420532227
tp1926
sS"print 'copy.copy:', time() - t"
p1927
(F-4.365764999389649
F-3.440268707275391
tp1928
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t"
p1929
(F-2.915553501674107
F-3.151841926574707
tp1930
sS'if is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    pass'
p1931
(F-2.582130138690655
F-3.069447326660156
tp1932
sS"print 'list append:', time() - t\nt = time()"
p1933
(F-4.046972751617432
F-3.501752471923828
tp1934
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1935
(F-2.5495682131265096
F-3.242310333251953
tp1936
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1937
(F-2.635175211175444
F-3.22174186706543
tp1938
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1939
(F-2.617667671683785
F-3.3087627410888674
tp1940
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p1941
(F-3.084844161053093
F-3.2155124664306642
tp1942
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1943
(F-2.7155691964285715
F-3.1873138427734373
tp1944
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1945
(F-2.667392931486431
F-3.2599018096923826
tp1946
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p1947
(F-2.743661221590909
F-3.1656396865844725
tp1948
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        pass'
p1949
(F-2.8058656480577255
F-2.906514358520508
tp1950
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p1951
(F-3.1847136124320654
F-3.1883367538452148
tp1952
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p1953
(F-1.7211350833668428
F-2.94488525390625
tp1954
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p1955
(F-1.125780625776811
F-3.1056962966918946
tp1956
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    pass'
p1957
(F-2.8994093199033997
F-2.9264991760253904
tp1958
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p1959
(F-2.505996794390255
F-3.2339462280273437
tp1960
sS't = type(obj)'
p1961
(F-3.817901611328125
F-3.2072223663330077
tp1962
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1963
(F-2.4847060598003927
F-3.2832000732421873
tp1964
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    pass'
p1965
(F-2.260066624691612
F-3.044453239440918
tp1966
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p1967
(F-2.691126320578835
F-3.2223136901855467
tp1968
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1969
(F-2.5721044591955238
F-3.2633811950683596
tp1970
sS"print 'Custom Copy:', time() - t\nt = time()"
p1971
(F-4.046972751617432
F-3.501752471923828
tp1972
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t"
p1973
(F-2.729664705237564
F-3.1350944519042967
tp1974
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1975
(F-2.561239013671875
F-3.2331569671630858
tp1976
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1977
(F-2.294681148929196
F-3.2807601928710937
tp1978
sS'foo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p1979
(F-2.785671731700068
F-3.341473388671875
tp1980
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p1981
(F-2.680401848357858
F-3.2731327056884765
tp1982
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p1983
(F-2.812244335254589
F-3.1583988189697267
tp1984
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1985
(F-2.4605895748987856
F-3.274323654174805
tp1986
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p1987
(F-2.5901079511309004
F-3.2663097381591797
tp1988
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1989
(F-2.5972153021364797
F-3.2608924865722657
tp1990
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1991
(F-2.4989726699401285
F-3.2445274353027345
tp1992
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p1993
(F-2.6212627844896144
F-3.2413185119628904
tp1994
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1995
(F-2.4485796082694575
F-3.272367477416992
tp1996
sS"for y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p1997
(F-2.5440467834472655
F-3.0534414291381835
tp1998
sS"if __name__ == '__main__':\n    pass"
p1999
(F-1.3719671689547026
F-3.2735740661621096
tp2000
sS"for y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2001
(F-2.7689071163054435
F-3.0948814392089843
tp2002
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p2003
(F-1.5296838042932912
F-3.122027778625488
tp2004
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p2005
(F-2.42931699081206
F-3.0061670303344727
tp2006
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p2007
(F-2.83548358308167
F-3.1560821533203125
tp2008
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2009
(F-2.475115931311319
F-3.166789245605469
tp2010
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2011
(F-2.6854407082141285
F-3.190997314453125
tp2012
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2013
(F-2.619431495666504
F-3.2335601806640626
tp2014
sS'copy.copy(L)'
p2015
(F-2.39212703704834
F-3.055039405822754
tp2016
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2017
(F-2.7366900776707848
F-3.213398742675781
tp2018
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2019
(F-2.598569597516741
F-3.256975555419922
tp2020
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p2021
(F-1.6796635219029017
F-3.0018692016601562
tp2022
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2023
(F-2.582495892237103
F-3.239194869995117
tp2024
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2025
(F-2.6633454516418
F-3.290370559692383
tp2026
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2027
(F-2.5870508829752605
F-3.2672447204589843
tp2028
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p2029
(F-2.697013107000613
F-3.247433090209961
tp2030
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2031
(F-2.5494019264398617
F-3.235045623779297
tp2032
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2033
(F-2.0729274260692105
F-3.1507894515991213
tp2034
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p2035
(F-2.638979622487272
F-3.177270698547363
tp2036
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2037
(F-2.626296523194876
F-3.3031177520751953
tp2038
sS"for y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2039
(F-2.421534994374151
F-3.148527908325195
tp2040
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time"
p2041
(F-3.081091447310014
F-3.1865257263183593
tp2042
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p2043
(F-2.8660851047463614
F-3.1538150787353514
tp2044
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2045
(F-2.688722590810245
F-3.243315887451172
tp2046
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2047
(F-2.5211604407074253
F-3.1748174667358398
tp2048
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2049
(F-2.7298375005307407
F-3.235892105102539
tp2050
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2051
(F-2.7284389588891007
F-3.195469284057617
tp2052
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p2053
(F-2.744095705868153
F-3.1680377960205077
tp2054
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t"
p2055
(F-2.9083154678344725
F-3.229107666015625
tp2056
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2057
(F-2.7230388584421643
F-3.1918750762939454
tp2058
sS'a.extend(L)'
p2059
(F-2.6346518993377686
F-3.0067817687988283
tp2060
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2061
(F-2.6400038775275734
F-3.303955841064453
tp2062
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p2063
(F-2.5784762339730376
F-3.245930862426758
tp2064
sS"print 'list expression(L):', time() - t"
p2065
(F-4.365764999389649
F-3.440268707275391
tp2066
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()"
p2067
(F-2.9755562091695853
F-3.2786636352539062
tp2068
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2069
(F-2.802747032859109
F-3.20813102722168
tp2070
sS'foo = Foo(1)'
p2071
(F-3.3587489128112793
F-3.1419631958007814
tp2072
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2073
(F-1.523904779905914
F-3.1400802612304686
tp2074
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2075
(F-2.5317807497678104
F-3.2544223785400392
tp2076
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2077
(F-2.571132298519737
F-3.126405715942383
tp2078
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2079
(F-2.6110661259403933
F-3.1945112228393553
tp2080
sS'from time import time'
p2081
(F-4.099633534749349
F-3.525288391113281
tp2082
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2083
(F-2.5833470799901463
F-3.2358676910400392
tp2084
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p2085
(F-2.824055647649685
F-3.126261520385742
tp2086
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2087
(F-2.4057729620682564
F-3.222556304931641
tp2088
sS'dignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    pass'
p2089
(F-3.1316120585457226
F-2.9691328048706054
tp2090
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p2091
(F-2.591802032900528
F-3.1732688903808595
tp2092
sS'dignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True'
p2093
(F-3.0903366297891695
F-2.9767997741699217
tp2094
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2095
(F-2.776400555621137
F-3.2018001556396483
tp2096
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2097
(F-2.6084727938213046
F-3.2240856170654295
tp2098
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        pass'
p2099
(F-2.456958718495826
F-3.0113702774047852
tp2100
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2101
(F-2.6293613366913378
F-3.1943788528442383
tp2102
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2103
(F-2.7153091887514034
F-3.224081039428711
tp2104
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2105
(F-2.5352541295493523
F-3.2940921783447266
tp2106
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2107
(F-2.5171112375161084
F-3.2340156555175783
tp2108
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2109
(F-2.6691712724401597
F-3.1967540740966798
tp2110
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2111
(F-2.4464874267578125
F-3.2668018341064453
tp2112
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p2113
(F-2.5057310713098406
F-3.2420017242431642
tp2114
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2115
(F-2.210012197494507
F-3.1505661010742188
tp2116
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2117
(F-2.5921413615598516
F-3.00010986328125
tp2118
sS'a.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p2119
(F-2.295556386311849
F-3.3392303466796873
tp2120
sS'if is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        continue'
p2121
(F-2.130208969116211
F-3.0800071716308595
tp2122
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2123
(F-2.6545554214382765
F-3.243010711669922
tp2124
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2125
(F-2.6207332611083984
F-3.2649467468261717
tp2126
sS'dignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p2127
(F-3.388323520092254
F-3.0637062072753904
tp2128
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2129
(F-2.4712253558961814
F-3.2900482177734376
tp2130
sS"print 'list slicing [:]:', time() - t\nt = time()"
p2131
(F-4.046972751617432
F-3.501752471923828
tp2132
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p2133
(F-2.7367609197443183
F-3.1575090408325197
tp2134
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2135
(F-2.5977783203125
F-3.2396572113037108
tp2136
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2137
(F-2.673701620509482
F-3.2105289459228517
tp2138
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2139
(F-2.4847368876139324
F-3.2579490661621096
tp2140
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2141
(F-2.570042569872359
F-3.2526313781738283
tp2142
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2143
(F-2.559973739996189
F-3.178096389770508
tp2144
sS"print 'list extend:', time() - t\nt = time()"
p2145
(F-4.046972751617432
F-3.501752471923828
tp2146
sS'import copy'
p2147
(F-2.897911548614502
F-2.981290817260742
tp2148
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2149
(F-1.9081245422363282
F-3.0993398666381835
tp2150
sS"print 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2151
(F-2.6158960978190104
F-3.218025970458984
tp2152
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2153
(F-2.5292501503464866
F-3.2389522552490235
tp2154
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2155
(F-2.196157455444336
F-3.2334213256835938
tp2156
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2157
(F-2.5582734868767556
F-3.234172058105469
tp2158
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2159
(F-2.5422960069444445
F-3.25195426940918
tp2160
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t"
p2161
(F-2.8681590360753675
F-3.2088302612304687
tp2162
sS'self.val = val'
p2163
(F-3.2584168570382253
F-3.408147430419922
tp2164
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2165
(F-2.285009511311849
F-3.0336795806884767
tp2166
sS'print """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p2167
(F-2.3143532696892235
F-3.5341217041015627
tp2168
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2169
(F-2.5832722981770835
F-3.138417434692383
tp2170
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2171
(F-2.5269486860795456
F-3.2441577911376953
tp2172
sS'for y in L:\n    a.append(y)'
p2173
(F-1.695961833000183
F-3.0494930267333986
tp2174
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()"
p2175
(F-2.7223557817175035
F-3.0110200881958007
tp2176
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2177
(F-2.5199899723392507
F-3.2750923156738283
tp2178
sS"for y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2179
(F-2.3042887369791667
F-3.224282073974609
tp2180
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2181
(F-2.628203861297123
F-3.2774356842041015
tp2182
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2183
(F-2.5787423940805287
F-3.246728515625
tp2184
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2185
(F-2.517598323684802
F-3.217279815673828
tp2186
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p2187
(F-2.301278273264567
F-3.0499027252197264
tp2188
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2189
(F-2.391924021195392
F-3.1859966278076173
tp2190
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p2191
(F-2.7860859401976863
F-3.16422119140625
tp2192
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2193
(F-2.735457862963517
F-3.2080223083496096
tp2194
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2195
(F-2.5474360738867743
F-3.2384567260742188
tp2196
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        pass'
p2197
(F-1.9612744305584882
F-3.134248161315918
tp2198
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p2199
(F-1.455511685075431
F-3.042964744567871
tp2200
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p2201
(F-2.7024161202566965
F-3.153376007080078
tp2202
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()"
p2203
(F-2.8325637389566296
F-3.1507308959960936
tp2204
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2205
(F-2.618049479771724
F-3.2491600036621096
tp2206
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p2207
(F-2.857495880126953
F-3.2218982696533205
tp2208
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2209
(F-2.7452867296006946
F-3.1644493103027345
tp2210
sS'if is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()'
p2211
(F-2.299825429916382
F-3.0534360885620115
tp2212
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2213
(F-2.9024680352980092
F-3.304494857788086
tp2214
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p2215
(F-1.7497377748842593
F-3.0128925323486326
tp2216
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p2217
(F-2.5112788551732113
F-3.0226982116699217
tp2218
sS'[i for i in L]'
p2219
(F-1.5660983191596136
F-3.101799201965332
tp2220
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2221
(F-2.531109482494753
F-3.3169036865234376
tp2222
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2223
(F-2.591014797404661
F-3.2880718231201174
tp2224
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2225
(F-1.5348450796944755
F-3.159879684448242
tp2226
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2227
(F-2.498736609710506
F-3.290570068359375
tp2228
sS'if t == tuple:\n    is_tuple = True'
p2229
(F-3.2812375386555988
F-3.0448301315307615
tp2230
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2231
(F-2.510129750885578
F-3.3002952575683593
tp2232
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2233
(F-2.3203013828822545
F-3.2626602172851564
tp2234
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2235
(F-2.5552399506440033
F-3.2712356567382814
tp2236
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2237
(F-2.5683149857954546
F-3.239948272705078
tp2238
sS't = time()\nfor i in xrange(num_times):\n    [i for i in L]'
p2239
(F-2.3668458121163503
F-3.2531143188476563
tp2240
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p2241
(F-3.0441060523464256
F-3.189125633239746
tp2242
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2243
(F-2.601547117155742
F-3.218368148803711
tp2244
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2245
(F-2.6011418881623642
F-3.246916961669922
tp2246
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2247
(F-2.6606553240520197
F-3.209306335449219
tp2248
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2249
(F-2.543520643088308
F-3.2163482666015626
tp2250
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2251
(F-3.2581404082629146
F-3.2532527923583983
tp2252
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2253
(F-2.5393661871189024
F-3.2828346252441407
tp2254
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2255
(F-2.4238313373766447
F-3.298689270019531
tp2256
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2257
(F-2.5776456635573815
F-3.2526325225830077
tp2258
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2259
(F-2.6508874985778217
F-3.2143272399902343
tp2260
sS'is_tuple = True'
p2261
(F-3.548429216657366
F-3.02270450592041
tp2262
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2263
(F-2.3398747419446244
F-3.3102752685546877
tp2264
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2265
(F-2.3350067138671875
F-3.2656124114990233
tp2266
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2267
(F-2.5675173672762783
F-3.2962196350097654
tp2268
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2269
(F-2.723225449070786
F-3.206035614013672
tp2270
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2271
(F-2.508802652359009
F-3.2709144592285155
tp2272
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p2273
(F-2.7496935437609267
F-3.186319351196289
tp2274
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2275
(F-2.3547601174181843
F-3.230815887451172
tp2276
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2277
(F-2.4325124321254434
F-3.2635963439941404
tp2278
sS'num_times = 100000'
p2279
(F-5.16810062953404
F-3.4537052154541015
tp2280
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2281
(F-2.5894596940380032
F-3.254180908203125
tp2282
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p2283
(F-2.6636608771558077
F-3.2229469299316404
tp2284
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2285
(F-2.730587271756904
F-3.153715133666992
tp2286
sS'for i in xrange(num_times):\n    copy.copy(L)'
p2287
(F-2.0096853347051713
F-3.185894012451172
tp2288
sS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p2289
(F-1.9894680023193358
F-3.2007335662841796
tp2290
sS'd = copy.copy(a)\ne = copy.deepcopy(a)'
p2291
(F-2.0122696725945723
F-3.187057685852051
tp2292
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2293
(F-2.515021944594109
F-3.2766494750976562
tp2294
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    pass"
p2295
(F-2.255069021451271
F-2.9985498428344726
tp2296
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2297
(F-2.5598057564058454
F-3.2355392456054686
tp2298
sS'from copy import deepcopy'
p2299
(F-2.1086597442626953
F-2.947426605224609
tp2300
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2301
(F-2.709156758076436
F-3.218898391723633
tp2302
sS"e = copy.deepcopy(a)\na.append('baz')"
p2303
(F-2.0518744973575367
F-3.0345436096191407
tp2304
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p2305
(F-2.3636932373046875
F-3.035232925415039
tp2306
sS'class Foo(object):\n\n    def __init__(self, val):\n        pass'
p2307
(F-1.2732577690711389
F-3.0840713500976564
tp2308
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2309
(F-2.4254566315681703
F-3.228124237060547
tp2310
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2311
(F-2.579519919978762
F-3.2528263092041017
tp2312
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2313
(F-2.9024680352980092
F-3.304494857788086
tp2314
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2315
(F-2.9727290562220983
F-3.2208614349365234
tp2316
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()"
p2317
(F-2.8844534067007213
F-3.2253345489501952
tp2318
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2319
(F-2.4473832563920452
F-3.285737991333008
tp2320
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2321
(F-2.628195041563453
F-3.1875476837158203
tp2322
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2323
(F-2.4922764369419643
F-3.239229202270508
tp2324
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2325
(F-2.6466049701425605
F-3.246042251586914
tp2326
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2327
(F-2.6086278604277484
F-3.2400684356689453
tp2328
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        pass"
p2329
(F-2.475469161053093
F-2.966976356506348
tp2330
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2331
(F-2.7081238172069098
F-3.2193572998046873
tp2332
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2333
(F-2.638700275031888
F-3.2540313720703127
tp2334
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p2335
(F-2.5067626953125
F-3.2432716369628904
tp2336
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2337
(F-2.609302686608356
F-3.2734439849853514
tp2338
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2339
(F-2.5329507284118358
F-3.311910629272461
tp2340
sS'a = []'
p2341
(F-2.409792900085449
F-2.9013710021972656
tp2342
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()'
p2343
(F-2.7487690205476722
F-2.9903913497924806
tp2344
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2345
(F-2.322055939705141
F-3.2846664428710937
tp2346
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2347
(F-2.9150623668323865
F-3.2158634185791017
tp2348
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2349
(F-2.4257208539553337
F-3.2829124450683596
tp2350
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2351
(F-2.6775555880564563
F-3.2699630737304686
tp2352
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2353
(F-2.86412911666067
F-3.1109424591064454
tp2354
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p2355
(F-2.757189343859266
F-3.167455291748047
tp2356
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p2357
(F-3.016230863683364
F-3.2160083770751955
tp2358
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2359
(F-2.617077718645134
F-3.2768489837646486
tp2360
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2361
(F-2.6342845129588293
F-3.2774307250976564
tp2362
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2363
(F-2.5608277072796244
F-3.21475830078125
tp2364
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        continue'
p2365
(F-2.220385070240826
F-3.0649539947509767
tp2366
sS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p2367
(F-1.720441593843348
F-3.1951272964477537
tp2368
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2369
(F-2.288781302315848
F-3.0320396423339844
tp2370
sS'def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = [\'foo\', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p2371
(F-1.896321137746175
F-3.164750099182129
tp2372
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p2373
(F-2.3846511840820312
F-3.031171417236328
tp2374
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2375
(F-2.592255344280618
F-3.280757522583008
tp2376
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2377
(F-2.489074551329321
F-3.2270534515380858
tp2378
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2379
(F-2.5353753141654556
F-3.2878402709960937
tp2380
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2381
(F-2.9024680352980092
F-3.304494857788086
tp2382
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2383
(F-2.6376835986821336
F-3.2030319213867187
tp2384
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2385
(F-2.4910359102136947
F-3.2609836578369142
tp2386
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p2387
(F-1.2327933175223214
F-3.0953989028930664
tp2388
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2389
(F-2.6054064240700527
F-3.210989761352539
tp2390
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p2391
(F-3.2720035055409307
F-3.0104408264160156
tp2392
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2393
(F-2.6070215823876595
F-3.26361083984375
tp2394
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2395
(F-2.4468673857131806
F-3.2970741271972654
tp2396
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p2397
(F-2.3134818909660217
F-3.052595329284668
tp2398
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2399
(F-2.6664331947884907
F-3.1932676315307615
tp2400
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2401
(F-2.5094406878361935
F-3.266793441772461
tp2402
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2403
(F-2.6477234273017207
F-3.201554870605469
tp2404
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2405
(F-2.6938028538480716
F-3.1984621047973634
tp2406
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2407
(F-2.5180807674632355
F-3.2568965911865235
tp2408
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2409
(F-2.4151500613190406
F-3.3003704071044924
tp2410
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2411
(F-2.7328859117296007
F-3.2380691528320313
tp2412
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2413
(F-2.4731020091269253
F-3.2555831909179687
tp2414
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p2415
(F-2.4813549144847973
F-3.2619773864746096
tp2416
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2417
(F-2.6920602689913617
F-3.1895565032958983
tp2418
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t"
p2419
(F-2.996912787942325
F-3.178782653808594
tp2420
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2421
(F-2.536249474634098
F-3.282802963256836
tp2422
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p2423
(F-2.95513134765625
F-3.2189697265625
tp2424
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2425
(F-2.105922372000558
F-3.148926544189453
tp2426
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2427
(F-2.888545022081973
F-3.2498195648193358
tp2428
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p2429
(F-2.9124491373697916
F-3.1109025955200194
tp2430
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p2431
(F-1.8904537077872985
F-3.163100814819336
tp2432
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2433
(F-2.8957681201753163
F-3.196116638183594
tp2434
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2435
(F-2.7201452162659283
F-3.3094646453857424
tp2436
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p2437
(F-2.638243999677835
F-3.2032947540283203
tp2438
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2439
(F-2.570875644683838
F-3.2723873138427733
tp2440
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2441
(F-2.7919783341257194
F-3.248585891723633
tp2442
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2443
(F-2.3458515514026987
F-3.2749343872070313
tp2444
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2445
(F-2.4702432923397777
F-3.2926254272460938
tp2446
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2447
(F-2.496978759765625
F-3.228898620605469
tp2448
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2449
(F-2.512620583558694
F-3.2684341430664063
tp2450
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2451
(F-2.6067347762608293
F-3.2009368896484376
tp2452
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2453
(F-2.4622071973320576
F-3.278028106689453
tp2454
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2455
(F-2.249680675159801
F-3.265705871582031
tp2456
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2457
(F-2.5078283180116983
F-3.272332763671875
tp2458
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2459
(F-2.6938224205603967
F-3.286518859863281
tp2460
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2461
(F-2.7203589749623496
F-3.1864471435546875
tp2462
sS'new_list = copy.copy(old_list)'
p2463
(F-1.581582478114537
F-3.108506202697754
tp2464
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2465
(F-2.747628820947854
F-3.1760591506958007
tp2466
sS'if t in (list, tuple):\n    if t == tuple:\n        pass'
p2467
(F-2.6243121934973677
F-3.067336845397949
tp2468
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p2469
(F-2.6601019325496265
F-3.210221862792969
tp2470
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2471
(F-2.242386862496349
F-3.255634307861328
tp2472
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2473
(F-2.6211370458743843
F-3.270879364013672
tp2474
sS'obj = obj.copy()'
p2475
(F-2.163547303941515
F-3.0902240753173826
tp2476
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2477
(F-2.628545346467391
F-3.2836688995361327
tp2478
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2479
(F-2.654010641163793
F-3.224024200439453
tp2480
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p2481
(F-2.9126756729618197
F-3.1907039642333985
tp2482
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2483
(F-1.909367596661603
F-3.1092514038085937
tp2484
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2485
(F-3.154859655043658
F-3.2163436889648436
tp2486
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2487
(F-2.7111985426682694
F-3.220838928222656
tp2488
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p2489
(F-2.747786865234375
F-3.204961395263672
tp2490
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2491
(F-2.6110378207289022
F-3.265979766845703
tp2492
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p2493
(F-2.6028606052505237
F-3.2541259765625
tp2494
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2495
(F-1.9938702705578926
F-3.1150293350219727
tp2496
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2497
(F-2.5509942861703725
F-3.2585174560546877
tp2498
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2499
(F-2.422670636858259
F-3.202991485595703
tp2500
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True"
p2501
(F-2.5364577349494484
F-2.9503101348876952
tp2502
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2503
(F-2.693211975097656
F-3.2473316192626953
tp2504
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2505
(F-2.8167435840893815
F-3.1869749069213866
tp2506
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2507
(F-2.7221469455295138
F-3.2200511932373046
tp2508
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2509
(F-2.949228989450555
F-3.2390167236328127
tp2510
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p2511
(F-2.6159415713624457
F-3.250035858154297
tp2512
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2513
(F-2.721760508778331
F-3.2147022247314454
tp2514
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2515
(F-2.846891923384233
F-3.210791015625
tp2516
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2517
(F-3.0198758443196616
F-3.156271553039551
tp2518
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2519
(F-2.6693609064275567
F-3.226737213134766
tp2520
sS"print 'copy.deepcopy:', time() - t"
p2521
(F-4.365764999389649
F-3.440268707275391
tp2522
sS'dignore = {str: None, unicode: None, int: None, type(None): None}'
p2523
(F-3.45033327738444
F-3.3613800048828124
tp2524
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2525
(F-2.5988022406228115
F-3.2489086151123048
tp2526
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    pass'
p2527
(F-2.4049239485231166
F-3.02744197845459
tp2528
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2529
(F-2.7577655498798075
F-3.1911983489990234
tp2530
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2531
(F-2.514534887764868
F-3.2535091400146485
tp2532
sS"print 'generator expression extend:', time() - t"
p2533
(F-4.365764999389649
F-3.440268707275391
tp2534
sS'for i in xrange(num_times):\n    a = []\na.extend(L)'
p2535
(F-1.9132502629206731
F-3.2251319885253906
tp2536
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2537
(F-2.6977852957589286
F-3.2790775299072266
tp2538
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2539
(F-2.5760212291370737
F-3.2890533447265624
tp2540
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2541
(F-1.815962720273146
F-3.1162954330444337
tp2542
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2543
(F-2.7042574415019915
F-3.2162166595458985
tp2544
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2545
(F-2.4167939284752156
F-3.307311248779297
tp2546
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2547
(F-2.477671125293833
F-3.2490638732910155
tp2548
sS'for y in L:\n    pass'
p2549
(F-2.013539574363015
F-3.0166048049926757
tp2550
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2551
(F-2.2587735576014363
F-3.2828594207763673
tp2552
sS"print 'Custom Copy:', time() - t"
p2553
(F-4.365764999389649
F-3.440268707275391
tp2554
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2555
(F-2.4162203610598385
F-3.289881134033203
tp2556
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2557
(F-2.4040040750108007
F-3.2698131561279298
tp2558
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2559
(F-2.234309826867055
F-3.2828857421875
tp2560
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2561
(F-2.666962012816011
F-3.2353919982910155
tp2562
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2563
(F-2.683273543172808
F-3.2690940856933595
tp2564
sS'def __init__(self):\n    pass'
p2565
(F-1.445916039603097
F-3.191219520568848
tp2566
sS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p2567
(F-2.185805402483259
F-3.2012256622314452
tp2568
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2569
(F-2.511842679251269
F-3.2781734466552734
tp2570
sS'if is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2571
(F-2.176174527122861
F-3.0557008743286134
tp2572
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2573
(F-2.788960164388021
F-3.221294403076172
tp2574
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2575
(F-2.5931147157756333
F-3.23462028503418
tp2576
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p2577
(F-1.4969387367123463
F-2.9940372467041017
tp2578
sS'def Copy(obj, use_deepcopy=True):\n    pass'
p2579
(F-3.102270338270399
F-3.094706344604492
tp2580
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2581
(F-2.3589029398050396
F-3.267022705078125
tp2582
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2583
(F-2.6492713023040255
F-3.2669132232666014
tp2584
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p2585
(F-2.8348200056287975
F-3.1739498138427735
tp2586
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2587
(F-2.746162283761161
F-3.2337169647216797
tp2588
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2589
(F-2.836836223360858
F-3.199351119995117
tp2590
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2591
(F-2.643459481252751
F-3.139099884033203
tp2592
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2593
(F-2.686457316080729
F-3.2261432647705077
tp2594
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2595
(F-2.457109971479936
F-3.2799697875976563
tp2596
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p2597
(F-4.046972751617432
F-3.501752471923828
tp2598
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p2599
(F-2.6464827896712664
F-3.192234420776367
tp2600
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2601
(F-2.5644726960555366
F-3.2530887603759764
tp2602
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    pass'
p2603
(F-2.9715517620707668
F-2.9813018798828126
tp2604
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2605
(F-2.5437281681941104
F-3.215164566040039
tp2606
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2607
(F-2.534483564660904
F-3.2562442779541017
tp2608
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2609
(F-2.129786956004607
F-3.270648956298828
tp2610
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2611
(F-2.5780173561789774
F-3.2496788024902346
tp2612
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2613
(F-2.6256923176231184
F-3.2146957397460936
tp2614
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2615
(F-2.475389827977341
F-3.260893630981445
tp2616
sS'for k in obj:\n    pass'
p2617
(F-2.129007512872869
F-3.0455547332763673
tp2618
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2619
(F-2.4681687001057586
F-3.2706535339355467
tp2620
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2621
(F-2.697198222867019
F-3.1538154602050783
tp2622
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p2623
(F-3.0044807665275806
F-2.998356246948242
tp2624
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2625
(F-2.4593899559428674
F-3.2692939758300783
tp2626
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2627
(F-2.714834386652166
F-3.2071727752685546
tp2628
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2629
(F-3.0192301432291666
F-3.154246711730957
tp2630
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2631
(F-2.638179894649621
F-3.1839435577392576
tp2632
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2633
(F-2.645823246290704
F-3.2398937225341795
tp2634
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t"
p2635
(F-2.701192907384924
F-3.068625068664551
tp2636
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2637
(F-2.3201762232287177
F-3.2183292388916014
tp2638
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2639
(F-2.725071154142681
F-3.2333137512207033
tp2640
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2641
(F-2.719318820121593
F-3.230887603759766
tp2642
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2643
(F-2.5311130476586614
F-3.245540237426758
tp2644
sS'dignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True\nobj = list(obj)'
p2645
(F-2.972543144226074
F-3.0301918029785155
tp2646
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2647
(F-2.5503059097483187
F-3.2458267211914062
tp2648
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2649
(F-2.541561760914237
F-3.280160903930664
tp2650
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2651
(F-2.6336324865167793
F-3.2790706634521483
tp2652
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2653
(F-2.1919582911900113
F-3.270404052734375
tp2654
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2655
(F-2.6951511142490148
F-3.1745273590087892
tp2656
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2657
(F-2.8176513671875
F-3.239491271972656
tp2658
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2659
(F-2.399949391682943
F-3.2766033172607423
tp2660
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2661
(F-2.4652277037154797
F-3.204605484008789
tp2662
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2663
(F-2.579665195794753
F-3.278321075439453
tp2664
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2665
(F-2.6277587574380665
F-3.251032257080078
tp2666
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2667
(F-2.6779660021410825
F-3.212629699707031
tp2668
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2669
(F-2.9232613058651196
F-3.215316390991211
tp2670
sS'obj = deepcopy(obj)'
p2671
(F-2.5245776176452637
F-3.2254432678222655
tp2672
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2673
(F-2.9280613793267145
F-3.173888397216797
tp2674
sS'import copy\nnew_list = copy.deepcopy(old_list)'
p2675
(F-1.1699135724235983
F-3.0056859970092775
tp2676
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2677
(F-2.8412331359027183
F-3.259963607788086
tp2678
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2679
(F-2.650204357087921
F-3.179576110839844
tp2680
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue'
p2681
(F-1.785281519736013
F-3.1498571395874024
tp2682
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2683
(F-2.9024680352980092
F-3.304494857788086
tp2684
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2685
(F-3.058580620344295
F-3.1902305603027346
tp2686
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2687
(F-2.5691432044619607
F-3.2066383361816406
tp2688
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2689
(F-2.4338464034231087
F-3.295718765258789
tp2690
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2691
(F-2.62494111396897
F-3.2212982177734375
tp2692
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2693
(F-2.669950391425461
F-3.1686962127685545
tp2694
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2695
(F-2.50410300806949
F-3.2577632904052733
tp2696
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2697
(F-2.70294005295326
F-3.2866241455078127
tp2698
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p2699
(F-3.35993023307956
F-3.1731754302978517
tp2700
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2701
(F-2.726659455367823
F-3.2020965576171876
tp2702
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2703
(F-2.602908828883495
F-3.2846927642822266
tp2704
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2705
(F-2.6392486704376354
F-3.1771316528320312
tp2706
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2707
(F-2.6516042856069713
F-3.2381458282470703
tp2708
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p2709
(F-2.8863850346318
F-3.1791234970092774
tp2710
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2711
(F-2.6805180763711736
F-3.217172622680664
tp2712
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2713
(F-1.7781808376312256
F-3.1774003982543944
tp2714
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2715
(F-2.6503092447916665
F-3.1736011505126953
tp2716
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p2717
(F-2.787722033123637
F-3.1839717864990233
tp2718
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2719
(F-2.3839378785551264
F-3.2164230346679688
tp2720
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2721
(F-1.9699575106302898
F-3.118678665161133
tp2722
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2723
(F-2.35531977171539
F-3.2221343994140623
tp2724
sS"a.extend(L)\nprint 'list extend:', time() - t"
p2725
(F-3.553467694450827
F-3.0034732818603516
tp2726
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p2727
(F-2.9599301207299327
F-3.1400184631347656
tp2728
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2729
(F-2.6081857936267547
F-3.2396469116210938
tp2730
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2731
(F-2.6910070374954578
F-3.222031021118164
tp2732
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2733
(F-2.200442379468108
F-3.2512168884277344
tp2734
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2735
(F-2.3615064433976714
F-3.1656232833862306
tp2736
sS'for i in xrange(num_times):\n    a = []'
p2737
(F-1.8306744224146794
F-3.216868209838867
tp2738
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    pass'
p2739
(F-2.0974631931470786
F-3.150283622741699
tp2740
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2741
(F-2.8381857299804687
F-3.1689767837524414
tp2742
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2743
(F-2.5491506144788683
F-3.234249496459961
tp2744
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2745
(F-2.5430028438568115
F-3.3175296783447266
tp2746
sS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)'
p2747
(F-2.2316877841949463
F-3.2242530822753905
tp2748
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p2749
(F-1.3658743071974369
F-3.1526086807250975
tp2750
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p2751
(F-1.927501747824929
F-3.1207366943359376
tp2752
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p2753
(F-2.761377832911036
F-3.2252601623535155
tp2754
sS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p2755
(F-1.899377362481479
F-3.1895212173461913
tp2756
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2757
(F-2.4895167300575656
F-3.2464920043945313
tp2758
sS'new_list = list(old_list)'
p2759
(F-1.4760723114013672
F-3.122904586791992
tp2760
sS'c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p2761
(F-1.753502919123723
F-3.1372100830078127
tp2762
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2763
(F-2.5970035760655446
F-3.2072120666503907
tp2764
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2765
(F-2.403824951171875
F-3.280255889892578
tp2766
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2767
(F-2.5916028703962053
F-3.267892074584961
tp2768
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p2769
(F-2.8239007247121712
F-3.1856359481811523
tp2770
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2771
(F-2.569048444801402
F-3.254734420776367
tp2772
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2773
(F-2.630773168410698
F-3.2260814666748048
tp2774
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2775
(F-2.7433826793323863
F-3.190988540649414
tp2776
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p2777
(F-2.6897120988701446
F-3.2257965087890623
tp2778
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2779
(F-2.4583709067486703
F-3.2717750549316404
tp2780
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2781
(F-2.4694157052547374
F-3.288480758666992
tp2782
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2783
(F-2.3678883143833707
F-3.219314193725586
tp2784
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p2785
(F-1.0394943410700017
F-3.1118305206298826
tp2786
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2787
(F-2.40428125
F-3.2484676361083986
tp2788
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2789
(F-2.4972664254610657
F-3.287235641479492
tp2790
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2791
(F-2.4870269907501354
F-3.276274490356445
tp2792
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2793
(F-2.4704976081848145
F-3.261424255371094
tp2794
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2795
(F-2.524813703481587
F-3.253874588012695
tp2796
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2797
(F-2.432970442861881
F-3.284345245361328
tp2798
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p2799
(F-2.853009765625
F-3.174042510986328
tp2800
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2801
(F-2.4158560483510256
F-3.2515769958496095
tp2802
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()'
p2803
(F-2.3033138226859178
F-3.0339879989624023
tp2804
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2805
(F-2.3367107157804528
F-3.188973617553711
tp2806
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2807
(F-2.5613596337473292
F-3.228655242919922
tp2808
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2809
(F-2.725483507213026
F-3.2609329223632812
tp2810
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p2811
(F-2.8401436578659784
F-3.1862600326538084
tp2812
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2813
(F-2.1753790378570557
F-3.2224178314208984
tp2814
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2815
(F-2.3103367338244545
F-3.2821395874023436
tp2816
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2817
(F-2.260344950358073
F-3.132527542114258
tp2818
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2819
(F-2.8551143646240233
F-3.2111019134521483
tp2820
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2821
(F-2.4078226558497695
F-3.2746864318847657
tp2822
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2823
(F-2.8910323079427083
F-3.1572341918945312
tp2824
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p2825
(F-3.1497369766235352
F-3.158188819885254
tp2826
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2827
(F-2.389995350557215
F-3.2813949584960938
tp2828
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2829
(F-2.5712045919040083
F-3.274241256713867
tp2830
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2831
(F-2.7002915362922515
F-3.250238800048828
tp2832
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2833
(F-2.865215974695542
F-3.1958099365234376
tp2834
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2835
(F-2.5402608522227115
F-3.245458221435547
tp2836
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2837
(F-2.657760813266416
F-3.1875959396362306
tp2838
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2839
(F-2.833053820060961
F-3.1785898208618164
tp2840
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2841
(F-2.652663988944812
F-3.201437759399414
tp2842
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2843
(F-2.534653347514798
F-3.2317466735839844
tp2844
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2845
(F-2.6065277635005484
F-3.180234909057617
tp2846
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t"
p2847
(F-3.0253223020638993
F-3.171399688720703
tp2848
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2849
(F-2.687303881959867
F-3.209505081176758
tp2850
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2851
(F-2.4869269853756752
F-3.2624443054199217
tp2852
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2853
(F-2.9559605039399246
F-3.17834529876709
tp2854
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2855
(F-2.6508660434691373
F-3.235940933227539
tp2856
sS'if t in (list, tuple):\n    if t == tuple:\n        is_tuple = True\nobj = list(obj)'
p2857
(F-2.6603988198673023
F-3.10900821685791
tp2858
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2859
(F-1.9421352464325574
F-3.107094573974609
tp2860
sS'obj = tuple(obj)'
p2861
(F-2.4527828693389893
F-3.073369789123535
tp2862
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2863
(F-2.60419970703125
F-3.1802495956420898
tp2864
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2865
(F-2.5433330294452134
F-3.2926662445068358
tp2866
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2867
(F-2.8085559446420243
F-3.244655990600586
tp2868
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2869
(F-2.506996437355324
F-3.2759750366210936
tp2870
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2871
(F-2.6813454141422195
F-3.237336349487305
tp2872
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2873
(F-2.5669799118899226
F-3.290979766845703
tp2874
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p2875
(F-2.7501153326653816
F-3.144612121582031
tp2876
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p2877
(F-2.816499418370864
F-3.2528759002685548
tp2878
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p2879
(F-2.711201801558965
F-3.220789337158203
tp2880
sS'continue'
p2881
(F-3.1214914321899414
F-3.462969970703125
tp2882
sS'if type(obj[k]) in dignore:\n    continue'
p2883
(F-2.5275860954733456
F-3.182428169250488
tp2884
sS"a.append('baz')"
p2885
(F-1.7039638757705688
F-3.039532279968262
tp2886
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2887
(F-2.677867465549045
F-3.183489990234375
tp2888
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2889
(F-2.311320597330729
F-3.2336936950683595
tp2890
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2891
(F-2.63392578125
F-3.2713489532470703
tp2892
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2893
(F-2.480993438185307
F-3.2914390563964844
tp2894
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p2895
(F-2.4059500443307975
F-3.242928314208984
tp2896
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2897
(F-1.9161506321119226
F-3.101333236694336
tp2898
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2899
(F-2.6996869255514704
F-3.195592498779297
tp2900
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        continue'
p2901
(F-2.2113225251725575
F-3.063801574707031
tp2902
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2903
(F-2.50760058098033
F-3.2210315704345702
tp2904
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2905
(F-1.512706382601869
F-3.1211029052734376
tp2906
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p2907
(F-2.706796191987537
F-3.144657325744629
tp2908
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p2909
(F-2.340971014472876
F-3.2083763122558593
tp2910
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p2911
(F-2.736418786710196
F-3.178441047668457
tp2912
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p2913
(F-2.593816856971154
F-3.1996410369873045
tp2914
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()"
p2915
(F-3.031541273328993
F-3.1739032745361326
tp2916
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2917
(F-2.3968614431527944
F-3.2560665130615236
tp2918
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2919
(F-2.4520513815957994
F-3.256161117553711
tp2920
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2921
(F-2.6852135067894345
F-3.2294841766357423
tp2922
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p2923
(F-3.038091345678402
F-3.207335662841797
tp2924
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2925
(F-2.6133154072892775
F-3.289908599853516
tp2926
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        pass'
p2927
(F-1.7652698639900453
F-3.1114301681518555
tp2928
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2929
(F-2.707481533873315
F-3.25179443359375
tp2930
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2931
(F-2.733226879222973
F-3.1297538757324217
tp2932
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2933
(F-2.369649098331767
F-3.233538818359375
tp2934
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p2935
(F-2.7854055196297267
F-3.2161914825439455
tp2936
sS'import copy\n\n\nclass Foo(object):\n    pass'
p2937
(F-1.7336971058565027
F-3.0374771118164063
tp2938
sS'def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p2939
(F-1.9372086701569733
F-3.156243896484375
tp2940
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2941
(F-2.8719505027488426
F-3.1749174118041994
tp2942
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = [\'foo\', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p2943
(F-1.639258231825501
F-3.1621912002563475
tp2944
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2945
(F-2.6596892113779105
F-3.212372970581055
tp2946
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2947
(F-2.0608610559682377
F-3.0972848892211915
tp2948
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2949
(F-2.3743239326711083
F-3.2532676696777343
tp2950
sS"print 'copy.deepcopy:', time() - t\nt = time()"
p2951
(F-4.046972751617432
F-3.501752471923828
tp2952
sS't = time()\nfor i in xrange(num_times):\n    pass'
p2953
(F-2.4301463040438565
F-3.261701965332031
tp2954
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p2955
(F-1.4991014268663194
F-3.0508445739746093
tp2956
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2957
(F-2.4231772521719397
F-3.256501007080078
tp2958
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p2959
(F-2.4703886821007854
F-3.2642311096191405
tp2960
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2961
(F-2.3501830048613495
F-3.2873512268066407
tp2962
sS'Copy(L)'
p2963
(F-3.5696163177490234
F-3.151310348510742
tp2964
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2965
(F-2.6077206893705984
F-3.2185337066650392
tp2966
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p2967
(F-2.682294492368345
F-3.1617481231689455
tp2968
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()"
p2969
(F-3.3417008833451702
F-3.1990713119506835
tp2970
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p2971
(F-2.643935354132401
F-3.2446258544921873
tp2972
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p2973
(F-2.5395221854337215
F-3.21015625
tp2974
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p2975
(F-2.550149792822722
F-3.244845962524414
tp2976
sS"a.append('baz')\nfoo.val = 5"
p2977
(F-2.70831298828125
F-3.218402862548828
tp2978
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p2979
(F-2.40390149681969
F-3.3215686798095705
tp2980
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p2981
(F-2.6604846772693453
F-3.189739990234375
tp2982
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p2983
(F-2.864796058804381
F-3.1659183502197266
tp2984
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p2985
(F-2.432106657951109
F-3.258871841430664
tp2986
sS'for i in xrange(num_times):\n    a = []\na.extend(i for i in L)'
p2987
(F-1.967175038655599
F-3.239653778076172
tp2988
sS'obj = list(obj)'
p2989
(F-2.1731820106506348
F-3.0257362365722655
tp2990
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p2991
(F-2.6694259370099687
F-3.2014156341552735
tp2992
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2993
(F-2.426513195037842
F-3.2808296203613283
tp2994
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2995
(F-2.4760401200275033
F-3.271626281738281
tp2996
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2997
(F-1.5040062537560097
F-3.149771499633789
tp2998
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p2999
(F-2.4868040121378114
F-3.254420852661133
tp3000
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3001
(F-2.522039711880846
F-3.221749114990234
tp3002
sS"print 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3003
(F-2.9024680352980092
F-3.304494857788086
tp3004
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3005
(F-2.406818051881428
F-3.274828338623047
tp3006
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p3007
(F-2.6569574282501853
F-3.2556716918945314
tp3008
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p3009
(F-3.5988155862559443
F-3.04709415435791
tp3010
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p3011
(F-2.6790834699358257
F-3.243571090698242
tp3012
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p3013
(F-2.710476847833076
F-3.1738651275634764
tp3014
sS'if is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        pass'
p3015
(F-2.1186113357543945
F-3.0715358734130858
tp3016
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p3017
(F-2.646330244085762
F-3.1731395721435547
tp3018
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p3019
(F-2.4954775117980645
F-3.275258255004883
tp3020
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p3021
(F-2.6968673551925506
F-3.253587341308594
tp3022
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3023
(F-2.5931681494355727
F-3.2291866302490235
tp3024
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p3025
(F-2.593589358859592
F-3.116791343688965
tp3026
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3027
(F-2.634563991001674
F-3.2769412994384766
tp3028
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()"
p3029
(F-2.747446632385254
F-3.0935821533203125
tp3030
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p3031
(F-2.5664125230577257
F-3.192926788330078
tp3032
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3033
(F-2.406673576258406
F-3.2481422424316406
tp3034
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p3035
(F-2.3736045591292845
F-3.2587051391601562
tp3036
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p3037
(F-2.626100376674107
F-3.2423564910888674
tp3038
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p3039
(F-2.5426815819802546
F-3.2378177642822266
tp3040
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3041
(F-2.553947386702871
F-3.2386985778808595
tp3042
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3043
(F-2.723282648364143
F-3.26395263671875
tp3044
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3045
(F-2.554902336283926
F-3.2181968688964844
tp3046
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3047
(F-2.824164109002976
F-3.194436454772949
tp3048
sS'new_list = copy.deepcopy(old_list)'
p3049
(F-1.369762556893485
F-3.0273990631103516
tp3050
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t"
p3051
(F-2.7756595284598213
F-3.1499267578125
tp3052
sS"print 'copy.copy:', time() - t\nt = time()"
p3053
(F-4.046972751617432
F-3.501752471923828
tp3054
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()"
p3055
(F-2.8968345023490287
F-3.144687843322754
tp3056
sS'dignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        pass'
p3057
(F-3.030610899994339
F-2.9764381408691407
tp3058
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3059
(F-2.5554590301922753
F-3.2403724670410154
tp3060
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p3061
(F-2.6183268229166665
F-3.2492637634277344
tp3062
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p3063
(F-2.8953541346958707
F-3.189188766479492
tp3064
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p3065
(F-2.774821646261535
F-3.183131217956543
tp3066
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p3067
(F-2.467312508104253
F-3.2718196868896485
tp3068
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3069
(F-2.5516903686523436
F-3.261646270751953
tp3070
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3071
(F-2.545516151459619
F-3.2582305908203124
tp3072
sS"print 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3073
(F-2.40503515625
F-3.2556957244873046
tp3074
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p3075
(F-2.582845943921233
F-3.274521255493164
tp3076
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3077
(F-2.5635481984991775
F-3.244813919067383
tp3078
sS'return str(self.val)'
p3079
(F-3.132814195421007
F-3.3214698791503907
tp3080
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p3081
(F-2.5247993728741496
F-3.2214080810546877
tp3082
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p3083
(F-2.6938258579799106
F-3.1755260467529296
tp3084
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3085
(F-2.380533968464712
F-3.2219337463378905
tp3086
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3087
(F-2.6907983896683674
F-3.175787925720215
tp3088
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p3089
(F-2.8804788340692933
F-3.2028308868408204
tp3090
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3091
(F-2.7699615920799365
F-3.2079776763916015
tp3092
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3093
(F-2.728798750508038
F-3.2088756561279297
tp3094
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p3095
(F-2.7205832057062223
F-3.230051040649414
tp3096
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p3097
(F-2.7025727062690548
F-3.2846302032470702
tp3098
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3099
(F-2.5320279445331058
F-3.224600601196289
tp3100
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()"
p3101
(F-2.582964977586126
F-3.2439979553222655
tp3102
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3103
(F-2.578830558505259
F-3.227873992919922
tp3104
sS'for k in obj:\n    if type(obj[k]) in dignore:\n        continue'
p3105
(F-2.069080505371094
F-3.1630783081054688
tp3106
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3107
(F-2.6012088628285945
F-3.2357688903808595
tp3108
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3109
(F-2.7715475442526225
F-3.220025634765625
tp3110
sS'new_list = old_list[:]'
p3111
(F-1.6688615481058757
F-3.052115249633789
tp3112
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p3113
(F-2.3988633099724264
F-3.3039485931396486
tp3114
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p3115
(F-2.6313854715098506
F-3.2401554107666017
tp3116
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p3117
(F-2.71467618589048
F-3.1694801330566404
tp3118
sS'foo.val = 5'
p3119
(F-4.416542598179409
F-3.1947341918945313
tp3120
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3121
(F-2.6910601265822787
F-3.1718772888183593
tp3122
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3123
(F-2.4073643978173136
F-3.264670562744141
tp3124
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3125
(F-2.5723973200871395
F-3.120005989074707
tp3126
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p3127
(F-1.6108963676120924
F-3.101065826416016
tp3128
sS"self.blah = 'blah'"
p3129
(F-2.6531900678362166
F-3.130320739746094
tp3130
sS'from copy import deepcopy\n\n\nclass old_class:\n    pass'
p3131
(F-2.6577495998806424
F-2.969849395751953
tp3132
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3133
(F-2.418744415406756
F-3.2630916595458985
tp3134
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3135
(F-2.653888795433975
F-3.2683250427246096
tp3136
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p3137
(F-2.3968076844146284
F-3.272732162475586
tp3138
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3139
(F-2.6437708536783853
F-3.2583377838134764
tp3140
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3141
(F-2.694902815908756
F-3.2448486328125
tp3142
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t"
p3143
(F-2.633462451753162
F-3.2345462799072267
tp3144
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3145
(F-2.6289986212134817
F-3.1954845428466796
tp3146
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p3147
(F-2.646484375
F-3.1984453201293945
tp3148
sS"print 'list expression(L):', time() - t\nt = time()"
p3149
(F-4.046972751617432
F-3.501752471923828
tp3150
sS'obj[x] = Copy(obj[x], use_deepcopy)'
p3151
(F-3.516999986436632
F-3.0056787490844727
tp3152
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3153
(F-2.4246207150545986
F-3.289175033569336
tp3154
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3155
(F-2.5699999170395933
F-3.2742271423339844
tp3156
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t"
p3157
(F-2.6434503220419847
F-3.2227500915527343
tp3158
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3159
(F-2.307811874941171
F-3.2036460876464843
tp3160
sS'list(L)'
p3161
(F-2.0685575803120932
F-3.050137519836426
tp3162
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)"
p3163
(F-2.4778912444612873
F-3.293134307861328
tp3164
sS'a.extend(i for i in L)'
p3165
(F-2.369814078013102
F-3.047826957702637
tp3166
sS't = time()'
p3167
(F-3.886417661394392
F-3.3935626983642577
tp3168
sS"print 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p3169
(F-2.819870842827691
F-3.1816162109375
tp3170
sS'for i in xrange(num_times):\n    Copy(L)'
p3171
(F-2.3803124678762337
F-3.1771678924560547
tp3172
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3173
(F-2.4883011848695817
F-3.2039981842041017
tp3174
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3175
(F-2.603702908470517
F-3.2332515716552734
tp3176
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p3177
(F-2.5500409526209675
F-3.222534942626953
tp3178
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3179
(F-2.6957869096235796
F-3.2738189697265625
tp3180
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()"
p3181
(F-2.775060239045516
F-3.187221336364746
tp3182
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3183
(F-2.525289633839401
F-3.260367202758789
tp3184
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p3185
(F-2.6049053214188946
F-3.288869857788086
tp3186
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p3187
(F-2.6813120052514487
F-3.241352844238281
tp3188
sS"return obj\nif __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3189
(F-2.573283743351064
F-3.2380298614501952
tp3190
sS'def __repr__(self):\n    return str(self.val)'
p3191
(F-1.3975290298461913
F-3.1690671920776365
tp3192
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p3193
(F-2.488636522737455
F-3.253326416015625
tp3194
sS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)'
p3195
(F-2.2411138746473522
F-3.236629104614258
tp3196
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p3197
(F-2.6056703920717594
F-3.2705867767333983
tp3198
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3199
(F-2.5709503173828123
F-3.216117095947266
tp3200
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3201
(F-1.5413666831122503
F-3.1644643783569335
tp3202
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3203
(F-2.649228876287287
F-3.236541748046875
tp3204
sS"a.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3205
(F-2.7318861426376717
F-3.13537712097168
tp3206
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3207
(F-2.472604751586914
F-3.294960784912109
tp3208
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p3209
(F-2.537095743815104
F-3.233673858642578
tp3210
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3211
(F-2.8260735405815973
F-3.1253318786621094
tp3212
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p3213
(F-2.7496224285042197
F-3.161474609375
tp3214
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3215
(F-2.567218182538007
F-3.2218273162841795
tp3216
sS'for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p3217
(F-2.748896179199219
F-3.134225845336914
tp3218
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p3219
(F-1.0637931060791015
F-3.141438674926758
tp3220
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()"
p3221
(F-3.0408267974853516
F-3.2019325256347657
tp3222
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p3223
(F-1.7402663812404726
F-3.14047794342041
tp3224
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p3225
(F-2.7099052308097717
F-3.1715774536132812
tp3226
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3227
(F-2.1368307165197424
F-3.2317310333251954
tp3228
sS"return obj\nif __name__ == '__main__':\n    pass"
p3229
(F-2.268557071685791
F-3.23997802734375
tp3230
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        pass'
p3231
(F-2.2046436198706765
F-3.052638626098633
tp3232
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p3233
(F-2.58740234375
F-3.1913496017456056
tp3234
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p3235
(F-2.5743006819385594
F-3.2541786193847657
tp3236
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()"
p3237
(F-2.78015244175011
F-3.1523876190185547
tp3238
sS"print 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3239
(F-2.9024680352980092
F-3.304494857788086
tp3240
sS'for x in xrange(len(obj)):\n    if type(obj[x]) in dignore:\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    pass'
p3241
(F-2.2515497100487183
F-3.040926933288574
tp3242
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()"
p3243
(F-2.663340467087766
F-3.2503307342529295
tp3244
sS'for k in obj:\n    if type(obj[k]) in dignore:\n        pass'
p3245
(F-2.0470706176757814
F-3.124949836730957
tp3246
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p3247
(F-2.5742645263671875
F-3.169879150390625
tp3248
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3249
(F-2.0431876409621466
F-3.112407112121582
tp3250
sS'obj = obj[:]'
p3251
(F-2.658498525619507
F-3.0999805450439455
tp3252
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t"
p3253
(F-2.6305948893229165
F-3.204266357421875
tp3254
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p3255
(F-1.510887319391424
F-3.157095718383789
tp3256
sS"print 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3257
(F-2.5403953043619794
F-3.2510562896728517
tp3258
sS"if __name__ == '__main__':\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()"
p3259
(F-2.680578957141285
F-3.172620391845703
tp3260
sS'if type(obj[k]) in dignore:\n    pass'
p3261
(F-2.4449501037597656
F-3.0895776748657227
tp3262
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3263
(F-1.5189546438363881
F-3.1370357513427733
tp3264
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3265
(F-2.4946271935287787
F-3.2000988006591795
tp3266
sS'if t in (list, tuple):\n    pass'
p3267
(F-2.7139307657877603
F-3.0268970489501954
tp3268
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3269
(F-2.4551505348899147
F-3.2377334594726563
tp3270
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3271
(F-2.4290584735016325
F-3.286049652099609
tp3272
sS'is_tuple = False'
p3273
(F-3.6428781236921037
F-3.0728206634521484
tp3274
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif t == dict:\n    obj = obj.copy()\nfor k in obj:\n    if type(obj[k]) in dignore:\n        continue'
p3275
(F-2.467128387869221
F-3.020517349243164
tp3276
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True"
p3277
(F-2.310801814152644
F-2.956691932678223
tp3278
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(i for i in L)\nprint 'generator expression extend:', time() - t"
p3279
(F-2.511784930561864
F-3.238521957397461
tp3280
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3281
(F-1.8041462253879856
F-3.119376564025879
tp3282
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3283
(F-2.7120539347330728
F-3.195069694519043
tp3284
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3285
(F-2.7385854794997577
F-3.203731155395508
tp3286
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t"
p3287
(F-2.8702938373272238
F-3.177876853942871
tp3288
sS"print 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p3289
(F-2.9654384706078507
F-3.2558082580566405
tp3290
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p3291
(F-1.4593400221604567
F-2.98572998046875
tp3292
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p3293
(F-2.615822531960227
F-3.317926025390625
tp3294
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t"
p3295
(F-2.7351354225394653
F-3.19085578918457
tp3296
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah'},\n    old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3297
(F-2.568173090616862
F-3.2355690002441406
tp3298
sS'd = copy.copy(a)\ne = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p3299
(F-2.0914360682169595
F-3.2137168884277343
tp3300
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3301
(F-2.4220443475441855
F-3.282389831542969
tp3302
sS"print 'list append:', time() - t"
p3303
(F-4.365764999389649
F-3.440268707275391
tp3304
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()"
p3305
(F-3.0360293668859146
F-3.174549865722656
tp3306
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()"
p3307
(F-2.543194540185866
F-3.239107131958008
tp3308
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif t in (list, tuple):\n    if t == tuple:\n        is_tuple = True\nobj = list(obj)'
p3309
(F-2.7569174085344588
F-2.9363759994506835
tp3310
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3311
(F-2.8124832403464395
F-3.2137638092041017
tp3312
sS"print 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()"
p3313
(F-2.786704821464343
F-3.2235183715820312
tp3314
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3315
(F-2.565378488587939
F-3.3053821563720702
tp3316
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3317
(F-2.523453090501868
F-3.1144071578979493
tp3318
sS"print 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3319
(F-2.576789066709321
F-3.1745723724365233
tp3320
sS"print 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3321
(F-2.3946047923603997
F-3.251555633544922
tp3322
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t"
p3323
(F-2.449929836577019
F-3.244019317626953
tp3324
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3325
(F-2.710014820098877
F-3.1864387512207033
tp3326
sS'for i in xrange(num_times):\n    copy.deepcopy(L)'
p3327
(F-1.8216540018717449
F-3.135219764709473
tp3328
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None}\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p3329
(F-2.232759035550631
F-3.0536399841308595
tp3330
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', time() - t\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', time() - t\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', time() - t\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3331
(F-2.470850451239224
F-3.268310546875
tp3332
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3333
(F-1.6981372833251953
F-3.1282424926757812
tp3334
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', time() - t\nt = time()\nfor i in xrange(num_times):\n    pass"
p3335
(F-2.2466966901506695
F-3.235991287231445
tp3336
sS'c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append(\'baz\')\nfoo.val = 5\nprint """original: %r\n slice: %r\n list(): %r\n copy: %r\n deepcopy: %r""" % (a,\n    b, c, d, e)'
p3337
(F-1.9450381192294035
F-3.179151725769043
tp3338
ssI610883
(dp3339
S"if hasattr(a, 'property'):\n    doStuff(a.property)\nelse:\n    otherStuff()"
p3340
(F-2.1928555806477865
F-1.8892677013690655
tp3341
sS'doStuff(a.property)'
p3342
(F-4.139122009277344
F-1.8619185227614183
tp3343
sS"if hasattr(a, 'property'):\n    doStuff(a.property)"
p3344
(F-2.2278308868408203
F-1.7919342334453876
tp3345
sS"if hasattr(a, 'property'):\n    a.property"
p3346
(F-2.076284885406494
F-1.6445023463322566
tp3347
sS"if hasattr(a, 'property'):\n    pass"
p3348
(F-1.132307529449463
F-1.849359659048227
tp3349
sS"if hasattr(a, 'property'):\n    doStuff(a.property)\nelse:\n    pass"
p3350
(F-1.838552404333044
F-1.7914396432729869
tp3351
sS'try:\n    doStuff(a.property)\nexcept AttributeError:\n    otherStuff()'
p3352
(F-2.6568271930401144
F-1.9734196296105018
tp3353
sS'a.property'
p3354
(F-3.6426929473876952
F-1.7633121197040265
tp3355
sS'try:\n    doStuff(a.property)\nexcept AttributeError:\n    pass'
p3356
(F-2.0794321143108867
F-1.8635437305157
tp3357
sS"getattr(a, 'property', 'default value')"
p3358
(F-1.758418655395508
F-1.6968533442570612
tp3359
sS'otherStuff()'
p3360
(F-3.51484743754069
F-2.112521978525015
tp3361
ssI402504
(dp3362
S'type(i) is float'
p3363
(F-3.9914298057556152
F-2.2023353576660156
tp3364
sS'type(i)\ntype(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long'
p3365
(F-3.4842313569167565
F-2.162641178477894
tp3366
sS'type(i)\ntype(i) is long\ni = 123.456\ntype(i)'
p3367
(F-3.3774851018732246
F-2.138499520041726
tp3368
sS'i = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456\ntype(i)\ntype(i) is float'
p3369
(F-3.1069021513967803
F-2.2075389515269888
tp3370
sS'type(i)\ntype(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456\ntype(i)'
p3371
(F-3.290017579731188
F-2.1394987973299893
tp3372
sS'i = 123.456'
p3373
(F-2.3394954681396483
F-2.2621695778586646
tp3374
sS'type(i) is long'
p3375
(F-4.20722770690918
F-2.1789122494784268
tp3376
sS'i = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456\ntype(i)'
p3377
(F-2.9454929645244894
F-2.16464580189098
tp3378
sS"v = 'hi'"
p3379
(F-1.844735336303711
F-2.2610518715598364
tp3380
sS'i = 123\ntype(i)\ntype(i) is int\ni = 123456789L'
p3381
(F-3.02272215343657
F-2.235458720814098
tp3382
sS'i = 123\ntype(i)\ntype(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456'
p3383
(F-3.1416147592905403
F-2.2061328887939453
tp3384
sS'type(i) is int'
p3385
(F-3.6426000595092773
F-2.147367477416992
tp3386
sS'i = 123\ntype(i)\ntype(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456\ntype(i)\ntype(i) is float'
p3387
(F-3.1526894082828445
F-2.218799591064453
tp3388
sS'i = 123'
p3389
(F-2.9265153884887694
F-2.3541346463290127
tp3390
sS'v = 10\ntype(v)'
p3391
(F-2.505567169189453
F-2.143007278442383
tp3392
sS'i = 123.456\ntype(i)'
p3393
(F-2.4542415618896483
F-2.1840055639093574
tp3394
sS'i = 123456789L\ntype(i)'
p3395
(F-2.4542415618896483
F-2.1840055639093574
tp3396
sS'i = 123\ntype(i)'
p3397
(F-2.670452880859375
F-2.2676523382013496
tp3398
sS'type(i)\ntype(i) is float'
p3399
(F-3.6928135798527646
F-2.1918584650213067
tp3400
sS'i = 123456789L'
p3401
(F-2.3394954681396483
F-2.2621694044633345
tp3402
sS'v = 100000000000000\ntype(v)'
p3403
(F-2.331729507446289
F-2.1399222287264736
tp3404
sS'type(i)\ntype(i) is long\ni = 123.456'
p3405
(F-3.629914227653952
F-2.1574935913085938
tp3406
sS'type(v)'
p3407
(F-2.282197952270508
F-2.102914983575994
tp3408
sS'type(i) is long\ni = 123.456\ntype(i)'
p3409
(F-3.3611138287712548
F-2.1430958834561435
tp3410
sS'type(i) is int\ni = 123456789L'
p3411
(F-3.3642053604125977
F-2.146436171098189
tp3412
sS'type(i)\ntype(i) is int\ni = 123456789L\ntype(i)'
p3413
(F-3.1668895374644888
F-2.1380597894841973
tp3414
sS'i = 123\ntype(i)\ntype(i) is int\ni = 123456789L\ntype(i)'
p3415
(F-2.9053717393141527
F-2.2086634202436968
tp3416
sS'type(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456\ntype(i)\ntype(i) is float'
p3417
(F-3.373249816894531
F-2.183490579778498
tp3418
sS'type(i) is long\ni = 123.456\ntype(i)\ntype(i) is float'
p3419
(F-3.553429285685221
F-2.1889721263538706
tp3420
sS'v = 100000000000000'
p3421
(F-2.1361766815185548
F-2.201373880559748
tp3422
sS'i = 123\ntype(i)\ntype(i) is int'
p3423
(F-3.0361276514389934
F-2.2433121421120386
tp3424
sS'type(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456'
p3425
(F-3.421355656215123
F-2.151141946965998
tp3426
sS'type(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long'
p3427
(F-3.52317746480306
F-2.1611289978027344
tp3428
sS'i = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456'
p3429
(F-3.0991007486979165
F-2.1880278153852983
tp3430
sS'type(i)\ntype(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456\ntype(i)\ntype(i) is float'
p3431
(F-3.375419108072917
F-2.182586669921875
tp3432
sS'v = -10\ntype(v)'
p3433
(F-2.6272288235751065
F-2.179461045698686
tp3434
sS'type(i)'
p3435
(F-2.4960899353027344
F-2.1321979869495737
tp3436
sS'type(i)\ntype(i) is int\ni = 123456789L'
p3437
(F-3.3301023595473347
F-2.1471092917702417
tp3438
sS'print type(variable_name)'
p3439
(F-2.696533203125
F-1.9594358964399858
tp3440
sS'i = 123456789L\ntype(i)\ntype(i) is long'
p3441
(F-3.1726949355181526
F-2.1978719884699043
tp3442
sS'type(i)\ntype(i) is long\ni = 123.456\ntype(i)\ntype(i) is float'
p3443
(F-3.5364963926117996
F-2.183744257146662
tp3444
sS'type(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456\ntype(i)'
p3445
(F-3.2747872092507104
F-2.1384639739990234
tp3446
sS'i = 123\ntype(i)\ntype(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456\ntype(i)'
p3447
(F-3.064766293480283
F-2.185000679709695
tp3448
sS'i = 123\ntype(i)\ntype(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long'
p3449
(F-3.1825457486239346
F-2.2181920138272373
tp3450
sS'type(i)\ntype(i) is long'
p3451
(F-3.8534014775202823
F-2.169125643643466
tp3452
sS'type(i)\ntype(i) is int\ni = 123456789L\ntype(i)\ntype(i) is long\ni = 123.456'
p3453
(F-3.410130587491122
F-2.1515270579944956
tp3454
sS'type(i)\ntype(i) is int'
p3455
(F-3.454508561354417
F-2.1504717740145596
tp3456
sS'v = 10'
p3457
(F-2.8719526290893556
F-2.1259389357133345
tp3458
sS'v = -10'
p3459
(F-3.067665417989095
F-2.2012516368519175
tp3460
sS'type(i) is int\ni = 123456789L\ntype(i)'
p3461
(F-3.1418699376723347
F-2.1346215334805576
tp3462
sS'type(i) is long\ni = 123.456'
p3463
(F-3.7428102493286133
F-2.1697533347389917
tp3464
sS"v = 'hi'\ntype(v)"
p3465
(F-2.0281015396118165
F-2.145671671087092
tp3466
sS'i = 123.456\ntype(i)\ntype(i) is float'
p3467
(F-3.038819256950827
F-2.226382515647195
tp3468
ssI275018
(dp3469
S'"""test string \n""".rstrip(\'\\n\')'
p3470
(F-1.6731228828430176
F-2.1598903111049106
tp3471
sS's.rstrip()'
p3472
(F-1.5749355043683733
F-2.1024036407470703
tp3473
sS"'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p3474
(F-1.6731230020523071
F-2.1598903111049106
tp3475
sS"s = ' \\n  abc   def   '"
p3476
(F-1.898753547668457
F-2.3079011099679128
tp3477
sS'\'Windows EOL\\r\\n\'.rstrip(\'\\r\\n\')\n"""Unix EOL\n""".rstrip(\'\\r\\n\')'
p3478
(F-1.8790751139322917
F-2.1766665322440013
tp3479
sS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'\ntext.splitlines()"
p3480
(F-1.7718575217507102
F-2.2663398470197404
tp3481
sS'"""Hello\n""".rstrip(\'\\n\')'
p3482
(F-1.6731228828430176
F-2.1598903111049106
tp3483
sS'\'Mac EOL\\r\'.rstrip(\'\\r\\n\')\n\'Windows EOL\\r\\n\'.rstrip(\'\\r\\n\')\n"""Unix EOL\n"""'
p3484
(F-1.8787574768066406
F-2.183993339538574
tp3485
sS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p3486
(F-1.8790751139322917
F-2.1766665322440013
tp3487
sS's.strip()'
p3488
(F-1.3638819285801478
F-2.2016537530081615
tp3489
sS"s = ' \\n  abc   def   '\ns.strip()"
p3490
(F-1.2269172668457031
F-2.2515792846679688
tp3491
sS'"""test string \n"""'
p3492
(F-2.222964604695638
F-2.3229658944266185
tp3493
sS's.rstrip()\ns.lstrip()'
p3494
(F-1.908551729642428
F-2.211605889456613
tp3495
sS's.strip()\ns.rstrip()'
p3496
(F-1.5143073155329778
F-2.151228632245745
tp3497
sS'\'Mac EOL\\r\'.rstrip(\'\\r\\n\')\n\'Windows EOL\\r\\n\'.rstrip(\'\\r\\n\')\n"""Unix EOL\n""".rstrip(\'\\r\\n\')'
p3498
(F-1.8893644159490413
F-2.1915201459612166
tp3499
sS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'"
p3500
(F-1.7216253280639648
F-2.284834997994559
tp3501
sS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()"
p3502
(F-1.128563824821921
F-2.181410653250558
tp3503
sS'text.splitlines()'
p3504
(F-1.76467650277274
F-2.2155023302350725
tp3505
sS'"""test string\n"""'
p3506
(F-2.222964604695638
F-2.3229658944266185
tp3507
sS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()\ns.lstrip()"
p3508
(F-1.2199420099673064
F-2.25192505972726
tp3509
sS's.lstrip()'
p3510
(F-2.1576870509556363
F-2.3589463915143694
tp3511
sS'"""test string\n""".rstrip()'
p3512
(F-1.8977948597499303
F-2.1411635535103932
tp3513
sS'\'Windows EOL\\r\\n\'.rstrip(\'\\r\\n\')\n"""Unix EOL\n"""'
p3514
(F-1.8457862854003906
F-2.1701447623116628
tp3515
sS'"""Unix EOL\n""".rstrip(\'\\r\\n\')'
p3516
(F-1.6731228828430176
F-2.1598903111049106
tp3517
sS'"""Hello\n"""'
p3518
(F-2.222964604695638
F-2.3229658944266185
tp3519
sS"'Mac EOL\\r'.rstrip('\\r\\n')"
p3520
(F-1.6731230020523071
F-2.1598903111049106
tp3521
sS'"""Unix EOL\n"""'
p3522
(F-2.222964604695638
F-2.3229658944266185
tp3523
sS's.strip()\ns.rstrip()\ns.lstrip()'
p3524
(F-1.642613461143092
F-2.237476485116141
tp3525
ssI364621
(dp3526
S'testlist = [1, 2, 3, 5, 3, 1, 2, 1, 6]\nfor position, item in enumerate(testlist):\n    pass'
p3527
(F-1.8172059310109991
F-2.085842572725736
tp3528
sS'testlist = [1, 2, 3, 5, 3, 1, 2, 1, 6]\nfor position, item in enumerate(testlist):\n    if item == 1:\n        pass'
p3529
(F-1.6095279196034307
F-2.0874702747051535
tp3530
sS'if element in testlist:\n    pass'
p3531
(F-2.4772302454168145
F-2.1392261798565206
tp3532
sS'(i for i, x in enumerate(testlist) if x == 1)\nfor i in (i for i, x in enumerate(testlist) if x == 1):\n    pass'
p3533
(F-2.081633456917696
F-2.0513716477614183
tp3534
sS'if element in testlist:\n    pass\n'
p3535
(F-2.4772302454168145
F-2.1392261798565206
tp3536
sS'try:\n    print testlist.index(element)\nexcept ValueError:\n    pass'
p3537
(F-1.7024421691894531
F-2.3256671612079325
tp3538
sS'pass'
p3539
(F-3.2122650146484375
F-2.490017524132362
tp3540
sS'for i in gen:\n    pass\n'
p3541
(F-2.2757233706387607
F-2.0928206810584435
tp3542
sS'for i in [i for i, x in enumerate(testlist) if x == 1]:\n    pass\n'
p3543
(F-1.7189917931189904
F-2.0270861112154446
tp3544
sS'print testlist.index(element)'
p3545
(F-3.0510376824273004
F-2.1158599853515625
tp3546
sS'print i'
p3547
(F-2.9568123817443848
F-2.3883787301870494
tp3548
sS'(i for i, x in enumerate(testlist) if x == 1)'
p3549
(F-2.2074835035536022
F-2.03326049217811
tp3550
sS'for position, item in enumerate(testlist):\n    if item == 1:\n        pass'
p3551
(F-1.6201890309651692
F-2.0614957075852613
tp3552
sS'testlist = [1, 2, 3, 5, 3, 1, 2, 1, 6]'
p3553
(F-1.7019557123598845
F-2.135944366455078
tp3554
sS'gen = (i for i, x in enumerate(testlist) if x == 1)\nfor i in gen:\n    pass\n'
p3555
(F-2.258160400390625
F-2.1199085529033956
tp3556
sS'for i in gen:\n    pass'
p3557
(F-2.2757233706387607
F-2.0928206810584435
tp3558
sS'[i for i, x in enumerate(testlist) if x == 1]'
p3559
(F-1.6264940897623699
F-2.0331617502065806
tp3560
sS'for i in (i for i, x in enumerate(testlist) if x == 1):\n    pass'
p3561
(F-1.8592303349421575
F-2.058760276207557
tp3562
sS'(i for i, x in enumerate(testlist) if x == 1)\nfor i in (i for i, x in enumerate(testlist) if x == 1):\n    pass\n'
p3563
(F-2.081633456917696
F-2.0513716477614183
tp3564
sS'testlist'
p3565
(F-6.106791814168294
F-2.5740599999061
tp3566
sS'for i in (i for i, x in enumerate(testlist) if x == 1):\n    pass\n'
p3567
(F-1.8592303349421575
F-2.058760276207557
tp3568
sS'if item == 1:\n    pass'
p3569
(F-1.6255191456187854
F-2.223977749164288
tp3570
sS'print testlist.index(element) if element in testlist else None'
p3571
(F-3.6688888549804686
F-2.0221319932204027
tp3572
sS'gen = (i for i, x in enumerate(testlist) if x == 1)\nfor i in gen:\n    pass'
p3573
(F-2.258160400390625
F-2.1199088463416467
tp3574
sS'if item == 1:\n    pass\n'
p3575
(F-1.6255191456187854
F-2.223977749164288
tp3576
sS'gen = (i for i, x in enumerate(testlist) if x == 1)'
p3577
(F-2.177444839477539
F-2.1048917036790113
tp3578
sS'for position, item in enumerate(testlist):\n    pass'
p3579
(F-2.099184989929199
F-2.038312765268179
tp3580
sS'testlist\n[i for i, x in enumerate(testlist) if x == 1]'
p3581
(F-2.4089262008666994
F-2.0366026071401744
tp3582
sS'testlist = [1, 2, 3, 5, 3, 1, 2, 1, 6]\nfor position, item in enumerate(testlist):\n    if item == 1:\n        pass\n'
p3583
(F-1.6095279196034307
F-2.0874702747051535
tp3584
sS'print position'
p3585
(F-3.725938558578491
F-2.4126286139855018
tp3586
sS'for position, item in enumerate(testlist):\n    if item == 1:\n        pass\n'
p3587
(F-1.6201890309651692
F-2.0614957075852613
tp3588
sS'for i in [i for i, x in enumerate(testlist) if x == 1]:\n    pass'
p3589
(F-1.7189917931189904
F-2.0270861112154446
tp3590
ssI952914
(dp3591
S'import itertools\nlist2d = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nmerged = list(itertools.chain(*list2d))'
p3592
(F-1.1745751563538895
F-2.050721388596755
tp3593
sS'sum(l, [])'
p3594
(F-2.035555945502387
F-2.23518914442796
tp3595
sS'import itertools\nlist2d = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]'
p3596
(F-1.1060143639059627
F-2.0876536736121545
tp3597
sS'list2d = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nmerged = list(itertools.chain(*list2d))'
p3598
(F-1.16398117759011
F-2.085577157827524
tp3599
sS'merged = list(itertools.chain(*list2d))'
p3600
(F-1.8071118763514928
F-2.139549548809345
tp3601
sS'list2d = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]'
p3602
(F-1.026638892389113
F-2.174334305983323
tp3603
sS'[item for sublist in l for item in sublist]'
p3604
(F-1.5484908177302434
F-2.0076211782602162
tp3605
sS'import itertools\nlist2d = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nmerged = list(itertools.chain.from_iterable(list2d))'
p3606
(F-1.1560855102539063
F-2.058653611403245
tp3607
sS'list2d = [[1, 2, 3], [4, 5, 6], [7], [8, 9]]\nmerged = list(itertools.chain.from_iterable(list2d))'
p3608
(F-1.1354578708080536
F-2.0864634880652795
tp3609
sS'import itertools'
p3610
(F-2.443108081817627
F-2.085723583514874
tp3611
sS'merged = list(itertools.chain.from_iterable(list2d))'
p3612
(F-1.5114109936882467
F-2.1423793205848107
tp3613
ssI276052
(dp3614
S'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3615
(F-2.980884552001953
F-2.780397268442007
tp3616
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3617
(F-2.6403521913470644
F-2.8471254202035756
tp3618
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3619
(F-2.9965955946180554
F-2.95973146878756
tp3620
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p3621
(F-2.8865563309432676
F-3.008164332463191
tp3622
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3623
(F-2.9494971159462615
F-2.8720327524038463
tp3624
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3625
(F-2.9499294832817413
F-2.9203109741210938
tp3626
sS"proc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3627
(F-3.7302510915708935
F-3.08974368755634
tp3628
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3629
(F-2.534774683083698
F-3.0420362032376804
tp3630
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3631
(F-2.9076498623551994
F-2.89090083195613
tp3632
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p3633
(F-2.8204120026917017
F-2.9294119614821215
tp3634
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p3635
(F-2.8359284577546298
F-2.8987814096304088
tp3636
sS'return proc_results_list\n\ndef get_sys_stats():\n    pass'
p3637
(F-2.8837203979492188
F-2.754180908203125
tp3638
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3639
(F-2.796618586001189
F-3.0452194213867188
tp3640
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3641
(F-2.944352382205311
F-2.9600163973294773
tp3642
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3643
(F-2.474278041294643
F-2.9035879281850963
tp3644
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p3645
(F-3.387692219502217
F-3.0521017221304088
tp3646
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p3647
(F-3.200693303888494
F-2.8215918907752404
tp3648
sS"'NumberInducedGC', 'NumberGen0Collections'\n'NumberGen1Collections', 'NumberGen2Collections'\n'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1'"
p3649
(F-2.160008063683143
F-3.3168854346642127
tp3650
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3651
(F-3.062777051738664
F-2.7233223548302283
tp3652
sS'import psutil'
p3653
(F-2.829991579055786
F-2.972686767578125
tp3654
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p3655
(F-2.780575706845238
F-2.8966228778545675
tp3656
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p3657
(F-3.0228342646440582
F-2.8742218017578125
tp3658
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3659
(F-2.232116340188419
F-2.825739933894231
tp3660
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p3661
(F-3.9027911915498623
F-2.9293526869553785
tp3662
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()"
p3663
(F-1.9259026616597348
F-2.7987081087552586
tp3664
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3665
(F-2.2220688831957083
F-2.8174940255972056
tp3666
sS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())'
p3667
(F-1.8338799476623535
F-2.9418258666992188
tp3668
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n"
p3669
(F-3.3078978531003935
F-2.7984771728515625
tp3670
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass"
p3671
(F-2.111521543305496
F-2.93792724609375
tp3672
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3673
(F-2.949749782747109
F-2.8975155170147238
tp3674
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p3675
(F-2.989261560272752
F-2.908428485576923
tp3676
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p3677
(F-3.0666250020516017
F-2.869946993314303
tp3678
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p3679
(F-2.77078049271195
F-2.876966036283053
tp3680
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3681
(F-3.107753578428666
F-2.9023023752065806
tp3682
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p3683
(F-2.8881442047828854
F-2.9660720825195312
tp3684
sS'import psutil\nprint psutil.cpu_percent()'
p3685
(F-1.7656013782207782
F-2.934321476862981
tp3686
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p3687
(F-3.017960307754089
F-2.8946782625638523
tp3688
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p3689
(F-3.3476677389705882
F-2.924389178936298
tp3690
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()'
p3691
(F-2.8113501412527904
F-3.1491053654597354
tp3692
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p3693
(F-2.514924154672713
F-2.8924305255596456
tp3694
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3695
(F-3.5812850088443398
F-3.018902118389423
tp3696
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p3697
(F-2.9576811224107997
F-2.9424998943622294
tp3698
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p3699
(F-2.880748327759197
F-2.8653907775878906
tp3700
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3701
(F-2.8385873189786586
F-2.88104981642503
tp3702
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p3703
(F-3.4427615356445314
F-3.067616682786208
tp3704
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p3705
(F-3.503546127357388
F-2.907361544095553
tp3706
sS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p3707
(F-3.059239890358665
F-2.6495150052584133
tp3708
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p3709
(F-2.992274517376417
F-2.9511580834021935
tp3710
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p3711
(F-2.56603872364965
F-2.9384947556715746
tp3712
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3713
(F-3.001607537813927
F-2.9148741502028246
tp3714
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p3715
(F-2.3990771484375
F-3.2227325439453125
tp3716
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3717
(F-3.515441337979673
F-2.9296610905573917
tp3718
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3719
(F-2.721730659512209
F-2.8858199486365685
tp3720
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p3721
(F-3.28561250663098
F-3.0464545029860277
tp3722
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3723
(F-3.176560087832148
F-2.654190650353065
tp3724
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p3725
(F-3.0720471263637203
F-2.962397942176232
tp3726
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p3727
(F-3.023463609483507
F-3.1423879770132213
tp3728
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3729
(F-3.0691244377771145
F-2.9018490131084738
tp3730
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3731
(F-2.978238573261336
F-3.1296859154334435
tp3732
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p3733
(F-2.897412443814212
F-2.8264526954064
tp3734
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3735
(F-2.5234649836668495
F-2.7975167494553785
tp3736
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p3737
(F-2.9246985093602595
F-2.8753139789287863
tp3738
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p3739
(F-3.6230850219726562
F-3.571790255033053
tp3740
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3741
(F-3.3681145163143382
F-2.8969990656926083
tp3742
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute"
p3743
(F-3.796039581298828
F-3.511942643385667
tp3744
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3745
(F-2.6927440025506106
F-2.9802495516263523
tp3746
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p3747
(F-2.939642923358224
F-2.8416067270132213
tp3748
sS'if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p3749
(F-2.8082667759486606
F-3.362152393047626
tp3750
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os'
p3751
(F-3.2355475393282314
F-2.7620826134314904
tp3752
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p3753
(F-2.8612969292534722
F-2.876729525052584
tp3754
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p3755
(F-2.9388392465263844
F-2.88597165621244
tp3756
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3757
(F-2.1345935821533204
F-2.649426973783053
tp3758
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p3759
(F-2.4153826756460854
F-2.9756199763371396
tp3760
sS"if proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute"
p3761
(F-3.3135353826707408
F-3.3955538823054385
tp3762
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass"
p3763
(F-2.318070705581761
F-2.9778536283052883
tp3764
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p3765
(F-2.199893527560764
F-2.8774713369516225
tp3766
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p3767
(F-3.0309778519007033
F-2.8662901658278246
tp3768
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3769
(F-2.9945132127448693
F-2.894215803879958
tp3770
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3771
(F-3.1813520543715534
F-2.7407924945537863
tp3772
sS'if proc_name.lower() in obj_name.lower():\n    found_flag = True'
p3773
(F-2.9325985378689237
F-3.284871321458083
tp3774
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p3775
(F-3.1691102145010963
F-2.9336321904109073
tp3776
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3777
(F-2.9665095011393228
F-2.958678025465745
tp3778
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p3779
(F-3.517862540524022
F-2.9712747427133412
tp3780
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p3781
(F-3.0271231135966614
F-2.875408466045673
tp3782
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3783
(F-3.4627113217213115
F-2.9435154841496396
tp3784
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]"
p3785
(F-2.3207824382376163
F-2.741033700796274
tp3786
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3787
(F-3.0895878675845054
F-2.8928037790151744
tp3788
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3789
(F-2.186540236166858
F-2.738060290996845
tp3790
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3791
(F-3.4503984559257077
F-2.9524007943960338
tp3792
sS'return proc_results_list'
p3793
(F-4.370079040527344
F-2.9334335327148438
tp3794
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p3795
(F-2.5812049458045085
F-2.9043315007136417
tp3796
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3797
(F-3.4220367431640626
F-2.902942950908954
tp3798
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3799
(F-2.991772282732664
F-2.867289029634916
tp3800
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3801
(F-2.9664854107481062
F-2.9945496779221754
tp3802
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3803
(F-2.286760272401752
F-2.6951983525202823
tp3804
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3805
(F-4.11476318359375
F-3.515044872577374
tp3806
sS'import pythoncom\nimport pywintypes'
p3807
(F-4.783409118652344
F-2.7757271986741285
tp3808
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3809
(F-2.275984764099121
F-2.7365103501539965
tp3810
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p3811
(F-2.905264442845395
F-2.9677611130934496
tp3812
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p3813
(F-3.6854180230034723
F-3.221935272216797
tp3814
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p3815
(F-2.579842055139463
F-3.001072810246394
tp3816
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3817
(F-3.2058639526367188
F-2.8312548123873196
tp3818
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3819
(F-2.4785872204912023
F-2.8110116811899037
tp3820
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3821
(F-2.7748113408818975
F-2.85172359759991
tp3822
sS'import os\nimport psutil\npid = os.getpid()'
p3823
(F-1.908739980061849
F-2.8786092904897838
tp3824
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3825
(F-3.097778750137544
F-3.120960529033954
tp3826
sS"'CreatingProcessID', 'Description', 'IODataBytesPersec'\n'IODataOperationsPersec', 'IOOtherBytesPersec'\n'IOOtherOperationsPersec', 'IOReadBytesPersec'\n'IOReadOperationsPersec', 'IOWriteBytesPersec'"
p3827
(F-1.647511733205695
F-3.3281596257136417
tp3828
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p3829
(F-3.025521510017779
F-2.866231771615835
tp3830
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p3831
(F-3.303900093867861
F-2.992901141826923
tp3832
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3833
(F-2.8295559969815343
F-3.1145154512845554
tp3834
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3835
(F-2.569579808057937
F-2.839628659761869
tp3836
sS"if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3837
(F-3.283171984614158
F-2.9215921255258412
tp3838
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p3839
(F-3.0976571076368558
F-2.924935267521785
tp3840
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p3841
(F-2.7647412724855567
F-2.9088577857384315
tp3842
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p3843
(F-3.377023767541956
F-3.1073215191180887
tp3844
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p3845
(F-2.923396268336893
F-2.920687748835637
tp3846
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p3847
(F-2.790210121556332
F-2.9137652470515323
tp3848
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n'
p3849
(F-3.2478387819840604
F-2.7712924663837137
tp3850
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p3851
(F-3.0749986605751247
F-2.907816373384916
tp3852
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3853
(F-3.6305558681488037
F-3.2120901254507213
tp3854
sS'def winmem():\n    x = MEMORYSTATUS()'
p3855
(F-1.8603111267089845
F-3.049197270320012
tp3856
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3857
(F-4.024409086807914
F-2.9861720158503604
tp3858
sS'break'
p3859
(F-2.7797724405924478
F-3.1955848106971154
tp3860
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p3861
(F-3.0608787536621094
F-3.3257968609149637
tp3862
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p3863
(F-2.9581134718865103
F-2.876363314115084
tp3864
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3865
(F-2.817823038921097
F-2.912811279296875
tp3866
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3867
(F-2.8918354105185498
F-2.8609340374286356
tp3868
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3869
(F-2.9040842899659864
F-2.8705130357008715
tp3870
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3871
(F-3.494976701407597
F-2.9039165790264425
tp3872
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p3873
(F-3.051660633619937
F-2.879344646747296
tp3874
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p3875
(F-3.452948122608418
F-2.9095288790189304
tp3876
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3877
(F-2.9791140853905063
F-2.880239046536959
tp3878
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p3879
(F-2.964820310999904
F-2.8562903771033654
tp3880
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p3881
(F-2.781183878580729
F-2.9569344153771033
tp3882
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass'
p3883
(F-3.2034245484264185
F-2.8014546907865086
tp3884
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p3885
(F-2.9781760440510547
F-2.9680926983173075
tp3886
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p3887
(F-2.941126275831653
F-2.829925537109375
tp3888
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3889
(F-3.465008507476994
F-2.930616232065054
tp3890
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3891
(F-4.205436257755055
F-3.249947474553035
tp3892
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p3893
(F-2.9473658068426722
F-2.97816408597506
tp3894
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p3895
(F-2.9598761089777543
F-2.849596463716947
tp3896
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p3897
(F-3.3548274845271915
F-2.7648670489971456
tp3898
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p3899
(F-3.656132748252467
F-3.260409721961388
tp3900
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3901
(F-2.533249016094925
F-2.9367030217097354
tp3902
sS"this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p3903
(F-2.9213218688964844
F-3.1342333280123196
tp3904
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p3905
(F-2.9239545338373385
F-2.853740692138672
tp3906
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3907
(F-2.741996208639706
F-2.8535320575420675
tp3908
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p3909
(F-2.938564361735461
F-2.944516108586238
tp3910
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p3911
(F-3.9052825927734376
F-3.2139822152944713
tp3912
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3913
(F-3.564417193012853
F-3.022926037128155
tp3914
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3915
(F-2.780040185776115
F-2.9308236929086537
tp3916
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3917
(F-2.720063554479721
F-2.8759354811448317
tp3918
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p3919
(F-2.8812954454536897
F-3.283525907076322
tp3920
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p3921
(F-2.4225548852848102
F-2.8250917287973256
tp3922
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3923
(F-2.6846233995892197
F-2.838316403902494
tp3924
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p3925
(F-3.5056860470077367
F-2.9959928072415867
tp3926
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p3927
(F-3.0361681198325394
F-2.8967032799353967
tp3928
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3929
(F-3.0259503965024597
F-2.728313152606671
tp3930
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])'
p3931
(F-3.38675153748063
F-2.748469719519982
tp3932
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3933
(F-3.453658056075048
F-2.9339370727539062
tp3934
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p3935
(F-2.7982130582752145
F-2.9240147517277646
tp3936
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p3937
(F-3.431948068979624
F-2.8441878098707933
tp3938
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3939
(F-2.7731535668466605
F-2.8440469595102162
tp3940
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3941
(F-3.1050010503724566
F-2.7113480201134315
tp3942
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p3943
(F-2.5228519762976696
F-2.9291898287259617
tp3944
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p3945
(F-3.035518101283482
F-2.9310804513784556
tp3946
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3947
(F-3.0906529456564464
F-2.9154833280123196
tp3948
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()'
p3949
(F-3.302675021914985
F-2.7995904775766225
tp3950
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3951
(F-3.237389337448847
F-3.003125704251803
tp3952
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p3953
(F-2.556918486705801
F-2.793644538292518
tp3954
sS"this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nproc_results_list.append(this_proc_dict)"
p3955
(F-2.9273055311272906
F-3.074289762056791
tp3956
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3957
(F-2.6839622007597477
F-2.9278103755070615
tp3958
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p3959
(F-2.8647967923072075
F-2.980862544133113
tp3960
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3961
(F-2.601713681931741
F-2.8405735309307394
tp3962
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p3963
(F-3.468380527641937
F-3.1102532606858473
tp3964
sS'pythoncom.CoInitialize()\nx = winmem()'
p3965
(F-3.5081541878836497
F-3.0413328317495494
tp3966
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p3967
(F-2.954119226421189
F-2.918596414419321
tp3968
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p3969
(F-3.046988573539008
F-2.880247849684495
tp3970
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3971
(F-2.6315759373462106
F-2.894319387582632
tp3972
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3973
(F-2.8011152564580715
F-3.0046771122859073
tp3974
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3975
(F-2.643497389190051
F-2.8095626831054688
tp3976
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3977
(F-2.5871527256109776
F-3.371977292574369
tp3978
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}"
p3979
(F-1.71498746288066
F-3.7671370873084435
tp3980
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3981
(F-2.435556648603452
F-2.97944582425631
tp3982
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3983
(F-3.102505747995163
F-2.91486329298753
tp3984
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3985
(F-3.1551641352392035
F-2.9502179072453427
tp3986
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3987
(F-2.8076264467032703
F-2.916040273813101
tp3988
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3989
(F-3.006773193359375
F-2.794715587909405
tp3990
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3991
(F-3.0815614331670167
F-2.9162271939791164
tp3992
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p3993
(F-2.501939174107143
F-2.878591097318209
tp3994
sS'if proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p3995
(F-2.8844089997120395
F-3.3428209744966946
tp3996
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p3997
(F-2.944918864482158
F-2.829833984375
tp3998
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3999
(F-2.576411485671997
F-2.9578924912672777
tp4000
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4001
(F-2.619488266638092
F-2.8457260131835938
tp4002
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4003
(F-3.339543392783717
F-2.7644163278432994
tp4004
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4005
(F-3.0583531121099354
F-2.97930908203125
tp4006
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p4007
(F-2.91137455531529
F-2.8739474369929385
tp4008
sS'__revision__ = 3'
p4009
(F-5.266937255859375
F-3.682127145620493
tp4010
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p4011
(F-2.4541926049069818
F-2.9153641920823317
tp4012
sS"if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nproc_results_list.append(this_proc_dict)"
p4013
(F-2.9511400159898695
F-3.1007411663348856
tp4014
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    pass"
p4015
(F-2.227669609917535
F-3.027417989877554
tp4016
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])"
p4017
(F-3.03894948151152
F-3.1978231576772838
tp4018
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4019
(F-2.5461512598498115
F-2.997968233548678
tp4020
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4021
(F-3.0266737717848557
F-2.8849161588228664
tp4022
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nproc_results_list.append(this_proc_dict)"
p4023
(F-3.2581005278087796
F-3.050753666804387
tp4024
sS'import os'
p4025
(F-2.4222095012664795
F-2.9719728323129506
tp4026
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p4027
(F-2.6427773172541182
F-2.9361842228816104
tp4028
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4029
(F-2.998576067496037
F-2.975942171536959
tp4030
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4031
(F-3.024323272705078
F-2.8932456970214844
tp4032
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4033
(F-3.174773387419872
F-2.8475925738994894
tp4034
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p4035
(F-2.89731542614923
F-2.9320018474872294
tp4036
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4037
(F-2.6382434710577574
F-2.877553206223708
tp4038
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p4039
(F-2.4868002391996837
F-2.8603040255033054
tp4040
sS'for counter_type in perf_object_list:\n    pass'
p4041
(F-3.6886453067555145
F-3.54740964449369
tp4042
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4043
(F-3.206507161458333
F-2.948473123403696
tp4044
sS'def winmem():\n    pass'
p4045
(F-1.5386695861816406
F-3.0632189237154446
tp4046
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p4047
(F-3.3510932651817376
F-3.0920659578763523
tp4048
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4049
(F-3.1497312946084106
F-2.8987321120042067
tp4050
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4051
(F-2.927484489889706
F-2.85448250403771
tp4052
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p4053
(F-2.7838484648686306
F-2.910138350266677
tp4054
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p4055
(F-4.284670459980867
F-3.5450404240534854
tp4056
sS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4057
(F-3.022270755491395
F-2.6272838299091044
tp4058
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p4059
(F-4.35388047354562
F-3.195049285888672
tp4060
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4061
(F-3.4448410152464874
F-2.994854266826923
tp4062
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4063
(F-3.8813797388321314
F-3.460309248704177
tp4064
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4065
(F-2.790592823213744
F-2.8599554208608775
tp4066
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4067
(F-2.1795354933965774
F-2.7348172114445615
tp4068
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4069
(F-3.013103757585798
F-2.658092205341046
tp4070
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4071
(F-3.092424406828704
F-2.894624563363882
tp4072
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4073
(F-3.003020770733173
F-3.161300072303185
tp4074
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4075
(F-2.8731033413057823
F-2.900271489070012
tp4076
sS'""" Returns a dictionary of the system stats"""'
p4077
(F-2.897493362426758
F-3.27553705068735
tp4078
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p4079
(F-2.925412859235491
F-2.981043888972356
tp4080
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p4081
(F-2.9814789539247046
F-2.963011228121244
tp4082
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4083
(F-3.666142054966518
F-3.0198314373309794
tp4084
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4085
(F-3.4775131597751523
F-2.921341822697566
tp4086
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p4087
(F-3.4237152902703536
F-2.8461779080904446
tp4088
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p4089
(F-2.9856834804888854
F-2.946377680851863
tp4090
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}"
p4091
(F-2.219031197684152
F-3.5158612177922177
tp4092
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4093
(F-2.892404734469615
F-2.8948399470402646
tp4094
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p4095
(F-2.9267922644000435
F-2.83669192974384
tp4096
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4097
(F-3.184191848292495
F-2.95689949622521
tp4098
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p4099
(F-2.920697965955179
F-2.9382781982421875
tp4100
sS'if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    pass'
p4101
(F-2.619214163886176
F-3.2658958435058594
tp4102
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p4103
(F-2.5474122322645765
F-3.252611600435697
tp4104
sS"'NumberInducedGC', 'NumberGen0Collections'\n'NumberGen1Collections', 'NumberGen2Collections'"
p4105
(F-2.5792198181152344
F-3.3010019155649037
tp4106
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4107
(F-2.917050516664101
F-2.833310053898738
tp4108
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4109
(F-3.4518814400880915
F-2.9246964087853065
tp4110
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4111
(F-3.42502377439274
F-2.976655813363882
tp4112
sS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4113
(F-3.0108937715229236
F-2.5840257497934194
tp4114
sS'pid = os.getpid()\npy = psutil.Process(pid)'
p4115
(F-2.2759831746419272
F-2.8840860220102162
tp4116
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4117
(F-3.338257628601867
F-2.8081814692570615
tp4118
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p4119
(F-2.4376216687654195
F-2.8961844811072717
tp4120
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4121
(F-2.4511157341723173
F-3.1020211439866285
tp4122
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4123
(F-2.999925372981224
F-2.898936931903546
tp4124
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4125
(F-2.6476577537647192
F-2.91545897263747
tp4126
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p4127
(F-3.0096800667898997
F-2.900064908541166
tp4128
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p4129
(F-2.5041097951489824
F-3.0670491732083836
tp4130
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4131
(F-2.93921484375
F-2.9721442002516527
tp4132
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4133
(F-3.332208215837648
F-2.880445333627554
tp4134
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4135
(F-2.957274697043679
F-2.705374791071965
tp4136
sS'import psutil\npid = os.getpid()'
p4137
(F-1.9472764333089192
F-2.8210590069110575
tp4138
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    pass"
p4139
(F-3.2994789455247964
F-3.0538864135742188
tp4140
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4141
(F-2.4227292959329785
F-2.924694061279297
tp4142
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4143
(F-2.9771767093150396
F-2.8847500727726865
tp4144
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4145
(F-3.000489976671007
F-2.917102813720703
tp4146
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict'
p4147
(F-3.7123955620659723
F-2.848070584810697
tp4148
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4149
(F-2.382428241032426
F-2.847685300386869
tp4150
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p4151
(F-3.8147029286807346
F-3.0650916466346154
tp4152
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4153
(F-2.978198318600841
F-2.9223714975210338
tp4154
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]"
p4155
(F-2.608515319824219
F-2.7654237013596754
tp4156
sS"'IOOtherOperationsPersec', 'IOReadBytesPersec'"
p4157
(F-3.2224597930908203
F-3.27936524611253
tp4158
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p4159
(F-2.78041557416524
F-3.031776134784405
tp4160
sS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4161
(F-3.1433648329514723
F-2.642071944016677
tp4162
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4163
(F-3.1186390918580376
F-2.9140806931715746
tp4164
sS'import pywintypes'
p4165
(F-4.449464797973633
F-2.8820662865271935
tp4166
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p4167
(F-2.8830126953125
F-2.857363774226262
tp4168
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4169
(F-3.131436060345362
F-2.9683030935434194
tp4170
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4171
(F-3.6200148638556984
F-2.98262698833759
tp4172
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p4173
(F-2.607452630996704
F-2.9712374760554385
tp4174
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4175
(F-2.9807469011789345
F-2.877018561730018
tp4176
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4177
(F-3.3761477170290646
F-2.9447543804462137
tp4178
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4179
(F-2.9725409715695488
F-2.849764897273137
tp4180
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4181
(F-2.812786795079023
F-2.918947073129507
tp4182
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4183
(F-3.5481865700711026
F-2.989266322209285
tp4184
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4185
(F-3.3460859818892046
F-3.32746094923753
tp4186
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4187
(F-2.743616117847909
F-2.88201170701247
tp4188
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p4189
(F-3.052076628713897
F-2.8651211078350363
tp4190
sS"'NumberGen1Collections', 'NumberGen2Collections'\n'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1'"
p4191
(F-2.5792198181152344
F-3.3010016221266527
tp4192
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p4193
(F-2.3844544982910154
F-2.854679694542518
tp4194
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4195
(F-2.6470133463541665
F-2.8234836871807394
tp4196
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p4197
(F-2.924713305254888
F-2.9571944016676683
tp4198
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p4199
(F-2.972284251245959
F-3.4631283099834738
tp4200
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p4201
(F-3.398494798309949
F-2.961773212139423
tp4202
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p4203
(F-2.914046687783355
F-2.8281112084021935
tp4204
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p4205
(F-2.51012010865857
F-2.8930960435133715
tp4206
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4207
(F-2.7001156616210937
F-2.8669295677771935
tp4208
sS'pid = os.getpid()'
p4209
(F-1.99986818101671
F-2.8772186866173377
tp4210
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4211
(F-3.1962088790594363
F-3.19771487896259
tp4212
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p4213
(F-3.7744642949737277
F-3.0250091552734375
tp4214
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p4215
(F-2.496704677365861
F-3.032640603872446
tp4216
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p4217
(F-3.0587716829978815
F-2.9255764301006613
tp4218
sS'pythoncom.CoInitialize()\nproc_results_list = []'
p4219
(F-3.7590257981244255
F-2.939057863675631
tp4220
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict"
p4221
(F-4.139563583746189
F-2.8978667626014123
tp4222
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4223
(F-3.3485333919525146
F-2.844559596135066
tp4224
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4225
(F-3.0114661465172006
F-2.8794596745417667
tp4226
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p4227
(F-2.915235587045656
F-2.859222118671124
tp4228
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4229
(F-1.8454707219050481
F-3.275727785550631
tp4230
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4231
(F-3.161931836585303
F-2.9392037024864783
tp4232
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p4233
(F-3.6159589315198133
F-3.1282794658954325
tp4234
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p4235
(F-3.5174703129002305
F-2.970913813664363
tp4236
sS'def get_pid_stats(self, pid):\n    pass'
p4237
(F-2.522982703314887
F-2.915607452392578
tp4238
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p4239
(F-3.6296409688970095
F-3.0354799123910756
tp4240
sS'import win32com.client'
p4241
(F-1.8657426834106445
F-2.749758793757512
tp4242
sS'if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True'
p4243
(F-2.6768021834524056
F-3.2927175668569713
tp4244
sS'if len(colItems) > 0:\n    pass'
p4245
(F-2.5898351033528644
F-3.433800037090595
tp4246
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4247
(F-2.4646763013756794
F-3.158189920278696
tp4248
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4249
(F-3.012041815396013
F-2.8651319650503306
tp4250
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p4251
(F-3.378093209496156
F-3.0011813823993387
tp4252
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p4253
(F-3.9216519869290867
F-3.382229731633113
tp4254
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4255
(F-2.6064336249168885
F-2.8072374784029446
tp4256
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4257
(F-3.237235514322917
F-3.0431498014009914
tp4258
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4259
(F-2.9781221015268264
F-2.8550165616548977
tp4260
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p4261
(F-3.1311426189284473
F-2.9351222698505106
tp4262
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4263
(F-2.9372040081921043
F-2.8536397493802586
tp4264
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4265
(F-3.306118881493284
F-3.040893261249249
tp4266
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p4267
(F-3.113327689792799
F-3.1493618304912863
tp4268
sS"py = psutil.Process(pid)\nmemoryUse = py.memory_info()[0] / 2.0 ** 30\nprint ('memory use:', memoryUse)"
p4269
(F-4.357943640814887
F-2.684844677264874
tp4270
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4271
(F-2.906437622700624
F-2.8795124934269833
tp4272
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4273
(F-3.059565311481611
F-2.8963499802809496
tp4274
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4275
(F-3.222909489033385
F-2.6554486201359677
tp4276
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4277
(F-3.4171461022418477
F-2.9287631695087137
tp4278
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4279
(F-3.2747093023255816
F-2.8395890455979567
tp4280
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4281
(F-3.053898695873038
F-2.9097542395958533
tp4282
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4283
(F-2.0728067537633383
F-2.819605900691106
tp4284
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p4285
(F-2.912610403415376
F-2.868201916034405
tp4286
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4287
(F-2.929185677837852
F-2.841916010929988
tp4288
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4289
(F-3.0284554163614907
F-2.7084010197566104
tp4290
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p4291
(F-3.294564141167535
F-3.1420810406024637
tp4292
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p4293
(F-2.6206670907827525
F-3.388811845045823
tp4294
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4295
(F-3.46426017515121
F-2.9251797015850363
tp4296
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4297
(F-3.2378983717698318
F-2.7410128666804385
tp4298
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])'
p4299
(F-3.341063372856748
F-2.7954949599045973
tp4300
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4301
(F-2.9886420698195977
F-2.9471456087552586
tp4302
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4303
(F-3.128794773560774
F-2.906855656550481
tp4304
sS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4305
(F-3.093318757556734
F-2.588902400090144
tp4306
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p4307
(F-2.8967102730027823
F-2.8440311138446512
tp4308
sS'proc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4309
(F-3.421400035511364
F-3.377749809852013
tp4310
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p4311
(F-2.992937442555147
F-2.9675780076246996
tp4312
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4313
(F-2.8048291015625
F-3.0068195049579325
tp4314
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p4315
(F-2.935534354967949
F-2.9838811434232273
tp4316
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4317
(F-2.8003082275390625
F-2.9457638080303488
tp4318
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p4319
(F-2.932350072967872
F-2.9332791841947117
tp4320
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4321
(F-3.7642743587493896
F-3.0580004178560696
tp4322
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p4323
(F-2.850248186115125
F-2.891308124248798
tp4324
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4325
(F-2.7430586904849648
F-2.835902580848107
tp4326
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4327
(F-3.526883147483648
F-2.9083521916316104
tp4328
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n"
p4329
(F-3.306118881493284
F-3.040893261249249
tp4330
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4331
(F-2.059995445838341
F-2.9097812359149637
tp4332
sS'import os\nimport psutil'
p4333
(F-2.2824722017560686
F-2.9981305049015927
tp4334
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint \'this proc results:\''
p4335
(F-3.173372890409185
F-2.6148646428034854
tp4336
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4337
(F-2.7067875548870894
F-2.8855130122258115
tp4338
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4339
(F-3.5916942686546505
F-3.0573885991023135
tp4340
sS'return x'
p4341
(F-4.51818323135376
F-3.092541914719802
tp4342
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4343
(F-2.9013096190565837
F-2.8741590059720554
tp4344
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    pass"
p4345
(F-3.4717315673828124
F-3.0656978900615988
tp4346
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p4347
(F-3.090755687040441
F-2.8736842228816104
tp4348
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4349
(F-2.2413705444335936
F-2.7338861318734975
tp4350
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4351
(F-3.20217484034849
F-2.6073992802546573
tp4352
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4353
(F-3.4133533296130953
F-2.9368541424091044
tp4354
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4355
(F-2.8378954225231987
F-2.889007274921124
tp4356
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4357
(F-2.944971778458911
F-2.848682110126202
tp4358
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4359
(F-3.0429691022952743
F-2.895914224477915
tp4360
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p4361
(F-2.9021813548445916
F-2.895922440748948
tp4362
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4363
(F-2.954483349174703
F-2.8680507953350363
tp4364
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4365
(F-3.2152410971151815
F-2.9632113530085635
tp4366
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4367
(F-2.5039230158299577
F-2.830330775334285
tp4368
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p4369
(F-2.4227889211554277
F-3.334795731764573
tp4370
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4371
(F-2.999475536232223
F-2.8512086134690504
tp4372
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4373
(F-3.489263687541778
F-2.923333974984976
tp4374
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p4375
(F-4.312724885486421
F-3.863961146428035
tp4376
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4377
(F-3.3414933414202634
F-2.9399772057166467
tp4378
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4379
(F-3.0846333359227036
F-2.620587569016677
tp4380
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4381
(F-3.2665495695891202
F-3.04130612886869
tp4382
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4383
(F-3.0002212524414062
F-2.9544331477238583
tp4384
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p4385
(F-2.8790664976811504
F-2.9098258385291467
tp4386
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p4387
(F-3.314648389816284
F-2.8989786001352162
tp4388
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p4389
(F-2.632800043845663
F-2.9737818791316104
tp4390
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()"
p4391
(F-2.528189756016043
F-2.98733403132512
tp4392
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True'
p4393
(F-2.6655641443589153
F-3.1956429114708533
tp4394
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4395
(F-3.0875682102814888
F-2.9014302767240086
tp4396
sS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = py.memory_info()[0] / 2.0 ** 30'
p4397
(F-3.5113192827273636
F-2.7526764502892127
tp4398
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4399
(F-3.0569275442477877
F-2.902618701641376
tp4400
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4401
(F-2.4524068629488034
F-2.794048015887921
tp4402
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p4403
(F-2.671183792586179
F-3.218595944918119
tp4404
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}"
p4405
(F-4.577565732209579
F-3.124127901517428
tp4406
sS'from __future__ import print_function'
p4407
(F-1.0389070510864258
F-2.909990750826322
tp4408
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4409
(F-2.647024949391683
F-2.8658438462477465
tp4410
sS"'CreatingProcessID', 'Description', 'IODataBytesPersec'\n'IODataOperationsPersec', 'IOOtherBytesPersec'\n'IOOtherOperationsPersec', 'IOReadBytesPersec'"
p4411
(F-1.847335942586263
F-3.316483130821815
tp4412
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}"
p4413
(F-2.0569400787353516
F-3.5896078256460338
tp4414
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4415
(F-3.4796982943481085
F-2.997796865609976
tp4416
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4417
(F-2.821353004092262
F-3.2183121901292067
tp4418
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4419
(F-2.555988468535959
F-2.8192666860727162
tp4420
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p4421
(F-2.8285574627737713
F-3.0102357130784254
tp4422
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p4423
(F-2.8106309276516153
F-2.8904744661771336
tp4424
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4425
(F-2.6253414203084833
F-2.8205190805288463
tp4426
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}"
p4427
(F-4.130173153347439
F-2.9437120877779446
tp4428
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p4429
(F-2.5057220458984375
F-2.9367041954627404
tp4430
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p4431
(F-3.3684121836786685
F-2.93284665621244
tp4432
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p4433
(F-2.9229576587677
F-2.9541602501502404
tp4434
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4435
(F-2.557456244652828
F-2.80179683978741
tp4436
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4437
(F-2.692503646657437
F-2.8120639507587137
tp4438
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4439
(F-2.9152534601046955
F-2.8972608126126804
tp4440
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p4441
(F-3.337932880108173
F-3.2045613802396336
tp4442
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4443
(F-3.0023228394661063
F-2.944652263934796
tp4444
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()'
p4445
(F-3.267561875380479
F-2.9356844975398135
tp4446
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4447
(F-3.4329171587330425
F-2.990240243765024
tp4448
sS'proc_results_list = []\nif not self.perf_object_list:\n    pass'
p4449
(F-3.05216552734375
F-3.23297119140625
tp4450
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4451
(F-3.331264624849034
F-2.916309356689453
tp4452
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4453
(F-2.5603303990350565
F-2.839824676513672
tp4454
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4455
(F-3.0579329045342485
F-2.918282435490535
tp4456
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p4457
(F-2.898722971518209
F-2.960127903864934
tp4458
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4459
(F-3.044190527057368
F-2.96283927330604
tp4460
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p4461
(F-3.3595260510341727
F-3.0970802307128906
tp4462
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4463
(F-3.5625649789663463
F-2.994761246901292
tp4464
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4465
(F-2.52010498046875
F-2.900116260235126
tp4466
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p4467
(F-2.481332500329178
F-2.8032569885253906
tp4468
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4469
(F-3.1135226105557714
F-2.9003650958721456
tp4470
sS'print psutil.virtual_memory()'
p4471
(F-3.09521598815918
F-2.75888178898738
tp4472
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p4473
(F-2.4227829453367624
F-2.806375943697416
tp4474
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4475
(F-2.5305844659674657
F-2.87431394136869
tp4476
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4477
(F-3.0165081734643624
F-2.8710415179912863
tp4478
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4479
(F-2.575027847290039
F-2.980854327862079
tp4480
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4481
(F-2.498870345186596
F-2.973069117619441
tp4482
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4483
(F-3.075634976091056
F-2.9133500319260817
tp4484
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p4485
(F-2.4902756853801447
F-2.980789771446815
tp4486
sS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4487
(F-3.5602816772460937
F-2.6294943002554088
tp4488
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p4489
(F-1.9134443329601754
F-2.8828072181114783
tp4490
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4491
(F-2.8089127450619102
F-3.031689863938552
tp4492
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4493
(F-2.760338320974576
F-2.9100916935847354
tp4494
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p4495
(F-2.9541558837890625
F-2.9918611966646633
tp4496
sS"'CreatingProcessID', 'Description', 'IODataBytesPersec'"
p4497
(F-2.678032466343471
F-3.285571758563702
tp4498
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4499
(F-2.70188123573284
F-2.82293701171875
tp4500
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4501
(F-2.794533999706698
F-2.8924581087552586
tp4502
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p4503
(F-2.929063441389698
F-2.898500295785757
tp4504
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p4505
(F-2.888808360650911
F-2.854963155893179
tp4506
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p4507
(F-2.47766699805274
F-2.932024148794321
tp4508
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4509
(F-3.536000045304446
F-3.327606201171875
tp4510
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p4511
(F-2.772611746338985
F-2.9465572650615988
tp4512
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4513
(F-2.501168750581287
F-2.8116073608398438
tp4514
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4515
(F-2.6116006729450634
F-2.834133735069862
tp4516
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4517
(F-3.1468427942154253
F-2.8212523827186
tp4518
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4519
(F-3.318599155970982
F-2.9866658724271336
tp4520
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p4521
(F-2.0921975069267806
F-2.824314704308143
tp4522
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p4523
(F-3.0555904327876986
F-2.9396007244403544
tp4524
sS'for proc_name in self.process_name_list:\n    pass'
p4525
(F-2.74062106483861
F-3.100344731257512
tp4526
sS"for counter_type in perf_object_list:\n    strComputer = '.'"
p4527
(F-4.4027351379394535
F-3.522503192608173
tp4528
sS"strComputer = '.'"
p4529
(F-5.056469599405925
F-3.4387591435359073
tp4530
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p4531
(F-3.0162788217358956
F-2.9183924748347354
tp4532
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4533
(F-2.895126940376142
F-2.8435008709247294
tp4534
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4535
(F-2.849767852247807
F-2.972064678485577
tp4536
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4537
(F-3.4057940552566226
F-2.9467057448167067
tp4538
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p4539
(F-2.5679250863882213
F-2.806452824519231
tp4540
sS"print ('memory use:', memoryUse)"
p4541
(F-4.136797587076823
F-2.9505110520582933
tp4542
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4543
(F-2.8911393925467914
F-2.853419377253606
tp4544
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4545
(F-2.946514346735264
F-2.9483642578125
tp4546
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4547
(F-2.8943764860733694
F-2.939913823054387
tp4548
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p4549
(F-3.0896922024813565
F-2.960719181941106
tp4550
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4551
(F-3.1332664642946786
F-2.9031017010028544
tp4552
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4553
(F-2.978798373909884
F-2.929401691143329
tp4554
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4555
(F-3.0465406629774305
F-2.8995425884540262
tp4556
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4557
(F-2.6056181808997847
F-3.0103240379920373
tp4558
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4559
(F-2.7444349789450353
F-2.950667748084435
tp4560
sS"'IODataOperationsPersec', 'IOOtherBytesPersec'"
p4561
(F-3.2224597930908203
F-3.27936524611253
tp4562
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4563
(F-2.9834350036071227
F-2.9165584857647238
tp4564
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4565
(F-2.9489198818032865
F-2.9350518446702223
tp4566
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p4567
(F-3.018448679070724
F-2.930299612192007
tp4568
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4569
(F-2.4326676078464673
F-2.816523625300481
tp4570
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p4571
(F-3.445428212483724
F-2.9236409113957333
tp4572
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4573
(F-3.01053900292756
F-2.885432316706731
tp4574
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4575
(F-2.836055965874139
F-2.898999434251052
tp4576
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4577
(F-2.960190375520008
F-2.944520803598257
tp4578
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4579
(F-3.0608798203310132
F-2.909991924579327
tp4580
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4581
(F-3.5558668567288305
F-2.9635901817908654
tp4582
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    pass'
p4583
(F-2.4827735023160953
F-2.7750599200908956
tp4584
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p4585
(F-2.8685582973613815
F-2.8921353266789365
tp4586
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4587
(F-3.032221848060345
F-2.899566650390625
tp4588
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass'
p4589
(F-3.0119720985149514
F-2.8861016493577223
tp4590
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()"
p4591
(F-2.270593031397406
F-2.9585653451772838
tp4592
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4593
(F-3.030818864410999
F-2.889545147235577
tp4594
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4595
(F-2.9882712194161822
F-2.8676702059232273
tp4596
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4597
(F-3.407374820907223
F-2.8751009427584133
tp4598
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p4599
(F-2.7676685066309257
F-2.9973396888146033
tp4600
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p4601
(F-3.286839517314782
F-2.7887053856482873
tp4602
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4603
(F-3.479029620135272
F-2.8451737623948317
tp4604
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4605
(F-2.7501346404819795
F-2.876312255859375
tp4606
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4607
(F-2.7821525641247233
F-2.8977288466233473
tp4608
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p4609
(F-3.4840947047919983
F-2.950520735520583
tp4610
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4611
(F-3.636270523071289
F-3.1034915630634012
tp4612
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4613
(F-2.9273826674659653
F-2.8687377342811
tp4614
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4615
(F-3.6110179388701025
F-2.979748065655048
tp4616
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4617
(F-2.704809873802227
F-2.888843829815204
tp4618
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p4619
(F-2.4380206800486945
F-2.92890372643104
tp4620
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p4621
(F-3.7564656575520834
F-3.1897533123309794
tp4622
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4623
(F-2.6274286085559475
F-2.9475904611440806
tp4624
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p4625
(F-2.675308867129023
F-2.9331494844876804
tp4626
sS'this_proc_results = stats_processor.get_pid_stats(this_pid)'
p4627
(F-3.8167925747958096
F-2.6177887549767127
tp4628
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4629
(F-3.3673076964261237
F-2.9351580693171573
tp4630
sS'obj_name = objItem.Name'
p4631
(F-4.717388153076172
F-3.56491206242488
tp4632
sS"if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute"
p4633
(F-2.9342549641927085
F-3.3602359478290262
tp4634
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4635
(F-3.2493850708007814
F-2.9595677302433896
tp4636
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4637
(F-3.526541404353762
F-3.007418999305138
tp4638
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4639
(F-3.467642832610567
F-2.9202179541954627
tp4640
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p4641
(F-2.5554041316853233
F-3.0175951444185696
tp4642
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]"
p4643
(F-2.296676017142631
F-2.6702188345102162
tp4644
sS"this_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4645
(F-2.5234224796295166
F-2.659110142634465
tp4646
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p4647
(F-3.605796531394676
F-2.8792777428260217
tp4648
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4649
(F-3.344022750854492
F-2.8272828322190504
tp4650
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p4651
(F-3.058190526489614
F-2.9621441180889425
tp4652
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4653
(F-3.3733121431790867
F-3.0674814077524037
tp4654
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4655
(F-2.8159317508820565
F-2.857799236591046
tp4656
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4657
(F-2.712313439711085
F-2.9317345252403846
tp4658
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p4659
(F-2.7844008060923793
F-3.2835658146784854
tp4660
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4661
(F-2.917009164165977
F-2.8564679072453427
tp4662
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4663
(F-3.09381567913553
F-3.1414237389197717
tp4664
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4665
(F-2.7902602373543433
F-2.8698348999023438
tp4666
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4667
(F-3.5681766012440557
F-2.953009091890775
tp4668
sS"'NumberTotalCommittedBytes', 'NumberTotalReservedBytes'"
p4669
(F-3.2224597930908203
F-3.27936524611253
tp4670
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4671
(F-3.419456612723214
F-2.864163031944862
tp4672
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4673
(F-2.583551198364752
F-2.914910829984225
tp4674
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p4675
(F-2.3487684461805554
F-3.1875877380371094
tp4676
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p4677
(F-3.0349260687538018
F-2.951072986309345
tp4678
sS'py = psutil.Process(pid)'
p4679
(F-3.1239137649536133
F-2.9273546659029446
tp4680
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]"
p4681
(F-2.4541823977515813
F-2.6970138549804688
tp4682
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4683
(F-2.811902463648243
F-2.880741999699519
tp4684
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p4685
(F-2.701268513997396
F-3.0239178584172177
tp4686
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4687
(F-3.168076854641155
F-2.998250227708083
tp4688
sS'import os\nthis_pid = os.getpid()'
p4689
(F-1.9426561083112444
F-2.8002119797926683
tp4690
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()'
p4691
(F-3.3551183363970587
F-2.8300414452186
tp4692
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4693
(F-2.0882747527091734
F-2.820408747746394
tp4694
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4695
(F-3.417053492723313
F-2.938770000751202
tp4696
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4697
(F-2.5466260673586003
F-2.9864930372971754
tp4698
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p4699
(F-2.772839116115196
F-3.00212654700646
tp4700
sS"if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p4701
(F-3.6033123240751377
F-3.158376253568209
tp4702
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p4703
(F-2.9357519915723427
F-2.8405227661132812
tp4704
sS"if __name__ == '__main__':\n    pass"
p4705
(F-1.2406379993145282
F-3.2402431781475363
tp4706
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p4707
(F-2.7627393334312775
F-2.9648126455453725
tp4708
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p4709
(F-3.0298227738360968
F-2.8847195551945615
tp4710
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4711
(F-3.049573729414147
F-2.908124776986929
tp4712
sS"import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = py.memory_info()[0] / 2.0 ** 30\nprint ('memory use:', memoryUse)"
p4713
(F-3.5138204956054686
F-2.7331548837515025
tp4714
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p4715
(F-2.924239116581239
F-2.840268061711238
tp4716
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4717
(F-3.4607618100175235
F-2.904967087965745
tp4718
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()'
p4719
(F-3.1686833699544272
F-2.951939509465144
tp4720
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4721
(F-3.0465481292579977
F-2.888355255126953
tp4722
sS'py = psutil.Process(pid)\nmemoryUse = py.memory_info()[0] / 2.0 ** 30'
p4723
(F-4.382744380405971
F-2.7211503248948317
tp4724
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4725
(F-2.653212803874524
F-2.8202796349158654
tp4726
sS'return this_proc_dict\n\ndef get_stats(self):\n    pass'
p4727
(F-2.8517738689075816
F-2.710653158334585
tp4728
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p4729
(F-2.5791498184204102
F-2.987073458158053
tp4730
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p4731
(F-2.9110443115234377
F-2.607309781588041
tp4732
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}'
p4733
(F-3.6792268424198546
F-2.8919718815730167
tp4734
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4735
(F-3.1304266755933203
F-2.8987981356107273
tp4736
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4737
(F-3.3673918908383667
F-2.917506291316106
tp4738
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4739
(F-3.0086562545211226
F-2.898127629206731
tp4740
sS"this_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p4741
(F-2.6795590209960936
F-2.694963601919321
tp4742
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4743
(F-3.3951717874278193
F-2.8208260169396033
tp4744
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p4745
(F-3.456760951450893
F-2.87504636324369
tp4746
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4747
(F-2.9942748764264864
F-2.8987467839167667
tp4748
sS'this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4749
(F-3.2125182151794434
F-2.6163919889009914
tp4750
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4751
(F-2.5196300441935913
F-2.923813746525691
tp4752
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4753
(F-3.4890601346237022
F-2.9773594782902646
tp4754
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p4755
(F-2.893561804673697
F-3.0010904165414662
tp4756
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4757
(F-4.194551908052885
F-3.25026614849384
tp4758
sS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4759
(F-2.8542602940609583
F-2.6237863393930287
tp4760
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4761
(F-2.6629168427399406
F-2.836498553936298
tp4762
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p4763
(F-2.762517638125662
F-3.1289907602163463
tp4764
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p4765
(F-3.732321130224021
F-3.043894254244291
tp4766
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p4767
(F-2.9521615245205637
F-2.8693158076359677
tp4768
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p4769
(F-1.7218738657183352
F-3.0541766240046573
tp4770
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p4771
(F-2.5337702658324117
F-2.996545644906851
tp4772
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass"
p4773
(F-2.5202036539713544
F-2.8991476205679088
tp4774
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}"
p4775
(F-2.368516276653548
F-3.1839851966271033
tp4776
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4777
(F-3.598713832618916
F-3.1437938396747294
tp4778
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4779
(F-3.2739686511811756
F-3.0101597125713644
tp4780
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4781
(F-3.192488441608049
F-2.955404134897085
tp4782
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4783
(F-3.10692388062836
F-2.9152142451359677
tp4784
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4785
(F-2.7367496561914795
F-2.92406492966872
tp4786
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()"
p4787
(F-2.150098352624266
F-3.0576688326322117
tp4788
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4789
(F-3.0354153380102042
F-2.90192618736854
tp4790
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4791
(F-1.9770822525024414
F-2.9769551203801083
tp4792
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4793
(F-2.8459081342143397
F-2.9171524047851562
tp4794
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4795
(F-3.508138453706782
F-3.199139815110427
tp4796
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4797
(F-2.9516305161741214
F-2.974487011249249
tp4798
sS'for proc_name in self.process_name_list:\n    obj_name = objItem.Name'
p4799
(F-3.41219241802509
F-3.201822721041166
tp4800
sS'from __future__ import print_function\nimport psutil'
p4801
(F-1.8778095245361328
F-2.8957431499774637
tp4802
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4803
(F-3.1180600675076064
F-2.90746336716872
tp4804
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p4805
(F-2.6710903953959924
F-2.954547882080078
tp4806
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4807
(F-2.654101792202201
F-2.843018751878005
tp4808
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4809
(F-3.347820027669271
F-3.205439934363732
tp4810
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p4811
(F-3.455003063130823
F-3.0975881723257213
tp4812
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4813
(F-3.0218728037558837
F-2.8753233689528246
tp4814
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4815
(F-2.9552678522074
F-2.9768028259277344
tp4816
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p4817
(F-2.899781130071272
F-2.8587086017315206
tp4818
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4819
(F-2.9771229619565216
F-2.8679269643930287
tp4820
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p4821
(F-3.65954563535493
F-2.884691385122446
tp4822
sS"'IOOtherOperationsPersec', 'IOReadBytesPersec'\n'IOReadOperationsPersec', 'IOWriteBytesPersec'"
p4823
(F-2.5792198181152344
F-3.3010019155649037
tp4824
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4825
(F-3.4381945747475435
F-2.9818238478440504
tp4826
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p4827
(F-2.4034215614548495
F-2.9943287189190206
tp4828
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4829
(F-3.1593978335950808
F-2.946073678823618
tp4830
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4831
(F-2.8914124503968255
F-2.9316206711989183
tp4832
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4833
(F-3.570217917151485
F-3.032856280987079
tp4834
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4835
(F-2.9519996643066406
F-2.901982234074519
tp4836
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4837
(F-3.8450837427256057
F-3.434236086331881
tp4838
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p4839
(F-3.613305556035675
F-2.9061082693246694
tp4840
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4841
(F-3.6313662809484146
F-2.9645846440241885
tp4842
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4843
(F-3.0063001675498753
F-2.93148921086238
tp4844
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p4845
(F-3.7790878680573794
F-3.210306314321665
tp4846
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4847
(F-3.3542967576246996
F-2.868922306941106
tp4848
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4849
(F-2.9693123627849403
F-2.868158193734976
tp4850
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4851
(F-3.061208370645998
F-2.870822026179387
tp4852
sS'if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p4853
(F-2.3813934326171875
F-3.2045021057128906
tp4854
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4855
(F-3.2370316700268815
F-2.5898701594426083
tp4856
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    pass'
p4857
(F-3.2947178141276043
F-2.8559271005483775
tp4858
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p4859
(F-2.9011991917116244
F-2.832958514873798
tp4860
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass"
p4861
(F-2.415597728222092
F-2.9566095792330227
tp4862
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4863
(F-3.353880429597494
F-2.9347669161283054
tp4864
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4865
(F-3.5879215549778296
F-2.9724942720853367
tp4866
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4867
(F-2.5305357952507173
F-2.9478577833909254
tp4868
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4869
(F-2.4471083632460586
F-2.760202847994291
tp4870
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4871
(F-3.0050814946492515
F-2.715740497295673
tp4872
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4873
(F-3.5038804194219284
F-2.929988274207482
tp4874
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p4875
(F-2.936153456050917
F-2.8903802724984975
tp4876
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p4877
(F-3.703023900741186
F-3.0510042630709133
tp4878
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4879
(F-2.4902441727487665
F-2.9025245079627404
tp4880
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4881
(F-3.634236325499832
F-2.9668761033278246
tp4882
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p4883
(F-3.5935527801513674
F-3.2809087313138523
tp4884
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p4885
(F-4.36431513605891
F-3.2321451627291164
tp4886
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p4887
(F-3.020955686216001
F-2.897821279672476
tp4888
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4889
(F-3.133206354114479
F-2.931428469144381
tp4890
sS'if proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak'
p4891
(F-2.9952802986934266
F-3.2786524846003604
tp4892
sS"if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4893
(F-3.4182416854366178
F-3.1622684185321512
tp4894
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4895
(F-3.006185323250394
F-2.9039488572340746
tp4896
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4897
(F-3.3555581631255764
F-2.9263845590444713
tp4898
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4899
(F-2.49262379791777
F-3.0481896033653846
tp4900
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4901
(F-3.2747323749870656
F-2.718367649958684
tp4902
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p4903
(F-3.052245832357468
F-2.9026530339167667
tp4904
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4905
(F-3.1581815133298883
F-2.8978644150954027
tp4906
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4907
(F-3.1735983813719892
F-2.9216094383826623
tp4908
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4909
(F-2.995055615377566
F-2.8710239116962137
tp4910
sS"return sys_dict\nif __name__ == '__main__':\n    pass"
p4911
(F-2.4400030771891275
F-3.25192143366887
tp4912
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4913
(F-3.0438818359375
F-2.892735407902644
tp4914
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4915
(F-3.0325853280141843
F-2.8833800095778246
tp4916
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4917
(F-2.9116167853860295
F-3.0059148348294773
tp4918
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p4919
(F-2.534427292282517
F-2.817138965313251
tp4920
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4921
(F-2.92246943810592
F-2.863435598520132
tp4922
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()'
p4923
(F-2.4796502529046474
F-2.7772442744328427
tp4924
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4925
(F-3.4869182811063877
F-2.9138858501727762
tp4926
sS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p4927
(F-2.1381534394763766
F-2.8897088857797475
tp4928
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4929
(F-2.69213630157767
F-2.8501187838040867
tp4930
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4931
(F-2.7583683268229167
F-2.8935667184682994
tp4932
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4933
(F-3.0882737204293225
F-2.8945060143103967
tp4934
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p4935
(F-2.89685676150137
F-2.866068033071665
tp4936
sS"print 'this proc results:'"
p4937
(F-2.4861247539520264
F-3.1109525240384617
tp4938
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4939
(F-3.419912936797202
F-2.8633240919846754
tp4940
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute"
p4941
(F-3.7435937769272747
F-3.5679717430701623
tp4942
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4943
(F-3.022086588541667
F-2.707515129676232
tp4944
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4945
(F-2.9563635071711754
F-2.644086691049429
tp4946
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4947
(F-2.597155725170752
F-2.9559681232158956
tp4948
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()"
p4949
(F-3.518771459185888
F-2.8674193162184496
tp4950
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4951
(F-2.952540820006847
F-2.88485835148738
tp4952
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p4953
(F-2.9627564817994507
F-2.9180523799015927
tp4954
sS"'NumberInducedGC', 'NumberGen0Collections'"
p4955
(F-3.2224597930908203
F-3.27936524611253
tp4956
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p4957
(F-3.504273748599024
F-3.0038877633901744
tp4958
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4959
(F-3.1588259285508986
F-2.9392899733323317
tp4960
sS"'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1'"
p4961
(F-3.2224597930908203
F-3.27936524611253
tp4962
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p4963
(F-2.8784212095547566
F-2.9660603449894833
tp4964
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p4965
(F-3.4973999966065397
F-2.901554987980769
tp4966
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    pass"
p4967
(F-1.1871013641357422
F-2.809862576998197
tp4968
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4969
(F-2.5414527022598574
F-3.2450843224158654
tp4970
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4971
(F-2.625834446327359
F-2.9348414494441104
tp4972
sS'break\nreturn this_proc_dict'
p4973
(F-4.544588088989258
F-2.8853096595177283
tp4974
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p4975
(F-2.9064453125
F-2.8736983079176683
tp4976
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4977
(F-2.839686223580135
F-2.8796345637394833
tp4978
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p4979
(F-2.7522361647914835
F-2.7611893873948317
tp4980
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4981
(F-3.074828655235946
F-2.898100046011118
tp4982
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()"
p4983
(F-2.9176338740757535
F-3.0766830444335938
tp4984
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4985
(F-3.329373646931476
F-2.9119658836951623
tp4986
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4987
(F-2.8718502221518003
F-2.9898285498985877
tp4988
sS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4989
(F-2.9382971869574654
F-2.5876676119290867
tp4990
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p4991
(F-2.8316247736984606
F-2.904224395751953
tp4992
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4993
(F-2.9420737737341773
F-2.998776069054237
tp4994
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4995
(F-2.8688926696777344
F-2.8195706881009617
tp4996
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4997
(F-2.516183194247159
F-2.872142498309796
tp4998
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4999
(F-3.8016771589006697
F-3.1114449134239783
tp5000
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p5001
(F-3.3078978531003935
F-2.7984771728515625
tp5002
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5003
(F-3.5068052900598405
F-3.006519611065204
tp5004
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5005
(F-3.311688298764436
F-3.1274789663461537
tp5006
sS'print psutil.cpu_percent()'
p5007
(F-2.213368606567383
F-2.9063770587627706
tp5008
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5009
(F-2.821427341318724
F-2.999988262469952
tp5010
sS"this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p5011
(F-3.0482110416187957
F-3.2630870525653544
tp5012
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5013
(F-2.6566531808035716
F-3.018705514761118
tp5014
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5015
(F-3.305600748022562
F-2.9139486459585338
tp5016
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p5017
(F-3.5848788637103457
F-2.848009549654447
tp5018
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p5019
(F-3.5170726021804377
F-3.0068573584923377
tp5020
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p5021
(F-2.9903406943044355
F-3.0886961129995494
tp5022
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""'
p5023
(F-2.201140594482422
F-2.7764332111065206
tp5024
sS"if proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p5025
(F-3.4849188388922276
F-3.3330406775841346
tp5026
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5027
(F-3.589016273373463
F-3.101138188288762
tp5028
sS'found_flag = True'
p5029
(F-3.909691401890346
F-3.72895754300631
tp5030
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5031
(F-3.468790154708059
F-2.9166089571439304
tp5032
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5033
(F-3.469876700074133
F-2.934525123009315
tp5034
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p5035
(F-2.877190553000891
F-3.0129224337064304
tp5036
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()"
p5037
(F-3.539936218261719
F-3.066942948561448
tp5038
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p5039
(F-3.464387630988024
F-2.965315892146184
tp5040
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5041
(F-2.907546665357507
F-3.0859105036808896
tp5042
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5043
(F-2.9219388646005795
F-2.861664111797626
tp5044
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client'
p5045
(F-4.217864445277622
F-2.992418435903696
tp5046
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5047
(F-2.5427968052455356
F-2.875751788799579
tp5048
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p5049
(F-2.8988847973544676
F-2.936963301438552
tp5050
sS'print psutil.cpu_percent()\nprint psutil.virtual_memory()'
p5051
(F-2.6200557507966695
F-2.8133770869328427
tp5052
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5053
(F-2.638194014386433
F-2.9795828599196215
tp5054
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p5055
(F-2.92721196431443
F-2.855380131648137
tp5056
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5057
(F-3.289067925347222
F-2.936235574575571
tp5058
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5059
(F-3.0180605606294013
F-2.883665231557993
tp5060
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5061
(F-2.916344901842949
F-2.8768580510066104
tp5062
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p5063
(F-3.8180307241586537
F-3.031519963191106
tp5064
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p5065
(F-2.8456529097123577
F-3.1191629263070912
tp5066
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p5067
(F-2.539336769444168
F-3.0486972515399637
tp5068
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5069
(F-2.973138398530951
F-2.8868026733398438
tp5070
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p5071
(F-2.8882131603554355
F-2.852046379676232
tp5072
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5073
(F-2.9889986761685075
F-3.2699288588303785
tp5074
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5075
(F-2.987002535983249
F-2.708783663236178
tp5076
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()'
p5077
(F-3.3137527465820313
F-2.971898005558894
tp5078
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5079
(F-3.46938461398486
F-2.9727968069223256
tp5080
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5081
(F-3.0829166778146404
F-2.8691018911508412
tp5082
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5083
(F-3.05172368099815
F-2.8434568551870494
tp5084
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5085
(F-3.6203162686136743
F-3.012227278489333
tp5086
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p5087
(F-3.6543896993001304
F-3.11184575007512
tp5088
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5089
(F-2.921894933721326
F-2.8533595158503604
tp5090
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5091
(F-2.9312551035045904
F-2.9331353994516225
tp5092
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5093
(F-2.946179558249081
F-2.902470515324519
tp5094
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5095
(F-3.5603755604137075
F-2.89334957416241
tp5096
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5097
(F-2.547445196854441
F-2.994845463679387
tp5098
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5099
(F-2.95457990418257
F-2.889404003436749
tp5100
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5101
(F-3.019903359292936
F-2.8741507897010217
tp5102
sS'import win32com.client\nfrom ctypes import *'
p5103
(F-2.2148896997625176
F-2.814678192138672
tp5104
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p5105
(F-3.571449788411458
F-3.604477809025691
tp5106
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5107
(F-3.35714352785886
F-3.0610377971942606
tp5108
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n'
p5109
(F-3.0119720985149514
F-2.8861016493577223
tp5110
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p5111
(F-3.495650898326527
F-2.8333863478440504
tp5112
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p5113
(F-2.474728950164603
F-2.938232421875
tp5114
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5115
(F-3.015916203878012
F-2.925929142878606
tp5116
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5117
(F-2.767417706459832
F-2.9227145268366885
tp5118
sS'class process_stats:\n    pass'
p5119
(F-3.2131656299937856
F-2.8220411447378306
tp5120
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5121
(F-2.9914740542524654
F-2.8714144780085635
tp5122
sS'return x\n\n\nclass process_stats:\n    pass'
p5123
(F-3.445932388305664
F-2.8676458505483775
tp5124
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p5125
(F-2.931452599029803
F-2.860435779278095
tp5126
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5127
(F-3.541475626030975
F-2.965459970327524
tp5128
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p5129
(F-2.9250874088759407
F-2.979280325082632
tp5130
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5131
(F-2.9369178771972657
F-3.0416268568772535
tp5132
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5133
(F-2.620466149371603
F-3.0734302814190206
tp5134
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5135
(F-2.8965101519834646
F-2.7227906447190504
tp5136
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5137
(F-3.051388555662188
F-2.8823776245117188
tp5138
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5139
(F-2.9012947414232335
F-2.8566448505108175
tp5140
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p5141
(F-3.624295949935913
F-2.917755126953125
tp5142
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p5143
(F-4.613709368024554
F-3.635960212120643
tp5144
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5145
(F-2.6578193536683834
F-2.8961140559269833
tp5146
sS"'NumberTotalCommittedBytes', 'NumberTotalReservedBytes'\n'NumberInducedGC', 'NumberGen0Collections'\n'NumberGen1Collections', 'NumberGen2Collections'"
p5147
(F-2.160008063683143
F-3.3168854346642127
tp5148
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5149
(F-2.928731652462121
F-2.9633319561298075
tp5150
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5151
(F-3.100860399658726
F-2.894957028902494
tp5152
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5153
(F-2.8118863247408727
F-2.9245772728553185
tp5154
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5155
(F-2.81840711536974
F-2.8540901770958533
tp5156
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p5157
(F-2.532099797175481
F-2.8949837317833533
tp5158
sS"'IODataOperationsPersec', 'IOOtherBytesPersec'\n'IOOtherOperationsPersec', 'IOReadBytesPersec'\n'IOReadOperationsPersec', 'IOWriteBytesPersec'"
p5159
(F-2.160008063683143
F-3.3168854346642127
tp5160
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5161
(F-3.4339144772046235
F-2.8788880568284254
tp5162
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p5163
(F-3.013909657796224
F-2.986110100379357
tp5164
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5165
(F-3.3392596098542944
F-2.758146432729868
tp5166
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p5167
(F-2.668810738457574
F-2.9085396986741285
tp5168
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p5169
(F-4.188952128092448
F-3.3423441373384914
tp5170
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5171
(F-2.3836619349888393
F-2.969514700082632
tp5172
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p5173
(F-2.9636470607069674
F-2.917248945969802
tp5174
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p5175
(F-3.454787297035331
F-2.8736607478215146
tp5176
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5177
(F-2.687248901999676
F-2.8589236919696512
tp5178
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p5179
(F-2.8536447471831425
F-2.877995124230018
tp5180
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5181
(F-3.071088845629829
F-2.8845032912034254
tp5182
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p5183
(F-2.914103835978836
F-2.870448185847356
tp5184
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n"
p5185
(F-3.074514969535496
F-3.148357097919171
tp5186
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5187
(F-2.9339395022259076
F-2.9833156879131613
tp5188
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5189
(F-3.381102631057518
F-3.072613055889423
tp5190
sS"proc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p5191
(F-3.7388878588406547
F-3.047061039851262
tp5192
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass'
p5193
(F-3.2478387819840604
F-2.7712924663837137
tp5194
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5195
(F-2.915186360677083
F-2.844793466421274
tp5196
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5197
(F-2.8615888964577656
F-2.8844205416165867
tp5198
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5199
(F-2.644827794547033
F-2.8549795884352465
tp5200
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5201
(F-2.6246413780898643
F-2.9508056640625
tp5202
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5203
(F-3.0777838876314254
F-2.891290517953726
tp5204
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5205
(F-2.940885774381868
F-2.8472689115084133
tp5206
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5207
(F-3.516944477576336
F-2.933520096998948
tp5208
sS'if found_flag:\n    pass'
p5209
(F-2.9754465276544746
F-3.530101482684796
tp5210
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5211
(F-2.7953836934549825
F-2.99701661330003
tp5212
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5213
(F-3.389936486069037
F-2.9145355224609375
tp5214
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p5215
(F-2.438356225046826
F-2.818848830003005
tp5216
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""'
p5217
(F-2.897493362426758
F-3.27553705068735
tp5218
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p5219
(F-2.8712048414276867
F-2.9806524423452525
tp5220
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nproc_results_list.append(this_proc_dict)"
p5221
(F-2.9361707899305554
F-2.850120837871845
tp5222
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5223
(F-2.5777159131262914
F-2.9421888498159556
tp5224
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p5225
(F-2.818015311840717
F-2.9004146869365988
tp5226
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5227
(F-2.4266660116552337
F-2.9557489248422475
tp5228
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5229
(F-3.554030126454879
F-2.982187711275541
tp5230
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p5231
(F-2.34376388630539
F-2.8867337153508115
tp5232
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5233
(F-3.1469674110412598
F-2.7931586045485277
tp5234
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nproc_results_list.append(this_proc_dict)"
p5235
(F-3.267802871276285
F-3.0389568622295675
tp5236
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p5237
(F-2.496464151410914
F-2.8090488727276144
tp5238
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5239
(F-3.634442522809222
F-2.9491365872896633
tp5240
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])"
p5241
(F-3.4901622425426138
F-2.7853962824894833
tp5242
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5243
(F-3.0231460019766567
F-2.930559598482572
tp5244
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p5245
(F-2.5194811139787947
F-3.1564108041616588
tp5246
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5247
(F-2.6265858968098956
F-2.6847830552321215
tp5248
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p5249
(F-2.736023188572304
F-3.0553404001089244
tp5250
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p5251
(F-2.4139795395934467
F-2.8901713444636417
tp5252
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p5253
(F-2.6941461432470035
F-2.9253431466909556
tp5254
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p5255
(F-2.398568624978537
F-3.1238104013296275
tp5256
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5257
(F-2.649225088266226
F-3.1468450106107273
tp5258
sS'print this_proc_results'
p5259
(F-4.006852149963379
F-2.7941513061523438
tp5260
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5261
(F-3.0255328587123325
F-2.9038355900691104
tp5262
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5263
(F-2.2819713245738638
F-3.0295084439791164
tp5264
sS'"""process_stats is able to provide counters of (all?) the items available in perfmon.\nRefer to the self.supported_types keys for the currently supported \'Performance Objects\'\nTo add logging support for other data you can derive the necessary data from perfmon:\n---------\nperfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\nClicking on the \'+\' will open the \'add counters\' menu,\nFrom the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n--> Where spaces are removed and symbols are entered as text (Ex. \nFor the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\nkeyed by the \'Performance Object\' name as mentioned above.\n---------\nNOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\nInitially the python implementation was derived from:\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n"""'
p5265
(F-2.897493362426758
F-3.27553705068735
tp5266
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5267
(F-3.0273353313577585
F-2.7184266310471754
tp5268
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p5269
(F-2.7206688449807364
F-2.9375035212590146
tp5270
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5271
(F-2.8498726877019136
F-2.9116334181565504
tp5272
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5273
(F-2.4586944580078125
F-2.819085928109976
tp5274
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5275
(F-2.58997285317001
F-2.9131722083458533
tp5276
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p5277
(F-2.9027971996686848
F-2.997035393348107
tp5278
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p5279
(F-2.775619672332565
F-2.9000467153695912
tp5280
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5281
(F-2.4862267445709745
F-2.971262711745042
tp5282
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p5283
(F-2.9468108467433765
F-2.978559053861178
tp5284
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5285
(F-3.3945353825887046
F-2.892032036414513
tp5286
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p5287
(F-3.204579866849459
F-3.192215846135066
tp5288
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5289
(F-2.912153781988682
F-2.844228010911208
tp5290
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5291
(F-2.644812417492642
F-2.992537571833684
tp5292
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p5293
(F-3.6352543131510417
F-3.0765151977539062
tp5294
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5295
(F-2.75196533203125
F-2.8786163330078125
tp5296
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5297
(F-2.5852811219262297
F-2.8748318598820615
tp5298
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5299
(F-2.7024856122952063
F-3.00460932804988
tp5300
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p5301
(F-2.5379366787997157
F-3.277547396146334
tp5302
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5303
(F-2.511520206227022
F-2.785106952373798
tp5304
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5305
(F-2.5146090024477474
F-3.1491643465482273
tp5306
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5307
(F-3.0475040558845765
F-2.90813475388747
tp5308
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p5309
(F-3.600835371990593
F-3.2366849459134617
tp5310
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p5311
(F-3.6651075026568245
F-2.7733741173377404
tp5312
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5313
(F-3.4115079439603364
F-2.911249014047476
tp5314
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p5315
(F-3.0151113403066527
F-2.9174769474909854
tp5316
sS'x = winmem()'
p5317
(F-2.96438843863351
F-3.101689265324519
tp5318
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5319
(F-3.3043465750558036
F-2.9805174607496996
tp5320
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5321
(F-2.963296965351255
F-2.696626516488882
tp5322
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5323
(F-3.1030157384738115
F-2.8921852111816406
tp5324
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5325
(F-2.6135782988175102
F-2.8921353266789365
tp5326
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5327
(F-3.0333662766676683
F-3.0770527766301083
tp5328
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()'
p5329
(F-2.9266718084161933
F-3.1883536118727465
tp5330
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5331
(F-2.4534673359867902
F-2.811411344088041
tp5332
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5333
(F-1.8909680684407553
F-3.105602557842548
tp5334
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5335
(F-2.124216416302849
F-2.66775630070613
tp5336
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p5337
(F-2.868650142081037
F-2.9345098642202525
tp5338
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5339
(F-2.432988841062898
F-2.850369086632362
tp5340
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p5341
(F-2.992009322835792
F-2.990025153526893
tp5342
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5343
(F-3.4041115545457408
F-2.924698462853065
tp5344
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n"
p5345
(F-3.003020770733173
F-3.161300072303185
tp5346
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5347
(F-2.909150000332164
F-2.875767341026893
tp5348
sS'class MEMORYSTATUS(Structure):\n    pass'
p5349
(F-2.0392611821492515
F-3.0247694162222056
tp5350
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5351
(F-2.7213025275077527
F-2.9223597599909854
tp5352
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5353
(F-2.9193088942307694
F-2.9633375314565806
tp5354
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p5355
(F-3.5322360460501745
F-2.926712916447566
tp5356
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5357
(F-2.6924087699802444
F-2.9168753990760217
tp5358
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p5359
(F-3.0507717180612404
F-2.9354647122896633
tp5360
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p5361
(F-2.756180006035408
F-2.8987770080566406
tp5362
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p5363
(F-3.518339563588627
F-2.962854238656851
tp5364
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p5365
(F-2.4015570525626018
F-2.863362532395583
tp5366
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p5367
(F-3.8109207718460647
F-3.0769917414738583
tp5368
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p5369
(F-2.8160663628931024
F-2.9775930551382213
tp5370
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5371
(F-3.018537352071006
F-2.8812085665189304
tp5372
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])"
p5373
(F-3.409796009893003
F-3.0695155217097354
tp5374
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5375
(F-3.2193410070867485
F-2.9454281146709738
tp5376
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5377
(F-3.0576970880681817
F-2.9091544518103967
tp5378
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5379
(F-3.458079762702441
F-2.9163791949932394
tp5380
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5381
(F-2.817851105628655
F-2.89816166804387
tp5382
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p5383
(F-3.582485101161859
F-3.059787163367638
tp5384
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p5385
(F-3.7246149236505683
F-3.2383848337026744
tp5386
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p5387
(F-2.782356544777199
F-2.800220782940204
tp5388
sS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5389
(F-3.492661476135254
F-2.5436826852651744
tp5390
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5391
(F-3.125856876373291
F-2.900104229266827
tp5392
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5393
(F-2.8725947249294523
F-2.9467139610877404
tp5394
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p5395
(F-3.053003049364277
F-2.9255321209247294
tp5396
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p5397
(F-2.75752197265625
F-3.094616229717548
tp5398
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5399
(F-3.548941022398844
F-3.089611053466797
tp5400
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p5401
(F-2.502985853754897
F-2.804735917311448
tp5402
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5403
(F-3.677681332542783
F-2.9681085439828725
tp5404
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5405
(F-3.5377893396326012
F-2.969920818622296
tp5406
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p5407
(F-2.999048540669103
F-2.7085694533128004
tp5408
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5409
(F-3.0737035950618004
F-2.904515193058894
tp5410
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5411
(F-2.9613409423828125
F-2.801862569955679
tp5412
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p5413
(F-2.7764016797737305
F-3.007384080153245
tp5414
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5415
(F-2.174780852603216
F-2.9864217318021336
tp5416
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5417
(F-2.7352639770507814
F-3.0899925231933594
tp5418
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5419
(F-2.774212959485176
F-2.8975633474496694
tp5420
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5421
(F-3.0133837209754732
F-2.881126697246845
tp5422
sS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p5423
(F-2.8545625748172885
F-2.7683014502892127
tp5424
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p5425
(F-2.4779468481091484
F-2.9243363600510817
tp5426
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])"
p5427
(F-3.5072216654932777
F-3.065863095797025
tp5428
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5429
(F-2.908735656738281
F-2.8213606614332933
tp5430
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5431
(F-3.962927384810014
F-2.909341958852915
tp5432
sS"print 'this proc results:'\nprint this_proc_results"
p5433
(F-3.2691913951526987
F-2.840963216928335
tp5434
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5435
(F-3.2296267860814143
F-2.9590718195988583
tp5436
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5437
(F-2.9773302435696216
F-2.855809138371394
tp5438
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5439
(F-3.068679611404221
F-2.917101639967698
tp5440
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5441
(F-3.0986096682964557
F-2.9096767718975363
tp5442
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5443
(F-3.088955898516574
F-2.935335012582632
tp5444
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p5445
(F-2.7192215900031886
F-3.0431321951059194
tp5446
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p5447
(F-2.7931312444682734
F-2.9303242610051083
tp5448
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'"
p5449
(F-5.401878703724254
F-4.248052450326773
tp5450
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5451
(F-3.2683419121636286
F-2.819020784818209
tp5452
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5453
(F-2.5717813968658447
F-2.660013345571665
tp5454
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak'
p5455
(F-2.6941805433952943
F-3.1838866013746996
tp5456
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5457
(F-3.400652850115741
F-2.985912616436298
tp5458
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""'
p5459
(F-2.990262570588485
F-2.7506303053635817
tp5460
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5461
(F-3.320540181706461
F-2.8632483849158654
tp5462
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint \'this proc results:\''
p5463
(F-3.2092101081969244
F-2.595364497258113
tp5464
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p5465
(F-2.8793546236478367
F-2.994121844951923
tp5466
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5467
(F-2.8641761957212934
F-2.884307861328125
tp5468
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5469
(F-2.880917653729839
F-2.9317474365234375
tp5470
sS"if proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5471
(F-3.154947830458819
F-3.14308841411884
tp5472
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p5473
(F-3.580929202633304
F-3.082984630878155
tp5474
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p5475
(F-2.9304692131393972
F-2.944455073429988
tp5476
sS'if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p5477
(F-2.6870554143732246
F-3.3160987267127404
tp5478
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5479
(F-2.9553047853893197
F-2.976409618671124
tp5480
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5481
(F-3.0536673576955375
F-2.9030418395996094
tp5482
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5483
(F-2.971603346891724
F-2.896929227388822
tp5484
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5485
(F-2.7643859206989245
F-2.8832359313964844
tp5486
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5487
(F-2.7467017158234937
F-2.921946305495042
tp5488
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5489
(F-3.3955519083838106
F-2.9667270366962137
tp5490
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p5491
(F-3.9055441284179686
F-3.4059665386493387
tp5492
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5493
(F-2.943527505300302
F-2.9989095834585338
tp5494
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p5495
(F-2.400335189399369
F-2.8043283315805287
tp5496
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5497
(F-3.006404816158234
F-2.922465104323167
tp5498
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5499
(F-2.3960747232242507
F-2.8429395235501804
tp5500
sS"for attribute in self.supported_types[counter_type]:\n    eval_str = 'objItem.%s' % attribute"
p5501
(F-3.8587593665489783
F-3.629364307110126
tp5502
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p5503
(F-2.902088777197099
F-3.015376164362981
tp5504
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p5505
(F-3.133255195617676
F-3.6635897709773135
tp5506
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint \'this proc results:\'\nprint this_proc_results'
p5507
(F-3.1591147564827127
F-2.580311114971454
tp5508
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5509
(F-3.491652170817057
F-3.3972238393930287
tp5510
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5511
(F-2.7620752306951992
F-2.9754292414738583
tp5512
sS'"""\nShow process stats for all processes in given list, if none given return all processes   \nIf filter list is defined return only the items that match or contained in the list\nReturns a list of result dictionaries\n"""'
p5513
(F-2.897493362426758
F-3.27553705068735
tp5514
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}"
p5515
(F-1.44523776661266
F-3.9197135338416467
tp5516
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5517
(F-3.0697844630741127
F-2.9119315514197717
tp5518
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5519
(F-3.275823563491742
F-2.88405755849985
tp5520
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os'
p5521
(F-3.277038967993952
F-2.7388384892390323
tp5522
sS'import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p5523
(F-2.9819492885044645
F-2.6057155315692606
tp5524
sS'perf_object_list = self.supported_types.keys()'
p5525
(F-3.773990406709559
F-3.263173323411208
tp5526
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5527
(F-2.6671284326438696
F-2.9086629427396336
tp5528
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5529
(F-3.010895583391675
F-2.888536599966196
tp5530
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5531
(F-2.9904201731962314
F-2.8652669466458836
tp5532
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5533
(F-2.983412611541025
F-2.9129421527569113
tp5534
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5535
(F-3.0224245921297483
F-2.866565997783954
tp5536
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5537
(F-2.933457223992599
F-2.9103513864370494
tp5538
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p5539
(F-2.8825307070389243
F-2.904460613544171
tp5540
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5541
(F-3.034068811408297
F-2.9425823505108175
tp5542
sS'print result_dict'
p5543
(F-3.9022598266601562
F-3.2417232806865988
tp5544
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5545
(F-3.0444369290044397
F-2.902991955096905
tp5546
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p5547
(F-2.870986774403562
F-3.0217657822829027
tp5548
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p5549
(F-3.6254874093191964
F-2.8531887347881613
tp5550
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5551
(F-3.019171573875803
F-2.88347420325646
tp5552
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p5553
(F-2.8217701338944754
F-2.885784149169922
tp5554
sS'for objItem in colItems:\n    found_flag = False'
p5555
(F-3.7870285931755516
F-3.8326495243952823
tp5556
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5557
(F-2.8998174639554484
F-2.9569118206317606
tp5558
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5559
(F-3.350350106825851
F-2.941147730900691
tp5560
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5561
(F-2.936094813193044
F-2.922979501577524
tp5562
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5563
(F-2.9974962317425273
F-2.9124506436861477
tp5564
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p5565
(F-2.4880831294928116
F-2.9873695373535156
tp5566
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5567
(F-2.7669832744295637
F-2.9808907142052283
tp5568
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5569
(F-3.1418441177962664
F-2.931066659780649
tp5570
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()"
p5571
(F-2.62154962598663
F-2.9218380267803488
tp5572
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p5573
(F-2.9829775730981902
F-2.883848630464994
tp5574
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5575
(F-3.428958777225379
F-2.984606522780198
tp5576
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5577
(F-3.2924727254839086
F-2.8585155193622294
tp5578
sS'for result_dict in proc_results:\n    pass\n'
p5579
(F-3.014977773030599
F-3.1513695350060096
tp5580
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5581
(F-2.8560563862130866
F-2.888214111328125
tp5582
sS'if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p5583
(F-2.7834237670898436
F-3.249315701998197
tp5584
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5585
(F-2.9804603847755393
F-2.8819858844463644
tp5586
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5587
(F-2.8432566849226806
F-3.021009005033053
tp5588
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5589
(F-2.8024651102838365
F-2.8990226158728967
tp5590
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5591
(F-2.563651861146439
F-2.936139913705679
tp5592
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p5593
(F-3.432020609357716
F-2.798976017878606
tp5594
sS'if proc_name.lower() in obj_name.lower():\n    pass'
p5595
(F-2.7294077665909477
F-3.232498755821815
tp5596
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5597
(F-3.0538049489965937
F-2.9050562931941104
tp5598
sS'from ctypes import *\nfrom ctypes.wintypes import *'
p5599
(F-2.624308072603666
F-3.03582763671875
tp5600
sS"if proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nproc_results_list.append(this_proc_dict)"
p5601
(F-3.1389970134075424
F-3.0662800715519833
tp5602
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5603
(F-3.240415498807833
F-2.703274360069862
tp5604
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5605
(F-2.9793234432444855
F-2.9504558856670675
tp5606
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5607
(F-3.0834149980878496
F-2.8783824627216044
tp5608
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint \'this proc results:\'\nprint this_proc_results'
p5609
(F-3.194403512137277
F-2.5653897798978367
tp5610
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5611
(F-2.5373541614996693
F-3.0243988037109375
tp5612
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5613
(F-2.4052162170410156
F-3.0271987915039062
tp5614
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()'
p5615
(F-3.34603271484375
F-2.7634007380558896
tp5616
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5617
(F-3.38961475300339
F-2.9340506333571215
tp5618
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p5619
(F-3.3593306631412148
F-3.0702089162973256
tp5620
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5621
(F-2.946875429001098
F-2.8667385394756613
tp5622
sS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5623
(F-3.0473224270728325
F-2.608094435471755
tp5624
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5625
(F-2.776417943050987
F-2.6798990689791164
tp5626
sS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())\nprint(psutil.virtual_memory())'
p5627
(F-2.0256733485630583
F-2.8631700369027944
tp5628
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p5629
(F-3.943741647820724
F-2.9184998732346754
tp5630
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5631
(F-2.8868183336759867
F-2.845240666316106
tp5632
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5633
(F-2.6640701293945312
F-2.92753659761869
tp5634
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5635
(F-3.3041124408747873
F-2.924920889047476
tp5636
sS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = py.memory_info()[0] / 2.0 ** 30'
p5637
(F-3.3716158185686385
F-2.7864808302659254
tp5638
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p5639
(F-2.860435122535342
F-2.88742681650015
tp5640
sS'from ctypes.wintypes import *\nimport pythoncom'
p5641
(F-3.8321474248712715
F-2.815034719613882
tp5642
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5643
(F-3.452139081746122
F-2.9306722787710338
tp5644
sS'break\nif found_flag:\n    pass'
p5645
(F-3.2558963482196512
F-3.460401094876803
tp5646
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p5647
(F-2.786973255085495
F-3.0167811467097354
tp5648
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5649
(F-2.9603280903380593
F-2.7538082416240988
tp5650
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5651
(F-2.2449871943547177
F-2.738069387582632
tp5652
sS"proc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5653
(F-3.5836362616960393
F-3.0101664616511417
tp5654
sS'"""process_names_list == the list of all processes to log (if empty log all)\nperf_object_list == list of process counters to log\nfilter_list == list of text to filter\nprint_results == boolean, output to stdout\n"""'
p5655
(F-2.897493362426758
F-3.27553705068735
tp5656
sS"if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p5657
(F-3.4141031901041665
F-2.9804887038010817
tp5658
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5659
(F-2.5750937980691386
F-2.8180630023662863
tp5660
sS'continue'
p5661
(F-3.358992258707682
F-3.645208505483774
tp5662
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5663
(F-3.0613672267982897
F-2.881428058330829
tp5664
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]"
p5665
(F-2.2555629845821494
F-3.003812936636118
tp5666
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5667
(F-4.061777049097522
F-3.3790758573091946
tp5668
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5669
(F-2.6714490712117804
F-2.8504497821514425
tp5670
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]"
p5671
(F-2.2400398791675835
F-2.8254224337064304
tp5672
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]'
p5673
(F-2.6449836282169117
F-2.7808394798865685
tp5674
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p5675
(F-2.5671936744867367
F-2.9414129990797777
tp5676
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5677
(F-3.550689697265625
F-2.805553729717548
tp5678
sS'import pythoncom'
p5679
(F-5.272708415985107
F-2.7373413672814
tp5680
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p5681
(F-2.484313774703076
F-2.8659336383526144
tp5682
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5683
(F-3.4777584772040373
F-2.934436504657452
tp5684
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5685
(F-3.521763320796746
F-2.9634279104379506
tp5686
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5687
(F-3.1448545374142367
F-2.9184995797964244
tp5688
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p5689
(F-3.0530261464718818
F-2.9032498873197117
tp5690
sS"if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p5691
(F-3.80532473609561
F-3.1013576801006613
tp5692
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5693
(F-1.581307705965909
F-2.8063284067007213
tp5694
sS'self.filter_list = filter_list'
p5695
(F-3.715887589888139
F-4.027095794677734
tp5696
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5697
(F-3.544016018161526
F-2.994871286245493
tp5698
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p5699
(F-2.912063027448195
F-2.8945858295147238
tp5700
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5701
(F-3.469067741842831
F-2.9421492356520433
tp5702
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5703
(F-2.7051877937468873
F-2.9442209097055287
tp5704
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5705
(F-3.508505939567176
F-2.9372808016263523
tp5706
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p5707
(F-2.6705459011057036
F-2.9136728140024037
tp5708
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p5709
(F-2.910268981600068
F-2.9660855806790867
tp5710
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5711
(F-2.830212779880799
F-3.0709862342247596
tp5712
sS'pythoncom.CoInitialize()'
p5713
(F-4.071680545806885
F-3.090711153470553
tp5714
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5715
(F-3.364506591796875
F-3.121055896465595
tp5716
sS'import pythoncom\nimport pywintypes\nimport datetime'
p5717
(F-3.887870025634766
F-2.7287618196927586
tp5718
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p5719
(F-3.598908923921131
F-3.05716059758113
tp5720
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p5721
(F-2.5182738552203756
F-2.8187408447265625
tp5722
sS'x = MEMORYSTATUS()'
p5723
(F-2.96438843863351
F-3.101689265324519
tp5724
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5725
(F-3.31679951060902
F-2.912190950833834
tp5726
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass"
p5727
(F-1.9662482367621528
F-3.067975851205679
tp5728
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5729
(F-2.2092198458584873
F-2.6289986830491285
tp5730
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5731
(F-3.435466869457348
F-2.914102994478666
tp5732
sS'proc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5733
(F-3.4393138396434293
F-3.2871305025540867
tp5734
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5735
(F-2.7863123444818503
F-2.890637911283053
tp5736
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p5737
(F-2.4155377608079176
F-3.081769209641677
tp5738
sS"this_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5739
(F-2.420456676948361
F-2.7126919673039365
tp5740
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5741
(F-3.055075738663064
F-2.8962135314941406
tp5742
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5743
(F-3.1864375728069287
F-2.9413833618164062
tp5744
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5745
(F-3.4610445994251178
F-3.1028882540189304
tp5746
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5747
(F-3.788391351699829
F-2.8669366102952223
tp5748
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5749
(F-3.480913751775568
F-3.1322816702035756
tp5750
sS"if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p5751
(F-3.090016042153666
F-3.3150115379920373
tp5752
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5753
(F-3.563444349500868
F-3.0438502385066104
tp5754
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5755
(F-3.510730743408203
F-2.930177541879507
tp5756
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5757
(F-3.4665537717997523
F-2.863472865178035
tp5758
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5759
(F-3.5482203637889587
F-2.95923585158128
tp5760
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p5761
(F-3.518593295784884
F-2.9611390920785756
tp5762
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    pass'
p5763
(F-3.18396679323111
F-2.9664541391225963
tp5764
sS'windll.kernel32.GlobalMemoryStatus(byref(x))'
p5765
(F-4.128153483072917
F-3.3502930861253004
tp5766
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5767
(F-2.7865028381347656
F-2.728435809795673
tp5768
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5769
(F-2.4680720199773343
F-2.8066447331355167
tp5770
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5771
(F-3.4472140608162714
F-2.9305590116060696
tp5772
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5773
(F-3.1214667915867556
F-2.892071063701923
tp5774
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5775
(F-2.449043896733498
F-3.3343546940730167
tp5776
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p5777
(F-3.160484945698149
F-2.6199810321514425
tp5778
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]"
p5779
(F-2.3973383528462957
F-2.740022512582632
tp5780
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p5781
(F-3.618039264359288
F-3.0820447481595554
tp5782
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5783
(F-3.10043680442954
F-2.8155957735501804
tp5784
sS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5785
(F-3.0555034092494417
F-2.6461577782264123
tp5786
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p5787
(F-3.5388581649116846
F-2.9659849313589244
tp5788
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5789
(F-2.6510361180160986
F-2.9378946744478664
tp5790
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5791
(F-2.924436857592838
F-2.9349388709435096
tp5792
sS'from ctypes import *'
p5793
(F-2.7961807250976562
F-3.0763461773212137
tp5794
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p5795
(F-2.8956081584348516
F-2.9795318016639123
tp5796
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p5797
(F-2.904381420852111
F-2.8936210045447717
tp5798
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p5799
(F-3.6521861252275487
F-3.314300243671124
tp5800
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5801
(F-3.554506089952257
F-3.0044039212740383
tp5802
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5803
(F-3.5743832278561283
F-2.9810720590444713
tp5804
sS"'IODataOperationsPersec', 'IOOtherBytesPersec'\n'IOOtherOperationsPersec', 'IOReadBytesPersec'"
p5805
(F-2.5792198181152344
F-3.3010016221266527
tp5806
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p5807
(F-2.9258127655712136
F-2.8535948533278246
tp5808
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p5809
(F-2.9328373313969016
F-2.8626427283653846
tp5810
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5811
(F-3.088170441103653
F-2.9023751478928785
tp5812
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5813
(F-2.6470424107142856
F-2.9257677518404446
tp5814
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5815
(F-3.079144631148878
F-2.9037833580603967
tp5816
sS"this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute"
p5817
(F-2.9023033142089845
F-3.285350506122296
tp5818
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p5819
(F-2.9410267408999653
F-2.9662114656888523
tp5820
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}"
p5821
(F-0.9517917143992889
F-3.5961820162259617
tp5822
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5823
(F-2.9379227664492547
F-2.7331026517427883
tp5824
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p5825
(F-3.071180216471354
F-3.622454129732572
tp5826
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5827
(F-3.0006062048002917
F-2.9037484389085035
tp5828
sS"this_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p5829
(F-2.4380340576171875
F-2.7134860112116885
tp5830
sS"import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = py.memory_info()[0] / 2.0 ** 30\nprint ('memory use:', memoryUse)"
p5831
(F-3.6400834753158247
F-2.7015665494478664
tp5832
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5833
(F-4.060641697474888
F-2.7930177541879506
tp5834
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5835
(F-2.671771445970857
F-2.9318389892578125
tp5836
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p5837
(F-3.5129855229304385
F-2.92466060931866
tp5838
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5839
(F-2.8534590801685966
F-2.8793006310096154
tp5840
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict'
p5841
(F-3.630571400035511
F-2.9801221994253306
tp5842
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5843
(F-2.498631509502282
F-2.9654215299166164
tp5844
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p5845
(F-2.576495124298392
F-2.91973876953125
tp5846
sS'__revision__ = 3\nimport win32com.client'
p5847
(F-4.219245274861653
F-3.032520587627704
tp5848
sS"'CreatingProcessID', 'Description', 'IODataBytesPersec'\n'IODataOperationsPersec', 'IOOtherBytesPersec'"
p5849
(F-2.137192119251598
F-3.3027255718524637
tp5850
sS"this_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nproc_results_list.append(this_proc_dict)"
p5851
(F-2.5531338282993863
F-2.695293719951923
tp5852
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5853
(F-2.2827827855160363
F-2.691852569580078
tp5854
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5855
(F-2.777229466931573
F-2.869763887845553
tp5856
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            pass"
p5857
(F-3.596469996165644
F-3.0226654639610877
tp5858
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p5859
(F-2.860804221000813
F-3.0076546302208533
tp5860
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5861
(F-3.4215338655220444
F-2.949461129995493
tp5862
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5863
(F-3.486222026504089
F-2.9409405634953427
tp5864
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5865
(F-3.067703379755435
F-2.908450200007512
tp5866
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5867
(F-3.0179204385747354
F-2.9316368103027344
tp5868
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p5869
(F-3.57630506854191
F-3.1483066265399637
tp5870
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5871
(F-2.6966853250984015
F-2.880580021784856
tp5872
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5873
(F-3.0417579828306684
F-2.8910006009615383
tp5874
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p5875
(F-3.160634474320845
F-3.3493804931640625
tp5876
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5877
(F-3.1451770275622817
F-2.925140087421124
tp5878
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p5879
(F-2.8980547805059524
F-2.8851092411921573
tp5880
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p5881
(F-3.461916135392099
F-2.957593477689303
tp5882
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5883
(F-2.9806672568633177
F-2.8864112267127404
tp5884
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p5885
(F-2.908711044618373
F-2.960001725416917
tp5886
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5887
(F-2.6876210805532095
F-2.924785907451923
tp5888
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5889
(F-3.010252186949824
F-2.844570746788612
tp5890
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5891
(F-2.916486745171585
F-2.9289269080528846
tp5892
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5893
(F-2.807587452423878
F-2.8629238422100363
tp5894
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5895
(F-3.638134280577401
F-2.99781007033128
tp5896
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5897
(F-3.450618157939851
F-2.954514430119441
tp5898
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5899
(F-3.0569473376377023
F-2.6459547189565806
tp5900
sS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p5901
(F-2.0611753463745117
F-2.9242269075833836
tp5902
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5903
(F-3.4277108999399037
F-2.9444850041316104
tp5904
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5905
(F-3.5026510487432065
F-2.9527493990384617
tp5906
sS'if not self.process_name_list:\n    pass'
p5907
(F-2.476357936859131
F-3.1931698138897238
tp5908
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5909
(F-2.9215432958665235
F-2.8570386446439304
tp5910
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5911
(F-3.434732012274141
F-2.866808084341196
tp5912
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5913
(F-2.8763782848011363
F-2.8404156611515927
tp5914
sS'this_proc_dict[attribute] = eval(eval_str)'
p5915
(F-4.1578369140625
F-3.1995585514948917
tp5916
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p5917
(F-2.7848800285356345
F-2.9200028639573317
tp5918
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5919
(F-2.6556596292559145
F-2.8597564697265625
tp5920
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p5921
(F-2.9250255766369047
F-2.8576313899113583
tp5922
sS'proc_results_list = []'
p5923
(F-3.3932899475097655
F-2.9067869919996996
tp5924
sS"memoryUse = py.memory_info()[0] / 2.0 ** 30\nprint ('memory use:', memoryUse)"
p5925
(F-4.639498675311053
F-2.8934317368727465
tp5926
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5927
(F-3.4492872382941417
F-2.945005857027494
tp5928
sS'proc_results = stats_processor.get_stats()'
p5929
(F-3.5744977315266926
F-2.9101007901705227
tp5930
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5931
(F-2.7664913821530033
F-3.0438599219689
tp5932
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5933
(F-2.6532338690434107
F-2.9571559612567606
tp5934
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5935
(F-3.8064693162421217
F-3.0643844604492188
tp5936
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5937
(F-2.7853181258491846
F-2.842222360464243
tp5938
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p5939
(F-3.0745491658834587
F-2.9080511239858775
tp5940
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5941
(F-3.040032052521658
F-2.8981968806340146
tp5942
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5943
(F-2.9000319096080043
F-2.9617403470552883
tp5944
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5945
(F-3.2871571525198515
F-2.7971041752741885
tp5946
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5947
(F-3.164611261541193
F-2.7815633920522838
tp5948
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p5949
(F-2.9102559608988243
F-2.9130483774038463
tp5950
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5951
(F-2.419955875562585
F-2.6186274014986477
tp5952
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5953
(F-2.950639730564316
F-2.8539581298828125
tp5954
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5955
(F-3.4659449411723426
F-2.956441732553335
tp5956
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5957
(F-2.870015523519861
F-3.2754651583158054
tp5958
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5959
(F-2.637776965430211
F-2.991202427790715
tp5960
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5961
(F-3.360864492563101
F-2.921399336594802
tp5962
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p5963
(F-3.130108580297353
F-3.1008776151216946
tp5964
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p5965
(F-2.9387581380208334
F-2.8857457087590146
tp5966
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5967
(F-2.679455752300127
F-2.9439626840444713
tp5968
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    pass"
p5969
(F-1.7992111732219827
F-2.970154982346755
tp5970
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p5971
(F-2.4173027934552938
F-3.1269754263070912
tp5972
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5973
(F-3.403567096379798
F-2.909134791447566
tp5974
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p5975
(F-3.055892561803621
F-2.8859129685621996
tp5976
sS'self.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5977
(F-2.9287894535990593
F-2.8665956350473256
tp5978
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p5979
(F-3.245345266241776
F-3.0294826214130106
tp5980
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p5981
(F-3.074514969535496
F-3.148357097919171
tp5982
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p5983
(F-2.946368741835812
F-2.836497967059796
tp5984
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p5985
(F-2.7889744894845143
F-3.0416338993952823
tp5986
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p5987
(F-3.342717488606771
F-2.8297348022460938
tp5988
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5989
(F-3.099199366188388
F-2.892255049485427
tp5990
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p5991
(F-2.6785107512972246
F-2.9563669057992787
tp5992
sS"proc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5993
(F-3.718093082822602
F-3.3616984440730167
tp5994
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5995
(F-2.3007361809938947
F-2.968957754281851
tp5996
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5997
(F-2.1054014983000577
F-2.995150932898888
tp5998
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5999
(F-2.9222478451936142
F-2.767505352313702
tp6000
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6001
(F-3.056938904153425
F-2.912461207463191
tp6002
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p6003
(F-2.293866687350803
F-2.9336495032677283
tp6004
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p6005
(F-3.0163563487293956
F-2.9000338040865383
tp6006
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p6007
(F-3.710985844678218
F-3.0015059251051683
tp6008
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]"
p6009
(F-2.391367924677861
F-2.6325290386493387
tp6010
sS'return proc_results_list\n\ndef get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p6011
(F-3.2024569424715907
F-2.600648733285757
tp6012
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p6013
(F-2.817936434290716
F-2.9006453294020433
tp6014
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p6015
(F-3.208591236787684
F-2.9175218435434194
tp6016
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p6017
(F-3.112207290974069
F-2.785906278170072
tp6018
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p6019
(F-2.4180530436988015
F-3.2234279926006613
tp6020
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p6021
(F-3.6105679390125704
F-3.0659232506385217
tp6022
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p6023
(F-2.0832273805296264
F-2.99262941800631
tp6024
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6025
(F-3.397021019747513
F-2.8699725224421573
tp6026
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6027
(F-3.7872891939603366
F-3.0074104895958533
tp6028
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p6029
(F-3.3405606587727865
F-3.0069213280311
tp6030
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True'
p6031
(F-2.897395166857489
F-3.07306641798753
tp6032
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6033
(F-2.962194880645705
F-2.8629203209510217
tp6034
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p6035
(F-2.8975604100210854
F-2.9003260685847354
tp6036
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6037
(F-2.6937948287553484
F-2.8483443626990685
tp6038
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p6039
(F-2.7756986361552567
F-3.011066730205829
tp6040
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p6041
(F-2.8991251291322313
F-2.8448492196890025
tp6042
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p6043
(F-2.2228808195694634
F-2.6309879009540262
tp6044
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p6045
(F-2.507476806640625
F-2.8723393953763523
tp6046
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}"
p6047
(F-4.0960580233869885
F-3.090653052696815
tp6048
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p6049
(F-3.052547159932201
F-2.89730717585637
tp6050
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p6051
(F-2.633708642787688
F-2.8646568885216346
tp6052
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p6053
(F-2.8251428525309916
F-2.9104523291954627
tp6054
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p6055
(F-2.4292556844293114
F-3.124659905066857
tp6056
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()"
p6057
(F-2.4324302673339844
F-2.9557354266826925
tp6058
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p6059
(F-2.5055632014541853
F-2.824644528902494
tp6060
sS'for result_dict in proc_results:\n    print result_dict\nimport os'
p6061
(F-3.3229097638811385
F-3.128463158240685
tp6062
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6063
(F-3.0269694549358444
F-2.9208913949819713
tp6064
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6065
(F-3.532436247794859
F-3.0136595505934496
tp6066
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6067
(F-2.9603149794343846
F-2.8663236177884617
tp6068
sS"if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p6069
(F-2.944699772817646
F-3.168057368351863
tp6070
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p6071
(F-3.0682312936493843
F-2.698252457838792
tp6072
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()"
p6073
(F-2.4473271893628072
F-3.0061448904184194
tp6074
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6075
(F-2.733409115045065
F-2.843424283541166
tp6076
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6077
(F-4.288381788465712
F-3.5980406541090746
tp6078
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p6079
(F-3.0263363713154354
F-2.897030463585487
tp6080
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p6081
(F-3.2236444752687103
F-2.7183377192570615
tp6082
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    pass"
p6083
(F-1.582525001381928
F-3.169351724477915
tp6084
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict"
p6085
(F-4.48126084463937
F-3.088561718280499
tp6086
sS'if not self.process_name_list:\n    found_flag = True'
p6087
(F-2.970946502685547
F-3.2966754619891825
tp6088
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6089
(F-2.6419172286987305
F-3.0194505544809194
tp6090
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p6091
(F-2.5625169797051224
F-2.948903303879958
tp6092
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p6093
(F-3.7507451375325522
F-2.861683185283954
tp6094
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6095
(F-3.397481590810448
F-2.91953130868765
tp6096
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6097
(F-2.707488338835995
F-2.8619742760291467
tp6098
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p6099
(F-2.6010440666518524
F-2.9616884084848256
tp6100
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6101
(F-3.027593597163999
F-2.866623805119441
tp6102
sS'colItems = objSWbemServices.ExecQuery(query_str)'
p6103
(F-4.200161933898926
F-3.6822586059570312
tp6104
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass"
p6105
(F-1.7018253173828124
F-2.7752342224121094
tp6106
sS'def get_sys_stats():\n    pass'
p6107
(F-2.103952662150065
F-2.740084721491887
tp6108
sS'import psutil\nprint psutil.cpu_percent()\nprint psutil.virtual_memory()'
p6109
(F-2.2706839821555396
F-2.848614032451923
tp6110
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p6111
(F-3.2058020888196395
F-2.9238882798414965
tp6112
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p6113
(F-2.695733388264974
F-2.9200994051419773
tp6114
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p6115
(F-3.468874289772727
F-2.8427801865797777
tp6116
sS'this_proc_dict = {}'
p6117
(F-3.6201568603515626
F-2.885493351862981
tp6118
sS'import datetime'
p6119
(F-3.400245428085327
F-2.89499752338116
tp6120
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p6121
(F-2.909846698938732
F-2.8717278700608473
tp6122
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p6123
(F-2.8610019508851776
F-2.829344529371995
tp6124
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p6125
(F-2.4459921131963314
F-2.7625491802509012
tp6126
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p6127
(F-2.5171770631726775
F-2.825477306659405
tp6128
sS"pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = py.memory_info()[0] / 2.0 ** 30\nprint ('memory use:', memoryUse)"
p6129
(F-3.752225008877841
F-2.6999969482421875
tp6130
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6131
(F-2.685694773791719
F-2.8922283466045675
tp6132
sS"query_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p6133
(F-3.4761149088541665
F-3.047682835505559
tp6134
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p6135
(F-2.8620516459147134
F-2.9666900634765625
tp6136
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p6137
(F-2.924216338212197
F-2.9399839547964244
tp6138
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p6139
(F-2.529986098476741
F-2.861949627216046
tp6140
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p6141
(F-3.24793483494045
F-2.620181450477013
tp6142
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p6143
(F-2.4813811339022265
F-2.922046367938702
tp6144
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6145
(F-2.9127232253931132
F-2.978058154766376
tp6146
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6147
(F-3.38276980276065
F-2.8647340627817006
tp6148
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p6149
(F-3.2324771457248263
F-2.917577890249399
tp6150
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p6151
(F-2.498352605646307
F-3.2586179879995494
tp6152
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p6153
(F-3.0632260131835936
F-3.7076263427734375
tp6154
sS'if not self.process_name_list:\n    found_flag = True\nelse:\n    pass'
p6155
(F-2.3669037995515048
F-3.270082033597506
tp6156
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p6157
(F-2.527563838635461
F-3.0639108511117787
tp6158
sS'return this_proc_dict'
p6159
(F-4.642960548400879
F-2.8386905376727762
tp6160
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p6161
(F-2.8991149266560874
F-2.817437685452975
tp6162
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p6163
(F-3.19183464050293
F-2.701121990497296
tp6164
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p6165
(F-2.8043151431613498
F-2.9428036029522238
tp6166
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p6167
(F-2.9429576361357275
F-2.9645872849684496
tp6168
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6169
(F-3.001742540107262
F-2.878657414362981
tp6170
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)"
p6171
(F-3.9336480533375457
F-3.111024416410006
tp6172
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6173
(F-3.454828537668143
F-2.88054451575646
tp6174
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6175
(F-3.065224793427799
F-2.9025013263408956
tp6176
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6177
(F-2.695125005016588
F-2.9103458111102762
tp6178
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p6179
(F-3.5529568990071616
F-3.08379393357497
tp6180
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6181
(F-3.420843605917008
F-2.8348784813514123
tp6182
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6183
(F-2.926025390625
F-2.920867919921875
tp6184
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p6185
(F-2.1409289756517733
F-2.670623485858624
tp6186
sS'return this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6187
(F-3.2583547893323397
F-2.9065158550555887
tp6188
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p6189
(F-2.4801887722190368
F-2.9208702674278846
tp6190
sS'query_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6191
(F-3.469394838906885
F-2.9835243225097656
tp6192
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os'
p6193
(F-3.200898960658482
F-2.853046123798077
tp6194
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p6195
(F-4.162793901231554
F-2.926147754375751
tp6196
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p6197
(F-2.3907641360634253
F-2.9393260662372294
tp6198
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    pass"
p6199
(F-3.452812338775059
F-2.8912955064039965
tp6200
sS"return sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])"
p6201
(F-3.235987663269043
F-3.222008044903095
tp6202
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6203
(F-2.6898622694124286
F-2.8998823899489183
tp6204
sS'sys_dict = get_sys_stats()'
p6205
(F-3.766922583946815
F-2.931049640362079
tp6206
sS"stats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])"
p6207
(F-3.269515785011085
F-3.2447920579176683
tp6208
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p6209
(F-3.0404210090637207
F-3.457241645226112
tp6210
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p6211
(F-2.434133733360513
F-3.1013033940241885
tp6212
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p6213
(F-3.113980720379601
F-2.9473797724797177
tp6214
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p6215
(F-3.524249093191964
F-3.0099334716796875
tp6216
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p6217
(F-3.0360706733486755
F-2.8969365633451023
tp6218
sS'found_flag = False'
p6219
(F-3.8769888196672713
F-3.7395885174091044
tp6220
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n"
p6221
(F-3.237235514322917
F-3.0431498014009914
tp6222
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()"
p6223
(F-3.4023121425083707
F-3.055719228891226
tp6224
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6225
(F-2.982344937383685
F-2.872285402738131
tp6226
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict"
p6227
(F-4.075969920438879
F-3.0617174001840444
tp6228
sS'if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p6229
(F-3.4689647129603793
F-3.60576658982497
tp6230
sS'self.perf_object_list = perf_object_list'
p6231
(F-4.597693379720052
F-3.4469193678635817
tp6232
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p6233
(F-2.8160863983497193
F-2.8775206345778246
tp6234
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute'
p6235
(F-2.9853422203842475
F-2.9510768010066104
tp6236
sS"proc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6237
(F-3.4989170619419645
F-3.0808416513296275
tp6238
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p6239
(F-3.0154274778387142
F-2.9001822838416467
tp6240
sS'return sys_dict'
p6241
(F-4.98278268178304
F-3.1963448157677283
tp6242
sS'this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6243
(F-3.105439453125
F-2.760645939753606
tp6244
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6245
(F-2.9489483825780014
F-2.8632589486929088
tp6246
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6247
(F-2.8453902534816575
F-2.89919926570012
tp6248
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6249
(F-3.498986166732318
F-2.9346527686485877
tp6250
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p6251
(F-1.3718877996055825
F-2.7494691702035756
tp6252
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6253
(F-2.631173889493682
F-2.9453336275540867
tp6254
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p6255
(F-2.9528724523286844
F-2.8950350834773135
tp6256
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p6257
(F-3.0065529690181636
F-2.9088973999023438
tp6258
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6259
(F-3.0863662719726563
F-2.8328396723820615
tp6260
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p6261
(F-2.6106943982712765
F-2.9588728684645433
tp6262
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p6263
(F-2.848100482292895
F-2.8714960538423977
tp6264
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6265
(F-2.969132336969566
F-2.928650195782001
tp6266
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6267
(F-3.0315813755245804
F-2.8806686401367188
tp6268
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            pass'
p6269
(F-2.8030786821919103
F-2.885238060584435
tp6270
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    pass'
p6271
(F-2.433416578504774
F-3.069225311279297
tp6272
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]'
p6273
(F-2.9006198092623876
F-2.8927682729867787
tp6274
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p6275
(F-2.835163975342292
F-2.9419825627253604
tp6276
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6277
(F-2.5906757376047485
F-2.9888719411996694
tp6278
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6279
(F-2.6093599873204387
F-2.9150836651141825
tp6280
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p6281
(F-3.3733213717344577
F-2.999956571138822
tp6282
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p6283
(F-3.0415041553730866
F-2.907031719501202
tp6284
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p6285
(F-2.511077600881594
F-3.034266545222356
tp6286
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p6287
(F-2.8310566804846937
F-2.988820589505709
tp6288
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6289
(F-2.534515468806286
F-2.9464536813589244
tp6290
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p6291
(F-3.225511678059896
F-2.971573462853065
tp6292
sS"'NumberTotalCommittedBytes', 'NumberTotalReservedBytes'\n'NumberInducedGC', 'NumberGen0Collections'"
p6293
(F-2.5792198181152344
F-3.3010016221266527
tp6294
sS"'NumberTotalCommittedBytes', 'NumberTotalReservedBytes'\n'NumberInducedGC', 'NumberGen0Collections'\n'NumberGen1Collections', 'NumberGen2Collections'\n'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1'"
p6295
(F-1.8756830552045036
F-3.329660855806791
tp6296
sS'for attribute in self.supported_types[counter_type]:\n    pass'
p6297
(F-3.5344383239746096
F-3.691371330848107
tp6298
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p6299
(F-2.919622487035291
F-3.136522439809946
tp6300
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6301
(F-3.342849596411781
F-2.9186665461613583
tp6302
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p6303
(F-3.231371649380388
F-2.5741183941180887
tp6304
sS'this_proc_dict = {}\nif not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    pass'
p6305
(F-2.614972903404707
F-3.172371790959285
tp6306
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p6307
(F-2.430008939640251
F-2.7924892718975363
tp6308
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p6309
(F-3.530596923828125
F-2.9340914212740383
tp6310
sS'if not self.perf_object_list:\n    pass'
p6311
(F-3.1268510818481445
F-3.3825196486253004
tp6312
sS"pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6313
(F-3.8704795837402344
F-3.012965569129357
tp6314
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p6315
(F-2.951920219089674
F-2.9601082435021033
tp6316
sS'for objItem in colItems:\n    pass'
p6317
(F-3.64105224609375
F-3.738419165978065
tp6318
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p6319
(F-2.8082099036223194
F-2.8662273700420675
tp6320
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p6321
(F-2.9131945780736865
F-2.8760593120868387
tp6322
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6323
(F-3.335030746459961
F-2.856273944561298
tp6324
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p6325
(F-2.5689394713131266
F-2.8155276958759012
tp6326
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass"
p6327
(F-3.591189187670511
F-3.112933819110577
tp6328
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p6329
(F-3.4188975825854238
F-2.9312720665564904
tp6330
sS"if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p6331
(F-3.3867972237723216
F-2.9682913560133715
tp6332
sS'self.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6333
(F-3.1497548619133027
F-2.95423331627479
tp6334
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6335
(F-3.5071202153744907
F-3.452717120830829
tp6336
sS'import pywintypes\nimport datetime'
p6337
(F-3.5586599622453963
F-2.7959920443021336
tp6338
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6339
(F-2.571451653374566
F-2.8333875215970554
tp6340
sS'this_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6341
(F-3.347364815117801
F-2.9455575209397535
tp6342
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p6343
(F-2.412490770293445
F-2.8577235295222354
tp6344
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p6345
(F-3.249050117538361
F-2.6086689875676083
tp6346
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6347
(F-2.6891136532738096
F-2.93440921490009
tp6348
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6349
(F-2.725776533647017
F-2.9025350717397838
tp6350
sS"eval_str = 'objItem.%s' % attribute"
p6351
(F-4.555728064643012
F-3.36756339439979
tp6352
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """'
p6353
(F-2.6909296809016046
F-2.9300143902118387
tp6354
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p6355
(F-3.6563074588775635
F-2.8743453392615685
tp6356
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p6357
(F-2.484106665259009
F-2.7962992741511417
tp6358
sS"'NumberGen1Collections', 'NumberGen2Collections'"
p6359
(F-3.2224597930908203
F-3.27936524611253
tp6360
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}'
p6361
(F-2.4038514890870846
F-3.0604694073016825
tp6362
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p6363
(F-2.991010052224864
F-2.907306964580829
tp6364
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6365
(F-2.9898385826064033
F-2.8641718350923977
tp6366
sS'break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p6367
(F-3.544575500488281
F-3.5370459923377404
tp6368
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6369
(F-2.9922050693403297
F-2.924406198354868
tp6370
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6371
(F-2.9629461282689764
F-2.8543886037973256
tp6372
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6373
(F-3.4872896902901784
F-2.9468213594876804
tp6374
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6375
(F-2.9988240458424253
F-2.926618429330679
tp6376
sS'from ctypes.wintypes import *'
p6377
(F-3.1455233097076416
F-2.952657259427584
tp6378
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    pass'
p6379
(F-2.8958841959635415
F-2.9853583115797777
tp6380
sS'if not self.process_name_list:\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak'
p6381
(F-2.7138487987029247
F-3.2821127084585338
tp6382
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p6383
(F-3.5064848015107306
F-3.312245882474459
tp6384
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6385
(F-3.048348538216702
F-2.9594485943134012
tp6386
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p6387
(F-4.761083693731399
F-3.8797337458683896
tp6388
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6389
(F-2.982192638308503
F-2.9639255817119894
tp6390
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass'
p6391
(F-2.8863046203438394
F-2.9795567439152646
tp6392
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p6393
(F-2.601311274937221
F-2.833173311673678
tp6394
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6395
(F-3.47863948519978
F-2.9394293565016527
tp6396
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6397
(F-3.894092238092997
F-3.128794156588041
tp6398
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6399
(F-2.9356024457037178
F-2.853046710674579
tp6400
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p6401
(F-2.8846128784391247
F-2.859453641451322
tp6402
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    pass'
p6403
(F-2.6285587433845765
F-2.8651774479792667
tp6404
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p6405
(F-2.8757695737092392
F-2.860126201923077
tp6406
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n"
p6407
(F-2.919622487035291
F-3.136522439809946
tp6408
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6409
(F-2.918246799045139
F-2.862438201904297
tp6410
sS"'IOReadOperationsPersec', 'IOWriteBytesPersec'"
p6411
(F-3.2224597930908203
F-3.27936524611253
tp6412
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6413
(F-3.0465151151631478
F-2.8911079993614783
tp6414
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p6415
(F-3.3882312774658203
F-2.8466339111328125
tp6416
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6417
(F-3.0041615044892724
F-2.857322986309345
tp6418
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)'
p6419
(F-2.926370979975728
F-2.9126390310434194
tp6420
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}'
p6421
(F-3.58413818359375
F-3.0389947157639723
tp6422
sS'pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = py.memory_info()[0] / 2.0 ** 30'
p6423
(F-3.6876733567979603
F-2.740775181696965
tp6424
sS'if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p6425
(F-3.471433473982901
F-2.926862276517428
tp6426
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p6427
(F-2.9470098030053826
F-3.0625965411846456
tp6428
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p6429
(F-2.685027178596048
F-3.0881852370042067
tp6430
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p6431
(F-3.1481572365274233
F-2.9183695866511417
tp6432
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p6433
(F-2.8657948047439485
F-2.8828647320087137
tp6434
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p6435
(F-3.2811792885384907
F-2.6072769165039062
tp6436
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p6437
(F-3.178056112502965
F-2.9325235806978664
tp6438
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6439
(F-3.050303011414007
F-2.92888435950646
tp6440
sS'def get_stats(self):\n    pass'
p6441
(F-1.878420284816197
F-2.871166522686298
tp6442
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6443
(F-2.9463792746689275
F-2.9134468665489783
tp6444
sS'pythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6445
(F-3.4735107421875
F-2.901409442608173
tp6446
sS'memoryUse = py.memory_info()[0] / 2.0 ** 30'
p6447
(F-4.899601584986637
F-2.9074601393479567
tp6448
sS'if proc_name.lower() in obj_name.lower():\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p6449
(F-3.128838130405971
F-3.4000481825608473
tp6450
sS'this_pid = os.getpid()'
p6451
(F-2.4045951149680396
F-2.7715272169846754
tp6452
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p6453
(F-3.444124780520044
F-2.9909386268028846
tp6454
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6455
(F-3.7248509724934897
F-3.0807324923001804
tp6456
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p6457
(F-3.0122573287398726
F-2.9499485309307394
tp6458
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p6459
(F-3.035893629045051
F-2.9295413677509012
tp6460
sS'this_proc_dict = {}\nif not self.process_name_list:\n    pass'
p6461
(F-2.684073791503906
F-3.028279818021334
tp6462
sS"if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]"
p6463
(F-3.3931252264207408
F-2.976658454308143
tp6464
sS'if len(colItems) > 0:\n    for objItem in colItems:\n        found_flag = False'
p6465
(F-3.2488542754074623
F-3.750610058124249
tp6466
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p6467
(F-3.3207834417169746
F-3.2216978806715746
tp6468
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p6469
(F-2.8891934867527174
F-2.9341043325570912
tp6470
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6471
(F-3.0031036376953124
F-2.8758679903470554
tp6472
sS'return x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6473
(F-3.0789686562358467
F-2.8980677678034854
tp6474
sS"if len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict"
p6475
(F-3.4212235759075424
F-2.936915471003606
tp6476
sS'for result_dict in proc_results:\n    pass'
p6477
(F-3.014977773030599
F-3.1513695350060096
tp6478
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p6479
(F-2.8303404507571703
F-3.0189740107609677
tp6480
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass'
p6481
(F-2.866580911684128
F-2.8914463336651144
tp6482
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6483
(F-2.401381089952257
F-2.959195063664363
tp6484
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """'
p6485
(F-2.5008632494055707
F-3.17616946880634
tp6486
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6487
(F-3.416270364544349
F-2.858499967134916
tp6488
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p6489
(F-3.189438819885254
F-3.0058168264535756
tp6490
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()'
p6491
(F-2.7709182103474936
F-2.896792485163762
tp6492
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p6493
(F-2.4674327305385044
F-2.7372955909142127
tp6494
sS'self.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6495
(F-3.0423445582660147
F-2.9141159057617188
tp6496
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p6497
(F-3.010710720486111
F-2.899920243483323
tp6498
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6499
(F-3.4957334321120688
F-2.932618654691256
tp6500
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), (\n        'dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile',\n        DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), (\n        'dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p6501
(F-2.4398072257874506
F-2.957883981557993
tp6502
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    pass"
p6503
(F-2.0875650259164664
F-3.0524344811072717
tp6504
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute"
p6505
(F-3.6997447294347428
F-3.1340337900015025
tp6506
sS'objSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    pass'
p6507
(F-3.413904181734443
F-2.907942845271184
tp6508
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    pass'
p6509
(F-2.4227761545488913
F-2.8241072434645433
tp6510
sS"if __name__ == '__main__':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p6511
(F-3.0352379785825128
F-3.178235567533053
tp6512
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p6513
(F-2.9013136216810533
F-2.8603465740497294
tp6514
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = datetime.datetime.now().strftime(\n    '%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3]\nbreak"
p6515
(F-3.501040825477013
F-2.9929947486290565
tp6516
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p6517
(F-2.4030833183964595
F-2.911626962515024
tp6518
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6519
(F-2.616742653821511
F-2.819564232459435
tp6520
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                pass"
p6521
(F-3.012560926488316
F-2.97104498056265
tp6522
sS'self.process_name_list = process_name_list'
p6523
(F-3.5715866088867188
F-3.2001612736628604
tp6524
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p6525
(F-2.778940518697103
F-2.903695033146785
tp6526
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    pass"
p6527
(F-2.3582555505613616
F-2.8670134911170373
tp6528
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6529
(F-2.596273907839157
F-2.8214307931753306
tp6530
sS'def get_sys_stats():\n    """ Returns a dictionary of the system stats"""\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {\'dwAvailPhys\': x.dwAvailPhys, \'dwAvailVirtual\': x.dwAvailVirtual}\nreturn sys_dict\nif __name__ == \'__main__\':\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=[\'process2watch\'],\n    perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass\n'
p6531
(F-3.2034245484264185
F-2.8014546907865086
tp6532
sS'class process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p6533
(F-3.4745492117745536
F-3.1321942256047177
tp6534
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6535
(F-3.0650125443527703
F-2.895663628211388
tp6536
sS'"""\nMonitor window processes\nderived from:\n>for sys available mem\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\n> individual process information and python script examples\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\nNOTE: the WMI interface/process is also available for performing similar tasks\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\n        to extend or improve this module, then may want to investigate the WMI tools available.\n        WMI for python:\n        http://tgolden.sc.sabren.com/python/wmi.html\n"""\n__revision__ = 3'
p6537
(F-5.045900980631511
F-3.6489727313701925
tp6538
sS'for counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6539
(F-3.4452991346373176
F-2.9232151324932394
tp6540
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)'
p6541
(F-3.036127151268116
F-2.911807427039513
tp6542
sS'objWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6543
(F-3.417080398893704
F-2.9267454880934496
tp6544
sS"if not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        pass"
p6545
(F-3.5627409991096046
F-3.131824199969952
tp6546
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = 'Select * from %s%s' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, 'IDProcess') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = 'objItem.%s' % attribute\nthis_proc_dict[attribute] = eval(eval_str)"
p6547
(F-2.903493379291735
F-2.914703662578876
tp6548
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6549
(F-3.09861888056216
F-2.898678706242488
tp6550
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """'
p6551
(F-3.1090094248453775
F-2.7075779254619894
tp6552
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()'
p6553
(F-2.9132906464776633
F-2.914286099947416
tp6554
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name',\n    'NumberTotalCommittedBytes', 'NumberTotalReservedBytes',\n    'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections',\n    'NumberGen2Collections', 'PromotedMemoryFromGen0',\n    'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'],\n    'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess',\n    'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec',\n    'IODataOperationsPersec', 'IOOtherBytesPersec',\n    'IOOtherOperationsPersec', 'IOReadBytesPersec',\n    'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6555
(F-2.606985740291262
F-2.889160449688251
tp6556
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []'
p6557
(F-2.9267823492462313
F-2.844610360952524
tp6558
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p6559
(F-1.9664201175465303
F-2.789368849534255
tp6560
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\n        \'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\',\n        DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\n        \'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    """process_stats is able to provide counters of (all?) the items available in perfmon.\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\n    To add logging support for other data you can derive the necessary data from perfmon:\n    ---------\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\n    Clicking on the \'+\' will open the \'add counters\' menu,\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\n    --> Where spaces are removed and symbols are entered as text (Ex. \n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\n    keyed by the \'Performance Object\' name as mentioned above.\n    ---------\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\n    Initially the python implementation was derived from:\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\n    """\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak\nreturn this_proc_dict'
p6561
(F-2.9394061589645126
F-2.824046795184796
tp6562
sS'proc_results_list.append(this_proc_dict)'
p6563
(F-3.4586563110351562
F-2.846404735858624
tp6564
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    """process_names_list == the list of all processes to log (if empty log all)\n        perf_object_list == list of process counters to log\n        filter_list == list of text to filter\n        print_results == boolean, output to stdout\n        """\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\',\n    \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\',\n    \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\',\n    \'NumberGen2Collections\', \'PromotedMemoryFromGen0\',\n    \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'],\n    \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\',\n    \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\',\n    \'IODataOperationsPersec\', \'IOOtherBytesPersec\',\n    \'IOOtherOperationsPersec\', \'IOReadBytesPersec\',\n    \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\']}\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = \'Select * from %s%s\' % (self.win32_perf_base, counter_type)\ncolItems = objSWbemServices.ExecQuery(query_str)\nif len(colItems) > 0:\n    for objItem in colItems:\n        if hasattr(objItem, \'IDProcess\') and pid == objItem.IDProcess:\n            for attribute in self.supported_types[counter_type]:\n                eval_str = \'objItem.%s\' % attribute\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = datetime.datetime.now().strftime(\n    \'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3]\nbreak'
p6565
(F-3.007338121974658
F-2.9089798560509315
tp6566
sS'def get_stats(self):\n    """\n        Show process stats for all processes in given list, if none given return all processes   \n        If filter list is defined return only the items that match or contained in the list\n        Returns a list of result dictionaries\n        """\npythoncom.CoInitialize()\nproc_results_list = []\nif not self.perf_object_list:\n    perf_object_list = self.supported_types.keys()'
p6567
(F-3.1306710970603815
F-2.9039588341346154
tp6568
ssI5137497
(dp6569
S"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'"
p6570
(F-1.5334349412184496
F-3.526438522338867
tp6571
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6572
(F-1.5516219904393325
F-3.040510368347168
tp6573
sS"print __file__ + '\\n'\nprint 'This file full path (following symlinks)'"
p6574
(F-2.1870463978160513
F-3.84312744140625
tp6575
sS"print __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6576
(F-1.6160070025731648
F-3.027447319030762
tp6577
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'"
p6578
(F-1.7093782839567766
F-3.577775573730469
tp6579
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6580
(F-1.6035055735754589
F-3.046640396118164
tp6581
sS"print 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6582
(F-1.9072307787443463
F-3.039381980895996
tp6583
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'"
p6584
(F-1.4819114535462623
F-3.1077831268310545
tp6585
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6586
(F-1.5282422579251802
F-3.0007091522216798
tp6587
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6588
(F-1.5740820843240488
F-3.04837646484375
tp6589
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6590
(F-1.5610350502861872
F-3.025237464904785
tp6591
sS'import os\ncwd = os.getcwd()'
p6592
(F-1.3330479462941487
F-3.1527509689331055
tp6593
sS"path, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6594
(F-1.7160598754882812
F-2.989657974243164
tp6595
sS"full_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6596
(F-1.4370184091421274
F-3.0000728607177733
tp6597
sS"print 'This file path, relative to os.getcwd()'"
p6598
(F-2.397197723388672
F-4.174661636352539
tp6599
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6600
(F-1.5633325576782227
F-3.014717864990234
tp6601
sS'import os'
p6602
(F-1.9842867851257324
F-3.270110321044922
tp6603
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'"
p6604
(F-2.1377816633744673
F-3.8821880340576174
tp6605
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'"
p6606
(F-1.50991939968533
F-3.1092756271362303
tp6607
sS"print path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6608
(F-2.057064643272987
F-3.0483001708984374
tp6609
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6610
(F-1.3853231731214022
F-3.122422218322754
tp6611
sS"print full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6612
(F-2.1047176947960486
F-3.0152729034423826
tp6613
sS'dir_path = os.path.dirname(os.path.realpath(__file__))'
p6614
(F-0.8405595862347147
F-3.00640811920166
tp6615
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6616
(F-1.6164093017578125
F-3.019926071166992
tp6617
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6618
(F-1.6030490759647253
F-3.0530776977539062
tp6619
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6620
(F-1.5713839408678887
F-3.0451765060424805
tp6621
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6622
(F-1.4589728187112248
F-2.992121696472168
tp6623
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'"
p6624
(F-1.2490153312683105
F-3.3189483642578126
tp6625
sS"print 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6626
(F-1.5307924137559048
F-2.9789093017578123
tp6627
sS"import os\nprint 'Path at terminal when executing this file'"
p6628
(F-1.6935928889683314
F-3.3327705383300783
tp6629
sS"print full_path + '\\n'\nprint 'This file directory and name'"
p6630
(F-2.5134436867453833
F-3.16632080078125
tp6631
sS"print __file__ + '\\n'"
p6632
(F-1.9926795959472656
F-3.7919239044189452
tp6633
sS"path, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6634
(F-1.5514973640441894
F-2.97452335357666
tp6635
sS"full_path = os.path.realpath(__file__)\nprint full_path + '\\n'"
p6636
(F-1.292966593866763
F-3.1127639770507813
tp6637
sS"print full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6638
(F-1.8964122972990338
F-3.0059295654296876
tp6639
sS"print 'This file full path (following symlinks)'"
p6640
(F-2.397197723388672
F-4.174661636352539
tp6641
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6642
(F-1.5342491551449424
F-3.136104202270508
tp6643
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6644
(F-1.5617929077148438
F-3.0314172744750976
tp6645
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'"
p6646
(F-1.5181148846944172
F-3.1200775146484374
tp6647
sS"path, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6648
(F-1.7801519121442522
F-3.006172943115234
tp6649
sS"print 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6650
(F-1.7415501994471396
F-3.0269216537475585
tp6651
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6652
(F-1.4778909990864415
F-3.011168670654297
tp6653
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'"
p6654
(F-1.5972984102037218
F-3.1066442489624024
tp6655
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6656
(F-1.5730575561523437
F-3.038679504394531
tp6657
sS"print __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6658
(F-1.5998382568359375
F-3.0145584106445313
tp6659
sS'import os\ndir_path = os.path.dirname(os.path.realpath(__file__))'
p6660
(F-0.6589286510760968
F-3.020707893371582
tp6661
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'"
p6662
(F-1.4148006439208984
F-3.5642662048339844
tp6663
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'"
p6664
(F-1.439807791458933
F-3.341856002807617
tp6665
sS"full_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6666
(F-1.5592439232802973
F-3.0346071243286135
tp6667
sS"print os.getcwd() + '\\n'"
p6668
(F-1.1876522064208985
F-3.4968456268310546
tp6669
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6670
(F-1.498814669522372
F-3.1343925476074217
tp6671
sS"print __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'"
p6672
(F-1.5578445665764087
F-3.09811954498291
tp6673
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'"
p6674
(F-1.7069547653198243
F-3.5159740447998047
tp6675
sS"print __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'"
p6676
(F-1.6185224321153429
F-3.1047189712524412
tp6677
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6678
(F-1.628693320534446
F-3.0332298278808594
tp6679
sS"print path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6680
(F-1.571792755126953
F-2.980172348022461
tp6681
sS"full_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'"
p6682
(F-1.435551716731145
F-3.1141130447387697
tp6683
sS"print 'This file directory and name'"
p6684
(F-2.397197723388672
F-4.174661636352539
tp6685
sS"print 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6686
(F-1.6994188853672572
F-3.0092704772949217
tp6687
sS'print os.path.dirname(full_path)'
p6688
(F-1.2260178052462065
F-3.0478693008422852
tp6689
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6690
(F-1.5464555693835746
F-3.1484193801879883
tp6691
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'"
p6692
(F-1.5538283703373927
F-3.129218101501465
tp6693
sS"print __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6694
(F-1.5950921865609975
F-3.127384567260742
tp6695
sS"full_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6696
(F-1.5085995483398438
F-3.0108448028564454
tp6697
sS"print 'Path at terminal when executing this file'"
p6698
(F-2.397197723388672
F-4.174661636352539
tp6699
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6700
(F-1.6766813772696036
F-3.0420053482055662
tp6701
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)"
p6702
(F-1.6502472449993264
F-3.1367626190185547
tp6703
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6704
(F-1.599992405284535
F-3.0241582870483397
tp6705
sS"print full_path + '\\n'"
p6706
(F-2.536834716796875
F-3.14145565032959
tp6707
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'"
p6708
(F-1.6428768451397235
F-3.1144687652587892
tp6709
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'"
p6710
(F-1.7436473680579143
F-3.548436737060547
tp6711
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'"
p6712
(F-1.6509662496632542
F-3.3792350769042967
tp6713
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'"
p6714
(F-1.5884934663772583
F-3.5937904357910155
tp6715
sS"print full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6716
(F-1.6761032104492188
F-2.9705677032470703
tp6717
sS"print 'This file directory only'\nprint os.path.dirname(full_path)"
p6718
(F-1.365121603012085
F-3.0384408950805666
tp6719
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6720
(F-1.5397760643149323
F-3.002264404296875
tp6721
sS"print __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6722
(F-1.513299051920573
F-2.99749755859375
tp6723
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'"
p6724
(F-1.7249864431527944
F-3.6091567993164064
tp6725
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'"
p6726
(F-1.4114068838266225
F-3.0924072265625
tp6727
sS"print path + ' --> ' + filename + '\\n'"
p6728
(F-2.0253042221069335
F-3.013890266418457
tp6729
sS"print 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'"
p6730
(F-1.5113756903286637
F-3.0972148895263674
tp6731
sS"print full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6732
(F-1.8826261247907365
F-2.9895538330078124
tp6733
sS"print __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)"
p6734
(F-1.6603040508195466
F-3.0367351531982423
tp6735
sS'cwd = os.getcwd()'
p6736
(F-1.8468623691134982
F-3.162409019470215
tp6737
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6738
(F-1.4906586394912895
F-3.0071773529052734
tp6739
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'"
p6740
(F-1.6158699622521033
F-3.3523536682128907
tp6741
sS"print 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'\nprint os.path.dirname(full_path)"
p6742
(F-1.4921235826280381
F-3.0104551315307617
tp6743
sS"print os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'"
p6744
(F-1.5530611673990886
F-3.117741012573242
tp6745
sS'path, filename = os.path.split(full_path)'
p6746
(F-1.9031434059143066
F-3.015315628051758
tp6747
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'"
p6748
(F-1.5191968282063801
F-3.1154638290405274
tp6749
sS'full_path = os.path.realpath(__file__)'
p6750
(F-1.1644344329833984
F-3.1467557907104493
tp6751
sS"print 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'"
p6752
(F-2.160748617989676
F-3.9249496459960938
tp6753
sS"full_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'\nprint 'This file directory only'"
p6754
(F-1.5415996335587412
F-3.0225460052490236
tp6755
sS"print 'This file directory only'"
p6756
(F-2.397197723388672
F-4.174661636352539
tp6757
sS"import os\nprint 'Path at terminal when executing this file'\nprint os.getcwd() + '\\n'\nprint 'This file path, relative to os.getcwd()'\nprint __file__ + '\\n'\nprint 'This file full path (following symlinks)'\nfull_path = os.path.realpath(__file__)\nprint full_path + '\\n'\nprint 'This file directory and name'\npath, filename = os.path.split(full_path)\nprint path + ' --> ' + filename + '\\n'"
p6758
(F-1.5400533431615584
F-3.027302932739258
tp6759
ssI6886493
(dp6760
S'obj = MyObj()\nprint obj.__dict__'
p6761
(F-1.8796910603841146
F-2.255504608154297
tp6762
sS'print obj.__dict__'
p6763
(F-1.712888479232788
F-2.2204708523220487
tp6764
sS"def __init__(self):\n    self.name = 'Chuck Norris'"
p6765
(F-0.8733408715989854
F-2.5018323262532554
tp6766
sS"self.phone = '+6661'\nobj = MyObj()\nprint obj.__dict__"
p6767
(F-2.2271590459914434
F-2.374539269341363
tp6768
sS'class MyObj(object):\n    pass'
p6769
(F-1.4577319805438702
F-2.231604894002279
tp6770
sS"class MyObj(object):\n\n    def __init__(self):\n        self.name = 'Chuck Norris'\nself.phone = '+6661'"
p6771
(F-1.4250455583844865
F-2.268355051676432
tp6772
sS'def __init__(self):\n    pass'
p6773
(F-1.1548412867954798
F-2.505771425035265
tp6774
sS'obj = MyObj()'
p6775
(F-2.8920445442199707
F-2.3088230556911893
tp6776
sS"class MyObj(object):\n\n    def __init__(self):\n        self.name = 'Chuck Norris'\nself.phone = '+6661'\nobj = MyObj()"
p6777
(F-1.6897468566894531
F-2.247123506334093
tp6778
sS"class MyObj(object):\n\n    def __init__(self):\n        self.name = 'Chuck Norris'"
p6779
(F-0.9310813114560884
F-2.240016089545356
tp6780
sS"class MyObj(object):\n\n    def __init__(self):\n        self.name = 'Chuck Norris'\nself.phone = '+6661'\nobj = MyObj()\nprint obj.__dict__"
p6781
(F-1.5561345937300701
F-2.211849848429362
tp6782
sS"self.name = 'Chuck Norris'"
p6783
(F-1.510728018624442
F-2.5566622416178384
tp6784
sS'class MyObj(object):\n\n    def __init__(self):\n        pass'
p6785
(F-1.1308003234863282
F-2.2347530788845487
tp6786
sS"self.phone = '+6661'\nobj = MyObj()"
p6787
(F-2.9212891714913503
F-2.4755015903049045
tp6788
sS"self.phone = '+6661'"
p6789
(F-2.1072654724121094
F-2.5995375315348306
tp6790
ssI961632
(dp6791
S"str(10)\nint('10')"
p6792
(F-2.321780811656605
F-1.9103785620795355
tp6793
sS'str(a)'
p6794
(F-2.018176237742106
F-1.9760267469618056
tp6795
sS'str(10)'
p6796
(F-2.34346596399943
F-1.9648810492621527
tp6797
sS'str(i)'
p6798
(F-1.831144650777181
F-1.9393204583062067
tp6799
sS"int('10')"
p6800
(F-1.4355700810750325
F-1.9400588141547308
tp6801
sS'a.__str__()'
p6802
(F-2.66426510281033
F-2.038293626573351
tp6803
ssI1712227
(dp6804
S"items.append('apple')\nitems.append('orange')"
p6805
(F-1.3771662394205728
F-2.021620750427246
tp6806
sS"items = []\nitems.append('apple')\nitems.append('orange')\nitems.append('banana')"
p6807
(F-1.1657704953794126
F-2.0361440658569334
tp6808
sS'print l'
p6809
(F-2.859454870223999
F-1.562376117706299
tp6810
sS'l.length'
p6811
(F-4.895208358764648
F-1.502248477935791
tp6812
sS"items.append('banana')"
p6813
(F-1.8251323699951172
F-1.9385869979858399
tp6814
sS'len(items)'
p6815
(F-1.9599315325419109
F-1.777792739868164
tp6816
sS"items.append('apple')"
p6817
(F-1.8251324892044067
F-1.9385869979858399
tp6818
sS'l = slist(range(10))\nl.length\nprint l'
p6819
(F-3.7147950066460504
F-1.6210905075073243
tp6820
sS"items = []\nitems.append('apple')\nitems.append('orange')"
p6821
(F-1.3796163558959962
F-1.9940498352050782
tp6822
sS'def length(self):\n    return len(self)'
p6823
(F-2.0474050045013428
F-1.9511247634887696
tp6824
sS"items.append('orange')\nitems.append('banana')"
p6825
(F-1.377166493733724
F-2.021620750427246
tp6826
sS'True'
p6827
(F-3.547506014506022
F-2.152462959289551
tp6828
sS'len([1, 2, 3])'
p6829
(F-1.2078761259714763
F-1.6630659103393555
tp6830
sS'items.__len__()'
p6831
(F-3.699459499782986
F-1.8966270446777345
tp6832
sS'def length(self):\n    pass'
p6833
(F-2.2378923098246255
F-1.898752784729004
tp6834
sS"items = []\nitems.append('apple')"
p6835
(F-1.7856351412259615
F-1.9320823669433593
tp6836
sS"items.append('orange')"
p6837
(F-1.8251323699951172
F-1.9385869979858399
tp6838
sS'l.length\nprint l'
p6839
(F-4.079444885253906
F-1.509368324279785
tp6840
sS'l = slist(range(10))\nl.length'
p6841
(F-4.008978780110677
F-1.6357078552246094
tp6842
sS'items = []'
p6843
(F-2.195112864176432
F-1.791639518737793
tp6844
sS'return len(self)'
p6845
(F-3.313092367989676
F-1.78548583984375
tp6846
sS'class slist(list):\n    pass'
p6847
(F-2.675453503926595
F-1.7174884796142578
tp6848
sS'l = slist(range(10))'
p6849
(F-3.8755021528764204
F-1.663892936706543
tp6850
sS"items.append('apple')\nitems.append('orange')\nitems.append('banana')"
p6851
(F-1.1905113567005505
F-2.073318862915039
tp6852
ssI1720421
(dp6853
S'for item in itertools.chain(listone, listtwo):\n    pass'
p6854
(F-1.5628384484185114
F-2.965077913724459
tp6855
sS'import itertools\nfor item in itertools.chain(listone, listtwo):\n    pass'
p6856
(F-1.6116271246047247
F-2.955949930044321
tp6857
sS'mergedlist = list(set(listone + listtwo))'
p6858
(F-1.9694008460411658
F-2.9902525681715746
tp6859
sS'mergedlist = listone + listtwo'
p6860
(F-2.5700607299804688
F-3.329451634333684
tp6861
sS'pass'
p6862
(F-3.2913716634114585
F-3.7421954228327823
tp6863
sS'import itertools'
p6864
(F-3.37923002243042
F-3.088891836313101
tp6865
ssI16196712
(dp6866
S'p.wait()\nif p.returncode == 0:\n    pass'
p6867
(F-1.6836964456658614
F-4.393866729736328
tp6868
sS"p = subprocess.Popen(['unrar', 'e', '%s/%s' % (root, i), testfolder],\n    bufsize=2048, stdin=subprocess.PIPE)\np.stdin.write('e')\np.wait()"
p6869
(F-1.4755584716796875
F-4.032725524902344
tp6870
sS'if p.returncode == 0:\n    pass'
p6871
(F-1.664826906644381
F-4.864567565917969
tp6872
sS"p.stdin.write('e')"
p6873
(F-1.0205015182495116
F-4.344562530517578
tp6874
sS"p.stdin.write('e')\np.wait()\nif p.returncode == 0:\n    pass"
p6875
(F-1.3326445988246374
F-4.308750915527344
tp6876
sS'p.wait()'
p6877
(F-1.3392324447631836
F-4.059060287475586
tp6878
sS"p = subprocess.Popen(['unrar', 'e', '%s/%s' % (root, i), testfolder],\n    bufsize=2048, stdin=subprocess.PIPE)"
p6879
(F-1.8485722133091518
F-3.978951263427734
tp6880
sS"p = subprocess.Popen('unrar e ' + root + '/' + i + ' ' + testfolder,\n    bufsize=2048, shell=True, stdin=subprocess.PIPE)"
p6881
(F-1.6583613804408481
F-3.9227882385253907
tp6882
sS'pass'
p6883
(F-2.9420979817708335
F-4.600579833984375
tp6884
sS"p = subprocess.Popen(['unrar', 'e', '%s/%s' % (root, i), testfolder],\n    bufsize=2048, stdin=subprocess.PIPE)\np.stdin.write('e')\np.wait()\nif p.returncode == 0:\n    pass"
p6885
(F-1.4678533000330771
F-4.070900726318359
tp6886
sS"p.stdin.write('e')\np.wait()"
p6887
(F-1.0101327896118164
F-4.2444007873535154
tp6888
sS"p = subprocess.Popen(['unrar', 'e', '%s/%s' % (root, i), testfolder],\n    bufsize=2048, stdin=subprocess.PIPE)\np.stdin.write('e')"
p6889
(F-1.6364725286310369
F-4.040992736816406
tp6890
ssI209513
(dp6891
S"x = int('deadbeef', 16)"
p6892
(F-2.1371181488037108
F-1.519325362311469
tp6893
sS'int(s, 16)'
p6894
(F-2.1147639751434326
F-1.4014871385362413
tp6895
sS"int('a', 16)\nint('0xa', 16)"
p6896
(F-1.984787368774414
F-1.4316683875189886
tp6897
sS"int('0xa', 16)"
p6898
(F-1.7675583362579346
F-1.4709864722357855
tp6899
sS"print int('10', 0)"
p6900
(F-2.3709008958604603
F-1.4565504921807184
tp6901
sS"print int('0xdeadbeef', 0)"
p6902
(F-2.3709008958604603
F-1.4565504921807184
tp6903
sS"print int('0xdeadbeef', 0)\nprint int('10', 0)"
p6904
(F-2.109785192153033
F-1.4307816823323567
tp6905
sS"int('a', 16)"
p6906
(F-1.7675583362579346
F-1.4709864722357855
tp6907
ssI642154
(dp6908
S'T2 = [[int(column) for column in row] for row in T1]'
p6909
(F-2.4485805511474608
F-1.9499379938299006
tp6910
sS'[[int(y) for y in x] for x in T1]'
p6911
(F-2.046592288547092
F-1.9618403694846414
tp6912
sS'T2 = [parse_a_row_of_T1(row) for row in T1]'
p6913
(F-3.72633882002397
F-1.9430368596857244
tp6914
sS'T2 = [map(int, x) for x in T1]'
p6915
(F-2.050165891647339
F-1.9103053699840198
tp6916
sS"print int('1') + 1"
p6917
(F-2.073352813720703
F-1.6078468669544568
tp6918
ssI7961363
(dp6919
S"list(OrderedDict.fromkeys('abracadabra'))"
p6920
(F-2.3581485748291016
F-2.5679529507954917
tp6921
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]\nlist(set(t) - set(s))'
p6922
(F-1.9876065935407365
F-2.3826513290405273
tp6923
sS"list(dict.fromkeys('abracadabra'))"
p6924
(F-2.5833906693892046
F-2.924478530883789
tp6925
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt'
p6926
(F-1.6380325317382813
F-2.833237648010254
tp6927
sS's = [1, 2, 3]\nlist(set(t) - set(s))'
p6928
(F-1.9048439661661785
F-2.406043370564779
tp6929
sS'from collections import OrderedDict'
p6930
(F-1.4167526790073939
F-2.4380745887756348
tp6931
sS'list(set(t))\ns = [1, 2, 3]\nlist(set(t) - set(s))'
p6932
(F-2.1948022842407227
F-2.297276178995768
tp6933
sS'list(set(t))'
p6934
(F-2.210213131374783
F-2.483154614766439
tp6935
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]'
p6936
(F-1.9315359426099201
F-2.53477414449056
tp6937
sS't\nlist(set(t))'
p6938
(F-3.482542558149858
F-2.6252527236938477
tp6939
sS't\nlist(set(t))\ns = [1, 2, 3]\nlist(set(t) - set(s))'
p6940
(F-2.609595579259536
F-2.381931940714518
tp6941
sS't'
p6942
(F-5.987929026285808
F-3.3878377278645835
tp6943
sS'list(set(t))\ns = [1, 2, 3]'
p6944
(F-2.1901425813373767
F-2.437971909840902
tp6945
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))'
p6946
(F-1.9321535283868962
F-2.572756290435791
tp6947
sS's = [1, 2, 3]'
p6948
(F-1.659368168223988
F-2.7798659006754556
tp6949
sS't\nlist(set(t))\ns = [1, 2, 3]'
p6950
(F-2.8874353681291853
F-2.5599889755249023
tp6951
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]'
p6952
(F-1.4158524222995923
F-2.832773208618164
tp6953
sS'list(set(t) - set(s))'
p6954
(F-2.416602543422154
F-2.4113667805989585
tp6955
sS"from collections import OrderedDict\nlist(OrderedDict.fromkeys('abracadabra'))"
p6956
(F-1.671929571363661
F-2.2762908935546875
tp6957
ssI6996603
(dp6958
S'shutil.rmtree(path, ignore_errors=False, onerror=None)'
p6959
(F-1.8752189212375217
F-2.2833675808376737
tp6960
sS'os.removedirs(name)'
p6961
(F-2.3175125122070312
F-2.465520011054145
tp6962
sS'os.rmdir'
p6963
(F-2.7827444076538086
F-2.382801267835829
tp6964
sS'os.remove'
p6965
(F-2.1583183288574217
F-2.263328128390842
tp6966
ssI930397
(dp6967
S"alist[-1:]\nastr = ''"
p6968
(F-3.7563578287760415
F-1.4186593836004084
tp6969
sS"alist[-1:]\nastr = ''\nastr[-1]"
p6970
(F-3.4832227494981556
F-1.4113224202936345
tp6971
sS"astr = ''\nastr[-1]\nastr[-1:]"
p6972
(F-2.995794508192274
F-1.5300705649636008
tp6973
sS'some_list = [1, 2, 3]'
p6974
(F-1.489641629732572
F-1.27422081340443
tp6975
sS"alist[-1]\nalist[-1:]\nastr = ''"
p6976
(F-3.63572014702691
F-1.442552306435325
tp6977
sS'astr[-1]'
p6978
(F-2.868772506713867
F-1.3488616943359375
tp6979
sS'alist.pop()'
p6980
(F-2.638193130493164
F-1.4755637428977273
tp6981
sS'alist[-1:]'
p6982
(F-2.5503742694854736
F-1.3756679188121448
tp6983
sS'some_list'
p6984
(F-2.552521514892578
F-1.3207328102805398
tp6985
sS"alist[-1]\nalist[-1:]\nastr = ''\nastr[-1]\nastr[-1:]"
p6986
(F-3.256077920236895
F-1.4338328621604226
tp6987
sS"alist[-1:]\nastr = ''\nastr[-1]\nastr[-1:]"
p6988
(F-3.222914733886719
F-1.4124214865944602
tp6989
sS"alist[-1]\nalist[-1:]\nastr = ''\nastr[-1]"
p6990
(F-3.4562320709228516
F-1.4326094714078037
tp6991
sS'some_list = [1, 2, 3]\nsome_list[-1] = 5\nsome_list[-2] = 3\nsome_list'
p6992
(F-1.8032069850612331
F-1.3062596754594282
tp6993
sS'some_list = [1, 2, 3]\nsome_list[-1] = 5'
p6994
(F-1.668046868365744
F-1.2819061279296875
tp6995
sS'alist = []\nalist[-1]\nalist[-1:]'
p6996
(F-2.7997984635202506
F-1.4789723482998935
tp6997
sS'some_list[-2] = 3'
p6998
(F-2.261703838001598
F-1.2705623453313655
tp6999
sS"astr = ''\nastr[-1]"
p7000
(F-3.2178268432617188
F-1.6339393962513318
tp7001
sS"alist = []\nalist[-1]\nalist[-1:]\nastr = ''\nastr[-1]"
p7002
(F-3.2866592407226562
F-1.4685056859796697
tp7003
sS"astr = ''"
p7004
(F-2.817719650268555
F-1.9565616954456677
tp7005
sS'alist[-1]\nalist[-1:]'
p7006
(F-2.791046687534877
F-1.4269801053133877
tp7007
sS'some_list = [1, 2, 3]\nsome_list[-1] = 5\nsome_list[-2] = 3'
p7008
(F-1.7963478781960227
F-1.3018009012395686
tp7009
sS'astr[-1:]'
p7010
(F-2.326685905456543
F-1.3582172393798828
tp7011
sS"alist = []\nalist[-1]\nalist[-1:]\nastr = ''"
p7012
(F-3.3849921848462974
F-1.4855813113125889
tp7013
sS'some_list[-1] = 5\nsome_list[-2] = 3\nsome_list'
p7014
(F-2.0326312255859373
F-1.2808148644187234
tp7015
sS'alist = []\nalist[-1]'
p7016
(F-2.9889923731486
F-1.4507756666703657
tp7017
sS'some_list[-1] = 5'
p7018
(F-2.030633406205611
F-1.2660423625599255
tp7019
sS'some_list[-1] = 5\nsome_list[-2] = 3'
p7020
(F-2.0588916596912203
F-1.2764178189364346
tp7021
sS'astr[-1]\nastr[-1:]'
p7022
(F-2.798030035836356
F-1.3620342774824663
tp7023
sS'alist = []'
p7024
(F-2.82180118560791
F-1.4044247540560635
tp7025
sS'alist[-1]'
p7026
(F-3.0722569056919644
F-1.3724425055763938
tp7027
sS"alist = []\nalist[-1]\nalist[-1:]\nastr = ''\nastr[-1]\nastr[-1:]"
p7028
(F-3.1563182406955295
F-1.4638911160555752
tp7029
sS'some_list[-2] = 3\nsome_list'
p7030
(F-2.1658561706542967
F-1.2698744860562412
tp7031
ssI2269827
(dp7032
S"chr(101) == 'e'\nhex(65)"
p7033
(F-2.8003290616548977
F-1.5511789321899414
tp7034
sS"'0x%X' % 255"
p7035
(F-3.2847671508789062
F-1.6363016764322917
tp7036
sS"'0x%x' % 255"
p7037
(F-3.2847671508789062
F-1.6363016764322917
tp7038
sS"hex(65)\nchr(65) == 'A'"
p7039
(F-2.4634375939002404
F-1.5119398434956868
tp7040
sS"chr(65) == 'A'"
p7041
(F-2.484335422515869
F-1.7563133239746094
tp7042
sS"chr(101) == 'e'"
p7043
(F-3.0422043800354004
F-1.6290082931518555
tp7044
sS"strHex = '0x%0.2X' % 255"
p7045
(F-3.0602617263793945
F-1.5552109082539876
tp7046
sS'hex(65)'
p7047
(F-2.2036619186401367
F-1.5008780161539714
tp7048
sS"chr(101) == 'e'\nhex(65)\nchr(65) == 'A'"
p7049
(F-2.818012809753418
F-1.602531909942627
tp7050
ssI9257094
(dp7051
S"lower = raw_input('type in the same thing caps lock.')"
p7052
(F-1.484347152709961
F-2.5989596048990884
tp7053
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p7054
(F-1.3444752326378455
F-2.5957732730441623
tp7055
sS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p7056
(F-1.5392804987290327
F-2.524884753757053
tp7057
sS'print upper.upper()\nprint lower.lower()'
p7058
(F-1.877219263712565
F-2.5064336988661022
tp7059
sS'print s.upper()'
p7060
(F-1.5305438041687012
F-2.358559078640408
tp7061
sS'string.ascii_uppercase'
p7062
(F-2.126128469194685
F-2.8621819814046225
tp7063
sS"upper = raw_input('type in something lowercase.')"
p7064
(F-1.5549234390258788
F-2.6006611718071833
tp7065
sS's.upper()'
p7066
(F-1.5711356571742467
F-2.356530507405599
tp7067
sS"s = 'sdsd'\ns.upper()"
p7068
(F-1.2198001688176936
F-2.362642076280382
tp7069
sS'print upper.upper()'
p7070
(F-1.9576854705810547
F-2.4281213548448353
tp7071
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p7072
(F-1.3820559183756511
F-2.573069042629666
tp7073
sS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p7074
(F-1.5455816586812336
F-2.5294746822781033
tp7075
sS"s = 'sdsd'\nprint s.upper()"
p7076
(F-0.986367384592692
F-2.3602462344699435
tp7077
sS"s = 'sdsd'"
p7078
(F-1.7436016082763672
F-2.5756717258029513
tp7079
sS'print lower.lower()'
p7080
(F-1.9237786531448364
F-2.5784484015570746
tp7081
sS'import string'
p7082
(F-1.9911247491836548
F-2.574327680799696
tp7083
sS'import string\nstring.ascii_uppercase'
p7084
(F-1.974947738647461
F-2.780453364054362
tp7085
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')"
p7086
(F-1.303342016119706
F-2.665176603529188
tp7087
ssI730764
(dp7088
S'try:\n    doSomething()\nexcept Exception:\n    pass'
p7089
(F-1.1266393159565173
F-3.326777140299479
tp7090
sS'try:\n    sys.exit(1)\nexcept Exception:\n    pass'
p7091
(F-0.897789546421596
F-3.3844950358072916
tp7092
sS'try:\n    doSomething()\nexcept:\n    pass'
p7093
(F-1.0184338887532551
F-3.327656046549479
tp7094
sS'pass'
p7095
(F-2.9715245564778647
F-3.562511698404948
tp7096
sS"shutil.rmtree('/fake/dir')"
p7097
(F-1.5983704328536987
F-3.5607213338216144
tp7098
sS'try:\n    do_something()\nexcept:\n    pass'
p7099
(F-0.8330661874068411
F-3.328772481282552
tp7100
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if e.errno == 2:\n        pass\nelse:\n    raise'
p7101
(F-1.3263864284608422
F-3.3625872294108072
tp7102
sS'raise'
p7103
(F-4.915041605631511
F-3.5545613606770834
tp7104
sS'shutil.rmtree(2)'
p7105
(F-2.6107676029205322
F-3.5410555521647136
tp7106
sS'shutil.rmtree(path)'
p7107
(F-2.1762309074401855
F-3.587079620361328
tp7108
sS'handle_exception()'
p7109
(F-3.5632536751883372
F-3.406122843424479
tp7110
sS'try:\n    do_something()\nexcept:\n    handle_exception()'
p7111
(F-1.7083736917246943
F-3.2959498087565104
tp7112
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if e.errno == 2:\n        pass\nelse:\n    pass'
p7113
(F-1.1758298176090891
F-3.372545115152995
tp7114
sS'sys.exit(1)'
p7115
(F-1.3401157855987549
F-3.426086934407552
tp7116
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    pass'
p7117
(F-1.1994451681772869
F-3.4574961344401043
tp7118
sS'try:\n    shutil.rmtree(path)\nexcept OSError:\n    pass'
p7119
(F-1.166489687832919
F-3.463934326171875
tp7120
sS'try:\n    sys.exit(1)\nexcept:\n    pass'
p7121
(F-0.8295348167419434
F-3.387522888183594
tp7122
sS'do_something()'
p7123
(F-1.2454210008893694
F-3.3536722819010416
tp7124
sS'doSomething()'
p7125
(F-1.9262909889221191
F-3.3805806477864584
tp7126
sS'if e.errno == 2:\n    pass'
p7127
(F-2.267081334040715
F-3.4562975565592446
tp7128
sS'try:\n    do_something()\nexcept:\n    handle_exception()\nraise'
p7129
(F-2.1195974731445313
F-3.293498738606771
tp7130
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if e.errno == 2:\n        pass'
p7131
(F-1.2410212124095243
F-3.388428243001302
tp7132
ssI70797
(dp7133
S"var = raw_input('Please enter something: ')"
p7134
(F-1.4059269905090332
F-3.9575733608669705
tp7135
sS'import sys'
p7136
(F-2.7677087783813477
F-4.248247358534071
tp7137
sS"input_var = input('Enter something: ')\nprint 'you entered ' + input_var"
p7138
(F-2.3253723593319164
F-3.878920661078559
tp7139
sS'import sys\nprint sys.argv'
p7140
(F-1.8709528181287978
F-3.959936353895399
tp7141
sS"print 'you entered', var"
p7142
(F-2.6170042355855307
F-3.940405527750651
tp7143
sS"input_var = input('Enter something: ')"
p7144
(F-2.205740737915039
F-3.9198167588975696
tp7145
sS"print 'you entered ' + input_var"
p7146
(F-2.986375331878662
F-3.860883500840929
tp7147
sS'print sys.argv'
p7148
(F-3.115447998046875
F-3.9379297892252603
tp7149
sS"var = raw_input('Please enter something: ')\nprint 'you entered', var"
p7150
(F-1.583502197265625
F-3.922423892550998
tp7151
ssI4706499
(dp7152
S"f.write('hi')"
p7153
(F-1.025754451751709
F-1.5592384338378906
tp7154
sS'f.seek(0)'
p7155
(F-1.1657445430755615
F-1.524232546488444
tp7156
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p7157
(F-0.9234673636300224
F-1.5493629773457844
tp7158
sS'f.seek(0)\nf.read()'
p7159
(F-1.252739361354283
F-1.5574498176574707
tp7160
sS"f.write('hi')\nf.seek(0)"
p7161
(F-0.9461609522501627
F-1.5367242495218914
tp7162
sS"open('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p7163
(F-0.7942597071329752
F-1.5865079561869304
tp7164
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p7165
(F-0.9552375793457031
F-1.5615620613098145
tp7166
sS"f.read()\nf.seek(0)\nf.write('bye')"
p7167
(F-1.229096185593378
F-1.5656909942626953
tp7168
sS"f.seek(0)\nf.write('bye')"
p7169
(F-0.8912460962931316
F-1.537554423014323
tp7170
sS"with open('foo', 'a') as f:\n    pass"
p7171
(F-0.6403555870056152
F-1.508775234222412
tp7172
sS"f.write('bye')\nf.seek(0)\nf.read()"
p7173
(F-1.1006346203031994
F-1.5499407450358074
tp7174
sS"f.write('cool beans...')"
p7175
(F-1.025754451751709
F-1.5592384338378906
tp7176
sS"myfile.write('appended text')"
p7177
(F-1.1420224905014038
F-1.5259450276692708
tp7178
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p7179
(F-0.9576961199442545
F-1.5618659655253093
tp7180
sS"with open('test.txt', 'a') as myfile:\n    myfile.write('appended text')"
p7181
(F-0.6843036469959077
F-1.5382181803385417
tp7182
sS"open('test', 'rb').read()"
p7183
(F-0.8470330238342285
F-1.57788880666097
tp7184
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p7185
(F-0.6173583377491344
F-1.5548073450724285
tp7186
sS"f.write('hi')\nf.seek(0)\nf.read()"
p7187
(F-1.1006346203031994
F-1.5499407450358074
tp7188
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p7189
(F-0.9872950111947408
F-1.55937655766805
tp7190
sS"f.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p7191
(F-0.930227415902274
F-1.5422151883443196
tp7192
sS"f.seek(0)\nf.write('bye')\nf.seek(0)"
p7193
(F-0.8092897588556464
F-1.5312344233194988
tp7194
sS'f.seek(0)\nf.read()\nf.seek(0)'
p7195
(F-1.150077638171968
F-1.552268664042155
tp7196
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p7197
(F-0.6802882144325658
F-1.5544816652933757
tp7198
sS"open('test', 'a+b').write('koko')"
p7199
(F-0.6491087399996244
F-1.5762651761372883
tp7200
sS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p7201
(F-1.094355583190918
F-1.5574529965718586
tp7202
sS"with open('foo', 'a') as f:\n    f.write('cool beans...')"
p7203
(F-0.2386785007658459
F-1.5301540692647297
tp7204
sS'f.read()\nf.seek(0)'
p7205
(F-1.5544347763061523
F-1.5775000254313152
tp7206
sS"with open('test.txt', 'a') as myfile:\n    pass"
p7207
(F-0.9582636952400208
F-1.5233192443847656
tp7208
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p7209
(F-1.0605081149509974
F-1.5467580159505208
tp7210
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()"
p7211
(F-0.6022691090901693
F-1.541323184967041
tp7212
sS"f.write('bye')"
p7213
(F-1.025754451751709
F-1.5592384338378906
tp7214
sS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p7215
(F-0.7173014746771919
F-1.595491091410319
tp7216
sS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')"
p7217
(F-0.5851978302001953
F-1.5925353368123372
tp7218
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p7219
(F-0.8988173348563058
F-1.5542469024658203
tp7220
sS"f = open('test', 'a+')\nf.write('hi')"
p7221
(F-0.40702110178330364
F-1.5452624956766765
tp7222
sS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p7223
(F-1.1482072718003218
F-1.5684215227762859
tp7224
sS"f.write('koko')"
p7225
(F-1.025754451751709
F-1.55923859278361
tp7226
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p7227
(F-0.6036666421329274
F-1.5481785138448079
tp7228
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)"
p7229
(F-0.4287251631418864
F-1.5334850947062175
tp7230
sS'f.read()'
p7231
(F-1.814065933227539
F-1.6207674344380696
tp7232
sS"open('test', 'wb').write('test')"
p7233
(F-0.6491087399996244
F-1.5762651761372883
tp7234
sS'"""testkoko"""'
p7235
(F-2.5845864613850913
F-1.8588182131449382
tp7236
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p7237
(F-0.6442454570048565
F-1.5384127298990886
tp7238
sS"f.write('test')"
p7239
(F-1.025754451751709
F-1.55923859278361
tp7240
sS'fseek(stream, 0, SEEK_END)'
p7241
(F-4.1622568766276045
F-1.8493674596150715
tp7242
sS"f = open('test', 'a+')"
p7243
(F-0.5898461818695069
F-1.5215024948120117
tp7244
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p7245
(F-0.9944370814732143
F-1.5546445846557617
tp7246
sS"f.write('bye')\nf.seek(0)"
p7247
(F-0.9461609522501627
F-1.5367242495218914
tp7248
ssI22676
(dp7249
S"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass"
p7250
(F-2.105504353841146
F-2.002394309410682
tp7251
sS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p7252
(F-0.8520407903762091
F-1.7208199134239783
tp7253
sS'import requests'
p7254
(F-2.1575188636779785
F-1.7935961209810698
tp7255
sS"f = open(file_name, 'wb')\nmeta = u.info()"
p7256
(F-2.1693208694458006
F-2.1485441648043118
tp7257
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192"
p7258
(F-2.7850203604068398
F-2.0289425483116736
tp7259
sS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')"
p7260
(F-0.8527631026047927
F-1.6768819368802583
tp7261
sS'while True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7262
(F-2.6180021497938366
F-2.0890527871938853
tp7263
sS'f.close()'
p7264
(F-1.3311703545706612
F-2.18807866023137
tp7265
sS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7266
(F-1.456561464251894
F-2.030177189753606
tp7267
sS"urllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p7268
(F-0.84327392578125
F-1.6374733264629657
tp7269
sS"while True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7270
(F-2.832731926578215
F-2.029741727388822
tp7271
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7272
(F-2.55664422776964
F-2.048340137188251
tp7273
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7274
(F-2.239077674018012
F-2.0622692108154297
tp7275
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7276
(F-2.7832112031824447
F-2.0507972423846903
tp7277
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7278
(F-2.5369272867838544
F-2.016473623422476
tp7279
sS"while True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7280
(F-2.8543194781292924
F-2.0295555408184347
tp7281
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7282
(F-2.425008787331006
F-1.907447521503155
tp7283
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7284
(F-2.2186365420101613
F-1.8838013869065504
tp7285
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7286
(F-1.2210992777122642
F-1.7349472045898438
tp7287
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7288
(F-2.089537696015063
F-1.9125546675461988
tp7289
sS"if not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7290
(F-2.8437910813551683
F-1.9358758192795973
tp7291
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7292
(F-2.8690467471168155
F-1.97627199613131
tp7293
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7294
(F-1.34899554045304
F-1.8000956315260668
tp7295
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass"
p7296
(F-2.009952513639592
F-1.9328792278583233
tp7297
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7298
(F-2.292223017266456
F-1.9441405076246996
tp7299
sS"while True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7300
(F-2.7724934453549595
F-1.9800403301532452
tp7301
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7302
(F-1.723723243264591
F-1.827877924992488
tp7303
sS"f = open(file_name, 'wb')"
p7304
(F-1.1889745394388835
F-2.194759809053861
tp7305
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)"
p7306
(F-1.8950035341324345
F-2.387421387892503
tp7307
sS"f.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7308
(F-3.124295711517334
F-1.926000448373648
tp7309
sS'while True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break'
p7310
(F-2.43405603479456
F-2.4104204911452074
tp7311
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7312
(F-2.3510674370659723
F-2.052411592923678
tp7313
sS'if not buffer:\n    pass'
p7314
(F-2.3291717529296876
F-2.61794427724985
tp7315
sS'if not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7316
(F-2.699448449271066
F-2.024510750403771
tp7317
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)"
p7318
(F-1.3832801292682517
F-1.9459530757023737
tp7319
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7320
(F-2.8985113328503025
F-2.0115836216853213
tp7321
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7322
(F-1.0704780347419507
F-1.7353914701021635
tp7323
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7324
(F-2.0611216681344167
F-1.8873880826509917
tp7325
sS'print status,\nf.close()'
p7326
(F-2.631492094560103
F-2.1172139094426083
tp7327
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7328
(F-2.646466290509259
F-2.021440652700571
tp7329
sS'for data in tqdm(response.iter_content()):\n    pass'
p7330
(F-1.9845235824584961
F-2.126641640296349
tp7331
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7332
(F-1.3930170012683403
F-1.7929923717792218
tp7333
sS'break'
p7334
(F-3.271857579549154
F-2.2454757690429688
tp7335
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7336
(F-2.5615971552861203
F-2.0155401963454027
tp7337
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)"
p7338
(F-1.3018807172775269
F-1.8263320922851562
tp7339
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7340
(F-1.3468830320570204
F-1.86449828514686
tp7341
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7342
(F-1.241643038662997
F-1.7859670198880708
tp7343
sS'while True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass'
p7344
(F-2.4226481119791665
F-2.429544889009916
tp7345
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7346
(F-2.7022360665457588
F-2.10105221088116
tp7347
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7348
(F-2.572347582001047
F-2.051441339346079
tp7349
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192"
p7350
(F-2.385267496109009
F-2.0275083688589244
tp7351
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7352
(F-2.498334584745971
F-1.941487532395583
tp7353
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7354
(F-1.1927997983735183
F-1.7235252673809345
tp7355
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7356
(F-2.715513326353946
F-1.9860097444974458
tp7357
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7358
(F-2.168656267438616
F-1.9567699432373047
tp7359
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass"
p7360
(F-2.387937948737346
F-2.167498075045072
tp7361
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break"
p7362
(F-2.564988341512559
F-2.144552230834961
tp7363
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass"
p7364
(F-2.255251797762784
F-1.9761211688701923
tp7365
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass"
p7366
(F-2.5258591263382524
F-2.164298571073092
tp7367
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7368
(F-1.4681051345098586
F-1.7131423950195312
tp7369
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7370
(F-2.651240829593879
F-1.9826290424053485
tp7371
sS'from tqdm import tqdm\nimport requests'
p7372
(F-3.2542396121554904
F-2.36282466008113
tp7373
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7374
(F-2.7064072862803505
F-2.019737537090595
tp7375
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break'
p7376
(F-2.8318550803444604
F-2.247240213247446
tp7377
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p7378
(F-1.0201153755187988
F-1.8849581204927885
tp7379
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7380
(F-2.753541849427304
F-2.0157010005070615
tp7381
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7382
(F-2.7480919731987847
F-2.0904623178335338
tp7383
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192"
p7384
(F-2.031090611996858
F-1.87157469529372
tp7385
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)"
p7386
(F-2.32229731633113
F-2.4081877194918118
tp7387
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7388
(F-2.4812753677368162
F-2.0112254802997294
tp7389
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7390
(F-2.9194559313587307
F-2.011462871844952
tp7391
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)"
p7392
(F-1.733924184526716
F-2.4620414147010217
tp7393
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)"
p7394
(F-1.5740013122558594
F-1.933004379272461
tp7395
sS'import urllib'
p7396
(F-2.2557106018066406
F-1.9166425558236928
tp7397
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break"
p7398
(F-2.396944717622139
F-2.154552459716797
tp7399
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0"
p7400
(F-2.488733656862949
F-2.1438868596003604
tp7401
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7402
(F-1.8726440179543418
F-1.9147940415602465
tp7403
sS'print status,'
p7404
(F-4.544485855102539
F-2.21823604290302
tp7405
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7406
(F-1.7759222177358773
F-1.9081827310415416
tp7407
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)"
p7408
(F-2.189609130859375
F-1.9623316251314604
tp7409
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)"
p7410
(F-2.6199420635516826
F-2.0560581500713644
tp7411
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break"
p7412
(F-2.534974839952257
F-2.1536941528320312
tp7413
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7414
(F-2.0260823567708335
F-1.9136384817270131
tp7415
sS'u = urllib2.urlopen(url)'
p7416
(F-1.6599090576171875
F-1.7796997657189002
tp7417
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7418
(F-2.4021506603853204
F-2.0903678307166467
tp7419
sS"if not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7420
(F-2.923108281315984
F-1.994394302368164
tp7421
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)"
p7422
(F-1.9365229797363281
F-2.2386399782620945
tp7423
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7424
(F-1.592880407969157
F-1.8679879995492787
tp7425
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7426
(F-2.4638838334517046
F-1.9837545248178334
tp7427
sS'for data in tqdm(response.iter_content()):\n    handle.write(data)'
p7428
(F-1.8554986572265626
F-2.025890350341797
tp7429
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7430
(F-2.3128077841212606
F-1.9416891244741588
tp7431
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7432
(F-2.8049424978402944
F-2.533110105074369
tp7433
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7434
(F-2.6360586281590814
F-2.013346892136794
tp7435
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0"
p7436
(F-1.8975815191501524
F-1.931818888737605
tp7437
sS'if not buffer:\n    break\nfile_size_dl += len(buffer)'
p7438
(F-2.882285890125093
F-2.0669874044565053
tp7439
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7440
(F-1.4697338342666626
F-1.8197411757249098
tp7441
sS"status = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7442
(F-3.3404885864257814
F-1.8982026026799128
tp7443
sS"status = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7444
(F-3.104965564816497
F-2.004924774169922
tp7445
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7446
(F-1.5334041819852942
F-1.7867061908428485
tp7447
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)"
p7448
(F-2.3809965530244432
F-2.0542086087740383
tp7449
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7450
(F-2.1070672740106997
F-1.827736341036283
tp7451
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7452
(F-2.861008504231771
F-1.9661659827599158
tp7453
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7454
(F-2.7285655628551138
F-2.0192181513859677
tp7455
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)'
p7456
(F-2.9095875133167612
F-2.0651218707744894
tp7457
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break'
p7458
(F-2.7731727041849275
F-2.0684339083158054
tp7459
sS'response = requests.get(url, stream=True)'
p7460
(F-1.1228652681623186
F-1.8167459047757661
tp7461
sS'print len(r.content)'
p7462
(F-2.4301976097954645
F-2.1734583928034854
tp7463
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7464
(F-2.551841140638852
F-2.0158392099233775
tp7465
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7466
(F-2.377594695694145
F-1.9584456223707933
tp7467
sS"import urllib\nurllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p7468
(F-0.6521509610689603
F-1.5713891249436598
tp7469
sS"url = 'http://download.thinkbroadband.com/10MB.zip'"
p7470
(F-2.0243417739868166
F-2.234604762150691
tp7471
sS'from tqdm import tqdm'
p7472
(F-3.721408208211263
F-2.7660587017352762
tp7473
sS"if not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7474
(F-2.742923927307129
F-1.9891505608191857
tp7475
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)"
p7476
(F-2.4746880880216273
F-2.0634403228759766
tp7477
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7478
(F-2.3283218212341996
F-1.9492916694054236
tp7479
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192"
p7480
(F-2.112314224243164
F-1.8815457270695612
tp7481
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7482
(F-2.5133743286132812
F-2.1971731919508715
tp7483
sS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7484
(F-1.3700395885266756
F-1.985521756685697
tp7485
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7486
(F-2.354010278052026
F-1.94811278123122
tp7487
sS"f.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7488
(F-3.061918029785156
F-2.0060094686654897
tp7489
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0"
p7490
(F-2.13158201559996
F-2.14580198434683
tp7491
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7492
(F-2.3290116593644425
F-1.9139480590820312
tp7493
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7494
(F-2.815490077918684
F-1.9304973895733173
tp7495
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7496
(F-1.955048828125
F-1.9025402069091797
tp7497
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7498
(F-0.9050119490850539
F-1.7072818462665265
tp7499
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)"
p7500
(F-1.9103041826668432
F-1.9285146273099458
tp7501
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7502
(F-2.0970743161822676
F-1.944923107440655
tp7503
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7504
(F-2.175378279252486
F-1.9653348189133863
tp7505
sS"with open('10MB', 'wb') as handle:\n    pass"
p7506
(F-1.0851242542266846
F-2.295737780057467
tp7507
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7508
(F-1.2986109116498161
F-1.782857161301833
tp7509
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7510
(F-2.532079881237399
F-2.1035393934983473
tp7511
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192"
p7512
(F-2.907954624720982
F-2.010384339552659
tp7513
sS"f.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7514
(F-3.0872260199652777
F-2.0068145165076623
tp7515
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass'
p7516
(F-2.7565404380240093
F-2.0823282095102162
tp7517
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass"
p7518
(F-2.555914190751088
F-2.1585220923790565
tp7519
sS'if not buffer:\n    break'
p7520
(F-2.3182701110839843
F-2.643844017615685
tp7521
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]"
p7522
(F-1.24535784514054
F-2.0324601393479567
tp7523
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7524
(F-1.2094375255496004
F-1.7820591559776893
tp7525
sS'handle.write(data)'
p7526
(F-2.6703648567199707
F-1.9967858241154597
tp7527
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0"
p7528
(F-2.2991086786443535
F-2.1399368873009315
tp7529
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7530
(F-2.6428225117345012
F-2.010730890127329
tp7531
sS'import urllib2'
p7532
(F-2.711165428161621
F-1.7976479163536658
tp7533
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7534
(F-2.338072735330333
F-1.9533896813025842
tp7535
sS"status = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7536
(F-3.118001734956782
F-2.0065703758826623
tp7537
sS'while True:\n    buffer = u.read(block_sz)'
p7538
(F-2.801414065890842
F-2.3528977907620945
tp7539
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7540
(F-2.2975160647661257
F-1.9262792147122896
tp7541
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)'
p7542
(F-2.8181818448580227
F-1.9878601661095252
tp7543
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)"
p7544
(F-2.6206339518229167
F-2.0600967407226562
tp7545
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)"
p7546
(F-2.0981930819424717
F-1.9090662736159105
tp7547
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)"
p7548
(F-2.3367082075639205
F-1.9357951237605169
tp7549
sS'f.write(buffer)'
p7550
(F-2.6088833808898926
F-2.177203105046199
tp7551
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)"
p7552
(F-1.6425054102768133
F-1.8954671713022084
tp7553
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7554
(F-2.7317876983107183
F-2.0164174299973707
tp7555
sS'status = status + chr(8) * (len(status) + 1)'
p7556
(F-2.986745934737356
F-2.722850506122296
tp7557
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]"
p7558
(F-1.3233419418334962
F-2.3083251072810245
tp7559
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192"
p7560
(F-2.314659641213613
F-1.829724825345553
tp7561
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192"
p7562
(F-1.9901603297183388
F-1.8137209965632513
tp7563
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7564
(F-1.438936710357666
F-1.76792966402494
tp7565
sS"f.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7566
(F-2.828577931722005
F-2.0041690239539514
tp7567
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass'
p7568
(F-2.923335531483526
F-1.8808420621431792
tp7569
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7570
(F-3.0335608849158655
F-1.9318649585430439
tp7571
sS'meta = u.info()'
p7572
(F-3.70021480984158
F-2.710875291090745
tp7573
sS"file_size = int(meta.getheaders('Content-Length')[0])"
p7574
(F-2.3896217346191406
F-2.363207303560697
tp7575
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7576
(F-3.005012637279073
F-1.9307669126070464
tp7577
sS'status = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()'
p7578
(F-2.5948154844086746
F-2.471852522629958
tp7579
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p7580
(F-1.1253256364302202
F-1.9309957944429839
tp7581
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0"
p7582
(F-1.7850067481566012
F-1.8580093383789062
tp7583
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7584
(F-2.796661376953125
F-1.9319597390981822
tp7585
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7586
(F-2.1928940761236495
F-1.866204628577599
tp7587
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7588
(F-1.4765647362018455
F-1.8007787557748647
tp7589
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)"
p7590
(F-1.6787171975160255
F-1.972654049213116
tp7591
sS"while True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7592
(F-2.7084743853696844
F-2.0241464468149037
tp7593
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7594
(F-2.212781132878484
F-2.1781475360576925
tp7595
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)"
p7596
(F-2.128136450006056
F-1.9516497391920824
tp7597
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7598
(F-2.562283875512295
F-2.0627640944260817
tp7599
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7600
(F-1.7267126603560015
F-1.8710335951585035
tp7601
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7602
(F-1.0574349297417536
F-1.833921872652494
tp7603
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7604
(F-2.343145073784722
F-1.920190957876352
tp7605
sS'buffer = u.read(block_sz)'
p7606
(F-3.672764460245768
F-2.354635091928335
tp7607
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7608
(F-2.9832568501317223
F-1.8644720224233775
tp7609
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7610
(F-2.5077196756998696
F-2.05342043363131
tp7611
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass'
p7612
(F-2.8196711684718276
F-2.261384670551007
tp7613
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0"
p7614
(F-1.8223227567450946
F-1.920713864839994
tp7615
sS'file_size_dl = 0\nblock_sz = 8192'
p7616
(F-3.9352574666341145
F-1.7895609048696666
tp7617
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0"
p7618
(F-2.1050622874292833
F-2.106077927809495
tp7619
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass"
p7620
(F-2.0414056293034957
F-1.9889058333176832
tp7621
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7622
(F-2.2693328058532396
F-1.9102266751802885
tp7623
sS"response = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p7624
(F-1.0310821533203125
F-1.8104201096754808
tp7625
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p7626
(F-0.7825651168823242
F-1.7194747924804688
tp7627
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break"
p7628
(F-2.0476185426873674
F-1.9781139080341046
tp7629
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7630
(F-1.4291082715231276
F-1.7900390625
tp7631
sS'r = requests.get(url)'
p7632
(F-1.1017162322998046
F-1.8712516197791467
tp7633
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7634
(F-2.4480690137874443
F-1.9370306455172026
tp7635
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p7636
(F-0.9425202941894532
F-1.780751448411208
tp7637
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7638
(F-1.252401065826416
F-1.8618257962740385
tp7639
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7640
(F-2.303435099059047
F-1.9151587853064904
tp7641
sS"print 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7642
(F-2.668797175089518
F-1.9766318981464093
tp7643
sS'while True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)'
p7644
(F-2.7122519643683183
F-2.1190220759465146
tp7645
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p7646
(F-3.1362109184265137
F-1.9670298649714544
tp7647
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7648
(F-2.775680986422937
F-2.00629028907189
tp7649
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)"
p7650
(F-1.7527923583984375
F-1.985539509699895
tp7651
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192"
p7652
(F-2.538365681966146
F-2.0290226569542518
tp7653
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7654
(F-2.117276808794807
F-1.954123276930589
tp7655
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7656
(F-2.522474043208397
F-1.9409496600811298
tp7657
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7658
(F-2.4320130080319524
F-2.0548095703125
tp7659
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break"
p7660
(F-2.1119007311369242
F-1.9916924696702223
tp7661
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0"
p7662
(F-2.068171714668843
F-1.8726249107947717
tp7663
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7664
(F-1.2810316467285157
F-1.8045912522536058
tp7665
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7666
(F-2.5481421546598453
F-1.9839553833007812
tp7667
sS'file_size_dl += len(buffer)'
p7668
(F-3.3473838170369468
F-1.8746354029728816
tp7669
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7670
(F-2.6208291090171754
F-2.022106464092548
tp7671
sS"file_name = url.split('/')[-1]"
p7672
(F-1.4447516202926636
F-2.4447606893686147
tp7673
sS"response = urllib2.urlopen('http://www.example.com/')"
p7674
(F-1.1713945388793945
F-1.7897999103252704
tp7675
sS'file_size_dl = 0'
p7676
(F-3.1142874823676214
F-1.8421077728271484
tp7677
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break"
p7678
(F-2.0160429142723397
F-1.9238640711857722
tp7679
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break"
p7680
(F-2.262667877505524
F-1.9637835575984075
tp7681
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7682
(F-2.32354736328125
F-2.067135737492488
tp7683
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7684
(F-1.156396405450229
F-1.7175364861121545
tp7685
sS'status = status + chr(8) * (len(status) + 1)\nprint status,'
p7686
(F-3.067013947860054
F-2.707740490253155
tp7687
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7688
(F-1.9752181480670798
F-1.7514856778658354
tp7689
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7690
(F-1.5486859541672926
F-1.8820146413949819
tp7691
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7692
(F-2.7370968380489864
F-1.9718648470365083
tp7693
sS"status = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,\nf.close()"
p7694
(F-2.8250948348135316
F-1.995272709773137
tp7695
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7696
(F-2.845842115949876
F-1.9761789762056792
tp7697
sS"file_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)\nprint status,"
p7698
(F-2.4027605378225947
F-1.9571609497070312
tp7699
sS'r = requests.get(url)\nprint len(r.content)'
p7700
(F-1.2034956614176433
F-1.9302488473745494
tp7701
sS'block_sz = 8192'
p7702
(F-5.937100001743862
F-1.9991645812988281
tp7703
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)"
p7704
(F-2.244889831542969
F-1.9176100217379057
tp7705
sS'html = response.read()'
p7706
(F-1.7073304918077257
F-2.0626326340895433
tp7707
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[-1]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7708
(F-1.9201273501498028
F-1.8452890836275542
tp7709
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7710
(F-1.0052311155531142
F-1.6550750732421875
tp7711
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    break"
p7712
(F-2.3066507975260415
F-2.1298823723426232
tp7713
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p7714
(F-3.337853113810221
F-2.1538587716909556
tp7715
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint 'Downloading: %s Bytes: %s' % (file_name, file_size)\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif not buffer:\n    pass"
p7716
(F-2.2991931491427953
F-2.141489762526292
tp7717
sS'while True:\n    pass'
p7718
(F-1.686407936943902
F-2.587802300086388
tp7719
sS'block_sz = 8192\nwhile True:\n    pass'
p7720
(F-3.2769541422526043
F-2.119842235858624
tp7721
sS'file_size_dl += len(buffer)\nf.write(buffer)'
p7722
(F-2.9610722190455387
F-1.8856101402869592
tp7723
sS"if not buffer:\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = '%10d  [%3.2f%%]' % (file_size_dl, file_size_dl * 100.0 / file_size)\nstatus = status + chr(8) * (len(status) + 1)"
p7724
(F-2.9000767299107144
F-1.9945137317364032
tp7725
ssI11709079
(dp7726
S'from bs4 import BeautifulSoup'
p7727
(F-1.2262581416538783
F-1.1007957458496094
tp7728
sS"parsed_html = BeautifulSoup(html)\nprint parsed_html.body.find('div', attrs={'class': 'container'}).text"
p7729
(F-1.5324599526145242
F-1.2587186495463054
tp7730
sS'pq = PyQuery(html)'
p7731
(F-3.9733314514160156
F-1.317841370900472
tp7732
sS"pq('div#mw-head.noprint')"
p7733
(F-3.347841262817383
F-1.6030723253885906
tp7734
sS"from BeautifulSoup import BeautifulSoup\npage = urllib2.urlopen('http://www.google.com/')\nsoup = BeautifulSoup(page)"
p7735
(F-0.9432579040527344
F-1.165056308110555
tp7736
sS"import urllib2\nfrom BeautifulSoup import BeautifulSoup\npage = urllib2.urlopen('http://www.google.com/')\nsoup = BeautifulSoup(page)"
p7737
(F-0.9274522917611259
F-1.194528579711914
tp7738
sS"pq = PyQuery(html)\ntag = pq('div#class')\nprint tag.text()"
p7739
(F-3.0094793568486753
F-1.1458323796590169
tp7740
sS"from BeautifulSoup import BeautifulSoup\npage = urllib2.urlopen('http://www.google.com/')"
p7741
(F-1.0618623845717485
F-1.1642833550771077
tp7742
sS"from BeautifulSoup import BeautifulSoup\npage = urllib2.urlopen('http://www.google.com/')\nsoup = BeautifulSoup(page)\nx = soup.body.find('div', attrs={'class': 'container'}).text"
p7743
(F-1.0676293580428413
F-1.191361427307129
tp7744
sS"tag = pq('div#class')"
p7745
(F-2.8758392333984375
F-1.3894481658935547
tp7746
sS"import urllib2\nfrom BeautifulSoup import BeautifulSoup\npage = urllib2.urlopen('http://www.google.com/')\nsoup = BeautifulSoup(page)\nx = soup.body.find('div', attrs={'class': 'container'}).text"
p7747
(F-1.0561937604631697
F-1.204816738764445
tp7748
sS"page = urllib2.urlopen('http://www.google.com/')"
p7749
(F-1.4450338363647461
F-1.3621913592020671
tp7750
sS"print parsed_html.body.find('div', attrs={'class': 'container'}).text"
p7751
(F-1.6865318961765454
F-1.2608389854431152
tp7752
sS'try:\n    from BeautifulSoup import BeautifulSoup\nexcept ImportError:\n    pass'
p7753
(F-0.7251928936351429
F-1.3107763926188152
tp7754
sS'import urllib2'
p7755
(F-2.8565351963043213
F-1.7695733706156414
tp7756
sS"x = soup.body.find('div', attrs={'class': 'container'}).text"
p7757
(F-1.4753873998468572
F-1.297521432240804
tp7758
sS'import urllib2\nfrom BeautifulSoup import BeautifulSoup'
p7759
(F-1.2386417388916016
F-1.2170217831929524
tp7760
sS'from BeautifulSoup import BeautifulSoup'
p7761
(F-1.2194466590881348
F-1.19284454981486
tp7762
sS"soup = BeautifulSoup(page)\nx = soup.body.find('div', attrs={'class': 'container'}).text"
p7763
(F-1.2244305928548178
F-1.3010649681091309
tp7764
sS'print tag.text()'
p7765
(F-2.4906563758850098
F-1.3593683242797852
tp7766
sS"tag = pq('div#class')\nprint tag.text()"
p7767
(F-2.419891611735026
F-1.3592634201049805
tp7768
sS"page = urllib2.urlopen('http://www.google.com/')\nsoup = BeautifulSoup(page)\nx = soup.body.find('div', attrs={'class': 'container'}).text"
p7769
(F-1.1999100905198317
F-1.2700293064117432
tp7770
sS'soup = BeautifulSoup(page)'
p7771
(F-1.2437667846679688
F-1.2896697521209717
tp7772
sS"page = urllib2.urlopen('http://www.google.com/')\nsoup = BeautifulSoup(page)"
p7773
(F-1.1546885172526042
F-1.2490320205688477
tp7774
sS"import urllib2\nfrom BeautifulSoup import BeautifulSoup\npage = urllib2.urlopen('http://www.google.com/')"
p7775
(F-1.0371149063110352
F-1.2174650033315022
tp7776
sS'from pyquery import PyQuery'
p7777
(F-3.8328685760498047
F-2.114607810974121
tp7778
sS'try:\n    from BeautifulSoup import BeautifulSoup\nexcept ImportError:\n    from bs4 import BeautifulSoup'
p7779
(F-0.8803715339073768
F-1.0951499144236247
tp7780
sS'parsed_html = BeautifulSoup(html)'
p7781
(F-2.0214148434725674
F-1.2723716894785564
tp7782
sS"pq = PyQuery(html)\ntag = pq('div#class')"
p7783
(F-3.469942569732666
F-1.2000049750010173
tp7784
ssI739993
(dp7785
S"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in\n    installed_packages])"
p7786
(F-3.4959622646899935
F-2.946850095476423
tp7787
sS'import pip\ninstalled_packages = pip.get_installed_distributions()'
p7788
(F-3.648487514919705
F-2.7799154009137834
tp7789
sS"'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3'"
p7790
(F-1.702210956149631
F-3.2218265533447266
tp7791
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.\n    get_installed_distributions()])\nimport os\nos.getcwd()"
p7792
(F-2.997769843207465
F-2.7708031790597096
tp7793
sS'docutils == 0.7'
p7794
(F-5.65276870727539
F-3.1919032505580356
tp7795
sS'iterpipes == 0.4'
p7796
(F-5.675545120239258
F-3.5857271466936385
tp7797
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.\n    get_installed_distributions()])\nimport os\nos.getcwd()"
p7798
(F-3.0074898856026784
F-2.9836807250976562
tp7799
sS"['behave==1.2.4', 'enum34==1.0', 'flask==0.10.1', 'itsdangerous==0.24',\n    'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3',\n    'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2',\n    'requests==2.3.0', 'six==1.6.1', 'vioozer-metadata==0.1',\n    'vioozer-users-server==0.1', 'werkzeug==0.9.4']"
p7800
(F-0.8293408124874799
F-3.1494478498186385
tp7801
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.\n    get_installed_distributions()])"
p7802
(F-3.2581796357125947
F-3.037395477294922
tp7803
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.\n    get_installed_distributions()])\nimport os"
p7804
(F-3.382781199919872
F-2.7704061780657088
tp7805
sS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in\n    installed_packages])\nprint installed_packages_list"
p7806
(F-3.507244444729989
F-2.838378361293248
tp7807
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.\n    get_installed_distributions()])\nimport os"
p7808
(F-3.410498301188151
F-3.0079896109444753
tp7809
sS"'requests==2.3.0', 'six==1.6.1', 'vioozer-metadata==0.1'"
p7810
(F-2.056211199079241
F-3.2095974513462613
tp7811
sS"'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3'\n'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2'"
p7812
(F-1.419027328491211
F-3.2458692278180803
tp7813
sS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in\n    installed_packages])"
p7814
(F-3.46534912109375
F-2.8415892464773997
tp7815
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.\n    get_installed_distributions()])"
p7816
(F-3.281947453816732
F-2.762486594063895
tp7817
sS"'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2'\n'requests==2.3.0', 'six==1.6.1', 'vioozer-metadata==0.1'"
p7818
(F-1.6502336355356069
F-3.2401425497872487
tp7819
sS'import os'
p7820
(F-1.888146996498108
F-2.9939983912876675
tp7821
sS'os.getcwd()'
p7822
(F-1.179847036089216
F-2.8877244676862444
tp7823
sS'cd / tmp'
p7824
(F-7.315264892578125
F-2.922410692487444
tp7825
sS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in\n    installed_packages])\nprint installed_packages_list"
p7826
(F-3.552387378833912
F-2.9334479740687778
tp7827
sS"help('modules')"
p7828
(F-2.420262654622396
F-2.958074297223772
tp7829
sS'print installed_packages_list'
p7830
(F-4.887651443481445
F-2.885798863002232
tp7831
sS'import pip'
p7832
(F-3.8264737129211426
F-2.9381400517054965
tp7833
sS"'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3'\n'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2'\n'requests==2.3.0', 'six==1.6.1', 'vioozer-metadata==0.1'"
p7834
(F-1.217730930873326
F-3.261277879987444
tp7835
sS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in\n    installed_packages])\nprint installed_packages_list"
p7836
(F-3.7135692596435548
F-3.0883917127336775
tp7837
sS'import os\nos.getcwd()'
p7838
(F-0.9201997756958008
F-2.9030979701450894
tp7839
sS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in\n    installed_packages])"
p7840
(F-3.5604960123697915
F-3.141864231654576
tp7841
sS'installed_packages = pip.get_installed_distributions()'
p7842
(F-3.8049138387044272
F-2.852715628487723
tp7843
sS"'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2'"
p7844
(F-2.056211199079241
F-3.2095974513462613
tp7845
ssI9210525
(dp7846
S"s = '6a48f82d8e828ce82b82'"
p7847
(F-1.7794689178466796
F-1.9687528610229492
tp7848
sS"ast.literal_eval('0xdeadbeef')"
p7849
(F-1.2594941139221192
F-1.9650354385375977
tp7850
sS"int('FFFF', 16)"
p7851
(F-1.7270069122314453
F-1.831973393758138
tp7852
sS'str(i)'
p7853
(F-1.9972543716430664
F-1.8980857531229656
tp7854
sS"int('0xff', 16)"
p7855
(F-1.7270069122314453
F-1.831973393758138
tp7856
sS"int('deadbeef', 16)"
p7857
(F-1.7270069122314453
F-1.831973393758138
tp7858
sS'i = int(s, 16)'
p7859
(F-2.285019874572754
F-1.7747500737508137
tp7860
ssI6797984
(dp7861
S"raw_input('Type Something').lower()"
p7862
(F-1.015161116917928
F-1.9950662092729048
tp7863
sS"s = 'Kilometer'"
p7864
(F-1.7379865646362305
F-1.658652045510032
tp7865
sS"print s.lower()\nprint s.decode('utf-8').lower()"
p7866
(F-1.5376265525817872
F-1.6456520774147727
tp7867
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'"
p7868
(F-1.7379865646362305
F-1.658652045510032
tp7869
sS"s = 'Kilometer'\nprint s.lower()"
p7870
(F-0.97869340578715
F-1.6218556490811435
tp7871
sS"print s.decode('utf-8').lower()"
p7872
(F-1.4727679032545824
F-1.644019213589755
tp7873
sS'print s.lower()'
p7874
(F-1.6320778131484985
F-1.6207382895729758
tp7875
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()\nprint s.decode('utf-8').lower()"
p7876
(F-1.074817180633545
F-1.6395374644886365
tp7877
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()"
p7878
(F-0.97869340578715
F-1.6218556490811435
tp7879
ssI1207457
(dp7880
S'import codecs'
p7881
(F-2.9894890785217285
F-2.2985448837280273
tp7882
sS"type(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7883
(F-2.041775703430176
F-2.411247968673706
tp7884
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')"
p7885
(F-1.8047041642038446
F-2.4278950691223145
tp7886
sS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7887
(F-1.5497389793395997
F-2.3374412059783936
tp7888
sS"title = (\n    u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe')\nimport unicodedata"
p7889
(F-3.640970403497869
F-2.5430288314819336
tp7890
sS'f.write(my_unicode_string)'
p7891
(F-2.2652289072672525
F-2.457530975341797
tp7892
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)"
p7893
(F-2.087605667114258
F-2.628112554550171
tp7894
sS"s = u'\\xa310'\ns.encode('utf8')\ns.encode('utf16')"
p7895
(F-0.9465814891614412
F-2.3984646797180176
tp7896
sS"f = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p7897
(F-1.350520477294922
F-2.4164741039276123
tp7898
sS"s = u'\\xa310'"
p7899
(F-1.785472297668457
F-2.4288482666015625
tp7900
sS'import unicodedata\nunicodedata.normalize(\'NFKD\', title).encode(\'ascii\', \'ignore\')\n"""Kluft skrams infor pa federal electoral groe"""'
p7901
(F-1.7442366860129617
F-2.3377020359039307
tp7902
sS"s.encode('utf16')"
p7903
(F-1.19740891456604
F-2.4006028175354004
tp7904
sS"a.encode('ascii', 'ignore')"
p7905
(F-1.5889772415161132
F-2.394054889678955
tp7906
sS"s.encode('utf8')"
p7907
(F-1.19740891456604
F-2.4006028175354004
tp7908
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'"
p7909
(F-2.1822052001953125
F-2.52089786529541
tp7910
sS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')"
p7911
(F-1.0532403833725874
F-2.3252527713775635
tp7912
sS'type(a)'
p7913
(F-2.951030731201172
F-2.8725547790527344
tp7914
sS"title = (\n    u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe')\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7915
(F-2.013924492730035
F-2.3488783836364746
tp7916
sS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p7917
(F-1.2895758492606026
F-2.366342067718506
tp7918
sS'"""Kluft skrams infor pa federal electoral groe"""'
p7919
(F-1.6351006825764973
F-2.5346269607543945
tp7920
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7921
(F-1.699723516191755
F-2.412047863006592
tp7922
sS"a.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7923
(F-1.6218841954281455
F-2.409836769104004
tp7924
sS"s.encode('utf8')\ns.encode('utf16')"
p7925
(F-1.2068895975748697
F-2.414534091949463
tp7926
sS"title = (\n    u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe')"
p7927
(F-3.349370002746582
F-2.8895981311798096
tp7928
sS'import unicodedata'
p7929
(F-3.2762527465820312
F-2.518125295639038
tp7930
sS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7931
(F-1.4790538339053882
F-2.349161386489868
tp7932
sS'unicodedata.normalize(\'NFKD\', title).encode(\'ascii\', \'ignore\')\n"""Kluft skrams infor pa federal electoral groe"""'
p7933
(F-1.7524369892321134
F-2.3491406440734863
tp7934
sS"f = codecs.open('path/to/file.txt', 'w', 'utf8')"
p7935
(F-1.0065597806658064
F-2.3792948722839355
tp7936
sS"a.encode('ascii', 'replace')"
p7937
(F-1.5889772415161132
F-2.394054889678955
tp7938
sS"type(a)\na.encode('ascii', 'ignore')"
p7939
(F-2.264870198567708
F-2.432239055633545
tp7940
sS'title = (\n    u\'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe\')\nimport unicodedata\nunicodedata.normalize(\'NFKD\', title).encode(\'ascii\', \'ignore\')\n"""Kluft skrams infor pa federal electoral groe"""'
p7941
(F-2.1037604233314253
F-2.349832057952881
tp7942
sS"s = u'\\xa310'\ns.encode('utf8')"
p7943
(F-1.031479279200236
F-2.385331630706787
tp7944
ssI3294889
(dp7945
S"print '{0} corresponds to {1}'.format(letter, number)"
p7946
(F-2.5371851487593218
F-3.329947280883789
tp7947
sS'for key, value in d.items():\n    pass'
p7948
(F-0.8222210267010857
F-2.4254985809326173
tp7949
sS'd.keys()'
p7950
(F-2.1858062744140625
F-2.5489994049072267
tp7951
sS'for key in d:\n    pass'
p7952
(F-1.5379141027277166
F-2.474312400817871
tp7953
sS'for k, v in d.items():\n    pass\n'
p7954
(F-0.8012551139382755
F-2.401537322998047
tp7955
sS'pass'
p7956
(F-3.457665125528971
F-3.3546062469482423
tp7957
sS"print k, 'corresponds to', v"
p7958
(F-2.67795991897583
F-2.7523759841918944
tp7959
sS'd.items()'
p7960
(F-2.2331455775669644
F-2.5934438705444336
tp7961
sS"print letter, 'corresponds to', number"
p7962
(F-4.147624969482422
F-3.1782854080200194
tp7963
sS'for letter, number in d.items():\n    pass'
p7964
(F-1.6954494925106274
F-2.574233818054199
tp7965
sS'list(d)'
p7966
(F-2.1621004740397134
F-2.63281307220459
tp7967
sS'for k, v in d.items():\n    pass'
p7968
(F-0.8012550578397863
F-2.401537322998047
tp7969
sS'for key, value in d.iteritems():\n    pass'
p7970
(F-0.9139149048749138
F-2.3985286712646485
tp7971
sS"d = {'x': 1, 'y': 2, 'z': 3}\nlist(d)\nd.keys()"
p7972
(F-1.4058373314993722
F-2.469997215270996
tp7973
sS"d = {'x': 1, 'y': 2, 'z': 3}\nlist(d)"
p7974
(F-1.2432314265858044
F-2.5417505264282227
tp7975
sS"d = {'x': 1, 'y': 2, 'z': 3}"
p7976
(F-1.0128925547880285
F-2.640669059753418
tp7977
sS'list(d)\nd.keys()'
p7978
(F-2.39339288075765
F-2.4584796905517576
tp7979
sS'for letter, number in d.items():\n    pass\n'
p7980
(F-1.6954494925106274
F-2.574233818054199
tp7981
ssI7571635
(dp7982
S"print 'Not found'"
p7983
(F-2.2214953899383545
F-2.3584445073054385
tp7984
sS"print 'found'"
p7985
(F-2.2214953899383545
F-2.3584445073054385
tp7986
sS"index = dict((y, x) for x, y in enumerate(a))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7987
(F-1.4729008224775206
F-1.7783653552715595
tp7988
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict((y, x) for x, y in enumerate(a))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7989
(F-1.4770669376148897
F-1.7718872657189002
tp7990
sS'a = [4, 2, 3, 1, 5, 6]\nindex = dict((y, x) for x, y in enumerate(a))'
p7991
(F-1.5652199822503168
F-1.842572725736178
tp7992
sS"index = dict((y, x) for x, y in enumerate(a))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7993
(F-1.6866651746961805
F-1.7926065004788911
tp7994
sS'index = dict((y, x) for x, y in enumerate(a))'
p7995
(F-1.702371324811663
F-1.8662156325120192
tp7996
sS'a = [4, 2, 3, 1, 5, 6]\nindex = dict((y, x) for x, y in enumerate(a))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7997
(F-1.6137911478678386
F-1.7869628025935247
tp7998
sS"a = [1, 2, 3, 4, 'a', 'b', 'c']"
p7999
(F-1.8034107810572575
F-1.8934467022235577
tp8000
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p8001
(F-1.5272300720214844
F-1.854456094595102
tp8002
sS'a_index = index[7]'
p8003
(F-3.3624221801757814
F-1.8994032052847056
tp8004
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p8005
(F-1.2189150723544033
F-1.889488513653095
tp8006
sS'a = [4, 2, 3, 1, 5, 6]'
p8007
(F-1.5246363247142118
F-1.9091802743765025
tp8008
sS"a = [1, 2, 3, 4, 'a', 'b', 'c']\nreturn 'a' in a"
p8009
(F-1.8081761995951335
F-1.881746585552509
tp8010
sS'index = dict((y, x) for x, y in enumerate(a))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p8011
(F-1.7504884546453303
F-1.7932466360238881
tp8012
sS'try:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p8013
(F-1.6404836972554524
F-1.8374164287860577
tp8014
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict((y, x) for x, y in enumerate(a))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p8015
(F-1.4165565380151721
F-1.772623795729417
tp8016
sS"index = dict((y, x) for x, y in enumerate(a))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p8017
(F-1.5527298267071064
F-1.7775336045485277
tp8018
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p8019
(F-1.3480507135391235
F-1.8740548353928785
tp8020
sS"return 'a' in a"
p8021
(F-2.465974489847819
F-2.075951943030724
tp8022
sS'7 in a'
p8023
(F-5.18980712890625
F-1.8613357543945312
tp8024
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict((y, x) for x, y in enumerate(a))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p8025
(F-1.570951618132044
F-1.7868724236121545
tp8026
ssI1093322
(dp8027
S"import sys\nsys.hexversion\n'%x' % sys.hexversion\nsys.hexversion < 33947648"
p8028
(F-3.302371597290039
F-2.5056561787923175
tp8029
sS'import sys'
p8030
(F-2.283298969268799
F-2.3886344909667967
tp8031
sS"import sys\nsys.hexversion\n'%x' % sys.hexversion"
p8032
(F-3.04888916015625
F-2.4610249837239584
tp8033
sS"'%x' % sys.hexversion"
p8034
(F-2.9982030051095143
F-2.50368169148763
tp8035
sS'sys.hexversion < 33947648'
p8036
(F-2.8442925044468472
F-2.5477137247721355
tp8037
sS'sys.version_info'
p8038
(F-2.6395974840436662
F-2.42579828898112
tp8039
sS'print sys.version'
p8040
(F-2.587594509124756
F-2.325230916341146
tp8041
sS'sys.version_info\nsys.hexversion'
p8042
(F-3.1553258028897373
F-2.451923624674479
tp8043
sS"'%x' % sys.hexversion\nsys.hexversion < 33947648"
p8044
(F-3.407704573411208
F-2.530777994791667
tp8045
sS'assert sys.version_info >= (2, 5)'
p8046
(F-3.095339366367885
F-2.4819714864095053
tp8047
sS"sys.hexversion\n'%x' % sys.hexversion\nsys.hexversion < 33947648"
p8048
(F-3.8702015596277572
F-2.5500284830729165
tp8049
sS'python - V'
p8050
(F-4.408729934692383
F-2.3681851704915364
tp8051
sS"sys.hexversion\n'%x' % sys.hexversion"
p8052
(F-3.8398978493430396
F-2.512465413411458
tp8053
sS'import sys\nsys.hexversion'
p8054
(F-2.1367714405059814
F-2.473863220214844
tp8055
sS'sys.hexversion'
p8056
(F-2.796639251708984
F-2.537000528971354
tp8057
ssI5618878
(dp8058
S"list1 = ['1', '2', '3']"
p8059
(F-1.1863197846846147
F-1.745423674583435
tp8060
sS"list1 = ['1', '2', '3']\nstr1 = ''.join(list1)"
p8061
(F-1.0715723037719727
F-1.4860951900482178
tp8062
sS"L = ['L', 'O', 'L']\nmakeitastring = ''.join(map(str, L))"
p8063
(F-1.0303421783447266
F-1.450240135192871
tp8064
sS'L = [1, 2, 3]\n""" """.join(str(x) for x in L)\n"""1 2 3"""'
p8065
(F-1.3791622585720487
F-1.464901328086853
tp8066
sS'""" """.join(str(x) for x in L)\n"""1 2 3"""'
p8067
(F-1.4324374479406021
F-1.3748528957366943
tp8068
sS'L = [1, 2, 3]'
p8069
(F-1.6840811642733486
F-1.9227955341339111
tp8070
sS'L = [1, 2, 3]\n""" """.join(str(x) for x in L)'
p8071
(F-1.2718500518798828
F-1.4539456367492676
tp8072
sS"str1 = ''.join(str(e) for e in list1)"
p8073
(F-1.8575612236471737
F-1.3201125860214233
tp8074
sS"str1 = ''.join(list1)"
p8075
(F-1.8082599639892578
F-1.3487025499343872
tp8076
sS'""" """.join(str(x) for x in L)'
p8077
(F-1.105324935913086
F-1.3390402793884277
tp8078
sS"makeitastring = ''.join(map(str, L))"
p8079
(F-1.2621846516927084
F-1.373748540878296
tp8080
sS"list1 = [1, 2, 3]\nstr1 = ''.join(str(e) for e in list1)"
p8081
(F-1.6565167462384258
F-1.459618091583252
tp8082
sS'list1 = [1, 2, 3]'
p8083
(F-1.6301885084672407
F-1.789074182510376
tp8084
sS"L = ['L', 'O', 'L']"
p8085
(F-1.1921795064752752
F-1.7779550552368164
tp8086
sS'"""1 2 3"""'
p8087
(F-2.2207860946655273
F-1.986802339553833
tp8088
ssI3277503
(dp8089
S'array.append(line)'
p8090
(F-2.5035181045532227
F-2.5942530314127605
tp8091
sS"with open('filename') as f:\n    lines = f.readlines()"
p8092
(F-0.5483620643615723
F-2.1819636027018228
tp8093
sS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    pass"
p8094
(F-1.4588312609442349
F-2.246959940592448
tp8095
sS'with open(fname) as f:\n    pass'
p8096
(F-1.269927978515625
F-2.2379414876302084
tp8097
sS"with open('file.txt', 'r') as ins:\n    pass"
p8098
(F-1.2910014390945435
F-2.2536524454752604
tp8099
sS"with open('file.txt', 'r') as ins:\n    array = []"
p8100
(F-1.3596641138980263
F-2.246563212076823
tp8101
sS'for line in ins:\n    array.append(line)'
p8102
(F-1.6696406602859497
F-2.4237548828125
tp8103
sS'array = []'
p8104
(F-2.744347254435221
F-2.9130869547526044
tp8105
sS'lines = f.readlines()'
p8106
(F-1.2014789581298828
F-2.192889404296875
tp8107
sS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    array.append(line)"
p8108
(F-1.3716313979204964
F-2.2520042419433595
tp8109
sS'content = f.readlines()'
p8110
(F-1.4568203820122614
F-2.284251403808594
tp8111
sS'with open(fname) as f:\n    content = f.readlines()'
p8112
(F-0.9775502204895019
F-2.217412312825521
tp8113
sS"lines = [line.rstrip('\\n') for line in open('filename')]"
p8114
(F-0.8057186729029605
F-2.1547940572102866
tp8115
sS'for line in ins:\n    pass'
p8116
(F-1.982278130271218
F-2.423553721110026
tp8117
sS"with open('filename') as f:\n    pass"
p8118
(F-0.8426543644496373
F-2.236891174316406
tp8119
ssI5844672
(dp8120
S'def removekey(d, key):\n    r = dict(d)\ndel r[key]\nreturn r'
p8121
(F-2.0332021713256836
F-2.0290937423706055
tp8122
sS'a'
p8123
(F-5.089674313863118
F-2.2486379146575928
tp8124
sS'del d[key]'
p8125
(F-1.8058253696986608
F-1.9221036434173584
tp8126
sS'del r[key]\nreturn r'
p8127
(F-3.287616729736328
F-1.9454896450042725
tp8128
sS'a\n{i: a[i] for i in a if i != 0}'
p8129
(F-2.097091484069824
F-2.0990772247314453
tp8130
sS'def removekey(d, key):\n    pass'
p8131
(F-1.4531745910644531
F-2.1784276962280273
tp8132
sS'return r'
p8133
(F-5.114720344543457
F-2.5702884197235107
tp8134
sS'def removekey(d, key):\n    r = dict(d)'
p8135
(F-1.553803895649157
F-2.1011745929718018
tp8136
sS'"""gdbye"""'
p8137
(F-3.11063543955485
F-2.720749616622925
tp8138
sS'def removekey(d, key):\n    r = dict(d)\ndel r[key]'
p8139
(F-1.900284423828125
F-2.0444369316101074
tp8140
sS'del r[key]'
p8141
(F-2.534814017159598
F-1.889359712600708
tp8142
sS'{}'
p8143
(F-2.343679189682007
F-2.1555891036987305
tp8144
sS'r = dict(d)'
p8145
(F-2.2944393157958984
F-2.1106646060943604
tp8146
sS'{i: a[i] for i in a if i != 0}'
p8147
(F-1.57720947265625
F-2.110565185546875
tp8148
ssI3940128
(dp8149
S'array = [0, 10, 20, 40]'
p8150
(F-2.1076683631310096
F-1.4541247974742542
tp8151
sS'L = [0, 10, 20, 40]\nL.reverse()\nL'
p8152
(F-1.906574975876581
F-1.0954341888427734
tp8153
sS'array = [0, 10, 20, 40]\nfor i in reversed(array):\n    pass'
p8154
(F-1.649424332838792
F-1.2670331434770064
tp8155
sS'L = [0, 10, 20, 40]\nL.reverse()'
p8156
(F-1.8517962004009045
F-1.1128543506969104
tp8157
sS'L[::-1]'
p8158
(F-1.7206482357449002
F-1.1494114615700461
tp8159
sS'for i in reversed(array):\n    pass'
p8160
(F-1.5537520817347936
F-1.1466381766579368
tp8161
sS'print i'
p8162
(F-2.9553542137145996
F-1.4479537443681196
tp8163
sS'array = [0, 10, 20, 40]\nfor i in reversed(array):\n    pass\n'
p8164
(F-1.6494246262770433
F-1.2670331434770064
tp8165
sS'L'
p8166
(F-4.395052591959636
F-1.1100344224409624
tp8167
sS'L = [0, 10, 20, 40]'
p8168
(F-1.9545496427095854
F-1.1320415843616833
tp8169
sS'for i in reversed(array):\n    pass\n'
p8170
(F-1.5537520817347936
F-1.1466381766579368
tp8171
sS'L.reverse()\nL'
p8172
(F-2.771307203504774
F-1.1964865597811611
tp8173
sS'L.reverse()'
p8174
(F-2.3809890747070312
F-1.2767994620583274
tp8175
sS'L = [0, 10, 20, 40]\nL[::-1]'
p8176
(F-1.6027147202264695
F-1.1386354619806462
tp8177
ssI16296643
(dp8178
S'if clicked[0] == 1:\n    x = (mousey + cameraY) // 60\ny = (mousex + cameraX) // 60'
p8179
(F-2.71087384223938
F-3.712264060974121
tp8180
sS"t = 'my', 'name', 'is', 'mr', 'tuple'\nt"
p8181
(F-2.438574727376302
F-3.500868797302246
tp8182
sS"l = ['my', 'name', 'is', 'mr', 'list']\nl\ntuple(l)"
p8183
(F-1.4607247439297764
F-2.9155807495117188
tp8184
sS'x = (mousey + cameraY) // 60'
p8185
(F-2.531744523481889
F-3.23577618598938
tp8186
sS'tuple(itertools.imap(tuple, edited))'
p8187
(F-3.337251516488882
F-3.0211782455444336
tp8188
sS'map(list, level)'
p8189
(F-2.5162367820739746
F-3.1150050163269043
tp8190
sS'l\ntuple(l)'
p8191
(F-3.091269016265869
F-2.906909465789795
tp8192
sS"l = ['my', 'name', 'is', 'mr', 'list']"
p8193
(F-0.9249804814656576
F-3.14825177192688
tp8194
sS'tuple(tuple(i) for i in edited)'
p8195
(F-2.814776200514573
F-2.8995819091796875
tp8196
sS'a[x][y] = 1'
p8197
(F-1.9745507673783735
F-3.0453171730041504
tp8198
sS'level1 = [list(row) for row in level1]'
p8199
(F-3.034048080444336
F-3.1820547580718994
tp8200
sS'a = numpy.array(level1)'
p8201
(F-3.84210090637207
F-3.4631872177124023
tp8202
sS'if clicked[0] == 1:\n    x = (mousey + cameraY) // 60'
p8203
(F-2.726726531982422
F-3.726558208465576
tp8204
sS'y = (mousex + cameraX) // 60\na[x][y] = 1'
p8205
(F-2.3377242315383184
F-3.1394519805908203
tp8206
sS'a = numpy.array(level1)\na'
p8207
(F-3.8558168411254883
F-3.432215690612793
tp8208
sS'level1 = map(list, level1)'
p8209
(F-3.826394271850586
F-3.215916156768799
tp8210
sS't\nlist(t)'
p8211
(F-3.5317702293395996
F-3.089334011077881
tp8212
sS'tuple(l)'
p8213
(F-2.0109175046284995
F-2.858506202697754
tp8214
sS'if clicked[0] == 1:\n    x = (mousey + cameraY) // 60\ny = (mousex + cameraX) // 60\na[x][y] = 1'
p8215
(F-2.5645479474748885
F-3.5991101264953613
tp8216
sS"l = ['my', 'name', 'is', 'mr', 'list']\nl"
p8217
(F-1.2142060223747702
F-3.123567581176758
tp8218
sg8123
(F-4.332961718241374
F-3.3198800086975098
tp8219
sS'list(t)'
p8220
(F-2.297905921936035
F-3.07650089263916
tp8221
sS'[list(i) for i in level]'
p8222
(F-2.053884506225586
F-3.0867748260498047
tp8223
sS"t = 'my', 'name', 'is', 'mr', 'tuple'"
p8224
(F-2.1055002946120043
F-3.5160412788391113
tp8225
sS"t = 'my', 'name', 'is', 'mr', 'tuple'\nt\nlist(t)"
p8226
(F-2.5370052337646483
F-3.2501749992370605
tp8227
sS'l'
p8228
(F-4.361416816711426
F-3.12996244430542
tp8229
sS'if clicked[0] == 1:\n    pass'
p8230
(F-2.357219968523298
F-3.9380483627319336
tp8231
sg6942
(F-4.952042897542317
F-3.3808884620666504
tp8232
sS'y = (mousex + cameraX) // 60'
p8233
(F-2.6925527399236504
F-3.380654811859131
tp8234
ssI4004550
(dp8235
S'floats = map(float, s.split())'
p8236
(F-2.0683901650565013
F-2.417180824279785
tp8237
sS"s = '5.2 5.6 5.3'"
p8238
(F-2.3388208389282226
F-2.9519691467285156
tp8239
sS'floats = [float(x) for x in s.split()]'
p8240
(F-1.3008066813151042
F-2.4279243469238283
tp8241
sS"s = '5.2 5.6 5.3'\nfloats = [float(x) for x in s.split()]"
p8242
(F-1.254020864313299
F-2.435380554199219
tp8243
ssI10543303
(dp8244
S'j = [4, 5, 6, 7, 1, 3, 7, 5]'
p8245
(F-1.7867108299618675
F-2.4485497107872596
tp8246
sS'len([(1) for i in j if i > 5])'
p8247
(F-2.2031256357828775
F-2.3373344127948465
tp8248
sS'import numpy as np\nj = np.array(j)\nsum(j > i)'
p8249
(F-2.3226682489568535
F-2.8822523263784556
tp8250
sS'j = np.array(j)'
p8251
(F-2.5830785751342775
F-2.9861385638897238
tp8252
sS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nlen([(1) for i in j if i > 5])'
p8253
(F-1.9968821876927425
F-2.364031571608323
tp8254
sS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nsum(i > 5 for i in j)'
p8255
(F-1.790570616722107
F-2.278395726130559
tp8256
sS'sum(i > 5 for i in j)'
p8257
(F-2.0706728299458823
F-2.135391822228065
tp8258
sS'import numpy as np\nj = np.array(j)'
p8259
(F-2.1897097269694012
F-2.981709993802584
tp8260
sS'j = np.array(j)\nsum(j > i)'
p8261
(F-2.5599872364717373
F-2.8562918442946215
tp8262
sS'import numpy as np'
p8263
(F-2.2320405642191568
F-2.9288148146409254
tp8264
sS'issubclass(bool, int)'
p8265
(F-3.682056188583374
F-2.4894444392277646
tp8266
sS'sum(j > i)'
p8267
(F-2.909712791442871
F-2.2202848287729116
tp8268
ssI674764
(dp8269
S"str.find('s', 11)\nstr.find('s', 15)"
p8270
(F-2.6139299493086967
F-3.512329339981079
tp8271
sS"str.find('g')\nstr.find('s', 11)\nstr.find('s', 15)\nstr.find('s', 16)\nstr.find('s', 11, 14)"
p8272
(F-2.6753639552904214
F-3.500959873199463
tp8273
sS"str = 'abcdefioshgoihgs sijsiojs '\nstr.find('a')\nstr.find('g')\nstr.find('s', 11)\nstr.find('s', 15)\nstr.find('s', 16)\nstr.find('s', 11, 14)"
p8274
(F-2.534124809398986
F-3.5130953788757324
tp8275
sS"str.find('a')\nstr.find('g')\nstr.find('s', 11)\nstr.find('s', 15)\nstr.find('s', 16)"
p8276
(F-2.480822063627697
F-3.5582468509674072
tp8277
sS"x.find('World')"
p8278
(F-1.783406138420105
F-3.535849094390869
tp8279
sS"str.find('a')\nstr.find('g')\nstr.find('s', 11)\nstr.find('s', 15)"
p8280
(F-2.477237585819129
F-3.563021183013916
tp8281
sS"x = 'Hello World'\nx.find('World')\nx.find('Aloha')"
p8282
(F-1.6682019484670538
F-3.5623106956481934
tp8283
sS"str.find('g')\nstr.find('s', 11)\nstr.find('s', 15)\nstr.find('s', 16)"
p8284
(F-2.5473181588309153
F-3.5390660762786865
tp8285
sS"str = 'abcdefioshgoihgs sijsiojs '\nstr.find('a')\nstr.find('g')\nstr.find('s', 11)\nstr.find('s', 15)"
p8286
(F-2.388107712204392
F-3.5553112030029297
tp8287
sS"str.find('s', 16)\nstr.find('s', 11, 14)"
p8288
(F-2.7394717988513766
F-3.48642897605896
tp8289
sS"x = 'Hello World'"
p8290
(F-2.1451587677001953
F-3.6261816024780273
tp8291
sS"x = 'Hello World'\nx.find('World')"
p8292
(F-1.7657105127970378
F-3.5235438346862793
tp8293
sS'"""sdfasdf""".index(\'cc\')'
p8294
(F-2.160980224609375
F-3.63350248336792
tp8295
sS"x.find('Aloha')"
p8296
(F-1.783406138420105
F-3.535849094390869
tp8297
sS"str.find('g')\nstr.find('s', 11)\nstr.find('s', 15)"
p8298
(F-2.562519366924579
F-3.5417003631591797
tp8299
sS"str = 'abcdefioshgoihgs sijsiojs '\nstr.find('a')\nstr.find('g')\nstr.find('s', 11)"
p8300
(F-2.2547055653163364
F-3.542950391769409
tp8301
sS"str.find('s', 16)"
p8302
(F-2.245631217956543
F-3.5362846851348877
tp8303
sS"str.find('a')\nstr.find('g')"
p8304
(F-2.0129168192545572
F-3.558098316192627
tp8305
sS"x.find('World')\nx.find('Aloha')"
p8306
(F-1.7510505676269532
F-3.573275327682495
tp8307
sS"str.find('s', 11)\nstr.find('s', 15)\nstr.find('s', 16)"
p8308
(F-2.575434820992606
F-3.5134100914001465
tp8309
sS"str.find('s', 15)\nstr.find('s', 16)\nstr.find('s', 11, 14)"
p8310
(F-2.7210459391276043
F-3.48459529876709
tp8311
sS"str = 'abcdefioshgoihgs sijsiojs '\nstr.find('a')\nstr.find('g')"
p8312
(F-1.9952099448756169
F-3.5408132076263428
tp8313
sS"str = 'abcdefioshgoihgs sijsiojs '\nstr.find('a')\nstr.find('g')\nstr.find('s', 11)\nstr.find('s', 15)\nstr.find('s', 16)"
p8314
(F-2.402275914731233
F-3.551743984222412
tp8315
sS"str.find('g')\nstr.find('s', 11)"
p8316
(F-2.3992358936983
F-3.5301616191864014
tp8317
sS"str.find('a')"
p8318
(F-1.7808759212493896
F-3.5200424194335938
tp8319
sS"str.find('a')\nstr.find('g')\nstr.find('s', 11)"
p8320
(F-2.3339964548746743
F-3.5537028312683105
tp8321
sS"str.find('s', 15)\nstr.find('s', 16)"
p8322
(F-2.518463134765625
F-3.5328826904296875
tp8323
sS"str = 'abcdefioshgoihgs sijsiojs '\nstr.find('a')"
p8324
(F-2.006023089090983
F-3.5040736198425293
tp8325
sS"str.find('a')\nstr.find('g')\nstr.find('s', 11)\nstr.find('s', 15)\nstr.find('s', 16)\nstr.find('s', 11, 14)"
p8326
(F-2.6084401832436614
F-3.5174381732940674
tp8327
sS'"""sdfasdf""".index(\'cc\')\n"""sdfasdf""".index(\'df\')'
p8328
(F-2.558899688720703
F-3.61584734916687
tp8329
sS"str.find('s', 11)"
p8330
(F-2.381806755065918
F-3.4986698627471924
tp8331
sS"str.find('s', 11, 14)"
p8332
(F-2.817368825276693
F-3.4760122299194336
tp8333
sS"str.find('s', 15)"
p8334
(F-2.4762807846069337
F-3.534982204437256
tp8335
sS'"""sdfasdf""".index(\'df\')'
p8336
(F-2.160980224609375
F-3.63350248336792
tp8337
sS"str = 'abcdefioshgoihgs sijsiojs '"
p8338
(F-2.0521888732910156
F-3.5690419673919678
tp8339
sS"str.find('s', 11)\nstr.find('s', 15)\nstr.find('s', 16)\nstr.find('s', 11, 14)"
p8340
(F-2.711012424566807
F-3.4801290035247803
tp8341
sS"str.find('g')"
p8342
(F-1.7808759212493896
F-3.5200424194335938
tp8343
ssI432842
(dp8344
S'bool(a) != bool(b)'
p8345
(F-1.9772141196511008
F-2.215831756591797
tp8346
sS'def logical_xor(str1, str2):\n    pass'
p8347
(F-2.6028480529785156
F-2.4398841857910156
tp8348
sS'return bool(str1) ^ bool(str2)'
p8349
(F-2.916356404622396
F-2.3289286295572915
tp8350
sS'def logical_xor(str1, str2):\n    return bool(str1) ^ bool(str2)'
p8351
(F-2.5273837280273437
F-2.3777033487955728
tp8352
sS'from operator import xor\nxor(bool(a), bool(b))'
p8353
(F-1.860430265727796
F-2.2595006306966146
tp8354
sS'xor(bool(a), bool(b))'
p8355
(F-1.6984624862670898
F-2.244140116373698
tp8356
sS'bool(a) ^ bool(b)'
p8357
(F-2.1699059226296167
F-2.1999415079752604
tp8358
sS'a and not b or not a and b'
p8359
(F-3.4342471036044033
F-2.548975626627604
tp8360
sS'from operator import xor'
p8361
(F-2.6688194274902344
F-2.357543436686198
tp8362
ssI1303243
(dp8363
S'isinstance(o, str)'
p8364
(F-2.531040668487549
F-1.9033374786376953
tp8365
sS'isinstance(obj_to_test, str)'
p8366
(F-3.0758050282796225
F-1.9997877393450056
tp8367
sS'isinstance(o, basestring)'
p8368
(F-3.17317533493042
F-1.894873891557966
tp8369
sS'type(o) is str'
p8370
(F-4.491647720336914
F-1.998098918369838
tp8371
ssI163542
(dp8372
S'p.stdin.close()'
p8373
(F-1.071595933702257
F-2.8598084222702753
tp8374
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p8375
(F-0.6808609239982836
F-2.593109130859375
tp8376
sS'p.stdin.write("""one\ntwo\nthree\nfour\nfive\nsix\n""")\np.communicate()[0]\np.stdin.close()'
p8377
(F-0.9674918563277634
F-2.828188214983259
tp8378
sS'print grep_stdout.decode()'
p8379
(F-3.7899829864501955
F-2.799105689639137
tp8380
sS'p = Popen([\'grep\', \'f\'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input="""one\ntwo\nthree\nfour\nfive\nsix\n""")[0]\nprint grep_stdout.decode()'
p8381
(F-1.7661786760602678
F-2.7098595755440846
tp8382
sS'p = Popen([\'grep\', \'f\'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input="""one\ntwo\nthree\nfour\nfive\nsix\n""")[0]'
p8383
(F-1.4172672271728515
F-2.6850916544596353
tp8384
sS'p.stdin.write("""one\ntwo\nthree\nfour\nfive\nsix\n""")\np.communicate()[0]'
p8385
(F-0.8869521492405942
F-2.7978441147577193
tp8386
sS'p.stdin.write("""one\ntwo\nthree\nfour\nfive\nsix\n""")'
p8387
(F-0.8860485076904296
F-2.8797073364257812
tp8388
sS'from subprocess import Popen, PIPE, STDOUT'
p8389
(F-1.199163055419922
F-2.6315560113816034
tp8390
sS"pipe = os.popen(cmd, 'w', bufsize)\npipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin"
p8391
(F-2.3666761125837055
F-2.7287719363258
tp8392
sS'grep_stdout = p.communicate(input="""one\ntwo\nthree\nfour\nfive\nsix\n""")[0]'
p8393
(F-2.4075207429773666
F-2.866286141531808
tp8394
sS'p.communicate()[0]'
p8395
(F-1.0457250595092773
F-2.719219934372675
tp8396
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=\n    subprocess.PIPE)"
p8397
(F-1.0322237367983218
F-2.6363245646158853
tp8398
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p8399
(F-0.8066746393839518
F-2.629237583705357
tp8400
sS"pipe = os.popen(cmd, 'w', bufsize)"
p8401
(F-2.5618384225027904
F-2.7190135774158297
tp8402
sS'from subprocess import Popen, PIPE, STDOUT\np = Popen([\'grep\', \'f\'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input="""one\ntwo\nthree\nfour\nfive\nsix\n""")[0]'
p8403
(F-1.2247829048001035
F-2.647129240490141
tp8404
sS'p = subprocess.Popen([\'grep\', \'f\'], stdout=subprocess.PIPE, stdin=\n    subprocess.PIPE)\np.stdin.write("""one\ntwo\nthree\nfour\nfive\nsix\n""")\np.communicate()[0]\np.stdin.close()'
p8405
(F-0.8586381156489534
F-2.716346195765904
tp8406
sS'from subprocess import Popen, PIPE, STDOUT\np = Popen([\'grep\', \'f\'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input="""one\ntwo\nthree\nfour\nfive\nsix\n""")[0]\nprint grep_stdout.decode()'
p8407
(F-1.546868686018319
F-2.6634617760067893
tp8408
sS'grep_stdout = p.communicate(input="""one\ntwo\nthree\nfour\nfive\nsix\n""")[0]\nprint grep_stdout.decode()'
p8409
(F-2.7070538447453427
F-2.8301734924316406
tp8410
sS'p.communicate()[0]\np.stdin.close()'
p8411
(F-1.1704031626383464
F-2.7885774884905135
tp8412
sS'p = subprocess.Popen([\'grep\', \'f\'], stdout=subprocess.PIPE, stdin=\n    subprocess.PIPE)\np.stdin.write("""one\ntwo\nthree\nfour\nfive\nsix\n""")\np.communicate()[0]'
p8413
(F-0.8336393568250868
F-2.6812181018647694
tp8414
sS'pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin'
p8415
(F-2.267473567615856
F-2.77889651343936
tp8416
sS'p = subprocess.Popen([\'grep\', \'f\'], stdout=subprocess.PIPE, stdin=\n    subprocess.PIPE)\np.stdin.write("""one\ntwo\nthree\nfour\nfive\nsix\n""")'
p8417
(F-0.9581896464029948
F-2.701278323218936
tp8418
ssI11801309
(dp8419
S'for f in filenames:\n    pass\n'
p8420
(F-1.467530684037642
F-1.8601215362548829
tp8421
sS"for fn in os.listdir('.'):\n    if os.path.isfile(fn):\n        pass\n"
p8422
(F-0.8384979511129445
F-1.8883575439453124
tp8423
sS"fullpath = os.path.join(source, f)\nlog = open(fullpath, 'r')"
p8424
(F-1.9560390969981318
F-2.053938865661621
tp8425
sS"for fn in os.listdir('.'):\n    pass"
p8426
(F-1.1274724006652832
F-1.9020515441894532
tp8427
sS"import os\nfor fn in os.listdir('.'):\n    if os.path.isfile(fn):\n        pass"
p8428
(F-0.785163938999176
F-1.8663274765014648
tp8429
sS'if os.path.isfile(fn):\n    pass'
p8430
(F-1.2588627338409424
F-1.9452791213989258
tp8431
sS"source = '/home/test/py_test/'"
p8432
(F-2.7777633666992188
F-2.1953048706054688
tp8433
sS"source = '/home/test/py_test/'\nfor root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        print f\nfullpath = os.path.join(source, f)"
p8434
(F-1.3435127424157185
F-1.7944358825683593
tp8435
sS'print f'
p8436
(F-3.1243691444396973
F-2.2630636215209963
tp8437
sS"import os\nfor fn in os.listdir('.'):\n    pass"
p8438
(F-0.9982409226266962
F-1.878786849975586
tp8439
sS"source = '/home/test/py_test/'\nfor root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        pass"
p8440
(F-1.1986584663391113
F-1.7829736709594726
tp8441
sS"source = '/home/test/py_test/'\nfor root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        pass\n"
p8442
(F-1.1986584663391113
F-1.7829736709594726
tp8443
sS'if os.path.isfile(fn):\n    pass\n'
p8444
(F-1.2588627338409424
F-1.9452791213989258
tp8445
sS'for root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        pass'
p8446
(F-1.108569553920201
F-1.8327939987182618
tp8447
sS'for f in filenames:\n    pass'
p8448
(F-1.467530684037642
F-1.8601215362548829
tp8449
sS"log = open(fullpath, 'r')"
p8450
(F-2.4804975509643556
F-2.1773097991943358
tp8451
sS'print fn'
p8452
(F-3.4444007873535156
F-2.287989616394043
tp8453
sS'import os'
p8454
(F-2.225663661956787
F-2.0720476150512694
tp8455
sS"for fn in os.listdir('.'):\n    if os.path.isfile(fn):\n        pass"
p8456
(F-0.8384980826542295
F-1.8883575439453124
tp8457
sS"for root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        print f\nfullpath = os.path.join(source, f)\nlog = open(fullpath, 'r')"
p8458
(F-1.4884535845588236
F-1.8523303985595703
tp8459
sS"source = '/home/test/py_test/'\nfor root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        print f\nfullpath = os.path.join(source, f)\nlog = open(fullpath, 'r')"
p8460
(F-1.5127771550958806
F-1.8209037780761719
tp8461
sS"import os\nfor fn in os.listdir('.'):\n    if os.path.isfile(fn):\n        pass\n"
p8462
(F-0.7851639986038208
F-1.866327667236328
tp8463
sS"log = open(os.path.join(root, f), 'r')"
p8464
(F-1.2057173879523027
F-2.0681148529052735
tp8465
sS'fullpath = os.path.join(source, f)'
p8466
(F-1.7985239028930664
F-2.07736873626709
tp8467
sS"source = '/home/test/py_test/'\nfor root, dirs, filenames in os.walk(source):\n    pass"
p8468
(F-1.4275380770365398
F-1.8183097839355469
tp8469
sS'for root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        print f\nfullpath = os.path.join(source, f)'
p8470
(F-1.2909416925339472
F-1.8256959915161133
tp8471
sS'for root, dirs, filenames in os.walk(source):\n    for f in filenames:\n        pass\n'
p8472
(F-1.108569553920201
F-1.8327939987182618
tp8473
sS'for root, dirs, filenames in os.walk(source):\n    pass'
p8474
(F-1.3552027702331544
F-1.857900619506836
tp8475
ssI306400
(dp8476
S'second_random_item = list_of_random_items[1]'
p8477
(F-2.738365809122721
F-1.8216039021809896
tp8478
sS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p8479
(F-2.490213615949764
F-1.873206075032552
tp8480
sS'random_index = randrange(0, len(foo))\nprint foo[random_index]'
p8481
(F-2.4196702708368716
F-2.0204984029134114
tp8482
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p8483
(F-2.5897756548070197
F-1.9358762105305989
tp8484
sS'first_random_item = list_of_random_items[0]'
p8485
(F-2.4726108974880643
F-1.807641092936198
tp8486
sS'from random import randrange'
p8487
(F-2.0262791315714517
F-2.0332261403401692
tp8488
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8489
(F-2.48891848609561
F-1.921288299560547
tp8490
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8491
(F-2.4445934076418823
F-1.8935124715169271
tp8492
sS'print foo[random_index]'
p8493
(F-2.869266086154514
F-1.8735865275065104
tp8494
sS'first_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8495
(F-2.288444301060268
F-1.8208196004231771
tp8496
sS'import random'
p8497
(F-2.3951637744903564
F-1.987072499593099
tp8498
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p8499
(F-2.6753401846255898
F-1.9515763600667317
tp8500
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))"
p8501
(F-1.6308415356804342
F-1.9950944264729817
tp8502
sS"foo = ['a', 'b', 'c', 'd', 'e']"
p8503
(F-1.0311883290608723
F-2.121811930338542
tp8504
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p8505
(F-3.1467010498046877
F-2.231762440999349
tp8506
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p8507
(F-2.5331760951450892
F-1.901974868774414
tp8508
sS'group_of_items = {1, 2, 3, 4}'
p8509
(F-2.761500190286075
F-2.2429908752441405
tp8510
sS'list_of_random_items = random.sample(group_of_items, num_to_select)'
p8511
(F-2.6912750831017127
F-1.9025552113850912
tp8512
sS"foo = ['a', 'b', 'c', 'd', 'e']\nprint random.choice(foo)"
p8513
(F-0.8961189933445143
F-1.8250895182291667
tp8514
sS'num_to_select = 2'
p8515
(F-4.348435719807942
F-2.478346761067708
tp8516
sS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']\nprint random.choice(foo)"
p8517
(F-0.8225728548490084
F-1.8102770487467448
tp8518
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p8519
(F-2.9628347669328963
F-1.9575637817382812
tp8520
sS'from random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]'
p8521
(F-2.193220547267369
F-2.020435078938802
tp8522
sS'import random\ngroup_of_items = {1, 2, 3, 4}'
p8523
(F-2.5708818435668945
F-1.9463395436604818
tp8524
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p8525
(F-2.753077392578125
F-2.00811767578125
tp8526
sS'from random import randrange\nrandom_index = randrange(0, len(foo))'
p8527
(F-2.0563690185546877
F-2.0621412913004558
tp8528
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange"
p8529
(F-1.3214179039001466
F-2.00380490620931
tp8530
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]"
p8531
(F-1.7667483375186013
F-1.9739187876383464
tp8532
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8533
(F-2.4915010788861442
F-1.8957093556722004
tp8534
sS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']"
p8535
(F-0.9324359893798828
F-1.9340245564778646
tp8536
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p8537
(F-2.6292527142693016
F-1.9046983083089193
tp8538
sS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8539
(F-2.3822181701660154
F-1.8751089731852213
tp8540
sS'print random.choice(foo)'
p8541
(F-1.6458384195963542
F-1.8414037068684896
tp8542
sS'random_index = randrange(0, len(foo))'
p8543
(F-2.480182393391927
F-2.094227091471354
tp8544
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p8545
(F-2.8904185575597428
F-1.957404073079427
tp8546
ssI3996904
(dp8547
S'print random.randint(0, 9)'
p8548
(F-1.1397435448386453
F-3.3497782813178167
tp8549
sS'frand = uniform(0, 10)'
p8550
(F-2.078361701965332
F-3.5625873141818576
tp8551
sS'irand = randrange(0, 10)'
p8552
(F-1.961632537841797
F-3.3372266557481556
tp8553
sS'import random'
p8554
(F-2.312152862548828
F-3.771437750922309
tp8555
sS'import random\nprint random.randint(0, 9)'
p8556
(F-0.8711189542497907
F-3.417849858601888
tp8557
sS'from random import randrange, uniform'
p8558
(F-2.899790048599243
F-3.3261082967122397
tp8559
sS'from random import randint\nprint randint(0, 9)'
p8560
(F-1.4975933347429549
F-3.2929144965277777
tp8561
sS'from random import randrange, uniform\nirand = randrange(0, 10)'
p8562
(F-2.1625446992761947
F-3.2194930182562933
tp8563
sS'print randint(0, 9)'
p8564
(F-1.920289569430881
F-3.4779268900553384
tp8565
sS'from random import randint'
p8566
(F-1.4106537501017253
F-3.435646480984158
tp8567
sS'random.randint(a, b)'
p8568
(F-1.6757410049438477
F-3.3095503913031683
tp8569
sS'irand = randrange(0, 10)\nfrand = uniform(0, 10)'
p8570
(F-1.8848507529810856
F-3.2867579989963107
tp8571
sS'from random import randrange, uniform\nirand = randrange(0, 10)\nfrand = uniform(0, 10)'
p8572
(F-1.9677358774038463
F-3.21146731906467
tp8573
ssI627435
(dp8574
S'global index\na.pop(index)'
p8575
(F-3.170740994540128
F-1.7446380615234376
tp8576
sS'def __init__(self, items):\n    pass'
p8577
(F-1.559814691543579
F-2.1823074340820314
tp8578
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p8579
(F-1.3866222542776188
F-1.9366363525390624
tp8580
sS'def del_method():\n    global a'
p8581
(F-2.735347202845982
F-2.2260457356770833
tp8582
sS'a = range(10)\nindex = 3'
p8583
(F-2.400683561960856
F-1.8869491577148438
tp8584
sS'global index\na = a[:index] + a[index + 1:]'
p8585
(F-1.7272342681884765
F-1.6038626352945964
tp8586
sS'del a[index]'
p8587
(F-1.9601658412388392
F-1.5172752380371093
tp8588
sS'def slice_method():\n    global a\nglobal index\na = a[:index] + a[index + 1:]'
p8589
(F-2.350839788263494
F-1.8633110046386718
tp8590
sS'def del_method():\n    global a\nglobal index'
p8591
(F-3.277532689711627
F-2.2409622192382814
tp8592
sS'a\ndel a[-1]\na'
p8593
(F-2.675198237101237
F-1.5431629180908204
tp8594
sS'a.pop(index)'
p8595
(F-2.7391316890716553
F-1.5517640431722006
tp8596
sS'def pop_method():\n    pass'
p8597
(F-2.6168597294734073
F-2.0372835795084634
tp8598
sS'a.pop()'
p8599
(F-2.062490327017648
F-1.6380327860514323
tp8600
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])'
p8601
(F-1.2428943980823863
F-1.9260106404622397
tp8602
sS'return foo(self.items + right.items)'
p8603
(F-3.9224043626051683
F-2.0123074849446616
tp8604
sS'a = [1, 2, 3, 4, 5, 6]\nindex = 3'
p8605
(F-1.2546436673118955
F-1.6012786865234374
tp8606
sS'return foo(self.items[index])'
p8607
(F-2.801255544026693
F-2.0286149342854816
tp8608
sS'del a[-1]\na'
p8609
(F-2.5263835906982424
F-1.536358642578125
tp8610
sS'class foo(object):\n\n    def __init__(self, items):\n        pass'
p8611
(F-1.4025993347167969
F-2.0713040669759115
tp8612
sS'class foo(object):\n    pass'
p8613
(F-1.768606185913086
F-2.05438232421875
tp8614
sS'a = a[:index] + a[index + 1:]'
p8615
(F-1.425026164335363
F-1.5102799733479817
tp8616
sS'a = [1, 2, 3, 4, 5, 6]\nindex = 3\na = a[:index] + a[index + 1:]'
p8617
(F-1.0926804413666595
F-1.554333241780599
tp8618
sS"a = ['a', 'b', 'c', 'd']\na.pop(1)"
p8619
(F-1.1017501831054688
F-1.6516403198242187
tp8620
sS'def del_method():\n    pass'
p8621
(F-2.5533103942871094
F-2.090110015869141
tp8622
sS'a = range(10)\na'
p8623
(F-2.3303243637084963
F-1.9398574829101562
tp8624
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items'
p8625
(F-1.326159413655599
F-2.0574933369954427
tp8626
sS'a.pop(1)'
p8627
(F-1.9103145599365234
F-1.600842030843099
tp8628
sS'def slice_method():\n    global a\nglobal index'
p8629
(F-3.3738450443043426
F-2.0690231323242188
tp8630
sS'def slice_method():\n    global a'
p8631
(F-2.8831795283726285
F-2.0521244049072265
tp8632
sS'def pop_method():\n    global a'
p8633
(F-2.872023718697684
F-2.203815205891927
tp8634
sS'def del_method():\n    global a\nglobal index\ndel a[index]'
p8635
(F-2.7715117413064707
F-1.9381239573160807
tp8636
sS'a = range(10)\na\ndel a[-1]\na'
p8637
(F-2.2892769261410364
F-1.648361333211263
tp8638
sS'del a[-1]'
p8639
(F-1.9164272546768188
F-1.5354606628417968
tp8640
sS'a = range(10)'
p8641
(F-2.240096092224121
F-2.0006160736083984
tp8642
sS'self.items = items'
p8643
(F-3.205453327723912
F-2.0422993977864583
tp8644
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    pass'
p8645
(F-1.2047738614289656
F-1.919500732421875
tp8646
sS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo(self.items + right.items)'
p8647
(F-1.889848596909467
F-1.8486209869384767
tp8648
sS'def __init__(self, items):\n    self.items = items'
p8649
(F-1.3690056800842285
F-2.113859939575195
tp8650
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo(self.items + right.items)'
p8651
(F-1.5921029926818093
F-1.9348739624023437
tp8652
sS'def pop_method():\n    global a\nglobal index\na.pop(index)'
p8653
(F-3.169241269429525
F-2.011438496907552
tp8654
sg8123
(F-4.234402338663737
F-1.8629801432291666
tp8655
sS'index = 3'
p8656
(F-3.3455955505371096
F-1.673062515258789
tp8657
sS'global index\ndel a[index]'
p8658
(F-2.6216697692871094
F-1.6371358235677083
tp8659
sS'global index'
p8660
(F-4.178119659423828
F-2.0990464528401693
tp8661
sS'index = 3\na = a[:index] + a[index + 1:]'
p8662
(F-1.529219491141183
F-1.4948389689127604
tp8663
sS'def __getitem__(self, index):\n    return foo(self.items[index])'
p8664
(F-1.392185516357422
F-1.8517712910970052
tp8665
sS'def __add__(self, right):\n    pass'
p8666
(F-2.017019033432007
F-2.07091064453125
tp8667
sS"a = ['a', 'b', 'c', 'd']\na.pop()"
p8668
(F-1.0915286415501644
F-1.6708310445149739
tp8669
sS'def slice_method():\n    pass'
p8670
(F-2.6892943749061
F-1.9928916931152343
tp8671
sS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p8672
(F-1.6157550346560594
F-1.867923100789388
tp8673
sS'a\ndel a[-1]'
p8674
(F-2.452415657043457
F-1.5398953755696614
tp8675
sS"a = ['a', 'b', 'c', 'd']"
p8676
(F-0.9233883344210111
F-1.7653719584147136
tp8677
sS'def __add__(self, right):\n    return foo(self.items + right.items)'
p8678
(F-2.420460921067458
F-2.0350826263427733
tp8679
sS'def pop_method():\n    global a\nglobal index'
p8680
(F-3.3765151079963234
F-2.2360992431640625
tp8681
sS'global a'
p8682
(F-4.249904155731201
F-2.202739715576172
tp8683
sS'a = [1, 2, 3, 4, 5, 6]'
p8684
(F-0.9186982547535616
F-1.6287766774495442
tp8685
sS'def __getitem__(self, index):\n    pass'
p8686
(F-1.2680706977844238
F-1.8996180216471354
tp8687
sS'a = range(10)\na\ndel a[-1]'
p8688
(F-2.2318074843462776
F-1.6495468139648437
tp8689
ssI1773805
(dp8690
S"with open('example.yaml') as stream:\n    pass"
p8691
(F-1.218782697405134
F-2.016653234308416
tp8692
sS'print data == data_loaded'
p8693
(F-4.65142822265625
F-1.7711991396817295
tp8694
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8695
(F-1.9947620260304417
F-1.7623363841663708
tp8696
sS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint data == data_loaded"
p8697
(F-1.8065507411956787
F-1.7687617215243252
tp8698
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}"
p8699
(F-1.9926183064778646
F-1.8243425542658025
tp8700
sS"with open('example.yaml', 'r') as stream:\n    pass"
p8701
(F-0.8848865032196045
F-2.012708143754439
tp8702
sS'data_loaded = yaml.load(stream)'
p8703
(F-2.153308391571045
F-1.7976622147993608
tp8704
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8705
(F-1.694736827503551
F-1.8429778705943713
tp8706
sS"import yaml\nwith open('example.yaml', 'r') as stream:\n    pass"
p8707
(F-0.841676862616288
F-1.7235048467462712
tp8708
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8709
(F-1.1209691654552112
F-1.8806780034845525
tp8710
sS'print exc'
p8711
(F-5.205292701721191
F-1.885236913507635
tp8712
sS'import yaml'
p8713
(F-1.3250195980072021
F-1.8047863353382458
tp8714
sS"with open('data.yaml', 'r') as stream:\n    pass"
p8715
(F-0.8848863840103149
F-2.012708143754439
tp8716
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8717
(F-1.7826121316027286
F-1.7531925548206677
tp8718
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8719
(F-1.7870993566031408
F-1.8068844188343396
tp8720
sS'import ruamel.yaml as yaml'
p8721
(F-2.6058621406555176
F-1.9156735160134055
tp8722
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8723
(F-1.7935350206163194
F-1.7828870253129439
tp8724
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint data == data_loaded"
p8725
(F-1.9084748827721463
F-1.7230016534978694
tp8726
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint data == data_loaded"
p8727
(F-1.9157595427139946
F-1.778925288807262
tp8728
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8729
(F-1.788929454067297
F-1.72553166476163
tp8730
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8731
(F-2.02995974518532
F-1.7388850125399502
tp8732
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8733
(F-1.5813582889617435
F-1.8909832347523083
tp8734
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint data == data_loaded"
p8735
(F-1.9805955629091005
F-1.750911365855824
tp8736
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8737
(F-1.9127229478624133
F-1.7124439586292615
tp8738
sS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8739
(F-1.2301962280273437
F-1.771193417635831
tp8740
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8741
(F-1.6112923000169836
F-1.7278768366033381
tp8742
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}"
p8743
(F-1.8593730926513672
F-1.7255958210338245
tp8744
sS'yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)'
p8745
(F-2.693937301635742
F-1.898316123268821
tp8746
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8747
(F-1.8524220784505208
F-1.7848493402654475
tp8748
sS'import io'
p8749
(F-3.9113926887512207
F-1.968859932639382
tp8750
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8751
(F-1.8507126816758164
F-1.7633254311301492
tp8752
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}"
p8753
(F-1.8137842814127605
F-1.9178527485240588
tp8754
sS'print yaml.load(stream)'
p8755
(F-1.1568261252509222
F-1.6461387981068005
tp8756
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint data == data_loaded"
p8757
(F-1.969588974774894
F-1.7613093636252664
tp8758
sS'import yaml\nimport io'
p8759
(F-2.1789308275495256
F-1.7542979500510476
tp8760
sS"import ruamel.yaml as yaml\nwith open('example.yaml') as stream:\n    pass"
p8761
(F-1.5323718843005953
F-1.7033436515114524
tp8762
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8763
(F-1.9240065075102306
F-1.795293461192738
tp8764
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string':\n    'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42}}\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8765
(F-1.7857173374720983
F-1.7312545776367188
tp8766
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8767
(F-1.7782821655273438
F-1.7775076085870916
tp8768
ssI663171
(dp8769
S"x = 'Hello World!'"
p8770
(F-1.9242706298828125
F-1.6977650569035456
tp8771
sS'x[2:]\nx[:2]\nx[:-2]'
p8772
(F-2.1389087677001952
F-1.8433842292198768
tp8773
sS'x[:2]'
p8774
(F-2.2916578565325056
F-1.7692920978252704
tp8775
sS'x[:2]\nx[:-2]\nx[-2:]\nx[2:-2]'
p8776
(F-2.058532846385035
F-1.8709410153902495
tp8777
sS'x[-2:]'
p8778
(F-1.9216759204864502
F-1.778196774996244
tp8779
sS'x[2:]\nx[:2]'
p8780
(F-2.14568123450646
F-1.8081832298865685
tp8781
sS'x[:-2]'
p8782
(F-2.066974639892578
F-1.779629633976863
tp8783
sS'x[2:]\nx[:2]\nx[:-2]\nx[-2:]'
p8784
(F-2.0505338598180702
F-1.8701465313251202
tp8785
sS"x = 'Hello World!'\nx[2:]\nx[:2]"
p8786
(F-1.8687023836023666
F-1.6926316481370192
tp8787
sS'x[2:]'
p8788
(F-1.9465044566563197
F-1.772222372201773
tp8789
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:-2]\nx[-2:]\nx[2:-2]"
p8790
(F-1.9001994988857172
F-1.763214111328125
tp8791
sS'x[:2]\nx[:-2]\nx[-2:]'
p8792
(F-2.1117953345889138
F-1.8463558783897986
tp8793
sS's = Substr(s, beginning, LENGTH)'
p8794
(F-4.057669957478841
F-1.788188494168795
tp8795
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:-2]\nx[-2:]"
p8796
(F-1.8977770651540449
F-1.7447627140925481
tp8797
sS'x[:-2]\nx[-2:]'
p8798
(F-2.030079142252604
F-1.817440913273738
tp8799
sS"x = 'Hello World!'\nx[2:]"
p8800
(F-1.7749942432750354
F-1.6682866903451772
tp8801
sS'x[:2]\nx[:-2]'
p8802
(F-2.2430125645228793
F-1.8152439410869892
tp8803
sS'x[2:]\nx[:2]\nx[:-2]\nx[-2:]\nx[2:-2]'
p8804
(F-2.0140008108956473
F-1.8922821925236628
tp8805
sS'x[-2:]\nx[2:-2]'
p8806
(F-1.98121976852417
F-1.8169222611647387
tp8807
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:-2]"
p8808
(F-1.936665693918864
F-1.7219723921555738
tp8809
sS'x[:-2]\nx[-2:]\nx[2:-2]'
p8810
(F-2.0064509847889775
F-1.8456888932448168
tp8811
sS'some_string[::-1]'
p8812
(F-1.705592068758878
F-1.597753378061148
tp8813
sS'"""H-e-l-l-o- -W-o-r-l-d"""[::2]'
p8814
(F-1.8573973178863525
F-1.681186529306265
tp8815
sS'x[2:-2]'
p8816
(F-2.013810051812066
F-1.7920543964092548
tp8817
sS's = s[beginning:beginning + LENGTH]'
p8818
(F-4.712425867716472
F-1.6713245098407452
tp8819
ssI10406130
(dp8820
S'(2, 3) not in [(2, 3), (5, 6), (9, 1)]'
p8821
(F-1.7487446921212333
F-2.2453420956929526
tp8822
sS"(2, 3) not in [(2, 7), (7, 3), 'hi']"
p8823
(F-2.3774801890055337
F-2.217743714650472
tp8824
sS'3 not in [4, 5, 6]'
p8825
(F-2.8948116302490234
F-2.1072746912638345
tp8826
sS'3 not in [2, 3, 4]'
p8827
(F-2.829970359802246
F-2.129950205485026
tp8828
sS'3 not in [2, 3, 4]\n3 not in [4, 5, 6]'
p8829
(F-2.678736811098845
F-2.1452325185139975
tp8830
sS"(2, 3) not in [(2, 3), (5, 6), (9, 1)]\n(2, 3) not in [(2, 7), (7, 3), 'hi']"
p8831
(F-1.9873028923483456
F-2.2696119944254556
tp8832
ssI1185524
(dp8833
S'str.lstrip()'
p8834
(F-2.1588333674839566
F-4.032634041526101
tp8835
sS'str.strip()\nstr.lstrip()'
p8836
(F-2.3697804671067457
F-4.020099293101918
tp8837
sS"s = '   foo    \\t   '"
p8838
(F-1.7723785400390626
F-3.9567031860351562
tp8839
sS"s = s.strip(' \\t\\n\\r')"
p8840
(F-1.5120856285095214
F-3.929136796431108
tp8841
sS"print pat.sub('', s)"
p8842
(F-2.0791397094726562
F-3.9309512051669033
tp8843
sS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p8844
(F-1.0828293071073645
F-3.8588777021928267
tp8845
sS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8846
(F-1.3907788594563801
F-3.8688174161044033
tp8847
sS"import re\nprint re.sub('[\\\\s+]', '', s)"
p8848
(F-0.6554471254348755
F-3.8835574063387783
tp8849
sS"print re.sub('[\\\\s+]', '', s)"
p8850
(F-0.9523109289316031
F-3.882532986727628
tp8851
sS's = s.lstrip()'
p8852
(F-2.120327843560113
F-3.9431575428355825
tp8853
sS'str.strip()'
p8854
(F-1.635678427559989
F-3.976636366410689
tp8855
sS"pat = re.compile('\\\\s+')"
p8856
(F-1.1231844902038575
F-3.8698047291148794
tp8857
sS"s = '  \\t a string example\\t  '"
p8858
(F-1.7723785400390626
F-3.9567031860351562
tp8859
sS'str.rstrip()'
p8860
(F-1.7598357881818498
F-4.007338090376421
tp8861
sS'print s.strip()'
p8862
(F-1.8829210996627808
F-3.915366432883523
tp8863
sS'import re'
p8864
(F-2.129855155944824
F-3.8972240794788706
tp8865
sS'str.lstrip()\nstr.rstrip()'
p8866
(F-2.3570631467379055
F-4.021064411510121
tp8867
sS's = s.strip()'
p8868
(F-1.542364862230089
F-3.948953455144709
tp8869
sS"s = '   foo    \\t   '\nprint s.strip()"
p8870
(F-1.1822021007537842
F-3.9349601052024146
tp8871
sS"s = '  \\t a string example\\t  '\ns = s.strip()"
p8872
(F-1.105483128474309
F-3.958552273837003
tp8873
sS's = s.rstrip()'
p8874
(F-1.7781045701768663
F-3.9539229653098364
tp8875
sS'str.strip()\nstr.lstrip()\nstr.rstrip()'
p8876
(F-2.4097848189504525
F-4.01966025612571
tp8877
sS'astringexample'
p8878
(F-3.0476131439208984
F-4.163488214666193
tp8879
sS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8880
(F-1.099776444611726
F-3.865540244362571
tp8881
sS"s = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8882
(F-1.4277357737223306
F-3.9351022893732246
tp8883
sS"import re\npat = re.compile('\\\\s+')"
p8884
(F-0.8658847075242263
F-3.8636308149857954
tp8885
sS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p8886
(F-1.515852791922433
F-3.862187472256747
tp8887
sS"s = '  \\t  foo   \\t   bar \\t  '"
p8888
(F-1.7723785400390626
F-3.9567031860351562
tp8889
ssI354038
(dp8890
S"b = '963spam'\nb.isdigit()"
p8891
(F-2.0401332161643286
F-1.4724534352620442
tp8892
sS"a = '03523'\na.isdigit()\nb = '963spam'\nb.isdigit()"
p8893
(F-1.6688305082775297
F-1.4528877470228407
tp8894
sS'a.isdigit()'
p8895
(F-2.100008283342634
F-1.3969455295138888
tp8896
sS"a = '03523'"
p8897
(F-2.386769485473633
F-1.6881846321953669
tp8898
sS"a = '03523'\na.isdigit()\nb = '963spam'"
p8899
(F-1.854748789469401
F-1.4593101077609592
tp8900
sS"a.isdigit()\nb = '963spam'"
p8901
(F-2.3226021853360264
F-1.4366023805406358
tp8902
sS'b.isdigit()'
p8903
(F-2.3600191388811385
F-1.4355430603027344
tp8904
sS"b = '963spam'"
p8905
(F-2.81190185546875
F-1.7357415093315973
tp8906
sS"a.isdigit()\nb = '963spam'\nb.isdigit()"
p8907
(F-1.9336134966681986
F-1.4475413428412542
tp8908
sS"float('NaN')"
p8909
(F-1.9867285092671711
F-1.6191332075330946
tp8910
sS"a = '03523'\na.isdigit()"
p8911
(F-1.815169941295277
F-1.4307560390896268
tp8912
ssI2600191
(dp8913
S'[1, 2, 3, 4, 1, 4, 1].count(1)'
p8914
(F-1.6382631822065874
F-1.8346080780029297
tp8915
sS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]"
p8916
(F-1.4289956861926663
F-1.7823785146077473
tp8917
sS"l = ['a', 'b', 'b']"
p8918
(F-1.1417177373712712
F-2.0352479298909505
tp8919
sS"import timeit\nt1 = timeit.Timer('Counter(l)',\n    'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8920
(F-3.0982289468088458
F-2.2283838907877604
tp8921
sS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]\ndict((x, l.count(x)) for x in set(l))"
p8922
(F-1.6289043426513672
F-1.785075887044271
tp8923
sS'import timeit'
p8924
(F-4.328105449676514
F-2.0192766825358075
tp8925
sS"l.count('a')\nl.count('b')"
p8926
(F-2.121748606363932
F-1.842792002360026
tp8927
sS"t1 = timeit.Timer('Counter(l)',\n    'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )"
p8928
(F-3.208967481340681
F-2.273145294189453
tp8929
sS'from collections import Counter\nCounter(l)'
p8930
(F-1.4960275129838423
F-1.648778533935547
tp8931
sS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8932
(F-3.751985029740767
F-2.296494547526042
tp8933
sS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p8934
(F-1.384876533790871
F-1.6705636342366537
tp8935
sS'from collections import Counter'
p8936
(F-1.533199628194173
F-1.7148789723714193
tp8937
sS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p8938
(F-1.094056297751034
F-2.116773986816406
tp8939
sS"l = ['a', 'b', 'b']\nfrom collections import Counter"
p8940
(F-1.2487034797668457
F-1.7282511393229167
tp8941
sS'Counter(l)'
p8942
(F-2.6339457829793296
F-1.6815193176269532
tp8943
sS"import timeit\nt1 = timeit.Timer('Counter(l)',\n    'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )"
p8944
(F-2.7831621805826825
F-2.2391807556152346
tp8945
sS'[[x, l.count(x)] for x in set(l)]\ndict((x, l.count(x)) for x in set(l))'
p8946
(F-1.922980717250279
F-1.795013682047526
tp8947
sS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p8948
(F-1.4104836203835227
F-1.7244247436523437
tp8949
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8950
(F-3.470148213704427
F-2.2280555725097657
tp8951
sS"l.count('b')"
p8952
(F-2.4589121341705322
F-1.8166781107584635
tp8953
sS"l = ['a', 'b', 'b']\nl.count('a')"
p8954
(F-1.4647973378499348
F-1.7891979217529297
tp8955
sS"l.count('a')"
p8956
(F-2.4589121341705322
F-1.8166781107584635
tp8957
sS"import timeit\nt1 = timeit.Timer('Counter(l)',\n    'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8958
(F-3.0057369729746943
F-2.2425852457682294
tp8959
sS"t1 = timeit.Timer('Counter(l)',\n    'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8960
(F-3.18269555043366
F-2.265868631998698
tp8961
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )"
p8962
(F-3.336975642613002
F-2.179473368326823
tp8963
sS'"""import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]"""'
p8964
(F-2.8548192977905273
F-2.267609151204427
tp8965
sS"print 'count():   ', t2.repeat(repeat=3, number=10000)"
p8966
(F-3.9012307559742645
F-2.223302205403646
tp8967
sS"import timeit\nt1 = timeit.Timer('Counter(l)',\n    'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )"
p8968
(F-3.083765815286075
F-2.1842915852864584
tp8969
sS"l = ['a', 'b', 'b']\nl.count('a')\nl.count('b')"
p8970
(F-1.5039007568359375
F-1.8081851959228517
tp8971
sS"l = ['a', 'b', 'b']\nfrom collections import Counter\nCounter(l)"
p8972
(F-1.119936080206008
F-1.6609725952148438
tp8973
sS'[[x, l.count(x)] for x in set(l)]'
p8974
(F-1.8974131629580544
F-1.7823586781819662
tp8975
sS"t1 = timeit.Timer('Counter(l)',\n    'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )"
p8976
(F-2.88581876401548
F-2.302074940999349
tp8977
sS"t1 = timeit.Timer('Counter(l)',\n    'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8978
(F-3.100168982217478
F-2.2922943115234373
tp8979
sS'"""import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]"""'
p8980
(F-2.8548192977905273
F-2.267609151204427
tp8981
sS'Counter(z)'
p8982
(F-3.431149164835612
F-1.776583989461263
tp8983
sS'dict((x, l.count(x)) for x in set(l))'
p8984
(F-1.8117075833407315
F-1.8093935648600261
tp8985
sS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p8986
(F-1.1969507390802556
F-1.7501408894856771
tp8987
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]',\n    'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]'\n    )\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8988
(F-3.487462582795516
F-2.2366129557291665
tp8989
sS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8990
(F-3.8959323658662686
F-2.301047770182292
tp8991
ssI4940032
(dp8992
S"import mmap\nwith open('example.txt', 'rb', 0) as file:\n    with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n        if s.find('blabla') != -1:\n            pass\n"
p8993
(F-1.9274239078644784
F-2.20727899339464
tp8994
sS"if s.find('blabla') != -1:\n    pass"
p8995
(F-1.596402785357307
F-2.72202640109592
tp8996
sS'found = False\nfor line in datafile:\n    pass'
p8997
(F-1.845451863606771
F-2.12064446343316
tp8998
sS"with open('example.txt', 'rb', 0) as file:\n    pass"
p8999
(F-1.2769748899671767
F-2.1814918518066406
tp9000
sS'for line in datafile:\n    pass'
p9001
(F-1.8840248801491477
F-2.1830743153889975
tp9002
sS'if check():\n    pass\n'
p9003
(F-2.3937388333407315
F-2.899738311767578
tp9004
sS'if check():\n    pass'
p9005
(F-2.3937388333407315
F-2.899738311767578
tp9006
sS"import mmap\nf = open('example.txt')\ns = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)"
p9007
(F-2.5285420137293197
F-2.322422875298394
tp9008
sS"s = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\nif s.find('blabla') != -1:\n    pass"
p9009
(F-2.3777257919311525
F-2.3568157619900174
tp9010
sS"import mmap\nf = open('example.txt')"
p9011
(F-1.9900047995827415
F-2.363324907090929
tp9012
sS"with open('example.txt', 'rb', 0) as file:\n    with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n        pass"
p9013
(F-2.14764404296875
F-2.253697289360894
tp9014
sS"print 'false'"
p9015
(F-2.1763319969177246
F-2.6833519405788846
tp9016
sS"import mmap\nwith open('example.txt', 'rb', 0) as file:\n    with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n        pass"
p9017
(F-2.13307523727417
F-2.250859578450521
tp9018
sS"if check():\n    print 'true'\nelse:\n    pass"
p9019
(F-1.5169350473504317
F-2.8255848354763455
tp9020
sS"if s.find('blabla') != -1:\n    pass\n"
p9021
(F-1.596402785357307
F-2.72202640109592
tp9022
sS'for line in datafile:\n    if blabla in line:\n        return True'
p9023
(F-1.5243772506713866
F-2.0901141696506076
tp9024
sS"def check():\n    datafile = file('example.txt')\nfound = False"
p9025
(F-2.2748489379882812
F-2.350780063205295
tp9026
sS'return False\nprint check()'
p9027
(F-3.5116570790608725
F-2.8640999264187283
tp9028
sS"if 'blabla' in open('example.txt').read():\n    pass\n"
p9029
(F-1.360613187154134
F-2.0999984741210938
tp9030
sS"def check():\n    datafile = file('example.txt')\nfound = False\nfor line in datafile:\n    if blabla in line:\n        pass"
p9031
(F-1.74953882317794
F-2.149878395928277
tp9032
sS'def check():\n    pass'
p9033
(F-1.9079504880038174
F-2.984197828504774
tp9034
sS'return True'
p9035
(F-3.036602735519409
F-3.2814417945014105
tp9036
sS"f = open('example.txt')\ns = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)"
p9037
(F-2.499780962544103
F-2.330827924940321
tp9038
sS"datafile = file('example.txt')"
p9039
(F-2.824784278869629
F-2.348791334364149
tp9040
sS'found = False'
p9041
(F-2.3004135131835937
F-2.607865651448568
tp9042
sS'with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n    pass'
p9043
(F-2.7987452189127606
F-2.3476325141059027
tp9044
sS'if True:\n    pass'
p9045
(F-1.9577776590983074
F-3.101184844970703
tp9046
sS"import mmap\nf = open('example.txt')\ns = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\nif s.find('blabla') != -1:\n    pass"
p9047
(F-2.150350799560547
F-2.2756190829806857
tp9048
sS'for line in datafile:\n    if blabla in line:\n        return True\nreturn False'
p9049
(F-1.6581226846446162
F-2.1108114454481335
tp9050
sS'found = False\nfor line in datafile:\n    if blabla in line:\n        return True\nreturn False\nprint check()'
p9051
(F-1.8911395072937012
F-2.082318411933051
tp9052
sS"def check():\n    datafile = file('example.txt')"
p9053
(F-2.0590009689331055
F-2.4092220730251737
tp9054
sS"print 'true'"
p9055
(F-2.1763319969177246
F-2.6833519405788846
tp9056
sS'import mmap'
p9057
(F-4.378350257873535
F-2.6559009552001953
tp9058
sS'if blabla in line:\n    pass'
p9059
(F-1.8301089893687854
F-2.2219263712565103
tp9060
sS"import mmap\nwith open('example.txt', 'rb', 0) as file:\n    pass"
p9061
(F-1.5588268098377047
F-2.2226719326443143
tp9062
sS"with open('example.txt', 'rb', 0) as file:\n    with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n        if s.find('blabla') != -1:\n            pass\n"
p9063
(F-1.918390047752251
F-2.203480190700955
tp9064
sS'found = False\nfor line in datafile:\n    if blabla in line:\n        return True\nreturn False'
p9065
(F-1.553241871021412
F-2.0783521864149304
tp9066
sS'return False'
p9067
(F-3.0718770027160645
F-3.3893445332845054
tp9068
sS"with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n    if s.find('blabla') != -1:\n        pass\n"
p9069
(F-2.2519798278808594
F-2.2993763817681208
tp9070
sS"with open('example.txt', 'rb', 0) as file:\n    with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n        if s.find('blabla') != -1:\n            pass"
p9071
(F-1.918390047752251
F-2.203480190700955
tp9072
sS"import mmap\nwith open('example.txt', 'rb', 0) as file:\n    with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n        if s.find('blabla') != -1:\n            pass"
p9073
(F-1.9274239078644784
F-2.20727899339464
tp9074
sS's = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)'
p9075
(F-3.043243090311686
F-2.402271270751953
tp9076
sS'if True:\n    pass\n'
p9077
(F-1.9577776590983074
F-3.101184844970703
tp9078
sS"def check():\n    datafile = file('example.txt')\nfound = False\nfor line in datafile:\n    if blabla in line:\n        return True\nreturn False\nprint check()"
p9079
(F-1.97578316546501
F-2.1578631930881076
tp9080
sS'for line in datafile:\n    if blabla in line:\n        return True\nreturn False\nprint check()'
p9081
(F-2.070247105189732
F-2.1104098425971136
tp9082
sS"f = open('example.txt')\ns = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\nif s.find('blabla') != -1:\n    pass"
p9083
(F-2.1121318086664727
F-2.277088165283203
tp9084
sS"if check():\n    print 'true'\nelse:\n    print 'false'"
p9085
(F-1.275510025024414
F-2.685548570421007
tp9086
sS"def check():\n    datafile = file('example.txt')\nfound = False\nfor line in datafile:\n    if blabla in line:\n        return True\nreturn False"
p9087
(F-1.79063233875093
F-2.1609590318467884
tp9088
sS'found = False\nfor line in datafile:\n    if blabla in line:\n        return True'
p9089
(F-1.4640531539916992
F-2.058505376180013
tp9090
sS'print check()'
p9091
(F-3.3457921346028647
F-2.754551569620768
tp9092
sS'if blabla in line:\n    return True'
p9093
(F-1.9546995162963867
F-2.171145757039388
tp9094
sS"s = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\nif s.find('blabla') != -1:\n    pass\n"
p9095
(F-2.3777257919311525
F-2.3568157619900174
tp9096
sS'for line in datafile:\n    if blabla in line:\n        pass'
p9097
(F-1.4631160936857526
F-2.099280675252279
tp9098
sS"if 'blabla' in open('example.txt').read():\n    pass"
p9099
(F-1.360613187154134
F-2.0999986860487194
tp9100
sS"f = open('example.txt')"
p9101
(F-1.2217144966125488
F-2.361530303955078
tp9102
sS'found = False\nfor line in datafile:\n    if blabla in line:\n        pass'
p9103
(F-1.445988364841627
F-2.067440456814236
tp9104
sS"import mmap\nf = open('example.txt')\ns = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\nif s.find('blabla') != -1:\n    pass\n"
p9105
(F-2.150350799560547
F-2.2756190829806857
tp9106
sS"with mmap.mmap(file.fileno(), 0, access=mmap.ACCESS_READ) as s:\n    if s.find('blabla') != -1:\n        pass"
p9107
(F-2.2519798278808594
F-2.2993763817681208
tp9108
sS"def check():\n    datafile = file('example.txt')\nfound = False\nfor line in datafile:\n    pass"
p9109
(F-2.0162841796875
F-2.201856401231554
tp9110
sS"def check():\n    datafile = file('example.txt')\nfound = False\nfor line in datafile:\n    if blabla in line:\n        return True"
p9111
(F-1.7421875
F-2.142317877875434
tp9112
sS"f = open('example.txt')\ns = mmap.mmap(f.fileno(), 0, access=mmap.ACCESS_READ)\nif s.find('blabla') != -1:\n    pass\n"
p9113
(F-2.1121318086664727
F-2.277088165283203
tp9114
ssI845058
(dp9115
S'def mapcount(filename):\n    pass'
p9116
(F-1.4727967580159504
F-2.5513329939408735
tp9117
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9118
(F-2.2681977567616958
F-2.4457917646928267
tp9119
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9120
(F-1.6360806274414061
F-2.3832121762362393
tp9121
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9122
(F-2.1300464574841484
F-2.473982897671786
tp9123
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9124
(F-1.9089620290708935
F-2.4374042857776987
tp9125
sS'lines = 0'
p9126
(F-3.5007373809814455
F-2.300729751586914
tp9127
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9128
(F-1.9223828585642688
F-2.526436198841442
tp9129
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9130
(F-1.7946922995827415
F-2.4309206875887783
tp9131
sS'from __future__ import with_statement'
p9132
(F-1.1728118896484374
F-2.3543274619362573
tp9133
sS'return lines\n\ndef bufcount(filename):\n    pass'
p9134
(F-2.4911160469055176
F-2.4235538135875356
tp9135
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9136
(F-1.8234136386180486
F-2.3988848599520596
tp9137
sS'def simplecount(filename):\n    pass'
p9138
(F-1.4727967580159504
F-2.5513329939408735
tp9139
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p9140
(F-2.4607791298314146
F-2.483830538662997
tp9141
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p9142
(F-2.0866606416758042
F-2.450426795265891
tp9143
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9144
(F-1.9570072398466223
F-2.3825647180730645
tp9145
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9146
(F-1.8038925834324049
F-2.397201884876598
tp9147
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9148
(F-2.188686310298859
F-2.432685678655451
tp9149
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9150
(F-2.1314802230543393
F-2.4088172912597656
tp9151
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9152
(F-2.088260183026714
F-2.4131785306063565
tp9153
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9154
(F-1.889375713509573
F-2.42403169111772
tp9155
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9156
(F-2.306653893512228
F-2.4655000513250176
tp9157
sS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9158
(F-1.3729825337727866
F-2.430011575872248
tp9159
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9160
(F-2.206552663865072
F-2.412034121426669
tp9161
sS"def mapcount(filename):\n    f = open(filename, 'r+')"
p9162
(F-1.1079853459408409
F-2.651296788995916
tp9163
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9164
(F-2.2432337935252855
F-2.4373838251287285
tp9165
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9166
(F-2.272535393999509
F-2.4519257978959517
tp9167
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9168
(F-2.4239608250307234
F-2.4245955727317114
tp9169
sS"num_lines = sum(1 for line in open('myfile.txt'))"
p9170
(F-1.9540459127987133
F-2.3947263197465376
tp9171
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9172
(F-1.8302431106567383
F-2.4081160805442114
tp9173
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9174
(F-2.0664741339856643
F-2.412790125066584
tp9175
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9176
(F-2.4601198446871053
F-2.4701449654319068
tp9177
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9178
(F-2.295896218039773
F-2.4739607030695137
tp9179
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9180
(F-1.949604183048397
F-2.3965301513671875
tp9181
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9182
(F-2.2752388129800054
F-2.497604023326527
tp9183
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass'
p9184
(F-2.797185262044271
F-2.449869155883789
tp9185
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9186
(F-2.404139440199908
F-2.437374635176225
tp9187
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9188
(F-2.040128565546292
F-2.429647619074041
tp9189
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p9190
(F-2.3619610922677174
F-2.5636777010830967
tp9191
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9192
(F-1.8911273790442424
F-2.4178492806174536
tp9193
sS'readline = buf.readline'
p9194
(F-4.924185071672712
F-2.358817707408558
tp9195
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9196
(F-2.172906247177565
F-2.4674313285134057
tp9197
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9198
(F-2.2650866004509655
F-2.4331911260431465
tp9199
sS"return i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9200
(F-2.0715940375077095
F-2.515819722955877
tp9201
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9202
(F-2.3312672008167614
F-2.4168950861150567
tp9203
sS"print key.__name__, ':', sum(vals) / float(len(vals))"
p9204
(F-2.5455517976180366
F-2.3599765084006568
tp9205
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9206
(F-2.3608836638621793
F-2.488276394930753
tp9207
sS'return lines\n\ndef simplecount(filename):\n    lines = 0'
p9208
(F-2.628240797254774
F-2.4263749556107954
tp9209
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9210
(F-2.1302964528401693
F-2.4295304038307886
tp9211
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9212
(F-3.1111760953577554
F-2.4565261494029653
tp9213
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9214
(F-1.9945489424693434
F-2.403492667458274
tp9215
sS'pass'
p9216
(F-2.9698778788248696
F-2.34688308022239
tp9217
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9218
(F-2.5559634374192925
F-2.4452972412109375
tp9219
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p9220
(F-2.156902385207842
F-2.4441134712912818
tp9221
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9222
(F-2.17102798761106
F-2.425694378939542
tp9223
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9224
(F-1.889147712189017
F-2.408762151544744
tp9225
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9226
(F-3.148951480263158
F-2.4542035189541904
tp9227
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9228
(F-2.4420321482532428
F-2.4032351753928443
tp9229
sS'lines += 1'
p9230
(F-3.3701850891113283
F-2.2821644869717685
tp9231
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9232
(F-2.274226361010448
F-2.4740524291992188
tp9233
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9234
(F-2.4814078776041666
F-2.4494542208584873
tp9235
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9236
(F-2.242632259022106
F-2.410694642500444
tp9237
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9238
(F-2.338867893108743
F-2.455048994584517
tp9239
sS'for key, vals in counts.items():\n    pass'
p9240
(F-1.7757645775290096
F-2.424530202692205
tp9241
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9242
(F-2.4233289246165426
F-2.4924368424849077
tp9243
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9244
(F-2.2467630423751532
F-2.421776684847745
tp9245
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9246
(F-2.0611407719435735
F-2.4125714735551314
tp9247
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9248
(F-2.6111041174994574
F-2.4447281577370386
tp9249
sS"def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9250
(F-1.636349585748488
F-2.4366566051136362
tp9251
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9252
(F-3.1871552643952548
F-2.5208103873512964
tp9253
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9254
(F-1.5239799655213648
F-2.397865642200817
tp9255
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9256
(F-2.091144857885631
F-2.4439496127041904
tp9257
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9258
(F-2.1865218026297435
F-2.4216854789040307
tp9259
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9260
(F-2.180059490781842
F-2.4034574682062324
tp9261
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9262
(F-2.4388259769410126
F-2.461732864379883
tp9263
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9264
(F-1.4862787458631728
F-2.371160853992809
tp9265
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9266
(F-2.0106595586783618
F-2.4277557026256216
tp9267
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9268
(F-2.01692876508159
F-2.4027659676291724
tp9269
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9270
(F-2.096957258169087
F-2.42006423256614
tp9271
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9272
(F-2.3260533429574277
F-2.4572824998335405
tp9273
sS'buf = mmap.mmap(f.fileno(), 0)'
p9274
(F-2.0294275283813477
F-2.4295175725763496
tp9275
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9276
(F-2.3699193235303535
F-2.4904089840975674
tp9277
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9278
(F-1.6755558229842276
F-2.3773151744495737
tp9279
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9280
(F-2.103326585557726
F-2.433449138294567
tp9281
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9282
(F-2.2747363886557337
F-2.4325039603493432
tp9283
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9284
(F-2.1314802230543393
F-2.4088172912597656
tp9285
sS'for i in range(5):\n    pass'
p9286
(F-1.1330487387520927
F-2.3097593134099785
tp9287
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9288
(F-2.9568127618319746
F-2.4978342923251065
tp9289
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9290
(F-2.3881797582073943
F-2.4470788782293145
tp9291
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9292
(F-2.2650222778320312
F-2.4485903653231533
tp9293
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9294
(F-2.028718684269832
F-2.3927735415371982
tp9295
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9296
(F-2.5310197310014204
F-2.4799069491299717
tp9297
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9298
(F-2.240850945784582
F-2.432469974864613
tp9299
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9300
(F-2.0287248577987937
F-2.4078351801091973
tp9301
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9302
(F-2.049441701061321
F-2.4199785752729936
tp9303
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9304
(F-2.161543491908482
F-2.4561183235862036
tp9305
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9306
(F-1.9312563250141759
F-2.46253793889826
tp9307
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9308
(F-1.9975494756931211
F-2.395184950395064
tp9309
sS'read_f = f.read'
p9310
(F-3.3881768120659723
F-2.4244185360995205
tp9311
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9312
(F-2.1070233261376097
F-2.4196399341930044
tp9313
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9314
(F-1.9651616056200485
F-2.3576819679953833
tp9315
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9316
(F-2.133192428434738
F-2.4659162001176314
tp9317
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9318
(F-2.097530704913753
F-2.44866267117587
tp9319
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9320
(F-2.2422010394888865
F-2.4642613150856714
tp9321
sS'buf = read_f(buf_size)\nreturn lines'
p9322
(F-3.475733439127604
F-2.519914453679865
tp9323
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9324
(F-2.2771951426630435
F-2.4440241726962
tp9325
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline'
p9326
(F-2.7155972994290867
F-2.418996117331765
tp9327
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9328
(F-2.1159496057502047
F-2.457967931574041
tp9329
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9330
(F-2.206552663865072
F-2.412034121426669
tp9331
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9332
(F-1.892661627822035
F-2.428000883622603
tp9333
sS"return i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9334
(F-2.058990478515625
F-2.489084937355735
tp9335
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9336
(F-1.87565405894134
F-2.4000672427090732
tp9337
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p9338
(F-2.6874411900838218
F-2.627762881192294
tp9339
sS'return lines\n\ndef opcount(fname):\n    pass'
p9340
(F-2.5850038528442383
F-2.2830515774813565
tp9341
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9342
(F-2.0420413547092013
F-2.3837228254838423
tp9343
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9344
(F-1.8962298801967077
F-2.3859811262650923
tp9345
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9346
(F-1.472380793371866
F-2.415178819136186
tp9347
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9348
(F-2.2125052558051217
F-2.4343898079612036
tp9349
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9350
(F-2.6147518363050235
F-2.4792211705988105
tp9351
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9352
(F-1.2219843183244978
F-2.451231349598278
tp9353
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9354
(F-2.333513226425439
F-2.463515368374911
tp9355
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9356
(F-2.1465649625439664
F-2.4296070445667612
tp9357
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9358
(F-2.200621589781746
F-2.43945971402255
tp9359
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9360
(F-1.668392259247449
F-2.550008600408381
tp9361
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9362
(F-2.380192902128575
F-2.463584553111683
tp9363
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass'
p9364
(F-1.9371477014878218
F-2.5062157024036753
tp9365
sS'counts[func].append(time.time() - start_time)'
p9366
(F-2.862976676539371
F-2.4590776616876777
tp9367
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9368
(F-3.145568193708147
F-2.407777959650213
tp9369
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9370
(F-2.1602555614406778
F-2.428403854370117
tp9371
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9372
(F-2.106046434859155
F-2.449533289129084
tp9373
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024"
p9374
(F-2.046310887192235
F-2.4635276794433594
tp9375
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p9376
(F-2.3370466232299805
F-2.5658385536887427
tp9377
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9378
(F-2.007795969645182
F-2.465669631958008
tp9379
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read"
p9380
(F-2.0730527052238807
F-2.4713472886519
tp9381
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9382
(F-2.904889050651999
F-2.358911861072887
tp9383
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9384
(F-2.2438816657433143
F-2.443958455866033
tp9385
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9386
(F-2.336130363996639
F-2.4385610060258345
tp9387
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9388
(F-2.232966021761868
F-2.442477139559659
tp9389
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9390
(F-2.1200253066196235
F-2.437107953158292
tp9391
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9392
(F-1.9861277530067845
F-2.4525833129882812
tp9393
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9394
(F-2.0468241373697915
F-2.3582815690474077
tp9395
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9396
(F-2.263983013986171
F-2.4419000799005683
tp9397
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9398
(F-2.1455223446800593
F-2.570140318437056
tp9399
sS'counts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n'
p9400
(F-2.504112025669643
F-2.417871822010387
tp9401
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9402
(F-2.4870269775390623
F-2.543548410589045
tp9403
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9404
(F-2.704922444111592
F-2.502992630004883
tp9405
sS'lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p9406
(F-3.5415456862676713
F-2.558708364313299
tp9407
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9408
(F-2.3065347874418216
F-2.435127605091442
tp9409
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9410
(F-2.353706714718841
F-2.464805256236683
tp9411
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9412
(F-2.3065347874418216
F-2.435127605091442
tp9413
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9414
(F-2.0706120829183265
F-2.4412108334628018
tp9415
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9416
(F-2.1884004569347995
F-2.4108123779296875
tp9417
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9418
(F-2.3495761163220434
F-2.4622455943714487
tp9419
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9420
(F-2.161693532843339
F-2.470137682828036
tp9421
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9422
(F-2.2677234225802954
F-2.4648716666481714
tp9423
sS"while buf:\n    lines += buf.count('\\n')"
p9424
(F-3.0038886070251465
F-2.3616984974254263
tp9425
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9426
(F-2.365260532924107
F-2.4907167608087715
tp9427
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9428
(F-2.237646287487399
F-2.4548249678178267
tp9429
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9430
(F-2.20694331118935
F-2.4260614568536933
tp9431
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9432
(F-2.3127432686941964
F-2.4062326604669746
tp9433
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9434
(F-2.4161554972330728
F-2.396299188787287
tp9435
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p9436
(F-2.462274642217727
F-2.5504512786865234
tp9437
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9438
(F-2.2335148861533716
F-2.426458705555309
tp9439
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9440
(F-1.8033217597253544
F-2.43457707491788
tp9441
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9442
(F-1.9551578521728517
F-2.387414412064986
tp9443
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p9444
(F-1.8113897818106193
F-2.461490284312855
tp9445
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9446
(F-1.8757011413574218
F-2.407739292491566
tp9447
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p9448
(F-2.7439837985568576
F-2.3761638294566763
tp9449
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9450
(F-2.3164138793945312
F-2.4409264651211826
tp9451
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9452
(F-2.132443961450609
F-2.451128526167436
tp9453
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9454
(F-2.051376990830116
F-2.436187570745295
tp9455
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9456
(F-1.8701386451721191
F-2.5378665924072266
tp9457
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9458
(F-2.513118777654867
F-2.485405141657049
tp9459
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9460
(F-2.2654703776041667
F-2.441105929287997
tp9461
sS'import mmap\nimport random\nfrom collections import defaultdict'
p9462
(F-2.708926518758138
F-2.2399004155939277
tp9463
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9464
(F-3.2105450100368924
F-2.4109729420055044
tp9465
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024"
p9466
(F-2.0275614420572916
F-2.474784330888228
tp9467
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9468
(F-1.9326021061387173
F-2.379500475796786
tp9469
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9470
(F-2.124877032111673
F-2.477012287486683
tp9471
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9472
(F-1.9121251599542026
F-2.4157392328435723
tp9473
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p9474
(F-2.4621550461341597
F-2.500482039018111
tp9475
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9476
(F-2.3296477036669074
F-2.4547755501487036
tp9477
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9478
(F-2.2397118623925265
F-2.4341196580366655
tp9479
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9480
(F-2.031097920735677
F-2.396347392689098
tp9481
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9482
(F-2.2600347345525567
F-2.4850439591841265
tp9483
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9484
(F-2.04959716796875
F-2.4789484197443183
tp9485
sS'import time\nimport mmap\nimport random\nfrom collections import defaultdict'
p9486
(F-2.5296096801757812
F-2.2506434700705786
tp9487
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random'
p9488
(F-1.98278125963713
F-2.4488754272460938
tp9489
sS"lines += buf.count('\\n')"
p9490
(F-3.434360885620117
F-2.2604054537686435
tp9491
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict'
p9492
(F-1.9235992431640625
F-2.3072520169344815
tp9493
sS'return i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9494
(F-1.7917918395996093
F-2.4870310696688565
tp9495
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9496
(F-2.099393420045162
F-2.418116482821378
tp9497
sS'for func in [mapcount, simplecount, bufcount, opcount]:\n    start_time = time.time()'
p9498
(F-1.345072004530165
F-2.455917011607777
tp9499
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9500
(F-2.3048326401483443
F-2.4492886283180932
tp9501
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9502
(F-1.8522413822642543
F-2.4478166753595527
tp9503
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9504
(F-2.2555898892677435
F-2.4482317837801846
tp9505
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9506
(F-2.0986328125
F-2.418159311467951
tp9507
sS'read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9508
(F-3.206399917602539
F-2.4622133428400215
tp9509
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9510
(F-2.412539274796196
F-2.5331897735595703
tp9511
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9512
(F-2.1797999064127604
F-2.4467906951904297
tp9513
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9514
(F-2.4406854966107536
F-2.4313833063299004
tp9515
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9516
(F-2.107259259905134
F-2.4524175470525567
tp9517
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9518
(F-2.3257659912109374
F-2.4463977813720703
tp9519
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p9520
(F-2.6957148501747534
F-2.3828988508744673
tp9521
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9522
(F-2.0322136677486795
F-2.4512209458784624
tp9523
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9524
(F-2.2665703886298725
F-2.4495970986106177
tp9525
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p9526
(F-2.607161877202053
F-2.494349392977628
tp9527
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9528
(F-2.082465979331298
F-2.435551730069247
tp9529
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9530
(F-2.0322136677486795
F-2.4512209458784624
tp9531
sS'readline = buf.readline\nwhile readline():\n    lines += 1'
p9532
(F-3.643932944849918
F-2.3404495932839136
tp9533
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9534
(F-2.586971185146234
F-2.4437944238836113
tp9535
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9536
(F-2.5818391852422593
F-2.4516433369029653
tp9537
sS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9538
(F-1.3079263787520559
F-2.42237680608576
tp9539
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9540
(F-2.086148371461962
F-2.4302331751043145
tp9541
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9542
(F-1.890417748755151
F-2.454378301447088
tp9543
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9544
(F-2.0520830116724307
F-2.42818901755593
tp9545
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9546
(F-1.9569681925945972
F-2.364384737881747
tp9547
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p9548
(F-2.824936294555664
F-2.372202439741655
tp9549
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9550
(F-2.6906131562732516
F-2.488928361372514
tp9551
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9552
(F-2.0671210096869275
F-2.4000991474498403
tp9553
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9554
(F-2.6233975849454363
F-2.490576310591264
tp9555
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9556
(F-1.9092257099766885
F-2.416894392533736
tp9557
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9558
(F-2.1864595600202974
F-2.4485933130437676
tp9559
sS'with open(fname) as f:\n    pass'
p9560
(F-1.3428922380719865
F-2.450252879749645
tp9561
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9562
(F-2.0347532384535847
F-2.3674404837868432
tp9563
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass'
p9564
(F-1.584981632232666
F-2.466941139914773
tp9565
sS'readline = buf.readline\nwhile readline():\n    pass'
p9566
(F-3.727229623233571
F-2.3324304060502485
tp9567
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9568
(F-2.4596030942855345
F-2.492498051036488
tp9569
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9570
(F-2.6375908851623535
F-2.4562814885919746
tp9571
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9572
(F-2.0606704439435686
F-2.4674748507413
tp9573
sS'lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9574
(F-3.263326644897461
F-2.5538170554421167
tp9575
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9576
(F-2.0950142996651784
F-2.41332331570712
tp9577
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p9578
(F-2.3041371384712113
F-2.5484643415971235
tp9579
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9580
(F-2.567101538598121
F-2.4456830458207564
tp9581
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9582
(F-2.146213307100184
F-2.470288536765359
tp9583
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9584
(F-2.5257890625
F-2.471289201216264
tp9585
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9586
(F-2.197594516248588
F-2.414832201871005
tp9587
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9588
(F-2.780977619228078
F-2.4785369526256216
tp9589
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9590
(F-2.228995353552946
F-2.462138436057351
tp9591
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9592
(F-2.034298609173487
F-2.4660795385187324
tp9593
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9594
(F-2.219876141615317
F-2.4021297801624644
tp9595
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9596
(F-2.073500303464515
F-2.404603958129883
tp9597
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9598
(F-2.1864595600202974
F-2.4485931396484375
tp9599
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9600
(F-3.059041623716001
F-2.4133952747691763
tp9601
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9602
(F-1.8429534415888593
F-2.4334064830433237
tp9603
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9604
(F-1.9435981575769323
F-2.4375728260387075
tp9605
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9606
(F-2.0611407719435735
F-2.412571820345792
tp9607
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9608
(F-2.1640589258692287
F-2.4365799643776636
tp9609
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9610
(F-2.418052190466772
F-2.4681970422918145
tp9611
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9612
(F-2.2339666748046874
F-2.452364834872159
tp9613
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p9614
(F-2.5703162427218453
F-2.494209636341442
tp9615
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9616
(F-2.200621589781746
F-2.43945971402255
tp9617
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9618
(F-2.2675894980104814
F-2.4713273481889204
tp9619
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9620
(F-2.336965560913086
F-2.4624758633700283
tp9621
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9622
(F-2.2166267007084217
F-2.4426266063343394
tp9623
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9624
(F-2.1299236909842785
F-2.468525626442649
tp9625
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9626
(F-1.9249763488769531
F-2.4782531044699927
tp9627
sS"assert func('big_file.txt') == 1209138"
p9628
(F-2.6547410753038196
F-2.626142675226385
tp9629
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p9630
(F-2.191605618125514
F-2.513163826682351
tp9631
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9632
(F-2.4197767914318646
F-2.4519500732421875
tp9633
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9634
(F-1.9435981575769323
F-2.437572652643377
tp9635
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9636
(F-1.856795873397436
F-2.442679665305398
tp9637
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9638
(F-1.878102571061514
F-2.3858510797674004
tp9639
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024"
p9640
(F-1.9725333319769964
F-2.4718381708318535
tp9641
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9642
(F-2.224046202911728
F-2.4413975802334873
tp9643
sS'for line in open(filename):\n    lines += 1\nreturn lines'
p9644
(F-1.7727263601202714
F-2.4570739052512427
tp9645
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p9646
(F-2.9504922231038413
F-2.3705503290349785
tp9647
sS'lines = 0\nreadline = buf.readline'
p9648
(F-4.149761199951172
F-2.3433773734352807
tp9649
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9650
(F-1.771295996273265
F-2.399736924604936
tp9651
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9652
(F-3.20961842638381
F-2.475951454856179
tp9653
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p9654
(F-2.3420996727881493
F-2.5268204428932886
tp9655
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9656
(F-1.7361821261319248
F-2.489141984419389
tp9657
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9658
(F-2.524803706577846
F-2.4082847942005503
tp9659
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)"
p9660
(F-2.2094954895458634
F-2.511873418634588
tp9661
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9662
(F-1.8971446790193256
F-2.411626469005238
tp9663
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9664
(F-2.5219209905256306
F-2.486581628972834
tp9665
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9666
(F-2.0279541015625
F-2.45827241377397
tp9667
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9668
(F-2.1118674990278565
F-2.435915860262784
tp9669
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9670
(F-1.9057621906713111
F-2.4187556180087
tp9671
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9672
(F-2.1726188497340426
F-2.4323355934836646
tp9673
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9674
(F-2.2678895950317384
F-2.4141700051047583
tp9675
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p9676
(F-2.4383116026182434
F-2.6395693692294033
tp9677
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9678
(F-2.536934271091368
F-2.4683168584650215
tp9679
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9680
(F-2.29758967185507
F-2.4475829384543677
tp9681
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9682
(F-2.0967639836115635
F-2.404227690263228
tp9683
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p9684
(F-2.8830716059758115
F-2.5958935130726206
tp9685
sS'f = open(filename)'
p9686
(F-1.8688325881958008
F-2.5733278447931465
tp9687
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9688
(F-2.154379407760545
F-2.436881325461648
tp9689
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9690
(F-2.2771951426630435
F-2.4440241726962
tp9691
sS'for key, vals in counts.items():\n    pass\n'
p9692
(F-1.7757645775290096
F-2.424530202692205
tp9693
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9694
(F-3.148753356933594
F-2.4129678552800957
tp9695
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9696
(F-2.115976448946221
F-2.454893805763938
tp9697
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9698
(F-2.1667759672124336
F-2.425821130925959
tp9699
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9700
(F-2.249913533528646
F-2.430836417458274
tp9701
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9702
(F-2.0510423966036497
F-2.4350769736550073
tp9703
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9704
(F-2.4937561633540133
F-2.407661264592951
tp9705
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9706
(F-2.310332934061686
F-2.446131099354137
tp9707
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9708
(F-2.099324330562303
F-2.4354752627286045
tp9709
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9710
(F-2.1943937029157365
F-2.4502440365878018
tp9711
sS"return i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9712
(F-1.9461650190682247
F-2.495658180930398
tp9713
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9714
(F-2.2864043826148626
F-2.480070114135742
tp9715
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p9716
(F-2.3236326329848347
F-2.4745500737970527
tp9717
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9718
(F-2.8808501621462264
F-2.431746396151456
tp9719
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9720
(F-1.869691495542173
F-2.4867571050470527
tp9721
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9722
(F-3.2193674547918913
F-2.491990002718839
tp9723
sS"assert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9724
(F-2.5123645871184594
F-2.4513003609397193
tp9725
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9726
(F-2.5460946219308034
F-2.4639225006103516
tp9727
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9728
(F-1.3805650280367943
F-2.386778224598278
tp9729
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9730
(F-2.244853210449219
F-2.4030106284401636
tp9731
sS'from collections import defaultdict'
p9732
(F-2.1868791580200195
F-2.2814483642578125
tp9733
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p9734
(F-2.497262472634787
F-2.483836954290217
tp9735
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)"
p9736
(F-2.098256116995782
F-2.4545955657958984
tp9737
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9738
(F-2.267668388259243
F-2.4505379416725854
tp9739
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9740
(F-1.9121251599542026
F-2.4157392328435723
tp9741
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9742
(F-2.504270573252255
F-2.4186633716930044
tp9743
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9744
(F-2.0844894720583547
F-2.4622150767933237
tp9745
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9746
(F-2.678767018503957
F-2.5083992697975854
tp9747
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9748
(F-2.8525317964099703
F-2.390494953502308
tp9749
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9750
(F-2.1797999064127604
F-2.4467905217950996
tp9751
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9752
(F-2.653264808654785
F-2.505685979669744
tp9753
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9754
(F-2.09985842023577
F-2.446540659124201
tp9755
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9756
(F-2.1164991590711804
F-2.4266307137229224
tp9757
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9758
(F-1.9811311721801759
F-2.5245493108575996
tp9759
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9760
(F-2.4100331720316186
F-2.4069643887606533
tp9761
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)"
p9762
(F-2.1539570201526987
F-2.459925564852628
tp9763
sS"return i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9764
(F-2.058990478515625
F-2.489084937355735
tp9765
sS'for func in [mapcount, simplecount, bufcount, opcount]:\n    pass'
p9766
(F-1.506133430882504
F-2.449120955033736
tp9767
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9768
(F-2.35159912109375
F-2.467331279407848
tp9769
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p9770
(F-2.4780328924005683
F-2.3816082694313745
tp9771
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9772
(F-1.9059841349973516
F-2.4424136768687856
tp9773
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9774
(F-1.5309741371556331
F-2.530072645707564
tp9775
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9776
(F-2.5534473765980112
F-2.4860539869828657
tp9777
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9778
(F-1.9249763488769531
F-2.4782531044699927
tp9779
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9780
(F-2.2461900587205763
F-2.4879944541237573
tp9781
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9782
(F-1.82124286998402
F-2.400697881525213
tp9783
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p9784
(F-2.3466270764668784
F-2.578995097767223
tp9785
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9786
(F-2.162159152560764
F-2.435375387018377
tp9787
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9788
(F-1.9392126959723395
F-2.373698494651101
tp9789
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9790
(F-2.320998528991083
F-2.4319447604092685
tp9791
sS'lines = 0\nbuf_size = 1024 * 1024'
p9792
(F-4.11031987116887
F-2.5430225025523794
tp9793
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9794
(F-1.3906576493207146
F-2.5403352217240767
tp9795
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9796
(F-2.4382232666015624
F-2.4121211658824575
tp9797
sS"f = open(filename, 'r+')"
p9798
(F-1.2318796157836913
F-2.576467687433416
tp9799
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9800
(F-2.5296989723488137
F-2.4644397388805044
tp9801
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9802
(F-2.2434652873447964
F-2.4257767417214136
tp9803
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9804
(F-2.0274485761791357
F-2.432353279807351
tp9805
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9806
(F-2.1570211557241588
F-2.3963841524991123
tp9807
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9808
(F-1.4086009979248046
F-2.438804106278853
tp9809
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read"
p9810
(F-1.9962427239668996
F-2.450858723033558
tp9811
sS'def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9812
(F-1.5439640733062243
F-2.4259912317449395
tp9813
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024"
p9814
(F-2.0501854306175593
F-2.489472649314187
tp9815
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p9816
(F-2.4858274459838867
F-2.5151620344682173
tp9817
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9818
(F-2.1588176258823326
F-2.420114690607244
tp9819
sS'while readline():\n    lines += 1\nreturn lines'
p9820
(F-2.8631701469421387
F-2.362377166748047
tp9821
sS'def simplecount(filename):\n    lines = 0'
p9822
(F-1.86209351675851
F-2.5099577470259233
tp9823
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9824
(F-3.159159757653061
F-2.4483014887029473
tp9825
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9826
(F-2.2389063759455605
F-2.423166448419744
tp9827
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0'
p9828
(F-1.8093819391159784
F-2.615949110551314
tp9829
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024"
p9830
(F-2.0495702462602954
F-2.4833318536931817
tp9831
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9832
(F-1.0957847595214845
F-2.459459998390891
tp9833
sS'read_f = f.read\nbuf = read_f(buf_size)'
p9834
(F-3.6440895080566404
F-2.5097333734685723
tp9835
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p9836
(F-2.161529541015625
F-2.4631500244140625
tp9837
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9838
(F-2.0700469730407236
F-2.4399323896928267
tp9839
sS'def bufcount(filename):\n    f = open(filename)'
p9840
(F-1.360071855432847
F-2.655220725319602
tp9841
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9842
(F-2.2211759720725577
F-2.413681897250089
tp9843
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9844
(F-2.0305792767068613
F-2.404136137528853
tp9845
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9846
(F-2.127687432792749
F-2.4227801236239346
tp9847
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9848
(F-2.023563585783306
F-2.5181862224232066
tp9849
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9850
(F-1.8596405893001917
F-2.3979674252596768
tp9851
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9852
(F-2.480494144189097
F-2.45448823408647
tp9853
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9854
(F-2.4463973810643327
F-2.434498526833274
tp9855
sS'return lines'
p9856
(F-3.8770346641540527
F-2.288400476629084
tp9857
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9858
(F-2.618169886465291
F-2.4616348960182886
tp9859
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9860
(F-3.350722919810902
F-2.3298792405561968
tp9861
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9862
(F-2.261427887773092
F-2.49535473910245
tp9863
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9864
(F-2.1901484604908212
F-2.442138671875
tp9865
sS'return i + 1\ncounts = defaultdict(list)'
p9866
(F-3.2779458852914662
F-2.480596889149059
tp9867
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9868
(F-2.4131810506184896
F-2.4393946907737036
tp9869
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9870
(F-2.0578794617583784
F-2.4092601429332388
tp9871
sS'import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9872
(F-1.486011686779204
F-2.4353682778098364
tp9873
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p9874
(F-3.580537341889881
F-2.326782920143821
tp9875
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9876
(F-1.945334214430589
F-2.3927534276788887
tp9877
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9878
(F-3.179839023323946
F-2.510827671397816
tp9879
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9880
(F-1.8526056128812123
F-2.3743391903963955
tp9881
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9882
(F-2.1416202776998445
F-2.4629228765314277
tp9883
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p9884
(F-2.2469836518964694
F-2.431054028597745
tp9885
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9886
(F-2.4041686670740225
F-2.4457931518554688
tp9887
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9888
(F-2.062506810789968
F-2.4434642791748047
tp9889
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9890
(F-2.2283056753653065
F-2.447062752463601
tp9891
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9892
(F-2.1494461742799675
F-2.4103145599365234
tp9893
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9894
(F-1.9126253349836482
F-2.462403037331321
tp9895
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p9896
(F-2.780024441805753
F-2.611869118430398
tp9897
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9898
(F-1.8569050035978618
F-2.379593762484464
tp9899
sS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9900
(F-1.4659428914388022
F-2.35191518610174
tp9901
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p9902
(F-2.145946096866689
F-2.4114281047474253
tp9903
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9904
(F-2.575241906302316
F-2.5910240520130503
tp9905
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9906
(F-2.236817020697882
F-2.4856619401411577
tp9907
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9908
(F-2.2581495138315053
F-2.4509299885142934
tp9909
sS'from collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9910
(F-1.3486093944973416
F-2.416319413618608
tp9911
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9912
(F-2.132443961450609
F-2.451128699562766
tp9913
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9914
(F-1.5963217552672042
F-2.4141096635298296
tp9915
sS'while readline():\n    pass'
p9916
(F-2.982328935102983
F-2.4174041748046875
tp9917
sS"def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9918
(F-1.8292704905111958
F-2.433045127175071
tp9919
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9920
(F-1.8585859934488933
F-2.4219485196200283
tp9921
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)"
p9922
(F-2.172613484969992
F-2.449050556529652
tp9923
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9924
(F-1.9054405905983665
F-2.5106745633212
tp9925
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9926
(F-2.544246736120005
F-2.466260563243519
tp9927
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9928
(F-2.4393299030807785
F-2.487246426669034
tp9929
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9930
(F-1.4627342224121094
F-2.394711060957475
tp9931
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9932
(F-2.158075714111328
F-2.453460693359375
tp9933
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9934
(F-2.2390171707056132
F-2.470470428466797
tp9935
sS"assert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9936
(F-2.5123645871184594
F-2.4513003609397193
tp9937
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9938
(F-2.3635961598363417
F-2.4006678841330786
tp9939
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9940
(F-1.3177347405012263
F-2.4125099182128906
tp9941
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9942
(F-2.099393420045162
F-2.418116482821378
tp9943
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9944
(F-2.2438816657433143
F-2.4439586292613638
tp9945
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9946
(F-2.255612395530523
F-2.4299867803400215
tp9947
sS'with open(fname) as f:\n    for i, l in enumerate(f):\n        pass'
p9948
(F-1.1249412254050926
F-2.4792789112437856
tp9949
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0'
p9950
(F-2.2207063674926757
F-2.4209998737681997
tp9951
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9952
(F-2.072036495053671
F-2.3924293518066406
tp9953
sS'import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9954
(F-1.6571593284606934
F-2.329658334905451
tp9955
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9956
(F-2.1533083128697665
F-2.4435442144220527
tp9957
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9958
(F-1.8430597641888786
F-2.4258025776256216
tp9959
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9960
(F-1.7538657482759452
F-2.4407052126797764
tp9961
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p9962
(F-2.1115662655587926
F-2.4341070001775567
tp9963
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9964
(F-2.558826725657393
F-2.371252580122514
tp9965
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9966
(F-2.1459175745646157
F-2.4209121357310903
tp9967
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p9968
(F-2.1488050377887227
F-2.566850488836115
tp9969
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9970
(F-1.5495500872212071
F-2.396236766468395
tp9971
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9972
(F-2.40458738341812
F-2.4628434614701704
tp9973
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9974
(F-1.9223570390181108
F-2.465895566073331
tp9975
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9976
(F-2.228600985762002
F-2.46767859025435
tp9977
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9978
(F-2.4960596512775033
F-2.3998085368763316
tp9979
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p9980
(F-2.5016842871597134
F-2.477402080189098
tp9981
sS'return lines\n\ndef simplecount(filename):\n    pass'
p9982
(F-2.4911160469055176
F-2.423553640192205
tp9983
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9984
(F-2.5898206922743054
F-2.462400783192028
tp9985
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9986
(F-2.140689590602245
F-2.448172829367898
tp9987
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9988
(F-2.218300559303977
F-2.4483557614413174
tp9989
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p9990
(F-2.1796303845326834
F-2.434809077869762
tp9991
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9992
(F-2.2957259091463955
F-2.5460974953391333
tp9993
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p9994
(F-2.3430404663085938
F-2.3978763927112925
tp9995
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p9996
(F-2.5053338443531707
F-2.478722659024325
tp9997
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9998
(F-1.603859543800354
F-2.4935772635719995
tp9999
sS'while buf:\n    pass'
p10000
(F-2.611219194200304
F-2.5075028159401636
tp10001
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p10002
(F-2.1920874608706122
F-2.392237056385387
tp10003
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p10004
(F-1.6104754572329314
F-2.4998274716463955
tp10005
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10006
(F-2.46539013671875
F-2.4669329903342505
tp10007
sS'def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p10008
(F-1.5503310166396105
F-2.4398781169544566
tp10009
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10010
(F-2.2467547329989346
F-2.4970149993896484
tp10011
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p10012
(F-2.4398034466199636
F-2.468758149580522
tp10013
sS'from __future__ import with_statement\nimport time\nimport mmap'
p10014
(F-1.9553849697113037
F-2.3264087330211294
tp10015
sS'for i, l in enumerate(f):\n    pass'
p10016
(F-1.3513579368591309
F-2.3643023750998755
tp10017
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p10018
(F-2.0523705021027596
F-2.483803488991477
tp10019
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p10020
(F-1.9083273315429687
F-2.39664008400657
tp10021
sS'def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass'
p10022
(F-1.11743958791097
F-2.480306451970881
tp10023
sS'def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p10024
(F-1.5380055147058824
F-2.4391389326615767
tp10025
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p10026
(F-2.33833833174272
F-2.4659978693181817
tp10027
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p10028
(F-2.014905625495358
F-2.3746102072975854
tp10029
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p10030
(F-2.259600759922773
F-2.4521269364790483
tp10031
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read"
p10032
(F-2.0971150398254395
F-2.507937344637784
tp10033
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10034
(F-2.383118432415418
F-2.4731774763627485
tp10035
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p10036
(F-2.108657709757487
F-2.4280046983198686
tp10037
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)'
p10038
(F-2.183934045216394
F-2.4604148864746094
tp10039
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p10040
(F-2.1728664622587317
F-2.3928600658069956
tp10041
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p10042
(F-1.8883909172968034
F-2.4141136516224253
tp10043
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p10044
(F-2.75392583211263
F-2.565817052667791
tp10045
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10046
(F-2.1806515998241163
F-2.4832205338911577
tp10047
sS'counts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass'
p10048
(F-2.504112025669643
F-2.4178719954057173
tp10049
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p10050
(F-1.8921963827950614
F-2.4089535799893467
tp10051
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p10052
(F-2.2031008131960603
F-2.454281893643466
tp10053
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p10054
(F-1.5499725341796875
F-2.435363075949929
tp10055
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10056
(F-2.3890948486328125
F-2.5062068592418325
tp10057
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p10058
(F-1.9182243347167969
F-2.461589293046431
tp10059
sS'buf_size = 1024 * 1024'
p10060
(F-4.659657796223958
F-2.7714869759299536
tp10061
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p10062
(F-1.9249940599714006
F-2.4801559448242188
tp10063
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10064
(F-2.51336932182312
F-2.4454160170121626
tp10065
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p10066
(F-2.3007796646712664
F-2.43861892006614
tp10067
sS'start_time = time.time()'
p10068
(F-1.53886569630016
F-2.38212065263228
tp10069
sS"def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p10070
(F-1.7978848294094876
F-2.450874155217951
tp10071
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p10072
(F-2.1737459309895835
F-2.493850361217152
tp10073
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1'
p10074
(F-1.9944970267159599
F-2.5060442144220527
tp10075
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p10076
(F-2.495472810706314
F-2.442970969460227
tp10077
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p10078
(F-1.8014067164007224
F-2.5399225408380683
tp10079
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10080
(F-2.1013081868489585
F-2.474895303899592
tp10081
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p10082
(F-1.9857319576639525
F-2.452249700372869
tp10083
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10084
(F-2.2345080375671387
F-2.417134024880149
tp10085
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p10086
(F-3.136434408334585
F-2.3343646309592505
tp10087
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10088
(F-2.594050375263343
F-2.4852352142333984
tp10089
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p10090
(F-1.7255093006605513
F-2.439740614457564
tp10091
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p10092
(F-2.004977803834727
F-2.3837977322665127
tp10093
sS'import random\nfrom collections import defaultdict'
p10094
(F-2.382377200656467
F-2.3265595869584517
tp10095
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p10096
(F-1.8795730302918632
F-2.4142594770951704
tp10097
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p10098
(F-2.088260183026714
F-2.4131785306063565
tp10099
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p10100
(F-2.5031442297510353
F-2.50045429576527
tp10101
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024"
p10102
(F-2.074877166748047
F-2.527014298872514
tp10103
sS'return i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p10104
(F-2.070164313683143
F-2.461912675337358
tp10105
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p10106
(F-2.4375782012939453
F-2.504797328602184
tp10107
sS'import mmap'
p10108
(F-4.234286785125732
F-2.264759063720703
tp10109
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p10110
(F-2.2420209996840534
F-2.396201567216353
tp10111
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p10112
(F-1.932275390625
F-2.4525529688054863
tp10113
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p10114
(F-2.1816574732462564
F-2.4388351440429688
tp10115
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10116
(F-2.352250382706926
F-2.476024454290217
tp10117
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p10118
(F-1.8997860344088808
F-2.3894322135231714
tp10119
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p10120
(F-2.104076477260524
F-2.4045639038085938
tp10121
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p10122
(F-2.1904635267192814
F-2.5044701316139917
tp10123
sS'def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)'
p10124
(F-1.6728054682413738
F-2.4328800548206675
tp10125
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p10126
(F-2.350480921128217
F-2.5073250857266514
tp10127
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p10128
(F-2.2406951904296877
F-2.436025792902166
tp10129
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p10130
(F-2.133469431023849
F-2.4796947132457388
tp10131
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p10132
(F-3.199352098547894
F-2.4432979930530894
tp10133
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p10134
(F-2.1641363006791257
F-2.4688276811079546
tp10135
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p10136
(F-1.8673338809255826
F-2.4012751145796343
tp10137
sS'for line in open(filename):\n    lines += 1'
p10138
(F-1.761049747467041
F-2.47795954617587
tp10139
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p10140
(F-2.143944757634943
F-2.4552574157714844
tp10141
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10142
(F-2.9828572730495506
F-2.47274433482777
tp10143
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p10144
(F-2.2794597050915026
F-2.4531099146062676
tp10145
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p10146
(F-2.2469836518964694
F-2.431054028597745
tp10147
sS'return i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p10148
(F-1.8866582598005022
F-2.4928347847678443
tp10149
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p10150
(F-1.8998163101520944
F-2.4235089041969995
tp10151
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p10152
(F-1.5299324367357336
F-2.3832251808860083
tp10153
sS'import mmap\nimport random'
p10154
(F-3.4230782645089284
F-2.357141147960316
tp10155
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p10156
(F-2.0986328125
F-2.4181594848632812
tp10157
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p10158
(F-2.4636359701351243
F-2.4936566786332564
tp10159
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p10160
(F-2.1394858654634454
F-2.4555131738836113
tp10161
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p10162
(F-2.8349259205353565
F-2.4920154918323862
tp10163
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10164
(F-2.542593612151892
F-2.446719429709695
tp10165
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p10166
(F-2.1932470976416742
F-2.4204316572709517
tp10167
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p10168
(F-2.1115662655587926
F-2.4341068267822266
tp10169
sS'buf_size = 1024 * 1024\nread_f = f.read'
p10170
(F-3.698129092945772
F-2.685108184814453
tp10171
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p10172
(F-1.5652413544831452
F-2.52114538712935
tp10173
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p10174
(F-1.6320058888402478
F-2.5131480477072974
tp10175
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p10176
(F-1.9381015918872975
F-2.4471718181263316
tp10177
sS'import time\nimport mmap'
p10178
(F-3.1041695731026784
F-2.258455276489258
tp10179
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p10180
(F-1.9877692328559027
F-2.4663162231445312
tp10181
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p10182
(F-1.8946176115999516
F-2.387441808527166
tp10183
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p10184
(F-1.6186412595353037
F-2.398527838967063
tp10185
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p10186
(F-3.1675537609663165
F-2.4981516057794746
tp10187
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p10188
(F-1.8788607788085938
F-2.4594872214577417
tp10189
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p10190
(F-2.206734919893569
F-2.445412375710227
tp10191
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p10192
(F-2.255612395530523
F-2.4299867803400215
tp10193
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p10194
(F-2.592016855875651
F-2.485038930719549
tp10195
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p10196
(F-2.1865216209774925
F-2.4216853055087
tp10197
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p10198
(F-2.0644164556571147
F-2.4571697928688745
tp10199
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p10200
(F-2.311368700484155
F-2.462299867109819
tp10201
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p10202
(F-1.8802082326152536
F-2.4018870267001065
tp10203
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p10204
(F-2.1061170366075306
F-2.41895207491788
tp10205
sS'def opcount(fname):\n    pass'
p10206
(F-1.6203420956929524
F-2.3545892888849433
tp10207
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p10208
(F-3.4380579409391983
F-2.3432098735462534
tp10209
sS'buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p10210
(F-3.6308086940220425
F-2.6829842654141514
tp10211
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p10212
(F-2.8030600842134454
F-2.498017744584517
tp10213
sS'def opcount(fname):\n    with open(fname) as f:\n        pass'
p10214
(F-1.1527522543202275
F-2.479411905462092
tp10215
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)'
p10216
(F-1.9765789325420673
F-2.4321859533136543
tp10217
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p10218
(F-1.907806968688965
F-2.384362654252486
tp10219
sS'return i + 1'
p10220
(F-2.658010959625244
F-2.317548058249734
tp10221
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10222
(F-2.1978520464792126
F-2.4371767911044033
tp10223
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p10224
(F-2.1633412194630455
F-2.4400112845680932
tp10225
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)"
p10226
(F-2.1777725219726562
F-2.4681568145751953
tp10227
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p10228
(F-1.9965371524586397
F-2.3718474995006216
tp10229
sS'counts = defaultdict(list)'
p10230
(F-2.417966604232788
F-2.352014194835316
tp10231
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p10232
(F-2.0967639836115635
F-2.404227690263228
tp10233
sS'from __future__ import with_statement\nimport time'
p10234
(F-1.5092904017521784
F-2.4032055247913706
tp10235
sS'while readline():\n    lines += 1'
p10236
(F-3.145914811354417
F-2.38535568930886
tp10237
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p10238
(F-2.213596397722271
F-2.406509746204723
tp10239
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p10240
(F-1.9705574729225852
F-2.387107328935103
tp10241
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p10242
(F-2.1617231697871766
F-2.4914127696644175
tp10243
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p10244
(F-2.2033184005553466
F-2.463062979958274
tp10245
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p10246
(F-2.1003040070229386
F-2.4367942810058594
tp10247
sS'counts = defaultdict(list)\nfor i in range(5):\n    pass'
p10248
(F-1.4779212588355655
F-2.331546263261275
tp10249
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p10250
(F-2.4343921013598173
F-2.3721372430974785
tp10251
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p10252
(F-2.0800659744827836
F-2.465403296730735
tp10253
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p10254
(F-2.2580669855667375
F-2.424951033158736
tp10255
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read"
p10256
(F-2.0719363915659215
F-2.463750492442738
tp10257
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read"
p10258
(F-2.050030048076923
F-2.4551856301047583
tp10259
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p10260
(F-2.799036327161287
F-2.3582389137961646
tp10261
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10262
(F-2.1643034699675323
F-2.47216796875
tp10263
sS'def bufcount(filename):\n    pass'
p10264
(F-1.4727967580159504
F-2.5513329939408735
tp10265
sS'def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1'
p10266
(F-1.3295105724799923
F-2.4806494279341265
tp10267
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p10268
(F-1.4157475864186007
F-2.397255290638317
tp10269
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p10270
(F-3.1453694126062226
F-2.5255619395862925
tp10271
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p10272
(F-2.07466156949702
F-2.470833518288352
tp10273
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p10274
(F-2.2061416625976564
F-2.4363278475674717
tp10275
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10276
(F-2.068184581712062
F-2.4246963154185903
tp10277
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p10278
(F-1.8360546959771051
F-2.535323749889027
tp10279
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p10280
(F-2.202843601718271
F-2.4326480518687856
tp10281
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p10282
(F-2.154642800723805
F-2.4472156871448862
tp10283
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass"
p10284
(F-2.1901484604908212
F-2.442138671875
tp10285
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p10286
(F-1.870242246647471
F-2.4130835099653765
tp10287
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p10288
(F-2.354088060783617
F-2.40354416587136
tp10289
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p10290
(F-2.111018446625256
F-2.5872452475807886
tp10291
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)"
p10292
(F-2.1823511476869935
F-2.4566877538507637
tp10293
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read"
p10294
(F-2.068220955984933
F-2.4441273429177026
tp10295
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p10296
(F-2.4806020925710865
F-2.454793756658381
tp10297
sS"def opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p10298
(F-1.8292703703632505
F-2.433045127175071
tp10299
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p10300
(F-2.607644052216501
F-2.4568675648082388
tp10301
sS'for line in open(filename):\n    pass'
p10302
(F-1.5396627698625838
F-2.4848481958562676
tp10303
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p10304
(F-2.353350830078125
F-2.547144282947887
tp10305
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10306
(F-2.7039678430044525
F-2.476198369806463
tp10307
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p10308
(F-2.269864715798928
F-2.4870683496648613
tp10309
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p10310
(F-2.4527014370622306
F-2.664766311645508
tp10311
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10312
(F-2.0987624057503633
F-2.4442563490434126
tp10313
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p10314
(F-2.3323419744318183
F-2.458912415937944
tp10315
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p10316
(F-2.0694120599982444
F-2.4156958840110083
tp10317
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10318
(F-2.0583578256460338
F-2.4345743005925957
tp10319
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1'
p10320
(F-1.7053351508246528
F-2.467786442149769
tp10321
sS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p10322
(F-1.5035922076251056
F-2.3529713370583276
tp10323
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p10324
(F-2.180120524570081
F-2.426150582053445
tp10325
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p10326
(F-2.204640588095022
F-2.4291647130792793
tp10327
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10328
(F-2.3264263377470127
F-2.4910273118452593
tp10329
sS'import time\nimport mmap\nimport random'
p10330
(F-2.886140060424805
F-2.3854224465110083
tp10331
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10332
(F-2.949862370725538
F-2.424369291825728
tp10333
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10334
(F-2.2471945420751034
F-2.4523547779430044
tp10335
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p10336
(F-2.0688802083333333
F-2.414425589821555
tp10337
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1"
p10338
(F-2.1146884183271215
F-2.452035730535334
tp10339
sS"lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138"
p10340
(F-2.2997688194373986
F-2.4297703829678623
tp10341
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p10342
(F-1.9081404602643355
F-2.452946749600497
tp10343
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10344
(F-2.2405474698996244
F-2.466935938054865
tp10345
sS'import random'
p10346
(F-3.54302978515625
F-2.5269758051091973
tp10347
sS"buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10348
(F-2.288508628731343
F-2.4685231989080254
tp10349
sS'import time'
p10350
(F-2.6658291816711426
F-2.380868911743164
tp10351
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p10352
(F-1.9825890751208288
F-2.454063068736683
tp10353
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p10354
(F-2.609552764892578
F-2.4145247719504614
tp10355
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p10356
(F-1.8605581665039062
F-2.431762001731179
tp10357
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p10358
(F-2.2896490942073773
F-2.4484282406893643
tp10359
sS'lines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p10360
(F-3.5920333862304688
F-2.595629258589311
tp10361
sS'buf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p10362
(F-3.2508451673719616
F-2.622119730169123
tp10363
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p10364
(F-2.1897460635345762
F-2.4596247239546343
tp10365
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p10366
(F-1.79341066800631
F-2.427207253196023
tp10367
sS'import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p10368
(F-1.6646672001591436
F-2.3390613902698862
tp10369
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p10370
(F-2.074696396336411
F-2.4828357696533203
tp10371
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10372
(F-2.4377118395520494
F-2.466929175636985
tp10373
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p10374
(F-2.232829106318486
F-2.4650086489590732
tp10375
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p10376
(F-1.913068135579427
F-2.3744562322443183
tp10377
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)'
p10378
(F-2.558741783028218
F-2.5670224970037285
tp10379
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read'
p10380
(F-2.7105644039991423
F-2.596617958762429
tp10381
sS"assert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)"
p10382
(F-2.7721594351309315
F-2.528716347434304
tp10383
sS'buf = read_f(buf_size)'
p10384
(F-3.694822311401367
F-2.542265458540483
tp10385
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10386
(F-2.495645669790415
F-2.498421408913352
tp10387
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)"
p10388
(F-2.1808827367322197
F-2.474898425015536
tp10389
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p10390
(F-1.8929684846297554
F-2.3884896365079014
tp10391
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert func('big_file.txt') == 1209138\ncounts[func].append(time.time() - start_time)\nfor key, vals in counts.items():\n    pass\n"
p10392
(F-2.242632259022106
F-2.410694642500444
tp10393
sS'buf = read_f(buf_size)\nwhile buf:\n    pass'
p10394
(F-3.0786321640014647
F-2.486797506159002
tp10395
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p10396
(F-2.160158573673461
F-2.4567921378395776
tp10397
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p10398
(F-2.1159069485134547
F-2.430582046508789
tp10399
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p10400
(F-2.2188165126702724
F-2.428952303799716
tp10401
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass"
p10402
(F-2.0536159046909264
F-2.4406681060791016
tp10403
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024'
p10404
(F-2.286537287785457
F-2.566710732199929
tp10405
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for i, l in enumerate(f):\n            pass\nreturn i + 1\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p10406
(F-2.211108503670528
F-2.4654612107710405
tp10407
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = 1024 * 1024\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p10408
(F-2.354197130705181
F-2.477911342274059
tp10409
ssI6416131
(dp10410
S"{'test1': 1} + Dict(test2=2)"
p10411
(F-3.689931869506836
F-2.425318717956543
tp10412
sS'copy = self.copy()'
p10413
(F-2.774158901638455
F-2.1651065349578857
tp10414
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()'
p10415
(F-1.6145217418670654
F-2.1662731170654297
tp10416
sS'class Dict(dict):\n\n    def __add__(self, other):\n        pass'
p10417
(F-1.4214569972111628
F-2.192995548248291
tp10418
sS"default_data + {'item3': 3}\n{'test1': 1} + Dict(test2=2)"
p10419
(F-3.7799015045166016
F-2.3562746047973633
tp10420
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}\n{'test1': 1} + Dict(test2=2)"
p10421
(F-3.010537940335561
F-2.1790966987609863
tp10422
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p10423
(F-2.5125496604225854
F-2.2363877296447754
tp10424
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}\n{'test1': 1} + Dict(test2=2)"
p10425
(F-3.322573194316789
F-2.247380256652832
tp10426
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}\n{'test1': 1} + Dict(test2=2)"
p10427
(F-2.610884013928865
F-2.1972713470458984
tp10428
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}"
p10429
(F-3.0858483565481087
F-2.167466163635254
tp10430
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p10431
(F-2.455142339070638
F-2.308846950531006
tp10432
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}"
p10433
(F-2.6233318781448625
F-2.153266668319702
tp10434
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p10435
(F-2.6542152582212934
F-2.245290756225586
tp10436
sS'copy.update(self)'
p10437
(F-3.0740928649902344
F-2.2063422203063965
tp10438
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}"
p10439
(F-2.722202361576141
F-2.1790080070495605
tp10440
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})"
p10441
(F-2.6847025553385415
F-2.135498046875
tp10442
sS'copy = other.copy()'
p10443
(F-2.8676749335394964
F-2.1589744091033936
tp10444
sS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p10445
(F-2.2587437629699707
F-2.3115246295928955
tp10446
sS'def __radd__(self, other):\n    pass'
p10447
(F-1.598725438117981
F-2.8473973274230957
tp10448
sS'return copy\n\ndef __radd__(self, other):\n    pass'
p10449
(F-2.1116403579711913
F-2.6905388832092285
tp10450
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})"
p10451
(F-2.2930831070784685
F-2.1596145629882812
tp10452
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}"
p10453
(F-2.9495130969632055
F-2.3766987323760986
tp10454
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p10455
(F-2.208914830134465
F-2.3359649181365967
tp10456
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p10457
(F-2.3859782363429214
F-2.298335552215576
tp10458
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p10459
(F-1.9709306914230873
F-2.1840691566467285
tp10460
sS'class Dict(dict):\n    pass'
p10461
(F-1.5436862309773762
F-2.230820894241333
tp10462
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}\n{'test1': 1} + Dict(test2=2)"
p10463
(F-2.8695587582058377
F-2.1951823234558105
tp10464
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy'
p10465
(F-2.0332859584263394
F-2.1607680320739746
tp10466
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p10467
(F-2.1841729653848185
F-2.1727962493896484
tp10468
sS'copy.update(other)'
p10469
(F-2.9114136695861816
F-2.1501269340515137
tp10470
sS"default_data.update({'item3': 3})"
p10471
(F-2.193516050066267
F-2.451995372772217
tp10472
sS'def __radd__(self, other):\n    copy = other.copy()'
p10473
(F-1.8651254827325994
F-2.352879047393799
tp10474
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}\n{'test1': 1} + Dict(test2=2)"
p10475
(F-3.2757349881258877
F-2.3726563453674316
tp10476
sS'copy.update(self)\nreturn copy'
p10477
(F-3.5810810435901987
F-2.20479154586792
tp10478
sS"default_data + {'item3': 3}"
p10479
(F-3.4711470170454546
F-2.8270206451416016
tp10480
sS"default_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}"
p10481
(F-2.65228271484375
F-2.4242374897003174
tp10482
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}"
p10483
(F-2.827872358049665
F-2.141141414642334
tp10484
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})"
p10485
(F-2.5494571901717276
F-2.174520492553711
tp10486
sS"default_data['item3'] = 3"
p10487
(F-2.7485397338867186
F-2.7439591884613037
tp10488
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p10489
(F-2.1500704053422095
F-2.161045551300049
tp10490
sS'return copy'
p10491
(F-3.426121234893799
F-2.4013636112213135
tp10492
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})"
p10493
(F-2.4190624003507653
F-2.147576332092285
tp10494
sS"default_data = Dict({'item1': 1, 'item2': 2})"
p10495
(F-2.2714962429470487
F-2.415384292602539
tp10496
sS'copy.update(other)\nreturn copy'
p10497
(F-3.5014273903586646
F-2.1684181690216064
tp10498
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)'
p10499
(F-1.921251737154447
F-2.139863967895508
tp10500
sS'def __add__(self, other):\n    pass'
p10501
(F-1.6931123733520508
F-2.8471744060516357
tp10502
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p10503
(F-2.02992582321167
F-2.163573980331421
tp10504
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})"
p10505
(F-2.9794627598353793
F-2.160987377166748
tp10506
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2})"
p10507
(F-2.737917945498512
F-2.3719146251678467
tp10508
sS'def __add__(self, other):\n    copy = self.copy()'
p10509
(F-1.8509559631347656
F-2.2944579124450684
tp10510
sS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p10511
(F-2.1334144329202585
F-2.302316665649414
tp10512
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}"
p10513
(F-2.4340885275661357
F-2.163926124572754
tp10514
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p10515
(F-2.605636215209961
F-2.232551097869873
tp10516
sS"default_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}\n{'test1': 1} + Dict(test2=2)"
p10517
(F-3.082570517935404
F-2.3620834350585938
tp10518
sS"default_data.update({'item4': 4, 'item5': 5})"
p10519
(F-1.8326076931423612
F-2.4507737159729004
tp10520
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p10521
(F-2.504100375705295
F-2.312645673751831
tp10522
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2})\ndefault_data + {'item3': 3}\n{'test1': 1} + Dict(test2=2)"
p10523
(F-2.9401520176937708
F-2.225862979888916
tp10524
ssI53513
(dp10525
S'if not a:\n    pass'
p10526
(F-1.5073230743408204
F-1.8745907870205967
tp10527
sS'if not a:\n    pass\n'
p10528
(F-1.5073230743408204
F-1.8745907870205967
tp10529
sS"print 'the list is empty'"
p10530
(F-2.346153974533081
F-2.1872447620738638
tp10531
sS'if len(li) == 0:\n    pass'
p10532
(F-1.35318238394601
F-1.7789506045254795
tp10533
sS"print 'List is empty'"
p10534
(F-2.346153974533081
F-2.1872447620738638
tp10535
sS'if len(li) == 0:\n    pass\n'
p10536
(F-1.35318238394601
F-1.7789506045254795
tp10537
ssI849674
(dp10538
S'print errtxt'
p10539
(F-3.414302349090576
F-3.484205118815104
tp10540
sS"import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring\nif __name__ == '__main__':\n    pass"
p10541
(F-2.2409331377814796
F-3.4864476521809897
tp10542
sS"if __name__ == '__main__':\n    pass"
p10543
(F-1.1596530033991888
F-3.4274915059407554
tp10544
sS'import thread, time'
p10545
(F-2.661656697591146
F-3.232159169514974
tp10546
sS"def myfunction(mystring, *args):\n    print mystring\nif __name__ == '__main__':\n    pass"
p10547
(F-2.352704184395926
F-3.5648643493652346
tp10548
sS'while 1:\n    pass'
p10549
(F-1.7843057844373915
F-3.3158218383789064
tp10550
sS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    pass'
p10551
(F-2.328336443219866
F-3.4328369140625
tp10552
sS'import thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p10553
(F-3.132423973083496
F-3.483221435546875
tp10554
sS'import thread'
p10555
(F-2.893648147583008
F-3.3127515157063803
tp10556
sS"Thread(target=myfunction, args=('MyStringHere', 1)).start()"
p10557
(F-1.5306684494018554
F-3.3538658142089846
tp10558
sS'def myfunction(mystring, *args):\n    pass'
p10559
(F-2.906513214111328
F-3.528265889485677
tp10560
sS'def myfunction(mystring, *args):\n    print mystring'
p10561
(F-3.3920769691467285
F-3.5516372680664063
tp10562
sS't.start()\nt.join()'
p10563
(F-1.1809114309457631
F-3.441046142578125
tp10564
sS't.start()'
p10565
(F-1.2707871028355189
F-3.3533236185709634
tp10566
sS'pass'
p10567
(F-3.0549144744873047
F-3.53203862508138
tp10568
sS'time.sleep(5)'
p10569
(F-0.8343661427497864
F-3.2375025431315105
tp10570
sS'print mystring'
p10571
(F-5.340108871459961
F-3.8188936869303385
tp10572
sS"import thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif __name__ == '__main__':\n    pass"
p10573
(F-2.3134677410125732
F-3.5029998779296876
tp10574
sS't.join()'
p10575
(F-1.5034033911568778
F-3.7526982625325522
tp10576
sS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p10577
(F-2.734296451915394
F-3.4525423685709637
tp10578
sS'from threading import Thread'
p10579
(F-1.201985279719035
F-3.3225011189778644
tp10580
sS'import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring'
p10581
(F-2.9430500377308237
F-3.4694239298502603
tp10582
sS'import thread\n\ndef myfunction(mystring, *args):\n    pass'
p10583
(F-2.7402903908177425
F-3.4587661743164064
tp10584
sS"from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif __name__ == '__main__':\n    pass"
p10585
(F-2.1001562230727253
F-3.4747879028320314
tp10586
sS'import thread, time\n\ndef myfunction(mystring, *args):\n    pass'
p10587
(F-2.5778427124023438
F-3.440010579427083
tp10588
sS"thread.start_new_thread(myfunction, ('MyStringHere', 1))"
p10589
(F-2.5457176632351346
F-3.257180023193359
tp10590
sS"t = Thread(None, myfunction, None, ('MyStringHere', 1))"
p10591
(F-3.0232533348931208
F-3.24352544148763
tp10592
ssI8270092
(dp10593
S"pattern = re.compile('\\\\s+')"
p10594
(F-1.129399299621582
F-2.0351282755533853
tp10595
sS'import re'
p10596
(F-2.344480514526367
F-1.9461731380886502
tp10597
sS'"""hello apple"""'
p10598
(F-2.01163387298584
F-2.3349906073676214
tp10599
sS"import re\npattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p10600
(F-1.0880435063288763
F-1.9605125851101346
tp10601
sS'"""hello  apple"""'
p10602
(F-2.01163387298584
F-2.3349906073676214
tp10603
sS"import re\npattern = re.compile('\\\\s+')"
p10604
(F-0.9762397179236779
F-1.9471677144368489
tp10605
sS"sentence = re.sub('\\\\s+', '', sentence, flags=re.UNICODE)"
p10606
(F-1.3878751754760743
F-1.9940206739637587
tp10607
sS"sentence = sentence.replace(' ', '')"
p10608
(F-1.7910143534342449
F-1.9097599453396268
tp10609
sS'sentence = sentence.strip()'
p10610
(F-2.4257939656575522
F-1.8715960184733074
tp10611
sS"sentence = re.sub(pattern, '', sentence)"
p10612
(F-1.78952271597726
F-1.9394823710123699
tp10613
sS'"""helloapple"""'
p10614
(F-2.01163387298584
F-2.3349906073676214
tp10615
sS"sentence = ''.join(sentence.split())"
p10616
(F-1.4963833945138114
F-1.8902854919433594
tp10617
sS"pattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p10618
(F-1.2368520653766135
F-2.0046785142686634
tp10619
ssI227459
(dp10620
S'chr(97)'
p10621
(F-2.8432210286458335
F-2.9335447947184243
tp10622
sS"chr(ord('a') + 3)"
p10623
(F-1.7057219418612393
F-2.9810888502332897
tp10624
sS'ord()'
p10625
(F-2.4531103134155274
F-2.9688551161024304
tp10626
sS'unichr(1234)'
p10627
(F-3.313464800516764
F-2.931464513142904
tp10628
sS'unichr(97)'
p10629
(F-3.3038864135742188
F-2.9219239552815757
tp10630
sS"ord('a')"
p10631
(F-1.5880829493204753
F-2.9414159986707897
tp10632
sS"chr(97)\nchr(ord('a') + 3)"
p10633
(F-2.2761878967285156
F-3.014401329888238
tp10634
sS'unichr(97)\nunichr(1234)'
p10635
(F-3.523781516335227
F-2.963187323676215
tp10636
sS"ord(u'\\u3042')"
p10637
(F-1.5880829493204753
F-2.9414159986707897
tp10638
sS"ord('a')\nchr(97)\nchr(ord('a') + 3)"
p10639
(F-2.156597137451172
F-3.033533732096354
tp10640
sS"ord('a')\nchr(97)"
p10641
(F-2.5177733681418677
F-2.9669657813178167
tp10642
ssI931092
(dp10643
S'step = -1'
p10644
(F-3.0825980504353843
F-3.0839478628976003
tp10645
sS"a_string = 'amanaplanacanalpanama' * 10"
p10646
(F-3.0750836266411676
F-1.9793191637311662
tp10647
sS'min(timeit.repeat(lambda : reverse_a_string_slowly(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_more_slowly(a_string)))'
p10648
(F-3.7282636992785396
F-2.1558476856776645
tp10649
sS'def reverse_a_string_slowly(a_string):\n    pass'
p10650
(F-2.406221389770508
F-1.7110463551112585
tp10651
sS'reverse_slice = slice(start, stop, step)\n"""foo"""[reverse_slice]'
p10652
(F-4.012248084658668
F-1.9860685893467493
tp10653
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]"
p10654
(F-1.9917058591489438
F-1.7675489698137556
tp10655
sS"return ''.join(reversed(string))"
p10656
(F-1.625913937886556
F-1.7394542694091797
tp10657
sS'string[slice_obj]'
p10658
(F-3.7289392948150635
F-1.8180969783238001
tp10659
sS'return new_string'
p10660
(F-2.3751490910847983
F-1.8745900562831335
tp10661
sS"while index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p10662
(F-2.164442443847656
F-1.8726039613996233
tp10663
sS'step = -1\nreverse_slice = slice(start, stop, step)'
p10664
(F-3.403592962967722
F-2.286717006138393
tp10665
sS"index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p10666
(F-2.0550226731733843
F-1.8856845583234514
tp10667
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1"
p10668
(F-2.0170222437658976
F-1.809807368687221
tp10669
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p10670
(F-2.1934300590963924
F-1.9151857921055384
tp10671
sS'start = stop = None\nstep = -1\nreverse_slice = slice(start, stop, step)\n"""foo"""[reverse_slice]'
p10672
(F-3.74058198928833
F-2.212179865155901
tp10673
sS'index = len(a_string)'
p10674
(F-2.779457855224609
F-1.9079207011631556
tp10675
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    pass"
p10676
(F-2.084634362197504
F-1.7557268142700195
tp10677
sS'start = stop = None\nstep = -1'
p10678
(F-3.5896100997924805
F-2.4180491311209544
tp10679
sS"a_string = 'amanaplanacanalpanama' * 10\nmin(timeit.repeat(lambda : reverse_string_readable_answer(a_string)))\nmin(timeit.repeat(lambda : reversed_string(a_string)))"
p10680
(F-3.582130282532935
F-2.0364294052124023
tp10681
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p10682
(F-2.136305491129557
F-1.9707072121756417
tp10683
sS'def reverse_a_string_more_slowly(a_string):\n    pass'
p10684
(F-2.775467785921964
F-1.792015620640346
tp10685
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)'
p10686
(F-2.4639114803738065
F-1.7764248166765486
tp10687
sS"return ''.join(new_strings)"
p10688
(F-1.4691295623779297
F-1.8634014129638672
tp10689
sS'min(timeit.repeat(lambda : reverse_a_string_more_slowly(a_string)))'
p10690
(F-3.8041604849008412
F-2.1172357286725725
tp10691
sS'slice_obj = slice(start, stop, step)'
p10692
(F-3.619125093732561
F-2.210508346557617
tp10693
sS'new_strings = []'
p10694
(F-2.07180118560791
F-1.7807362420218331
tp10695
sS'index -= 1'
p10696
(F-3.3017196655273438
F-2.1862361090523854
tp10697
sS'while index:\n    index -= 1\nnew_string += a_string[index]'
p10698
(F-2.4211384166370737
F-1.9048401968819755
tp10699
sS'reverse_slice = slice(start, stop, step)'
p10700
(F-3.897472654070173
F-2.025505474635533
tp10701
sS'min(timeit.repeat(lambda : reverse_string_readable_answer(a_string)))\nmin(timeit.repeat(lambda : reversed_string(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_slowly(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_more_slowly(a_string)))'
p10702
(F-3.7718925056876715
F-2.165054593767439
tp10703
sS'min(timeit.repeat(lambda : reverse_string_readable_answer(a_string)))\nmin(timeit.repeat(lambda : reversed_string(a_string)))'
p10704
(F-3.795722429142442
F-2.134756633213588
tp10705
sS'step = -1\nreverse_slice = slice(start, stop, step)\n"""foo"""[reverse_slice]'
p10706
(F-3.6833402193509617
F-2.2268713542393277
tp10707
sS'min(timeit.repeat(lambda : reverse_string_readable_answer(a_string)))'
p10708
(F-3.7529608408610025
F-2.077246529715402
tp10709
sS"new_string = ''"
p10710
(F-1.6614510672433036
F-2.0116525377546037
tp10711
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    pass'
p10712
(F-2.3833789825439453
F-1.768364770071847
tp10713
sS'min(timeit.repeat(lambda : reverse_string_readable_answer(a_string)))\nmin(timeit.repeat(lambda : reversed_string(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_slowly(a_string)))'
p10714
(F-3.741947058475379
F-2.1648458753313338
tp10715
sS'def reversed_string(a_string):\n    return a_string[::-1]'
p10716
(F-1.6013374328613281
F-1.6913622447422572
tp10717
sS"a_string = 'amanaplanacanalpanama' * 10\nmin(timeit.repeat(lambda : reverse_string_readable_answer(a_string)))"
p10718
(F-3.5624594688415527
F-1.9451307569231306
tp10719
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []'
p10720
(F-2.476865980360243
F-1.7196459089006697
tp10721
sS'"""foo"""[::-1]'
p10722
(F-1.7505644692314997
F-1.996161597115653
tp10723
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]'
p10724
(F-2.2093651063980593
F-1.9065798350742884
tp10725
sS'min(timeit.repeat(lambda : reversed_string(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_slowly(a_string)))'
p10726
(F-3.7786166168922604
F-2.18779604775565
tp10727
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p10728
(F-2.214403025309245
F-1.7888058253696986
tp10729
sS'min(timeit.repeat(lambda : reverse_a_string_slowly(a_string)))'
p10730
(F-3.576493581136068
F-2.1526167733328685
tp10731
sS'string[start:stop:step]'
p10732
(F-3.1477005004882814
F-1.90181337084089
tp10733
sS'slice_obj = slice(start, stop, step)\nstring[slice_obj]'
p10734
(F-3.6696904500325522
F-2.099134990147182
tp10735
sS'start = stop = None'
p10736
(F-4.25349725995745
F-2.2600782939365933
tp10737
sS'min(timeit.repeat(lambda : reversed_string(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_slowly(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_more_slowly(a_string)))'
p10738
(F-3.814901912913603
F-2.1820496150425504
tp10739
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1'
p10740
(F-2.312815293021824
F-1.8131633486066545
tp10741
sS'new_string += a_string[index]\nreturn new_string'
p10742
(F-2.235194486730239
F-1.938443320138114
tp10743
sS"new_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p10744
(F-1.9324888610839843
F-1.8529069083077567
tp10745
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)"
p10746
(F-2.0934258663293086
F-1.7740569795880998
tp10747
sS'new_string += a_string[index]'
p10748
(F-2.4879798889160156
F-1.8646082196916853
tp10749
sS'index = len(a_string)\nwhile index:\n    pass'
p10750
(F-2.527137968275282
F-1.871577262878418
tp10751
sS'def reversed_string(a_string):\n    pass'
p10752
(F-2.344374418258667
F-1.7106617518833704
tp10753
sS'return a_string[::-1]'
p10754
(F-1.973031997680664
F-1.7596228463309151
tp10755
sS"def reverse_string_readable_answer(string):\n    return ''.join(reversed(string))"
p10756
(F-1.7419011151349102
F-1.6777046748570033
tp10757
sS'"""foo"""[reverse_slice]'
p10758
(F-3.551802158355713
F-1.9339275360107422
tp10759
sS"a_string = 'amanaplanacanalpanama' * 10\nmin(timeit.repeat(lambda : reverse_string_readable_answer(a_string)))\nmin(timeit.repeat(lambda : reversed_string(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_slowly(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_more_slowly(a_string)))"
p10760
(F-3.6344900420217803
F-2.0984691892351424
tp10761
sS'while index:\n    pass'
p10762
(F-2.497642093234592
F-2.226912498474121
tp10763
sS'min(timeit.repeat(lambda : reversed_string(a_string)))'
p10764
(F-3.8817703247070314
F-2.1597502572195872
tp10765
sS'while index:\n    index -= 1'
p10766
(F-2.310090325095437
F-2.4062012263706754
tp10767
sS'start = stop = None\nstep = -1\nreverse_slice = slice(start, stop, step)'
p10768
(F-3.493807373046875
F-2.28166321345738
tp10769
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''"
p10770
(F-2.0688411394755044
F-1.7566078730991908
tp10771
sS"a_string = 'amanaplanacanalpanama' * 10\nmin(timeit.repeat(lambda : reverse_string_readable_answer(a_string)))\nmin(timeit.repeat(lambda : reversed_string(a_string)))\nmin(timeit.repeat(lambda : reverse_a_string_slowly(a_string)))"
p10772
(F-3.5743709254909204
F-2.081383432660784
tp10773
sS'string[subscript]'
p10774
(F-2.9136584599812827
F-1.8080949783325195
tp10775
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string"
p10776
(F-1.9558198573225636
F-1.842700685773577
tp10777
sS"reversed_string('foo')"
p10778
(F-3.0456056594848633
F-1.749462400163923
tp10779
sS'index = len(a_string)\nwhile index:\n    index -= 1'
p10780
(F-2.3128742218017577
F-1.981710978916713
tp10781
sS'"""hello world"""[::-1]'
p10782
(F-1.7505644692314997
F-1.996161597115653
tp10783
sS'def reverse_string_readable_answer(string):\n    pass'
p10784
(F-2.3492827945285373
F-1.6632018770490373
tp10785
sS'new_strings.append(a_string[index])'
p10786
(F-2.119740041097005
F-1.8291665485927038
tp10787
sS'while index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p10788
(F-2.282944573296441
F-1.9674600873674666
tp10789
sS'while index:\n    index -= 1\nnew_strings.append(a_string[index])'
p10790
(F-2.372784423828125
F-1.9006874901907784
tp10791
sS"def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p10792
(F-2.095284162248884
F-1.7759876251220703
tp10793
ssI415511
(dp10794
S'import datetime'
p10795
(F-2.2980048656463623
F-1.1689333385891385
tp10796
sS'from time import gmtime, strftime'
p10797
(F-2.243234157562256
F-1.1263007058037653
tp10798
sS'datetime.datetime.now()'
p10799
(F-0.9034682379828559
F-1.0565049913194444
tp10800
sS'str(datetime.now())'
p10801
(F-1.71566162109375
F-1.158660888671875
tp10802
sS'datetime.datetime.time(datetime.datetime.now())'
p10803
(F-1.5840609073638916
F-1.0368725458780925
tp10804
sS'from datetime import datetime'
p10805
(F-1.5713707605997722
F-1.1969910727606878
tp10806
sS'datetime.datetime.now().time()'
p10807
(F-0.816284913283128
F-1.0383000903659396
tp10808
sS'import datetime\ndatetime.datetime.now()'
p10809
(F-0.7139867146809896
F-0.9978136486477323
tp10810
sS"from time import gmtime, strftime\nstrftime('%Y-%m-%d %H:%M:%S', gmtime())"
p10811
(F-2.01758373484892
F-1.1530757480197482
tp10812
sS"strftime('%Y-%m-%d %H:%M:%S', gmtime())"
p10813
(F-2.1060182571411135
F-1.5130869547526042
tp10814
sS'from datetime import datetime\nstr(datetime.now())'
p10815
(F-1.366382853190104
F-1.0521638658311632
tp10816
ssI14043934
(dp10817
S'import datetime'
p10818
(F-2.2339444160461426
F-2.8718402862548826
tp10819
sS'dt = datetime.datetime.combine(datetime.date.today(), t)'
p10820
(F-1.5147421836853028
F-3.189991760253906
tp10821
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p10822
(F-1.665797840465199
F-3.158199501037598
tp10823
sS'dt -= datetime.timedelta(hours=5)'
p10824
(F-1.7634817759195964
F-3.364166259765625
tp10825
sS't = datetime.datetime.now()\nt - datetime.timedelta(hours=1, minutes=10)'
p10826
(F-1.4169647510235126
F-2.8025131225585938
tp10827
sS'import datetime\nt = datetime.datetime.now()'
p10828
(F-0.8908256122044155
F-2.7507404327392577
tp10829
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p10830
(F-1.6212666829427083
F-3.128826904296875
tp10831
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)'
p10832
(F-1.4016004993069557
F-2.860814666748047
tp10833
sS'dt -= datetime.timedelta(hours=5)\ndt.time()'
p10834
(F-1.7480515374077692
F-3.2857429504394533
tp10835
sS'dt.time()'
p10836
(F-1.681229591369629
F-3.2978981018066404
tp10837
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p10838
(F-1.5601537877863103
F-2.8680187225341798
tp10839
sS'import datetime\nt = datetime.datetime.now()\nt - datetime.timedelta(hours=1, minutes=10)'
p10840
(F-1.1974626738449623
F-2.689630126953125
tp10841
sS'dt\ndt -= datetime.timedelta(hours=5)'
p10842
(F-2.2388132640293668
F-3.4133277893066407
tp10843
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p10844
(F-1.8311295942826704
F-3.135659027099609
tp10845
sS't = datetime.time(1, 2)'
p10846
(F-1.4881332715352376
F-2.9680105209350587
tp10847
sS't = datetime.datetime.now()'
p10848
(F-1.2075665213844993
F-2.9177059173583983
tp10849
sS'dt'
p10850
(F-5.005462010701497
F-3.466482162475586
tp10851
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p10852
(F-1.5445404052734375
F-2.8575233459472655
tp10853
sS'dt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p10854
(F-2.0207212448120115
F-3.3412006378173826
tp10855
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p10856
(F-1.6230445630622632
F-2.8201013565063477
tp10857
sS't - datetime.timedelta(hours=1, minutes=10)'
p10858
(F-1.7667860984802246
F-2.9664039611816406
tp10859
ssI1400608
(dp10860
S'lst[:] = []'
p10861
(F-1.5429532792833116
F-1.4170794486999512
tp10862
sS'lst1 = [1, 2, 3]\nlst2 = lst1\ndel lst1[:]\nprint lst2'
p10863
(F-3.2049687703450522
F-1.7511383056640626
tp10864
sS'lst2 = lst1\ndel lst1[:]'
p10865
(F-4.279832319779829
F-1.7069915771484374
tp10866
sS'alist[:] = []'
p10867
(F-1.8706427680121527
F-1.515449047088623
tp10868
sS'alist.clear()'
p10869
(F-3.100265775408064
F-1.7203903198242188
tp10870
sS'lst1 = [1, 2, 3]\nlst2 = lst1\ndel lst1[:]'
p10871
(F-3.045084998721168
F-1.8127431869506836
tp10872
sS'del lst1[:]'
p10873
(F-3.1106025150844028
F-1.615776252746582
tp10874
sS'lst1 = [1, 2, 3]\nlst2 = lst1'
p10875
(F-3.15426025390625
F-1.778985595703125
tp10876
sS'lst2 = lst1'
p10877
(F-6.2549182891845705
F-1.632925033569336
tp10878
sS'del lst1[:]\nprint lst2'
p10879
(F-3.640598678588867
F-1.584097671508789
tp10880
sS'del lst[:]'
p10881
(F-1.9680961881365096
F-1.4266669273376464
tp10882
sS'lst1 = [1, 2, 3]'
p10883
(F-2.0123797329989346
F-1.765341567993164
tp10884
sS'print lst2'
p10885
(F-4.942388534545898
F-1.573985481262207
tp10886
sS'lst2 = lst1\ndel lst1[:]\nprint lst2'
p10887
(F-4.247843333653042
F-1.6805349349975587
tp10888
ssI1949318
(dp10889
S'import httplib'
p10890
(F-3.5843474864959717
F-3.3229026794433594
tp10891
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10892
(F-1.1968250889931955
F-3.2071308135986327
tp10893
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10894
(F-1.2566164970397948
F-3.143745994567871
tp10895
sS"conn = httplib.HTTPConnection('www.python.org')"
p10896
(F-1.3907066692005505
F-3.1128334045410155
tp10897
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p10898
(F-1.0557226098102073
F-3.1293434143066405
tp10899
sS"conn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10900
(F-1.6320745680067275
F-3.308003234863281
tp10901
sS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)'
p10902
(F-1.7212844848632813
F-3.0766469955444338
tp10903
sS'r1 = conn.getresponse()'
p10904
(F-2.8120089636908636
F-3.3481674194335938
tp10905
sS"print urllib.urlopen('http://www.stackoverflow.com').getcode()"
p10906
(F-1.4815660623403697
F-3.104510498046875
tp10907
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')"
p10908
(F-1.3795479365757533
F-3.1473457336425783
tp10909
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p10910
(F-1.0717552185058594
F-3.147836685180664
tp10911
sS'return r.status_code == 200'
p10912
(F-2.2478431701660155
F-3.387378692626953
tp10913
sS"conn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10914
(F-1.6871472111454717
F-3.1873607635498047
tp10915
sS"conn.request('HEAD', '/')"
p10916
(F-1.1780523300170898
F-3.3593048095703124
tp10917
sS'200'
p10918
(F-4.819446563720703
F-3.6449378967285155
tp10919
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10920
(F-1.3166359566353463
F-3.1419452667236327
tp10921
sS'r = requests.head(url)'
p10922
(F-2.0307687759399413
F-3.2823909759521483
tp10923
sS'print r1.status, r1.reason'
p10924
(F-3.185826873779297
F-3.3588031768798827
tp10925
sS'def url_ok(url):\n    pass'
p10926
(F-2.102733884538923
F-3.1926105499267576
tp10927
sS'r1 = conn.getresponse()\nprint r1.status, r1.reason'
p10928
(F-2.3009012010362415
F-3.268635940551758
tp10929
sS'import requests\n\ndef url_ok(url):\n    pass'
p10930
(F-1.6634067959255643
F-3.0204259872436525
tp10931
sS'def url_ok(url):\n    r = requests.head(url)\nreturn r.status_code == 200'
p10932
(F-1.9952150980631511
F-3.145066833496094
tp10933
sS'import requests'
p10934
(F-2.1146318912506104
F-3.0228614807128906
tp10935
sS'def url_ok(url):\n    r = requests.head(url)'
p10936
(F-2.078526088169643
F-3.141439437866211
tp10937
sS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)\nreturn r.status_code == 200'
p10938
(F-1.733582103953642
F-3.081435966491699
tp10939
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10940
(F-1.241626467023577
F-3.2248794555664064
tp10941
sS"print urllib.urlopen('http://www.stackoverflow.com').getcode()\n200"
p10942
(F-1.8725176493326823
F-3.104388618469238
tp10943
ssI2052390
(dp10944
S'if 0 < distance <= RADIUS:\n    pass'
p10945
(F-3.3181117131159854
F-4.575712377374822
tp10946
sS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    pass'
p10947
(F-2.2790261404854912
F-4.589155023748225
tp10948
sS'raise AppError, error, sys.exc_info()[2]\nraise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p10949
(F-2.028182103083684
F-4.709970300847834
tp10950
sS'raise AppError, error, sys.exc_info()[2]'
p10951
(F-2.4709529876708984
F-4.903366435657848
tp10952
sS'if foo not in _ALLOWED_ARGS:\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10953
(F-2.147590900289601
F-4.759211106733843
tp10954
sS"'message', 'foo', 'bar', 'baz'"
p10955
(F-1.7632120980156794
F-4.670696605335582
tp10956
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)\nraise'
p10957
(F-2.400478553771973
F-4.440432808615944
tp10958
sS'do_something_in_app_that_breaks_easily()'
p10959
(F-2.9822271010454964
F-4.536466425115412
tp10960
sS'class MyAppLookupError(LookupError):\n    """raise this when there\'s a lookup error for my app"""'
p10961
(F-3.8189220428466797
F-4.993130423805931
tp10962
sS'raise'
p10963
(F-3.181891759236654
F-4.47458926114169
tp10964
sS"raise MyAppLookupError('resource is missing, and that is not ok.')"
p10965
(F-4.215809631347656
F-5.204435868696733
tp10966
sS'logger.error(error)'
p10967
(F-2.6976542472839355
F-4.412429115988991
tp10968
sS'def api_func(foo):\n    """foo should be either \'baz\' or \'bar\'. returns something very useful."""\nif foo not in _ALLOWED_ARGS:\n    pass'
p10969
(F-2.6016023423936634
F-4.720974662087181
tp10970
sS'def api_func(foo):\n    """foo should be either \'baz\' or \'bar\'. returns something very useful."""'
p10971
(F-2.4361754826136996
F-4.72360576282848
tp10972
sS'def api_func(foo):\n    pass'
p10973
(F-2.2657198224748885
F-4.7414772727272725
tp10974
sS'demo_bad_catch()'
p10975
(F-4.201094309488933
F-4.532420418479226
tp10976
sS"raise Exception('I know python!')"
p10977
(F-1.12909391948155
F-4.468643535267223
tp10978
sS'raise error.with_traceback(sys.exc_info()[2])'
p10979
(F-2.728662300109863
F-4.430923115123402
tp10980
sS'"""raise this when there\'s a lookup error for my app"""'
p10981
(F-2.3437865575154624
F-4.641404238614169
tp10982
sS'print err.args'
p10983
(F-3.6268819173177085
F-4.488967548717152
tp10984
sS"raise 'message'"
p10985
(F-3.1344852447509766
F-4.557057467373935
tp10986
sS'"""foo should be either \'baz\' or \'bar\'. returns something very useful."""'
p10987
(F-2.3437865575154624
F-4.641404238614169
tp10988
sS'demo_no_catch()'
p10989
(F-3.9916500515407987
F-4.547451712868431
tp10990
sS'class MyAppLookupError(LookupError):\n    pass'
p10991
(F-3.6125009059906006
F-4.984386097301137
tp10992
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)'
p10993
(F-2.19131831118935
F-4.45299599387429
tp10994
sS"raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz')"
p10995
(F-1.392544882638114
F-4.55427343195135
tp10996
sS"raise Exception('I know Python!')"
p10997
(F-1.12909391948155
F-4.468643535267223
tp10998
sS'def api_func(foo):\n    """foo should be either \'baz\' or \'bar\'. returns something very useful."""\nif foo not in _ALLOWED_ARGS:\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10999
(F-2.242579323904855
F-4.692434137517756
tp11000
sS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print err.args'
p11001
(F-2.43904615703382
F-4.576122630726207
tp11002
sS"raise ValueError('A very specific bad thing happened')"
p11003
(F-1.0224401950836182
F-4.555983456698331
tp11004
sS'if important_key not in resource_dict and not ok_to_be_missing:\n    pass'
p11005
(F-3.477916564941406
F-5.005772677334872
tp11006
sS'some_code_that_may_raise_our_value_error()'
p11007
(F-3.5290302477384867
F-4.77417026866566
tp11008
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    pass'
p11009
(F-2.1754508740974194
F-4.541075966574929
tp11010
sS"raise ValueError, 'message'"
p11011
(F-1.8589845384870256
F-4.517375252463601
tp11012
sS'raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p11013
(F-1.7457171848842077
F-4.707467165860263
tp11014
sS"if important_key not in resource_dict and not ok_to_be_missing:\n    raise MyAppLookupError('resource is missing, and that is not ok.')"
p11015
(F-3.8343892097473145
F-4.864555705677379
tp11016
sS'if foo not in _ALLOWED_ARGS:\n    pass'
p11017
(F-2.7270216260637556
F-4.678218841552734
tp11018
sS'raise AssertionError("Unexpected value of \'distance\'!", distance)'
p11019
(F-2.9046321868896485
F-4.522705078125
tp11020
ssI2331943
(dp11021
S"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p11022
(F-1.5691819508870444
F-1.4948616027832031
tp11023
sS'try:\n    import json\nexcept ImportError:\n    pass'
p11024
(F-0.6864994896782769
F-1.6692841053009033
tp11025
sS'import urllib2'
p11026
(F-3.4764695167541504
F-2.142974376678467
tp11027
sS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p11028
(F-1.70155668258667
F-1.5361891984939575
tp11029
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p11030
(F-1.46156492687407
F-1.4690773487091064
tp11031
sS'import simplejson as json'
p11032
(F-1.8288690249125164
F-1.5735307931900024
tp11033
sS'print json.load(u)'
p11034
(F-2.210279252794054
F-1.5324472188949585
tp11035
sS'import json'
p11036
(F-1.6047359704971313
F-1.4799633026123047
tp11037
sS'import urllib2\nimport json'
p11038
(F-2.042278834751674
F-1.6862494945526123
tp11039
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p11040
(F-1.5298707750108507
F-1.4929594993591309
tp11041
sS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p11042
(F-1.6359623670578003
F-1.6460652351379395
tp11043
sS'u.close()'
p11044
(F-2.4307973044259206
F-2.4334397315979004
tp11045
sS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p11046
(F-1.534769058227539
F-1.4729344844818115
tp11047
sS'try:\n    import json\nexcept ImportError:\n    import simplejson as json'
p11048
(F-1.0083590007963634
F-1.5618982315063477
tp11049
sS"u = urllib2.urlopen('http://www.reddit.com/.json')"
p11050
(F-1.8794727325439453
F-2.0404434204101562
tp11051
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p11052
(F-1.519559566791241
F-1.6078102588653564
tp11053
sS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p11054
(F-1.673433197869195
F-1.5042386054992676
tp11055
sS'print json.load(u)\nu.close()'
p11056
(F-2.245780181884766
F-1.5482847690582275
tp11057
ssI273192
(dp11058
S'os.makedirs(path, exist_ok=True)'
p11059
(F-2.1225716727120534
F-2.849406433105469
tp11060
sS'if not os.path.exists(directory):\n    os.makedirs(directory)'
p11061
(F-0.7714954723011364
F-2.7137359619140624
tp11062
sS'os.makedirs(directory)'
p11063
(F-1.51982843875885
F-2.8626698811848956
tp11064
sS'distutils.dir_util.mkpath(path)'
p11065
(F-3.0369237263997397
F-2.8884251912434897
tp11066
sS'import distutils.dir_util'
p11067
(F-3.8168563842773438
F-2.9459627787272136
tp11068
sS'raise'
p11069
(F-4.086931546529134
F-3.267442830403646
tp11070
sS'import distutils.dir_util\ndistutils.dir_util.mkpath(path)'
p11071
(F-3.041553497314453
F-2.901381429036458
tp11072
sS'if not os.path.exists(directory):\n    pass'
p11073
(F-0.9270195680506089
F-2.637427266438802
tp11074
sS'import errno'
p11075
(F-4.122138500213623
F-3.026081339518229
tp11076
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    pass'
p11077
(F-0.8344006971879439
F-2.721558380126953
tp11078
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    if not os.path.isdir(path):\n        pass'
p11079
(F-0.8547946612040201
F-2.6815973917643228
tp11080
sS'import errno\n\ndef make_sure_path_exists(path):\n    pass'
p11081
(F-2.3334328044544566
F-2.914805603027344
tp11082
sS'import os'
p11083
(F-2.0800986289978027
F-2.8615099589029946
tp11084
sS'os.makedirs(path)'
p11085
(F-1.3756027221679688
F-2.858900960286458
tp11086
sS'if exception.errno != errno.EEXIST:\n    pass'
p11087
(F-2.37245356241862
F-3.1677523295084637
tp11088
sS'def make_sure_path_exists(path):\n    pass'
p11089
(F-2.22426520453559
F-2.8560882568359376
tp11090
sS'if not os.path.isdir(path):\n    pass'
p11091
(F-0.9588400896857766
F-2.703601582845052
tp11092
sS'if not os.path.isdir(path):\n    raise'
p11093
(F-1.1752927443560433
F-2.700587209065755
tp11094
sS'import os\nimport errno\n\ndef make_sure_path_exists(path):\n    pass'
p11095
(F-2.063719940185547
F-2.8670725504557293
tp11096
sS'import os\nimport errno'
p11097
(F-3.019373757498605
F-2.8968159993489584
tp11098
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    if not os.path.isdir(path):\n        raise'
p11099
(F-0.939658694797092
F-2.6765261332194012
tp11100
sS'if exception.errno != errno.EEXIST:\n    raise'
p11101
(F-2.4980573018391925
F-3.2038653055826822
tp11102
ssI14931769
(dp11103
S'[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]'
p11104
(F-1.1530301643140388
F-3.111516316731771
tp11105
sS'import itertools\nlst = list(itertools.product([0, 1], repeat=3))'
p11106
(F-1.538805643717448
F-2.947943369547526
tp11107
sS'for i in range(1 << n):\n    s = bin(i)[2:]'
p11108
(F-2.1029737854003905
F-3.2203362782796225
tp11109
sS'lst = list(map(list, itertools.product([0, 1], repeat=n)))'
p11110
(F-1.7753009796142578
F-3.04695192972819
tp11111
sS'def per(n):\n    for i in range(1 << n):\n        pass'
p11112
(F-1.7784403991699218
F-3.202078183492025
tp11113
sS'[0, 0, 0]\n[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]\n[1, 1, 1]'
p11114
(F-0.932283196082482
F-3.1263087590535483
tp11115
sS'[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]'
p11116
(F-1.0751485126774485
F-3.1133766174316406
tp11117
sS'[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]\n[1, 1, 1]'
p11118
(F-0.967922009919819
F-3.1250788370768228
tp11119
sS'[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]\n[1, 1, 1]'
p11120
(F-1.038963596995284
F-3.1174112955729165
tp11121
sS'[0, 1, 0]\n[0, 1, 1]'
p11122
(F-1.430569704841165
F-3.1197888056437173
tp11123
sS'[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]'
p11124
(F-1.261671600341797
F-3.1116968790690103
tp11125
sS'[0, 1, 1]\n[1, 0, 0]'
p11126
(F-1.4347085391773897
F-3.1148993174235025
tp11127
sS'per(3)'
p11128
(F-4.277627944946289
F-3.2781006495157876
tp11129
sS'[1, 1, 0]\n[1, 1, 1]'
p11130
(F-1.4501725365133846
F-3.1128225326538086
tp11131
sS'for i in range(1 << n):\n    pass'
p11132
(F-1.9092696905136108
F-3.1587772369384766
tp11133
sS"s = '0' * (n - len(s)) + s\nprint map(int, list(s))\nper(3)"
p11134
(F-2.5096054077148438
F-3.19578488667806
tp11135
sS'bin = [0, 1]\n[(x, y, z) for x in bin for y in bin for z in bin]'
p11136
(F-2.736475790700605
F-2.9361852010091147
tp11137
sS"def per(n):\n    for i in range(1 << n):\n        s = bin(i)[2:]\ns = '0' * (n - len(s)) + s"
p11138
(F-1.8881792340959822
F-3.206000010172526
tp11139
sS'[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]'
p11140
(F-1.261754150390625
F-3.1171747843424478
tp11141
sS'def per(n):\n    for i in range(1 << n):\n        s = bin(i)[2:]'
p11142
(F-1.9791538014131433
F-3.2296711603800454
tp11143
sS'[1, 0, 1]\n[1, 1, 0]\n[1, 1, 1]'
p11144
(F-1.242854766845703
F-3.11515744527181
tp11145
sS'[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]'
p11146
(F-1.2583818054199218
F-3.111241658528646
tp11147
sS'[1, 1, 1]'
p11148
(F-1.7994119856092665
F-3.116270383199056
tp11149
sS'[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]'
p11150
(F-1.1480386907404119
F-3.1132119496663413
tp11151
sS'[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]'
p11152
(F-1.0254838126046317
F-3.1179046630859375
tp11153
sS'[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]'
p11154
(F-1.3051547241210937
F-3.1102539698282876
tp11155
sS'lst = list(itertools.product([0, 1], repeat=3))'
p11156
(F-1.7280827476864768
F-2.9806289672851562
tp11157
sS'lst = [list(i) for i in itertools.product([0, 1], repeat=n)]'
p11158
(F-1.7078720375343606
F-2.994343121846517
tp11159
sS'[0, 0, 0]'
p11160
(F-1.6441589991251628
F-3.163846969604492
tp11161
sS'[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]'
p11162
(F-1.0803845103194074
F-3.115000089009603
tp11163
sS'def per(n):\n    pass'
p11164
(F-1.9589735666910808
F-3.1964406967163086
tp11165
sS"s = '0' * (n - len(s)) + s\nprint map(int, list(s))"
p11166
(F-1.9687850387008101
F-3.1867198944091797
tp11167
sS'[0, 0, 0]\n[0, 0, 1]'
p11168
(F-1.3674931245691635
F-3.139479955037435
tp11169
sS'[0, 0, 0]\n[0, 0, 1]\n[0, 1, 0]'
p11170
(F-1.2309100341796875
F-3.123159408569336
tp11171
sS'[(x, y, z) for x in bin for y in bin for z in bin]'
p11172
(F-2.834067966627038
F-2.9347499211629233
tp11173
sS'[0, 0, 1]\n[0, 1, 0]'
p11174
(F-1.433674644021427
F-3.1285603841145835
tp11175
sS'[0, 0, 0]\n[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]'
p11176
(F-1.0578432780940359
F-3.1132380167643228
tp11177
sS'[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]'
p11178
(F-1.1410085504705256
F-3.1114012400309243
tp11179
sS'lst = list(map(list, itertools.product([0, 1], repeat=n)))\nlst = [list(i) for i in itertools.product([0, 1], repeat=n)]'
p11180
(F-1.6959928365854116
F-3.0472513834635415
tp11181
sS'n = 3\nlst = list(itertools.product([0, 1], repeat=n))'
p11182
(F-1.8232015991210937
F-2.9706802368164062
tp11183
sS'lst = map(list, itertools.product([0, 1], repeat=n))'
p11184
(F-1.8894918690557065
F-3.041271209716797
tp11185
sS'[1, 0, 0]'
p11186
(F-1.9086954328748915
F-3.1260786056518555
tp11187
sS'n = 3'
p11188
(F-2.674909210205078
F-3.0299723943074546
tp11189
sS'[0, 0, 0]\n[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]'
p11190
(F-1.015612388143734
F-3.115751584370931
tp11191
sS'[0, 0, 0]\n[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]'
p11192
(F-1.1302691372958096
F-3.1157801946004233
tp11193
sS'[1, 0, 1]\n[1, 1, 0]'
p11194
(F-1.5003655377556295
F-3.1129722595214844
tp11195
sS'[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]\n[1, 1, 1]'
p11196
(F-1.1416763536857837
F-3.114518483479818
tp11197
sS'[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]\n[1, 1, 1]'
p11198
(F-0.9999945504324776
F-3.1201368967692056
tp11199
sS'[1, 0, 1]'
p11200
(F-1.8976253933376737
F-3.1235733032226562
tp11201
sS'import itertools'
p11202
(F-1.992018699645996
F-2.8551578521728516
tp11203
sS"s = '0' * (n - len(s)) + s"
p11204
(F-1.9271328449249268
F-3.2344287236531577
tp11205
sS'[0, 0, 0]\n[0, 0, 1]\n[0, 1, 0]\n[0, 1, 1]\n[1, 0, 0]\n[1, 0, 1]\n[1, 1, 0]'
p11206
(F-0.9764347411038583
F-3.119032541910807
tp11207
sS'print map(int, list(s))'
p11208
(F-2.213114102681478
F-3.140340805053711
tp11209
sS'[0, 1, 0]'
p11210
(F-1.7511604097154405
F-3.1435184478759766
tp11211
sS'print map(int, list(s))\nper(3)'
p11212
(F-2.9933285432703354
F-3.152232805887858
tp11213
sS'[1, 0, 0]\n[1, 0, 1]'
p11214
(F-1.5225767247817095
F-3.1139701207478843
tp11215
sS"def per(n):\n    for i in range(1 << n):\n        s = bin(i)[2:]\ns = '0' * (n - len(s)) + s\nprint map(int, list(s))"
p11216
(F-1.9185925801595052
F-3.165579160054525
tp11217
sS'lst = list(itertools.product([0, 1], repeat=n))'
p11218
(F-1.8432228451683408
F-2.9801063537597656
tp11219
sS'[0, 0, 1]'
p11220
(F-1.7216690911187067
F-3.154738744099935
tp11221
sS"def per(n):\n    for i in range(1 << n):\n        s = bin(i)[2:]\ns = '0' * (n - len(s)) + s\nprint map(int, list(s))\nper(3)"
p11222
(F-2.17642822265625
F-3.1735970179239907
tp11223
sS'[0, 1, 1]'
p11224
(F-1.7138373057047527
F-3.1329835255940757
tp11225
sS'bin = [0, 1]'
p11226
(F-2.815069834391276
F-3.2107597986857095
tp11227
sS'[1, 1, 0]'
p11228
(F-1.9279488457573786
F-3.117504119873047
tp11229
sS's = bin(i)[2:]'
p11230
(F-2.5365757942199707
F-3.3015823364257812
tp11231
ssI3518778
(dp11232
S'df.values\narray([[1.0, 2.0, 3.0], [4.0, 5.5, 6.0]])'
p11233
(F-2.202054977416992
F-3.2487169901529946
tp11234
sS'import pandas as pd'
p11235
(F-2.0962816874186196
F-3.1534560521443686
tp11236
sS"import pandas as pd\ndf = pd.read_csv('myfile.csv', sep=',', header=None)\ndf.values"
p11237
(F-1.0574781483617322
F-2.785629908243815
tp11238
sS'from numpy import genfromtxt'
p11239
(F-2.0305353800455728
F-2.6887505849202475
tp11240
sS'array([[1.0, 2.0, 3.0], [4.0, 5.5, 6.0]])'
p11241
(F-1.9562468095259233
F-2.995320955912272
tp11242
sS'4, 5.5, 6\nimport numpy as np'
p11243
(F-3.6094048817952475
F-3.0319430033365884
tp11244
sS"df = pd.read_csv('myfile.csv', sep=',', header=None)"
p11245
(F-0.8739631652832032
F-2.9195149739583335
tp11246
sS"import pandas as pd\ndf = pd.read_csv('myfile.csv', sep=',', header=None)\ndf.values\narray([[1.0, 2.0, 3.0], [4.0, 5.5, 6.0]])"
p11247
(F-1.548978271484375
F-2.8041610717773438
tp11248
sS"np.genfromtxt('myfile.csv', delimiter=',')"
p11249
(F-0.8790442943572998
F-2.795047124226888
tp11250
sS'1.0, 2, 3\n4, 5.5, 6'
p11251
(F-4.292167076697717
F-3.4332288106282554
tp11252
sS"my_data = genfromtxt('my_file.csv', delimiter=',')"
p11253
(F-1.501046861921038
F-3.1437257130940757
tp11254
sS'df.values'
p11255
(F-2.741670036315918
F-3.430816650390625
tp11256
sS"df = pd.read_csv('myfile.csv', sep=',', header=None)\ndf.values"
p11257
(F-1.254696528116862
F-2.930929183959961
tp11258
sS'1.0, 2, 3\n4, 5.5, 6\nimport numpy as np'
p11259
(F-3.721912807888455
F-3.2272523244222007
tp11260
sS"df = pd.read_csv('myfile.csv', sep=',', header=None)\ndf.values\narray([[1.0, 2.0, 3.0], [4.0, 5.5, 6.0]])"
p11261
(F-1.690445793999566
F-2.92689577738444
tp11262
sS'4, 5.5, 6'
p11263
(F-4.800936017717634
F-3.289780616760254
tp11264
sS'1.0, 2, 3'
p11265
(F-4.317679268973214
F-3.508128801981608
tp11266
sS"np.genfromtxt('myfile.csv', delimiter=',', dtype=None)"
p11267
(F-1.1085797548294067
F-2.6553684870402017
tp11268
sS"import numpy as np\nnp.genfromtxt('myfile.csv', delimiter=',')"
p11269
(F-0.7292142755845014
F-2.5600269635518393
tp11270
sS"from numpy import genfromtxt\nmy_data = genfromtxt('my_file.csv', delimiter=',')"
p11271
(F-1.2942894383480674
F-2.701994260152181
tp11272
sS"array([(1.0, 2.0, 3), (4.0, 5.5, 6)], dtype=[('f0', '<f8'), ('f1', '<f8'),\n    ('f2', '<i4')])"
p11273
(F-1.6692148844401042
F-2.946086883544922
tp11274
sS"import pandas as pd\ndf = pd.read_csv('myfile.csv', sep=',', header=None)"
p11275
(F-0.7724180603027344
F-2.761274973551432
tp11276
sS'import numpy as np'
p11277
(F-1.5448649724324544
F-2.9548047383626304
tp11278
sS"4, 5.5, 6\nimport numpy as np\nnp.genfromtxt('myfile.csv', delimiter=',')"
p11279
(F-2.0127576745074727
F-2.6367324193318686
tp11280
sS"1.0, 2, 3\n4, 5.5, 6\nimport numpy as np\nnp.genfromtxt('myfile.csv', delimiter=',')"
p11281
(F-2.436390317719558
F-2.748427708943685
tp11282
ssI4020539
(dp11283
S'import codecs'
p11284
(F-3.424694299697876
F-3.0626943588256834
tp11285
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p11286
(F-2.5383562771779187
F-3.1540195465087892
tp11287
sS"decoded_string = myString.decode('string_escape')\nprint decoded_string"
p11288
(F-2.170241038004557
F-3.131488037109375
tp11289
sS"return codecs.decode(match.group(0), 'unicode-escape')"
p11290
(F-2.351886510848999
F-3.122391128540039
tp11291
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p11292
(F-2.5080888809696322
F-3.104827117919922
tp11293
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p11294
(F-1.839915248325893
F-3.1179433822631837
tp11295
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)'
p11296
(F-3.0591153745298034
F-3.201915740966797
tp11297
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p11298
(F-2.6265240837545956
F-3.143590545654297
tp11299
sS'"""\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""'
p11300
(F-1.5950875282287598
F-3.223352813720703
tp11301
sS'print decoded_string'
p11302
(F-3.6600802739461265
F-3.1281177520751955
tp11303
sS"s = 'na\\xc3\\xafve \\\\t test'"
p11304
(F-1.4428583145141602
F-3.0163246154785157
tp11305
sS"def decode_match(match):\n    return codecs.decode(match.group(0), 'unicode-escape')"
p11306
(F-1.9978490758825231
F-3.1346099853515623
tp11307
sS"myString = 'na\\xc3\\xafve \\\\t test'"
p11308
(F-1.750871976216634
F-3.071478080749512
tp11309
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p11310
(F-2.4672867911202565
F-3.1409826278686523
tp11311
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p11312
(F-2.4675055035090043
F-3.128669548034668
tp11313
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p11314
(F-2.42177340858861
F-3.0720481872558594
tp11315
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p11316
(F-1.9198377858037534
F-3.0947944641113283
tp11317
sS'def decode_match(match):\n    pass'
p11318
(F-2.075639179774693
F-3.1442047119140626
tp11319
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p11320
(F-2.4314043449633047
F-3.0828601837158205
tp11321
sS"import codecs\nprint codecs.decode(s, 'unicode_escape')"
p11322
(F-2.746269771030971
F-3.1142246246337892
tp11323
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p11324
(F-2.6544616134078414
F-3.1548076629638673
tp11325
sS'ESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)'
p11326
(F-2.9647865295410156
F-3.243198013305664
tp11327
sS"print decode_escapes('Ern\\xc5\\x91 \\\\t Rubik')"
p11328
(F-2.3999775780571833
F-3.110300636291504
tp11329
sS'return ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p11330
(F-3.9094314575195312
F-3.3056922912597657
tp11331
sS"print 'Ern\\xc5\\x91 \\\\t Rubik'.encode('latin-1').decode('unicode_escape')"
p11332
(F-1.3088912963867188
F-3.1338544845581056
tp11333
sS"decoded_string = myString.decode('string_escape')"
p11334
(F-2.2472446148212137
F-3.144890785217285
tp11335
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n    pass'
p11336
(F-2.530638087879528
F-3.1447690963745116
tp11337
sS'ESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p11338
(F-2.494058837890625
F-3.1673349380493163
tp11339
sS'import re\nimport codecs'
p11340
(F-2.5347802298409596
F-3.0298751831054687
tp11341
sS'def decode_escapes(s):\n    pass'
p11342
(F-1.7171339307512556
F-3.076058197021484
tp11343
sS'import re'
p11344
(F-1.858477234840393
F-3.132294273376465
tp11345
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p11346
(F-2.130896250406901
F-3.140463447570801
tp11347
sS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')"
p11348
(F-1.9733041616586537
F-3.1108749389648436
tp11349
sS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)"
p11350
(F-2.5296131480823862
F-3.1201887130737305
tp11351
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p11352
(F-2.3264592488606772
F-3.1097864151000976
tp11353
sS'def decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p11354
(F-2.049833591167743
F-3.098850059509277
tp11355
sS"import codecs\nmyString = 'spam\\\\neggs'"
p11356
(F-2.37221188015408
F-3.0552444458007812
tp11357
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p11358
(F-2.679424540201823
F-3.133388900756836
tp11359
sS"s = 'na\\xc3\\xafve \\\\t test'\nprint s.encode('utf-8').decode('unicode_escape')"
p11360
(F-0.9967498779296875
F-3.112042236328125
tp11361
sS'ESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p11362
(F-2.669236002089102
F-3.152083969116211
tp11363
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint decoded_string"
p11364
(F-1.8302005767822265
F-3.1046077728271486
tp11365
sS'ESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p11366
(F-2.3870471772693453
F-3.128498840332031
tp11367
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n    pass'
p11368
(F-2.6056336193549923
F-3.163864326477051
tp11369
sS"myString = 'na\\xc3\\xafve \\\\t test'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p11370
(F-2.3264592488606772
F-3.1097864151000976
tp11371
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p11372
(F-2.42247402306759
F-3.1321456909179686
tp11373
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p11374
(F-2.3558887905544705
F-3.123954010009766
tp11375
sS"myString = 'spam\\\\neggs'"
p11376
(F-1.750871976216634
F-3.071478080749512
tp11377
sS"myString = 'spam\\\\neggs'\nprint codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')\nmyString = 'na\\xc3\\xafve \\\\t test'"
p11378
(F-2.334163120814732
F-3.0984447479248045
tp11379
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint decoded_string"
p11380
(F-2.0895677839006694
F-3.1258623123168947
tp11381
sS'ESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n    pass'
p11382
(F-2.5399308455617806
F-3.192917823791504
tp11383
sS"print codecs.decode(s, 'unicode_escape')"
p11384
(F-2.758889978582209
F-3.1316247940063477
tp11385
sS"print s.encode('utf-8').decode('unicode_escape')"
p11386
(F-1.295776094709124
F-3.15423583984375
tp11387
sS"print codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8')"
p11388
(F-2.651741943359375
F-3.152743911743164
tp11389
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)'
p11390
(F-2.9792210896809896
F-3.1764503479003907
tp11391
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p11392
(F-2.6855195208293634
F-3.1534194946289062
tp11393
sS"print s.encode('latin-1').decode('unicode_escape')"
p11394
(F-1.295776094709124
F-3.15423583984375
tp11395
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\n    """\n    ( \\\\\\\\U........      \n    | \\\\\\\\u....          \n    | \\\\\\\\x..            \n    | \\\\\\\\[0-7]{1,3}     \n    | \\\\\\\\N\\\\{[^}]+\\\\}     \n    | \\\\\\\\[\\\\\\\\\'"abfnrtv]  \n    )"""\n    , re.UNICODE | re.VERBOSE)\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p11396
(F-2.3631501128708106
F-3.125199317932129
tp11397
ssI21129020
(dp11398
S"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\nu'The currency is: %s' % '\\xe2\\x82\\xac'\nu'The currency is: ' + '\\xe2\\x82\\xac'"
p11399
(F-2.6572866893949962
F-4.071839182000411
tp11400
sS"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    pass"
p11401
(F-1.0934805075327556
F-4.043865806178043
tp11402
sS'import sys'
p11403
(F-2.8799047470092773
F-4.332811857524671
tp11404
sS'use_unicode = True'
p11405
(F-3.395759310041155
F-3.9795889603464225
tp11406
sS"charset = 'utf8',"
p11407
(F-4.315683364868164
F-4.186973973324425
tp11408
sS"sys.setdefaultencoding('utf8')"
p11409
(F-1.4725391864776611
F-4.314797652395148
tp11410
sS'sys.getdefaultencoding()'
p11411
(F-2.2391439165387834
F-4.3994895533511515
tp11412
sS"u'The currency is: %s' % '\\xe2\\x82\\xac'\nu'The currency is: ' + '\\xe2\\x82\\xac'"
p11413
(F-2.8333426581488714
F-4.260967053865132
tp11414
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)\npsycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p11415
(F-3.5254671650548137
F-4.464773077713816
tp11416
sS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'"
p11417
(F-2.7765791756766185
F-4.334902311626234
tp11418
sS"charset = 'utf8',\nuse_unicode = True"
p11419
(F-3.9007975260416665
F-3.9856286299856087
tp11420
sS'import sys\nreload(sys)'
p11421
(F-1.6900581783718533
F-4.477690847296464
tp11422
sS'type(my_u)'
p11423
(F-3.587806224822998
F-4.3518516138980265
tp11424
sS"reload(sys)\nsys.setdefaultencoding('utf8')"
p11425
(F-1.090600380530724
F-4.323924014442845
tp11426
sS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'\ntype(my_u)"
p11427
(F-3.051447187151228
F-4.3237557662160775
tp11428
sS'my_unicode_string = my_file.read()'
p11429
(F-1.5611718495686848
F-3.9987415514494242
tp11430
sS'import sys\nreload(sys)\nsys.getdefaultencoding()'
p11431
(F-1.5558080037434896
F-4.5103077135588
tp11432
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p11433
(F-3.369706630706787
F-4.42485207005551
tp11434
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\nu'The currency is: %s' % '\\xe2\\x82\\xac'"
p11435
(F-2.2640469868977866
F-4.195394817151521
tp11436
sS"source = unicode(source, 'utf-8')"
p11437
(F-2.367050361633301
F-4.017404255114104
tp11438
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')"
p11439
(F-1.577946424484253
F-4.178645886872944
tp11440
sS"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    my_unicode_string = my_file.read()"
p11441
(F-1.1668447918362088
F-3.9797604209498356
tp11442
sS'reload(sys)'
p11443
(F-1.976653258005778
F-4.484830354389391
tp11444
sS'reload(sys)\nsys.getdefaultencoding()'
p11445
(F-1.951213041941325
F-4.511552509508635
tp11446
sS"u'Z\\xfcrich'"
p11447
(F-2.1514644622802734
F-4.260211743806538
tp11448
sS"u'The currency is: ' + '\\xe2\\x82\\xac'"
p11449
(F-2.2958126068115234
F-4.274772242495888
tp11450
sS"import sys\nreload(sys)\nsys.setdefaultencoding('utf8')"
p11451
(F-0.8396021723747253
F-4.307848880165501
tp11452
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)'
p11453
(F-3.7793750762939453
F-4.406707763671875
tp11454
sS"unicode('\\xe2\\x82\\xac')"
p11455
(F-1.7444252967834473
F-4.05459915964227
tp11456
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\nu'The currency is: %s' % '\\xe2\\x82\\xac'"
p11457
(F-2.5664960075827206
F-4.07210982473273
tp11458
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')"
p11459
(F-2.3108555720402646
F-4.057213632684005
tp11460
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\nu'The currency is: %s' % '\\xe2\\x82\\xac'\nu'The currency is: ' + '\\xe2\\x82\\xac'"
p11461
(F-2.4477243423461914
F-4.198083977950247
tp11462
sS"u'The currency is: %s' % '\\xe2\\x82\\xac'"
p11463
(F-2.2898611068725585
F-4.247183548776727
tp11464
ssI1854
(dp11465
S'platform.system()'
p11466
(F-2.0783646447317943
F-4.418515638871626
tp11467
sS'import os\nprint os.name\nimport platform\nplatform.system()'
p11468
(F-2.1972567240397134
F-4.336692810058594
tp11469
sS'import platform\nplatform.system()'
p11470
(F-2.352279281616211
F-4.3897028836337
tp11471
sS'import os\nos.name\nimport platform\nplatform.system()'
p11472
(F-2.3830855874454273
F-4.338565479625355
tp11473
sS'os.name'
p11474
(F-2.3044652938842773
F-4.4204864501953125
tp11475
sS'os.name\nimport platform\nplatform.system()'
p11476
(F-2.765477861676897
F-4.368516401811079
tp11477
sS'os.name\nimport platform'
p11478
(F-3.6861743927001953
F-4.32297793301669
tp11479
sS'os.name\nimport platform\nplatform.system()\nplatform.release()'
p11480
(F-2.764638900756836
F-4.387477527965199
tp11481
sS'import os\nprint os.name\nimport platform'
p11482
(F-2.466551144917806
F-4.26772724498402
tp11483
sS'import os\nos.name\nimport platform\nplatform.system()\nplatform.release()'
p11484
(F-2.4947078538977583
F-4.360446236350319
tp11485
sS'platform.system()\nplatform.release()'
p11486
(F-2.6342042776254506
F-4.427294644442472
tp11487
sS'import os\nos.name\nimport platform'
p11488
(F-2.7795659845525567
F-4.272155068137429
tp11489
sS'import platform\nplatform.system()\nplatform.release()'
p11490
(F-2.5043487548828125
F-4.423403653231534
tp11491
sS'import os\nos.name'
p11492
(F-1.5256590843200684
F-4.361240733753551
tp11493
sS'platform.release()'
p11494
(F-2.7919654846191406
F-4.459786848588423
tp11495
sS'import os'
p11496
(F-1.9452601671218872
F-4.362803025679155
tp11497
sS'import platform'
p11498
(F-3.4475936889648438
F-4.340991973876953
tp11499
sS'print os.name\nimport platform\nplatform.system()\nplatform.release()'
p11500
(F-2.6761193048386347
F-4.375918301669034
tp11501
sS'print os.name\nimport platform\nplatform.system()'
p11502
(F-2.663593292236328
F-4.354528947310015
tp11503
sS'print os.name\nimport platform'
p11504
(F-3.3954700893825955
F-4.295964327725497
tp11505
sS'print os.name'
p11506
(F-2.4764889081319175
F-4.389226740056818
tp11507
sS'import os\nprint os.name\nimport platform\nplatform.system()\nplatform.release()'
p11508
(F-2.32793919245402
F-4.359060807661577
tp11509
sS'import os\nprint os.name'
p11510
(F-1.5325573815239801
F-4.361901023171165
tp11511
ssI613183
(dp11512
S'x = {(1): 2, (3): 4, (4): 3, (2): 1, (0): 0}'
p11513
(F-2.0865929739815847
F-2.5538582801818848
tp11514
sS'sorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p11515
(F-1.0476001241932744
F-1.908431053161621
tp11516
sS'for w in sorted(d, key=d.get, reverse=True):\n    pass\n'
p11517
(F-1.7200231552124023
F-1.8379753828048706
tp11518
sS'd = defaultdict(int)\nfor w in text.split():\n    pass'
p11519
(F-1.6764047796075994
F-2.8064322471618652
tp11520
sS'd = defaultdict(int)\nfor w in text.split():\n    d[w] += 1'
p11521
(F-1.5961069177698206
F-2.722409248352051
tp11522
sS'for w in text.split():\n    d[w] += 1'
p11523
(F-1.785426712036133
F-3.3845503330230713
tp11524
sS'for w in text.split():\n    pass'
p11525
(F-1.89700927734375
F-3.7270889282226562
tp11526
sS'for w in sorted(d, key=d.get, reverse=True):\n    pass'
p11527
(F-1.7200231552124023
F-1.8379753828048706
tp11528
sS'x = {(1): 2, (3): 4, (4): 3, (2): 1, (0): 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p11529
(F-1.673055280718887
F-1.9223268032073975
tp11530
sS'd = defaultdict(int)'
p11531
(F-1.9030511379241943
F-2.324044942855835
tp11532
sS'import operator\nx = {(1): 2, (3): 4, (4): 3, (2): 1, (0): 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p11533
(F-1.6483250935872396
F-1.9751040935516357
tp11534
sS'import operator'
p11535
(F-2.1386122703552246
F-3.0020980834960938
tp11536
sS'd[w] += 1'
p11537
(F-2.900106430053711
F-2.47062611579895
tp11538
sS'import operator\nx = {(1): 2, (3): 4, (4): 3, (2): 1, (0): 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p11539
(F-1.6535699208577475
F-1.9658851623535156
tp11540
sS'x = {(1): 2, (3): 4, (4): 3, (2): 1, (0): 0}\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p11541
(F-1.6641199212325246
F-1.93037748336792
tp11542
sS'print w, d[w]'
p11543
(F-3.7852308485243054
F-2.7434353828430176
tp11544
sS'import operator\nx = {(1): 2, (3): 4, (4): 3, (2): 1, (0): 0}'
p11545
(F-2.079328235826994
F-2.559718132019043
tp11546
sS'sorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p11547
(F-1.0667230357294497
F-1.8962891101837158
tp11548
ssI31818050
(dp11549
S'round(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)'
p11550
(F-1.9824078877766926
F-2.55500062306722
tp11551
sS'round(7.005, 2)\nround(3.005, 2)'
p11552
(F-1.651250457763672
F-2.553233782450358
tp11553
sS'def roundTraditional(val, digits):\n    pass'
p11554
(F-2.2622047424316407
F-2.621107737223307
tp11555
sS'round(0.075, 2)'
p11556
(F-1.49757719039917
F-2.5740315119425454
tp11557
sS'round(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)'
p11558
(F-1.997446104537609
F-2.5702155431111655
tp11559
sS'round(1.0005, 3)'
p11560
(F-1.5672314167022705
F-2.5740184783935547
tp11561
sS'h = int(round(h))'
p11562
(F-1.9931997819380327
F-2.5569432576497397
tp11563
sS'round(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)'
p11564
(F-1.8100379597056995
F-2.5561421712239585
tp11565
sS'round(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)'
p11566
(F-2.045878761693051
F-2.5782254536946616
tp11567
sS'round(2.0005, 3)'
p11568
(F-1.5672314167022705
F-2.5740184783935547
tp11569
sS'round(3.0005, 3)\nround(4.0005, 3)'
p11570
(F-1.7172022501627604
F-2.5464364687601724
tp11571
sS'round(7.005, 2)\nround(3.005, 2)\nround(8.005, 2)'
p11572
(F-1.8100379597056995
F-2.5561421712239585
tp11573
sS'round(1.0005, 3)\nround(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)'
p11574
(F-2.0460165405273436
F-2.565908114115397
tp11575
sS'return round(val + 10 ** (-len(str(val)) - 1))'
p11576
(F-2.4561940973455254
F-2.606766859690348
tp11577
sS'round(6.005, 2)\nround(7.005, 2)'
p11578
(F-1.651250457763672
F-2.553233782450358
tp11579
sS'round(3.005, 2)'
p11580
(F-1.49757719039917
F-2.5740315119425454
tp11581
sS'round(1.0005, 3)\nround(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)'
p11582
(F-2.0304693177688953
F-2.5571680068969727
tp11583
sS'round(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)\nround(8.005, 2)'
p11584
(F-1.94413333468967
F-2.5739819208780923
tp11585
sS'round(6.005, 2)'
p11586
(F-1.49757719039917
F-2.574031352996826
tp11587
sS'round(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)'
p11588
(F-1.8445198752663352
F-2.5451939900716147
tp11589
sS'round(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)'
p11590
(F-2.0198594913926233
F-2.560053507486979
tp11591
sS'round(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)'
p11592
(F-2.009376880734466
F-2.5640570322672525
tp11593
sS'round(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)\nround(8.005, 2)'
p11594
(F-2.052149772644043
F-2.587235450744629
tp11595
sS'round(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)'
p11596
(F-2.026039733886719
F-2.573367118835449
tp11597
sS'int(round(x))'
p11598
(F-1.8610479566786025
F-2.5587803522745767
tp11599
sS'round(2.0005, 3)\nround(3.0005, 3)'
p11600
(F-1.7172022501627604
F-2.5464364687601724
tp11601
sS'round(4.0005, 3)'
p11602
(F-1.5672314167022705
F-2.5740184783935547
tp11603
sS'round(32.268907563, 3)'
p11604
(F-1.5672314167022705
F-2.5740184783935547
tp11605
sS'round(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)'
p11606
(F-1.9693936241997614
F-2.5607735315958657
tp11607
sS'round(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)\nround(8.005, 2)'
p11608
(F-1.8938816991345635
F-2.564303716023763
tp11609
sS'round(4.0005, 3)\nround(1.005, 2)'
p11610
(F-1.6929561614990234
F-2.544895807902018
tp11611
sS'def roundTraditional(val, digits):\n    return round(val + 10 ** (-len(str(val)) - 1))'
p11612
(F-2.0698273602653954
F-2.565364201863607
tp11613
sS'round(1.0005, 3)\nround(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)'
p11614
(F-2.0555303473221627
F-2.5748260815938315
tp11615
sS'round(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)'
p11616
(F-1.9486735113735856
F-2.5440754890441895
tp11617
sS'round(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)'
p11618
(F-1.9230505844642376
F-2.5519824028015137
tp11619
sS'round(0.075 + 10 ** (-2 * 5), 2)'
p11620
(F-2.5939021391027115
F-2.587998390197754
tp11621
sS'round(1.0005, 3)\nround(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)'
p11622
(F-2.0612106323242188
F-2.5836965243021646
tp11623
sS'round(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)'
p11624
(F-1.8938816991345635
F-2.564303716023763
tp11625
sS'round(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)\nround(8.005, 2)'
p11626
(F-2.0152413940429685
F-2.5797999699910483
tp11627
sS'round(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)'
p11628
(F-1.8764669244939631
F-2.5426789919535318
tp11629
sS'round(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)'
p11630
(F-1.8100379597056995
F-2.5561421712239585
tp11631
sS'round(5.005, 2)\nround(6.005, 2)'
p11632
(F-1.651250457763672
F-2.553233782450358
tp11633
sS'round(1.0005, 3)\nround(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)\nround(8.005, 2)'
p11634
(F-2.064579923387984
F-2.5924062728881836
tp11635
sS'round(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)'
p11636
(F-1.8938816991345635
F-2.564303716023763
tp11637
sS'round(5.005, 2)'
p11638
(F-1.49757719039917
F-2.5740315119425454
tp11639
sS'round(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)'
p11640
(F-1.8100379597056995
F-2.5561421712239585
tp11641
sS'round(1.0005, 3)\nround(2.0005, 3)'
p11642
(F-1.7172022501627604
F-2.5464364687601724
tp11643
sS'round(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)'
p11644
(F-2.0359431457519532
F-2.5691099166870117
tp11645
sS'round(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)\nround(8.005, 2)'
p11646
(F-2.0367000646758497
F-2.582662264506022
tp11647
sS'round(3.005, 2)\nround(8.005, 2)'
p11648
(F-1.651250457763672
F-2.553233782450358
tp11649
sS'round(3.0005, 3)'
p11650
(F-1.5672314167022705
F-2.5740184783935547
tp11651
sS'round(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)\nround(8.005, 2)'
p11652
(F-1.975330441497093
F-2.5840401649475098
tp11653
sS'round(1.005, 2)\nround(5.005, 2)\nround(6.005, 2)\nround(7.005, 2)\nround(3.005, 2)'
p11654
(F-1.94413333468967
F-2.5739819208780923
tp11655
sS'round(1.005, 2)\nround(5.005, 2)'
p11656
(F-1.651250457763672
F-2.553233782450358
tp11657
sS'round(1.0005, 3)\nround(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)'
p11658
(F-2.0040355258517795
F-2.54919163386027
tp11659
sS'round(8.005, 2)'
p11660
(F-1.49757719039917
F-2.574031352996826
tp11661
sS'round(0.075, 2)\nround(0.075 + 10 ** (-2 * 5), 2)'
p11662
(F-2.419769763946533
F-2.5756142934163413
tp11663
sS'round(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)'
p11664
(F-1.9374740863668507
F-2.546812057495117
tp11665
sS'round(1.0005, 3)\nround(2.0005, 3)\nround(3.0005, 3)'
p11666
(F-1.8764669244939631
F-2.5426789919535318
tp11667
sS'round(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)'
p11668
(F-1.8597861203280361
F-2.5412702560424805
tp11669
sS'round(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)\nround(1.005, 2)\nround(5.005, 2)'
p11670
(F-1.9936400519476996
F-2.5514005025227866
tp11671
sS'round(7.005, 2)'
p11672
(F-1.49757719039917
F-2.574031352996826
tp11673
sS'round(1.005, 2)'
p11674
(F-1.49757719039917
F-2.574031352996826
tp11675
sS'round(1.0005, 3)\nround(2.0005, 3)\nround(3.0005, 3)\nround(4.0005, 3)'
p11676
(F-1.9630960924872036
F-2.5452442169189453
tp11677
ssI3501382
(dp11678
S'def is_int(val):\n    if type(val) == int:\n        return True'
p11679
(F-1.397550289447491
F-2.4735464616255327
tp11680
sS'x = Spam(0)'
p11681
(F-3.6843605041503906
F-2.790051893754439
tp11682
sS'try:\n    x += 1\nexcept TypeError:\n    pass'
p11683
(F-0.8685403121145148
F-2.4869393435391514
tp11684
sS'class Spam(int):\n    pass\nx = Spam(0)\ntype(x) == int'
p11685
(F-3.3437335674579325
F-2.8241667314009233
tp11686
sS'for index in range(y):\n    pass'
p11687
(F-1.9734898975917272
F-2.7318781072443183
tp11688
sS'pass'
p11689
(F-2.951331456502279
F-2.8159720680930396
tp11690
sS'type(x) == int\nisinstance(x, int)'
p11691
(F-2.4779093424479166
F-2.6559730876575816
tp11692
sS'import numbers\nisinstance(3, numbers.Integral)'
p11693
(F-3.2745889516977162
F-2.7086035988547583
tp11694
sS'x = Spam(0)\ntype(x) == int'
p11695
(F-3.4630579630533855
F-2.747587724165483
tp11696
sS'class Spam(int):\n    pass\nx = Spam(0)'
p11697
(F-3.321927923905222
F-2.852475253018466
tp11698
sS'def is_int(val):\n    pass'
p11699
(F-1.8234455926077706
F-2.4828066392378374
tp11700
sS'type(x) == int'
p11701
(F-2.9138050079345703
F-2.6864031011408027
tp11702
sS'return True'
p11703
(F-2.0913069248199463
F-2.8954299579967153
tp11704
sS'class Spam(int):\n    pass\nx = Spam(0)\ntype(x) == int\nisinstance(x, int)'
p11705
(F-3.063979640151515
F-2.764884428544478
tp11706
sS'class Spam(int):\n    pass'
p11707
(F-2.5506081581115723
F-2.8523386174982246
tp11708
sS'def is_int(val):\n    if type(val) == int:\n        pass'
p11709
(F-1.4323635864257813
F-2.4697390469637783
tp11710
sS'if type(val) == int:\n    pass'
p11711
(F-1.4859339850289481
F-2.522754669189453
tp11712
sS'return False'
p11713
(F-2.0871968269348145
F-2.914036837491122
tp11714
sS'float(5).is_integer()\nfloat(5.1).is_integer()\nfloat(5.0).is_integer()'
p11715
(F-3.2651452457203582
F-2.8898996873335405
tp11716
sS'x += 1'
p11717
(F-1.818673324584961
F-2.608171983198686
tp11718
sS'float(5.1).is_integer()\nfloat(5.0).is_integer()'
p11719
(F-3.494646155315897
F-2.8398988897150215
tp11720
sS'float(5).is_integer()\nfloat(5.1).is_integer()'
p11721
(F-3.140584199324898
F-2.822350935502486
tp11722
sS'import numbers'
p11723
(F-3.7788033485412598
F-2.7522572604092685
tp11724
sS'float(5).is_integer()'
p11725
(F-2.6089653968811035
F-2.719207070090554
tp11726
sS'if type(val) == int:\n    return True'
p11727
(F-1.4318197886149089
F-2.5339332927357066
tp11728
sS'x = Spam(0)\ntype(x) == int\nisinstance(x, int)'
p11729
(F-2.9996285872025923
F-2.688576091419567
tp11730
sS'float(5.1).is_integer()'
p11731
(F-3.382235527038574
F-2.7492956681685015
tp11732
sS'isinstance(3, numbers.Integral)'
p11733
(F-3.048527145385742
F-2.7000241713090376
tp11734
sS'float(5.0).is_integer()'
p11735
(F-3.020366350809733
F-2.7542544278231533
tp11736
sS'isinstance(x, int)'
p11737
(F-1.786321997642517
F-2.6517711986194956
tp11738
ssI89228
(dp11739
S"return_code = subprocess.call('echo Hello World', shell=True)"
p11740
(F-1.9554314613342285
F-1.8352950811386108
tp11741
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=\n    subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass\n"
p11742
(F-1.128732725631359
F-2.000971555709839
tp11743
sS'from subprocess import call'
p11744
(F-1.5088857014973958
F-1.849892497062683
tp11745
sS"print os.popen('echo Hello World').read()"
p11746
(F-1.2858766409067006
F-2.102137565612793
tp11747
sS'for line in p.stdout.readlines():\n    pass\n'
p11748
(F-1.515107323141659
F-2.700066328048706
tp11749
sS'for line in p.stdout.readlines():\n    pass'
p11750
(F-1.515107323141659
F-2.700066328048706
tp11751
sS'for line in p.stdout.readlines():\n    print line,\nretval = p.wait()'
p11752
(F-1.76958578604239
F-2.591059446334839
tp11753
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=\n    subprocess.STDOUT)"
p11754
(F-1.023853231359411
F-1.9040979146957397
tp11755
sS"os.system('some_command < input_file | another_command > output_file')"
p11756
(F-0.5992356538772583
F-1.9199903011322021
tp11757
sS"call(['ls', '-l'])"
p11758
(F-1.0070880889892577
F-2.1796319484710693
tp11759
sS'import subprocess'
p11760
(F-1.8125637769699097
F-1.9118683338165283
tp11761
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=\n    subprocess.STDOUT)"
p11762
(F-0.9033107757568359
F-1.9028524160385132
tp11763
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=\n    subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p11764
(F-1.036320396091627
F-1.9835237264633179
tp11765
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=\n    subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p11766
(F-1.2267424719674247
F-2.029581069946289
tp11767
sS"print subprocess.Popen('echo %s ' % user_input, stdout=PIPE).stdout.read()"
p11768
(F-1.8855740091075068
F-1.9953725337982178
tp11769
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=\n    subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p11770
(F-1.128732725631359
F-2.000971555709839
tp11771
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=\n    subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass\n"
p11772
(F-1.036320396091627
F-1.9835237264633179
tp11773
sS'retval = p.wait()'
p11774
(F-2.9792425367567272
F-2.2421696186065674
tp11775
sS'print line,'
p11776
(F-3.706948089599609
F-2.7960946559906006
tp11777
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=\n    subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p11778
(F-1.3076818214272552
F-2.056873083114624
tp11779
sS"from subprocess import call\ncall(['ls', '-l'])"
p11780
(F-0.5800167083740234
F-1.9252643585205078
tp11781
sS"print subprocess.Popen('echo Hello World', shell=True, stdout=subprocess.PIPE\n    ).stdout.read()"
p11782
(F-1.2939012967623198
F-1.9655218124389648
tp11783
ssI493386
(dp11784
S'print i,'
p11785
(F-3.1517030715942385
F-2.6722656885782876
tp11786
sS"strings = ['one', 'two', 'three']\nfor i in xrange(3):\n    pass\n"
p11787
(F-1.2382757663726807
F-2.8545926411946616
tp11788
sS"import sys\nsys.stdout.write('.')"
p11789
(F-0.8416288082416241
F-2.5944692293802896
tp11790
sS"strings = ['one', 'two', 'three']\nfor i in xrange(3):\n    pass"
p11791
(F-1.2382757663726807
F-2.8545923233032227
tp11792
sS'import sys'
p11793
(F-2.744373321533203
F-2.937922159830729
tp11794
sS'sys.stdout.flush()'
p11795
(F-1.0038139555189345
F-2.6194737752278647
tp11796
sS'for i in range(10):\n    pass\n'
p11797
(F-1.1900882720947266
F-2.9422760009765625
tp11798
sS'from __future__ import print_function'
p11799
(F-0.9596227645874024
F-2.6532627741495767
tp11800
sS"print '.' * 10"
p11801
(F-2.3245484034220376
F-2.6370201110839844
tp11802
sS"print 'Item %d: %s' % (i, strings[i])"
p11803
(F-2.114499018742488
F-2.6470247904459634
tp11804
sS'for i in xrange(3):\n    pass'
p11805
(F-1.2845332281930106
F-2.92173703511556
tp11806
sS'for i in range(10):\n    pass'
p11807
(F-1.1900882720947266
F-2.9422760009765625
tp11808
sS"strings = ['one', 'two', 'three']"
p11809
(F-1.4292585199529475
F-2.8528725306193032
tp11810
sS'print'
p11811
(F-3.547449747721354
F-2.7140658696492515
tp11812
sS"sys.stdout.write('.')"
p11813
(F-0.9647863388061524
F-2.599353790283203
tp11814
sS'for i in xrange(3):\n    pass\n'
p11815
(F-1.2845332281930106
F-2.92173703511556
tp11816
sS'for i in range(10):\n    print i,\nelse:\n    pass'
p11817
(F-1.0296418563179348
F-2.841496785481771
tp11818
sS'for i in range(10):\n    print i,\nelse:\n    print'
p11819
(F-1.1341784933338994
F-2.7663955688476562
tp11820
ssI311627
(dp11821
S"2008 - 11 - 22\nprint 'This is a new day : ', mylist[0]"
p11822
(F-4.059315236409505
F-2.5252239520733175
tp11823
sS'import datetime\nmylist = []\ntoday = datetime.date.today()'
p11824
(F-1.9313193873355263
F-2.0855394510122447
tp11825
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11826
(F-0.933240305079092
F-1.826853532057542
tp11827
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11828
(F-0.97705078125
F-1.8181463388296275
tp11829
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11830
(F-0.8863034681840376
F-1.8673282036414514
tp11831
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11832
(F-0.938612072284405
F-1.8362608689528246
tp11833
sS'today = datetime.date.today()\nmylist.append(today)'
p11834
(F-1.7000789642333984
F-2.157350393442007
tp11835
sS'print mylist[0]'
p11836
(F-2.7251668657575334
F-2.584850017841046
tp11837
sS'2008 - 11 - 22'
p11838
(F-5.845570155552456
F-2.6084776658278246
tp11839
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p11840
(F-0.9793495698408647
F-1.8252575214092548
tp11841
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11842
(F-1.052504452792081
F-1.7982101440429688
tp11843
sS"print 'Day of year: ', datetime.date.today().strftime('%j')"
p11844
(F-1.2546528086942785
F-1.7846544705904448
tp11845
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p11846
(F-0.9240498860677083
F-1.8859286675086389
tp11847
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p11848
(F-0.9291580745152065
F-1.8611809657170222
tp11849
sS"print 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11850
(F-1.052504337195194
F-1.7982101440429688
tp11851
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p11852
(F-0.9735954395238904
F-1.8057518005371094
tp11853
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11854
(F-0.8750542231968471
F-1.8867615919846754
tp11855
sS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n2008 - 11 - 22'
p11856
(F-2.8986727396647134
F-2.3030025775615988
tp11857
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11858
(F-0.8778277609845717
F-1.8987020345834584
tp11859
sS"print mylist[0]\n2008 - 11 - 22\nprint 'This is a new day : ', mylist[0]"
p11860
(F-3.780995323544457
F-2.5028903667743387
tp11861
sS"mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n2008 - 11 - 22\nprint 'This is a new day : ', mylist[0]"
p11862
(F-2.714323354321857
F-2.3631659287672777
tp11863
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p11864
(F-2.0573562095905173
F-2.319904767549955
tp11865
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()"
p11866
(F-1.6128073930740356
F-1.958982907808744
tp11867
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11868
(F-0.8903824797773783
F-1.875672853910006
tp11869
sS"today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n2008 - 11 - 22\nprint 'This is a new day : ', mylist[0]"
p11870
(F-2.69512939453125
F-2.2998489966759315
tp11871
sS'for date in mylist:\n    pass\n'
p11872
(F-2.42544867775657
F-2.2067011319673977
tp11873
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p11874
(F-1.0084985697044517
F-1.798162313608023
tp11875
sS'import time\nimport datetime'
p11876
(F-2.5555332728794644
F-2.2391988314115086
tp11877
sS'import datetime\nmylist = []'
p11878
(F-2.839189741346571
F-2.2098717322716346
tp11879
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11880
(F-0.9157518928433642
F-1.8516907325157752
tp11881
sS'import datetime'
p11882
(F-2.990933895111084
F-2.1142427004300632
tp11883
sS"import time\nprint time.strftime('%Y-%m-%d %H:%M')"
p11884
(F-1.142362117767334
F-1.9864921569824219
tp11885
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11886
(F-0.905736063862895
F-1.8875741225022535
tp11887
sS'for date in mylist:\n    pass'
p11888
(F-2.42544867775657
F-2.2067011319673977
tp11889
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11890
(F-0.8807141703944052
F-1.8789096245398889
tp11891
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p11892
(F-1.052504337195194
F-1.7982101440429688
tp11893
sS'print \'We are the {:%d, %b %Y}\'.format(today)\n"""We are the 22, Nov 2008"""'
p11894
(F-2.065509969537908
F-2.0651165888859677
tp11895
sS"print 'This is a new day : ', mylist[0]"
p11896
(F-2.4358448452419705
F-2.4914313096266527
tp11897
sS"print 'This is a new day : ' + mylist[0]"
p11898
(F-2.6439662509494357
F-2.4415465134840746
tp11899
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p11900
(F-2.1335462487262227
F-2.2805821345402646
tp11901
sS"print 'This is a new day : ' + str(mylist[0])"
p11902
(F-1.7905073165893555
F-2.361959457397461
tp11903
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11904
(F-0.87585816016564
F-1.872544948871319
tp11905
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11906
(F-0.8633745417875403
F-1.8832610203669622
tp11907
sS"print 'Time in seconds since the epoch: %s' % time.time()"
p11908
(F-1.6505599975585938
F-1.940536352304312
tp11909
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11910
(F-0.8844796777740727
F-1.8946586022010217
tp11911
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()"
p11912
(F-1.270957072575887
F-1.8812032846304088
tp11913
sS"print 'Day of week: ', datetime.date.today().strftime('%A')"
p11914
(F-1.2546528086942785
F-1.7846544705904448
tp11915
sS"print 'We are the {:%d, %b %Y}'.format(today)"
p11916
(F-1.7282206217447917
F-2.058616931621845
tp11917
sS'print str(date)'
p11918
(F-1.9089770998273576
F-1.95010860149677
tp11919
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p11920
(F-1.1914957831887638
F-1.8080623333270733
tp11921
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11922
(F-0.9157518928433642
F-1.8516907325157752
tp11923
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11924
(F-0.8821775723347621
F-1.875699703509991
tp11925
sS'print today.strftime(\'We are the %d, %b %Y\')\n"""We are the 22, Nov 2008"""'
p11926
(F-1.8790612654252485
F-1.9452686309814453
tp11927
sS'mylist = []\ntoday = datetime.date.today()'
p11928
(F-2.1862094402313232
F-2.2282688434307394
tp11929
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11930
(F-0.9157518928433642
F-1.8516907325157752
tp11931
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p11932
(F-1.9598668905404897
F-2.1282777052659254
tp11933
sS'"""We are the 22, Nov 2008"""'
p11934
(F-1.820085843404134
F-2.30458010160006
tp11935
sS"mylist.append(today)\nprint mylist[0]\n2008 - 11 - 22\nprint 'This is a new day : ', mylist[0]"
p11936
(F-3.513852528163365
F-2.621103726900541
tp11937
sS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p11938
(F-1.8739821116129558
F-2.206210356492263
tp11939
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11940
(F-0.8987600077753481
F-1.8599075904259315
tp11941
sS"import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n2008 - 11 - 22\nprint 'This is a new day : ', mylist[0]"
p11942
(F-2.561187744140625
F-2.2251199575570912
tp11943
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()"
p11944
(F-1.4102001190185547
F-1.8307872185340295
tp11945
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p11946
(F-0.9022974438137479
F-1.8629942673903246
tp11947
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11948
(F-0.9206427549704527
F-1.8370706118070161
tp11949
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p11950
(F-1.0801778520856584
F-1.8222081111027644
tp11951
sS"print 'Current date and time: ', datetime.datetime.now()"
p11952
(F-1.6964441935221355
F-1.842948473416842
tp11953
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n2008 - 11 - 22'
p11954
(F-2.9504725864955357
F-2.358244382418119
tp11955
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11956
(F-0.97705078125
F-1.8181463388296275
tp11957
sS'mylist.append(today)\nprint mylist[0]'
p11958
(F-2.8386434827532088
F-2.7174415588378906
tp11959
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11960
(F-0.938612072284405
F-1.8362608689528246
tp11961
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11962
(F-0.938612072284405
F-1.8362608689528246
tp11963
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p11964
(F-1.0143359871797784
F-1.9002309945913463
tp11965
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p11966
(F-1.9201319217681885
F-2.1636356940636268
tp11967
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11968
(F-0.9109042174834058
F-1.84650758596567
tp11969
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11970
(F-0.97705078125
F-1.8181463388296275
tp11971
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11972
(F-0.903186772493708
F-1.8551122225247896
tp11973
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11974
(F-0.9500721650965074
F-1.8161327655498798
tp11975
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11976
(F-1.052504452792081
F-1.7982101440429688
tp11977
sS"print today.strftime('We are the %d, %b %Y')"
p11978
(F-1.5870839224921331
F-1.9462829002967248
tp11979
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11980
(F-0.8908571852851159
F-1.865351310143104
tp11981
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11982
(F-0.8882762767650463
F-1.8699986384465144
tp11983
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11984
(F-0.938612072284405
F-1.8362608689528246
tp11985
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11986
(F-0.8727090158770161
F-1.9027086404653697
tp11987
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n2008 - 11 - 22'
p11988
(F-2.7379074096679688
F-2.2131734994741588
tp11989
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11990
(F-0.9218909630408654
F-1.8394408592810998
tp11991
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11992
(F-0.8594886378238076
F-1.8883172548734224
tp11993
sS"import datetime\nprint datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p11994
(F-0.8252647717793783
F-1.9676400698148286
tp11995
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()"
p11996
(F-1.585771267230694
F-1.9098322941706731
tp11997
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11998
(F-1.2546528086942785
F-1.7846544705904448
tp11999
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p12000
(F-0.9886520385742188
F-1.8662994091327374
tp12001
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p12002
(F-0.9539170346017611
F-1.8880742880014272
tp12003
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p12004
(F-0.9008075674784553
F-1.8646871126615083
tp12005
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p12006
(F-1.2546528086942785
F-1.7846544705904448
tp12007
sS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p12008
(F-0.9770507033990354
F-1.8181463388296275
tp12009
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p12010
(F-0.9008075674784553
F-1.8646871126615083
tp12011
sS'import time'
p12012
(F-3.0357108116149902
F-2.412530752328726
tp12013
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p12014
(F-0.9140366002133018
F-1.848626503577599
tp12015
sS"print 'Current year: ', datetime.date.today().strftime('%Y')"
p12016
(F-1.2546528086942785
F-1.7846544705904448
tp12017
sS"print time.strftime('%Y-%m-%d %H:%M')"
p12018
(F-1.1630584928724501
F-1.8865379920372596
tp12019
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p12020
(F-0.9379357655843099
F-1.8365198282095103
tp12021
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p12022
(F-0.8933699420679395
F-1.8907998891977162
tp12023
sS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p12024
(F-1.052504337195194
F-1.7982101440429688
tp12025
sS"print datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p12026
(F-0.9209373474121094
F-1.9126406449538012
tp12027
sS'mylist = []'
p12028
(F-3.207984288533529
F-2.782292292668269
tp12029
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p12030
(F-0.97705078125
F-1.8181463388296275
tp12031
sS'today = datetime.date.today()'
p12032
(F-1.416241385719993
F-2.1035103431114783
tp12033
sS'print mylist[0]\n2008 - 11 - 22'
p12034
(F-4.8454413780799275
F-2.5086197486290565
tp12035
sS"print 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p12036
(F-1.0744927896035683
F-1.8017378586989183
tp12037
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p12038
(F-0.9527815993951292
F-1.8239038907564604
tp12039
sS"print 'Day of the month : ', datetime.date.today().strftime('%d')"
p12040
(F-1.2546528086942785
F-1.7846544705904448
tp12041
sS"print 'Month of year: ', datetime.date.today().strftime('%B')"
p12042
(F-1.2546528086942785
F-1.7846544705904448
tp12043
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p12044
(F-1.052504337195194
F-1.7982101440429688
tp12045
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p12046
(F-1.0116335550944011
F-1.8087152334359975
tp12047
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p12048
(F-0.8758025058480197
F-1.8846309368426983
tp12049
sS'mylist.append(today)\nprint mylist[0]\n2008 - 11 - 22'
p12050
(F-4.171502685546875
F-2.6514857365534854
tp12051
sS"import datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p12052
(F-0.8686086654663085
F-1.8779582977294922
tp12053
sS'mylist.append(today)'
p12054
(F-3.1170055866241455
F-2.719821343055138
tp12055
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p12056
(F-0.9032086972837094
F-1.8533279712383564
tp12057
sS"import time\nimport datetime\nprint 'Time in seconds since the epoch: %s' % time.time()\nprint 'Current date and time: ', datetime.datetime.now()"
p12058
(F-1.28246745356807
F-1.9230692936823919
tp12059
ssI1024847
(dp12060
S"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)"
p12061
(F-1.6724150148156571
F-1.7079034805297852
tp12062
sS'data.pop(key)\ndata.clear()'
p12063
(F-2.7118497576032365
F-1.7849754333496093
tp12064
sS"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})"
p12065
(F-1.5197439927321215
F-1.7327932357788085
tp12066
sS'print x\nx.update({(3): 4})\nprint x'
p12067
(F-2.8890220642089846
F-1.7809881210327148
tp12068
sS"d = {'key': 'value'}\nprint d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p12069
(F-1.2452000704678623
F-1.6363843917846679
tp12070
sS"data['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p12071
(F-2.09828689863097
F-1.6884553909301758
tp12072
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p12073
(F-1.6026286673038563
F-1.7408729553222657
tp12074
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)"
p12075
(F-1.65448055267334
F-1.7348007202148437
tp12076
sS"d = {'key': 'value'}\nprint d\nd['mynewkey'] = 'mynewvalue'"
p12077
(F-1.229323336952611
F-1.720302200317383
tp12078
sS'data.update(a=1)\ndata.update(data2)'
p12079
(F-2.9178356843836166
F-1.894035530090332
tp12080
sS'data = {}\ndata = dict()'
p12081
(F-1.5673925081888835
F-1.6640291213989258
tp12082
sS"data['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)"
p12083
(F-1.9232202529907227
F-1.6868900299072265
tp12084
sS'data.update(dict(a=1))'
p12085
(F-2.003023000863882
F-1.6733123779296875
tp12086
sS"d['mynewkey'] = 'mynewvalue'"
p12087
(F-1.2553184032440186
F-1.786473274230957
tp12088
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]'
p12089
(F-2.795855646548064
F-1.7464401245117187
tp12090
sS"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p12091
(F-1.881550336124921
F-1.7275976181030273
tp12092
sS'x = {(1): 2}\nprint x'
p12093
(F-2.5795901162283763
F-1.8769580841064453
tp12094
sS'data.pop(key)'
p12095
(F-2.863743305206299
F-1.7356533050537108
tp12096
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p12097
(F-1.616999259361854
F-1.7288307189941405
tp12098
sS"data.update({'a': 1})"
p12099
(F-1.4714760780334473
F-1.6853731155395508
tp12100
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p12101
(F-1.8640018809925427
F-1.721771240234375
tp12102
sS'data.update(dict(a=1))\ndata.update(a=1)'
p12103
(F-2.2547137520530005
F-1.6960969924926759
tp12104
sS"data.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p12105
(F-2.2681952007746293
F-1.6801998138427734
tp12106
sS'data.update(a=1)'
p12107
(F-2.839304733276367
F-1.9469131469726562
tp12108
sS"data['a'] = 1"
p12109
(F-1.888633131980896
F-2.0118129730224608
tp12110
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))"
p12111
(F-1.6300379435221355
F-1.7082923889160155
tp12112
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p12113
(F-1.7683133974180116
F-1.711197853088379
tp12114
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p12115
(F-1.8559352990352747
F-1.7138851165771485
tp12116
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p12117
(F-1.9310963439941407
F-1.8139328002929687
tp12118
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]'
p12119
(F-2.456087166922433
F-1.678177833557129
tp12120
sS'data.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p12121
(F-2.57845221625434
F-1.7120796203613282
tp12122
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))"
p12123
(F-1.608479745047433
F-1.7118701934814453
tp12124
sS'data = dict()'
p12125
(F-1.6744941983904158
F-1.6786916732788086
tp12126
sS"data['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p12127
(F-2.0426242909532912
F-1.7044055938720704
tp12128
sS"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)"
p12129
(F-1.6057804332059973
F-1.7579360961914063
tp12130
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))"
p12131
(F-1.7732257843017578
F-1.7178327560424804
tp12132
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p12133
(F-2.0088119506835938
F-1.7102529525756835
tp12134
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p12135
(F-1.7625042227811591
F-1.7153488159179688
tp12136
sS"data = {'a': 1, 'b': 2, 'c': 3}"
p12137
(F-0.9924962660845589
F-1.8780181884765625
tp12138
sS"data.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p12139
(F-2.2028213169263755
F-1.6573871612548827
tp12140
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p12141
(F-1.966417908668518
F-1.7239585876464845
tp12142
sS'data.update(data2)\ndel data[key]'
p12143
(F-2.6610110146658763
F-1.7020254135131836
tp12144
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p12145
(F-2.0620230142172282
F-1.7171810150146485
tp12146
sS"print d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p12147
(F-1.952727999005999
F-1.7034442901611329
tp12148
sS"print d\nd['mynewkey'] = 'mynewvalue'"
p12149
(F-2.0540726401589136
F-1.7791606903076171
tp12150
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p12151
(F-1.8475781954251802
F-1.7100252151489257
tp12152
sS'del data[key]'
p12153
(F-2.10298034123012
F-1.7376020431518555
tp12154
sS"data['a'] = 1\ndata.update({'a': 1})"
p12155
(F-1.5582178015457957
F-1.7342390060424804
tp12156
sS"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p12157
(F-1.7505931854248047
F-1.7171478271484375
tp12158
sS"data.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p12159
(F-2.263201875506707
F-1.6643444061279298
tp12160
sS'x = {(1): 2}\nprint x\nx.update({(3): 4})\nprint x'
p12161
(F-2.526961008707682
F-1.7603656768798828
tp12162
sS'x.update({(3): 4})'
p12163
(F-2.659374237060547
F-1.7712203979492187
tp12164
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p12165
(F-1.8032941403596296
F-1.7046794891357422
tp12166
sS"data.update({'a': 1})\ndata.update(dict(a=1))"
p12167
(F-1.7911116282145183
F-1.6304697036743163
tp12168
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})"
p12169
(F-1.763978746202257
F-1.749867820739746
tp12170
sS"data['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p12171
(F-2.1599365234375
F-1.694352149963379
tp12172
sS'del data[key]\ndata.pop(key)'
p12173
(F-2.349490301949637
F-1.7337022781372071
tp12174
sS"d = {'key': 'value'}"
p12175
(F-1.2772513495551214
F-1.6974512100219727
tp12176
sS'data.clear()'
p12177
(F-2.5455357687813893
F-2.2071865081787108
tp12178
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p12179
(F-2.6945003933376737
F-1.7310194015502929
tp12180
sS"data['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p12181
(F-2.170766657049006
F-1.7088714599609376
tp12182
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})"
p12183
(F-1.5716460655475486
F-1.728969192504883
tp12184
sS"data.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p12185
(F-2.1485269546508787
F-1.6721471786499023
tp12186
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)"
p12187
(F-1.7180313836960566
F-1.7038204193115234
tp12188
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p12189
(F-2.4769741694132485
F-1.6935405731201172
tp12190
sS'x = {(1): 2}\nprint x\nx.update({(3): 4})'
p12191
(F-2.531889456289786
F-1.7861528396606445
tp12192
sS'data.update(data2)'
p12193
(F-2.7619693279266357
F-1.9183427810668945
tp12194
sS'data = dict(a=1, b=2, c=3)'
p12195
(F-2.128961351182726
F-1.8053606033325196
tp12196
sS'x.update({(3): 4})\nprint x'
p12197
(F-2.8026046752929688
F-1.7562265396118164
tp12198
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p12199
(F-2.0774234633847892
F-1.728205680847168
tp12200
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)"
p12201
(F-1.6622407701280382
F-1.7242280960083007
tp12202
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)"
p12203
(F-1.8783398009183114
F-1.7173702239990234
tp12204
sS'x = {(1): 2}'
p12205
(F-2.5227914289994673
F-1.8831001281738282
tp12206
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)'
p12207
(F-2.4496249494881464
F-1.7052968978881835
tp12208
sS'print x\nx.update({(3): 4})'
p12209
(F-2.895999684053309
F-1.7989852905273438
tp12210
sS"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p12211
(F-1.5549713693014005
F-1.764214324951172
tp12212
sS'print d'
p12213
(F-3.773287296295166
F-1.8484687805175781
tp12214
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)"
p12215
(F-1.7008118448378164
F-1.7076360702514648
tp12216
sS"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p12217
(F-1.8587057462302587
F-1.7147947311401368
tp12218
sS'print x'
p12219
(F-3.7129340171813965
F-2.3242740631103516
tp12220
sS"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))"
p12221
(F-1.5679084062576294
F-1.7098690032958985
tp12222
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p12223
(F-2.761047871907552
F-1.7153533935546874
tp12224
sS'data.update(data2)\ndel data[key]\ndata.pop(key)'
p12225
(F-2.6477991739908853
F-1.6784107208251953
tp12226
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})"
p12227
(F-1.5920188540504092
F-1.723839569091797
tp12228
sS"data = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p12229
(F-1.7996588418650072
F-1.7061992645263673
tp12230
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p12231
(F-2.4896957760765437
F-1.679774856567383
tp12232
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p12233
(F-1.8752159481956845
F-1.7259138107299805
tp12234
sS'data = {}'
p12235
(F-1.9661877950032551
F-1.7091968536376954
tp12236
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}"
p12237
(F-1.1413066698157268
F-1.7117219924926759
tp12238
sS"d = {'key': 'value'}\nprint d"
p12239
(F-1.4440271059672039
F-1.6068008422851563
tp12240
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}"
p12241
(F-1.1821215493338448
F-1.702996826171875
tp12242
sS"d['mynewkey'] = 'mynewvalue'\nprint d"
p12243
(F-1.510166341608221
F-1.7190574645996093
tp12244
sS'del data[key]\ndata.pop(key)\ndata.clear()'
p12245
(F-2.4095489501953127
F-1.7578718185424804
tp12246
sS"data['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))"
p12247
(F-1.7466885966639365
F-1.6740367889404297
tp12248
sS"data.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)"
p12249
(F-1.9929495146780303
F-1.6516294479370117
tp12250
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3}\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1})\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p12251
(F-1.8011417978817654
F-1.700445556640625
tp12252
ssI120656
(dp12253
S"import os\nfor dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p12254
(F-1.2801902524886593
F-2.168152332305908
tp12255
sS"dirnames.remove('.git')"
p12256
(F-2.8735008239746094
F-2.6478254000345864
tp12257
sS"if '.git' in dirnames:\n    dirnames.remove('.git')"
p12258
(F-2.12186598777771
F-2.5565953254699707
tp12259
sS'for subdirname in dirnames:\n    pass\n'
p12260
(F-2.4765840010209517
F-2.594857692718506
tp12261
sS'for filename in filenames:\n    pass'
p12262
(F-1.7973752455277876
F-2.4963223139444985
tp12263
sS"import os\nfor filename in os.listdir('C:\\\\temp'):\n    pass"
p12264
(F-0.9500613965486225
F-2.3612356185913086
tp12265
sS"import os\nfor dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif '.git' in dirnames:\n    pass"
p12266
(F-1.1812023109113667
F-2.1303884188334146
tp12267
sS'print os.path.join(dirname, subdirname)'
p12268
(F-1.3914812528170073
F-2.34609047571818
tp12269
sS"import os\nfor dirname, dirnames, filenames in os.walk('.'):\n    pass"
p12270
(F-1.1738725745159646
F-2.181855042775472
tp12271
sS'for filename in filenames:\n    pass\n'
p12272
(F-1.7973752455277876
F-2.4963223139444985
tp12273
sS"for dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p12274
(F-1.3667043958391463
F-2.1152613957722983
tp12275
sS"for dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif '.git' in dirnames:\n    pass"
p12276
(F-1.2086167055017807
F-2.105023225148519
tp12277
sS"import os\nfor dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass\n"
p12278
(F-1.2037907020718444
F-2.1456244786580405
tp12279
sS"for filename in os.listdir('C:\\\\temp'):\n    pass\n"
p12280
(F-1.2167608737945557
F-2.348859945933024
tp12281
sS"import os\nfor dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        pass\n"
p12282
(F-1.2801902524886593
F-2.168152332305908
tp12283
sS"for dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass\n"
p12284
(F-1.2483953634897869
F-2.108042558034261
tp12285
sS"for dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass"
p12286
(F-1.2483953634897869
F-2.108042558034261
tp12287
sS'for subdirname in dirnames:\n    pass'
p12288
(F-2.4765840010209517
F-2.594857692718506
tp12289
sS"import os\nfor filename in os.listdir('C:\\\\temp'):\n    pass\n"
p12290
(F-0.9500613965486225
F-2.3612356185913086
tp12291
sS'import os'
p12292
(F-1.8026888370513916
F-2.726163864135742
tp12293
sS'print filename'
p12294
(F-2.766223907470703
F-2.5890067418416343
tp12295
sS"for dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        pass\n"
p12296
(F-1.3667043958391463
F-2.1152613957722983
tp12297
sS'os.listdir(path)'
p12298
(F-0.953452467918396
F-2.391287326812744
tp12299
sS"for filename in os.listdir('C:\\\\temp'):\n    pass"
p12300
(F-1.2167608737945557
F-2.348859945933024
tp12301
sS"import os\nfor dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif '.git' in dirnames:\n    dirnames.remove('.git')"
p12302
(F-1.260442432604338
F-2.1579642295837402
tp12303
sS"for filename in filenames:\n    print os.path.join(dirname, filename)\nif '.git' in dirnames:\n    pass"
p12304
(F-1.4140474873204385
F-2.21724526087443
tp12305
sS"for dirname, dirnames, filenames in os.walk('.'):\n    pass"
p12306
(F-1.3056674957275392
F-2.116405169169108
tp12307
sS"if '.git' in dirnames:\n    pass"
p12308
(F-2.0422990972345527
F-2.628014087677002
tp12309
sS"for filename in filenames:\n    print os.path.join(dirname, filename)\nif '.git' in dirnames:\n    dirnames.remove('.git')"
p12310
(F-1.5527920193142362
F-2.230569362640381
tp12311
sS"import os\nfor dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    pass"
p12312
(F-1.20379077686983
F-2.1456244786580405
tp12313
sS"for dirname, dirnames, filenames in os.walk('.'):\n    for subdirname in dirnames:\n        print os.path.join(dirname, subdirname)\nfor filename in filenames:\n    print os.path.join(dirname, filename)\nif '.git' in dirnames:\n    dirnames.remove('.git')"
p12314
(F-1.2882983063998288
F-2.140395164489746
tp12315
sS'print os.path.join(dirname, filename)'
p12316
(F-1.0746094630314753
F-2.2976155281066895
tp12317
ssI1823058
(dp12318
S"if x < 0:\n    return '-' + intWithCommas(-x)"
p12319
(F-2.5045379638671874
F-4.044089317321777
tp12320
sS"import locale\nlocale.setlocale(locale.LC_ALL, 'en_US')"
p12321
(F-0.6918182373046875
F-3.906057675679525
tp12322
sS"locale.setlocale(locale.LC_ALL, 'en_US')"
p12323
(F-0.7615434101649693
F-3.9855264027913413
tp12324
sS'group(-23432432434.34)'
p12325
(F-3.218878609793527
F-3.9966373443603516
tp12326
sS"def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        raise TypeError('Parameter must be an integer.')\nif x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)\nresult = ',%03d%s' % (r, result)"
p12327
(F-2.223037883799563
F-3.999255816141764
tp12328
sS"if x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)"
p12329
(F-2.5855358035065406
F-3.9328314463297525
tp12330
sS"format(1234567, ',d')"
p12331
(F-2.0922183990478516
F-3.8123928705851235
tp12332
sS"result = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)\nresult = ',%03d%s' % (r, result)"
p12333
(F-2.290963789995979
F-3.7955058415730796
tp12334
sS'"""{:,}""".format(value)'
p12335
(F-2.0445213317871094
F-3.79399045308431
tp12336
sS"def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        raise TypeError('Parameter must be an integer.')\nif x < 0:\n    pass"
p12337
(F-1.9592306099685968
F-4.189192454020183
tp12338
sS"if x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''"
p12339
(F-2.671856244405111
F-4.029559135437012
tp12340
sS'x, r = divmod(x, 1000)'
p12341
(F-2.838078180948893
F-3.7675606409708657
tp12342
sS'"""{:20,.2f}""".format(f)'
p12343
(F-1.8552327156066895
F-3.8190911610921225
tp12344
sS"result = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)\nresult = ',%03d%s' % (r, result)\nreturn '%d%s' % (x, result)"
p12345
(F-2.2821256060932957
F-3.77665646870931
tp12346
sS"result = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)"
p12347
(F-2.525110880533854
F-3.855144182840983
tp12348
sS"def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        raise TypeError('Parameter must be an integer.')\nif x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)\nresult = ',%03d%s' % (r, result)\nreturn '%d%s' % (x, result)"
p12349
(F-2.2232121486289826
F-3.9764525095621743
tp12350
sS"if x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)\nresult = ',%03d%s' % (r, result)\nreturn '%d%s' % (x, result)"
p12351
(F-2.4054897677513862
F-3.858330408732096
tp12352
sS'while x >= 1000:\n    x, r = divmod(x, 1000)'
p12353
(F-2.711190414428711
F-3.889794031778971
tp12354
sS"while x >= 1000:\n    x, r = divmod(x, 1000)\nresult = ',%03d%s' % (r, result)"
p12355
(F-2.4362828572591146
F-3.8172972997029624
tp12356
sS"if x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)\nresult = ',%03d%s' % (r, result)"
p12357
(F-2.444713664504717
F-3.8786357243855796
tp12358
sS"def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        raise TypeError('Parameter must be an integer.')\nif x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''"
p12359
(F-2.209263563156128
F-4.1733353932698565
tp12360
sS'def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        pass'
p12361
(F-2.2948131561279297
F-4.243643760681152
tp12362
sS"def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        raise TypeError('Parameter must be an integer.')\nif x < 0:\n    return '-' + intWithCommas(-x)"
p12363
(F-2.1363932291666665
F-4.182624181111653
tp12364
sS"def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        raise TypeError('Parameter must be an integer.')"
p12365
(F-2.1045789020817454
F-4.211638450622559
tp12366
sS"result = ',%03d%s' % (r, result)\nreturn '%d%s' % (x, result)"
p12367
(F-2.3058086395263673
F-3.8082669576009116
tp12368
sS"raise TypeError('Parameter must be an integer.')"
p12369
(F-1.7671915292739868
F-4.26858393351237
tp12370
sS"result = ''"
p12371
(F-2.0537532806396483
F-4.077567418416341
tp12372
sS"result = ',%03d%s' % (r, result)"
p12373
(F-2.272458856756037
F-3.8098939259847007
tp12374
sS"result = ''\nwhile x >= 1000:\n    pass"
p12375
(F-2.374805450439453
F-4.132666905721028
tp12376
sS"return '%d%s' % (x, result)"
p12377
(F-2.3623123168945312
F-3.793231964111328
tp12378
sS'def intWithCommas(x):\n    pass'
p12379
(F-2.4033238547188893
F-4.2699400583903
tp12380
sS"def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        raise TypeError('Parameter must be an integer.')\nif x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''\nwhile x >= 1000:\n    x, r = divmod(x, 1000)"
p12381
(F-2.2659851441900414
F-4.055052121480306
tp12382
sS"return '-' + intWithCommas(-x)"
p12383
(F-3.265965461730957
F-4.103271484375
tp12384
sS"def intWithCommas(x):\n    if type(x) not in [type(0), type(0L)]:\n        raise TypeError('Parameter must be an integer.')\nif x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''\nwhile x >= 1000:\n    pass"
p12385
(F-2.2065384323532515
F-4.171896616617839
tp12386
sS"while x >= 1000:\n    x, r = divmod(x, 1000)\nresult = ',%03d%s' % (r, result)\nreturn '%d%s' % (x, result)"
p12387
(F-2.4153092213166065
F-3.7957515716552734
tp12388
sS'if type(x) not in [type(0), type(0L)]:\n    pass'
p12389
(F-2.487024383544922
F-4.207956314086914
tp12390
sS"if type(x) not in [type(0), type(0L)]:\n    raise TypeError('Parameter must be an integer.')"
p12391
(F-2.1592981974283854
F-4.175971031188965
tp12392
sS'if x < 0:\n    pass'
p12393
(F-1.8458512046120383
F-3.9909938176472983
tp12394
sS"import locale\nlocale.setlocale(locale.LC_ALL, 'en_US')\nlocale.format('%d', 1255000, grouping=True)"
p12395
(F-1.2101310729980468
F-3.8501294453938804
tp12396
sS"if x < 0:\n    return '-' + intWithCommas(-x)\nresult = ''\nwhile x >= 1000:\n    pass"
p12397
(F-2.536431032068589
F-4.073540369669597
tp12398
sS'import locale'
p12399
(F-2.641663074493408
F-3.8900038401285806
tp12400
sS"locale.format('%d', 1255000, grouping=True)"
p12401
(F-2.2403038569859097
F-3.790724754333496
tp12402
sS'while x >= 1000:\n    pass'
p12403
(F-2.6255198392001065
F-4.245337168375651
tp12404
sS"locale.setlocale(locale.LC_ALL, 'en_US')\nlocale.format('%d', 1255000, grouping=True)"
p12405
(F-1.3189163208007812
F-3.8871024449666343
tp12406
ssI4383571
(dp12407
S"sys.path.insert(0, '/path/to/application/app/folder')"
p12408
(F-1.1198987166086833
F-2.221533033582899
tp12409
sS'import sys'
p12410
(F-2.783332109451294
F-2.427323235405816
tp12411
sS'import file'
p12412
(F-2.928173065185547
F-2.3014043172200522
tp12413
sS'PYTHONPATH'
p12414
(F-3.655546506245931
F-2.9691285027398004
tp12415
sS"sys.path.insert(0, '/path/to/application/app/folder')\nimport file"
p12416
(F-1.6796112060546875
F-2.1667077806260853
tp12417
sS"import sys\nsys.path.insert(0, '/path/to/application/app/folder')"
p12418
(F-0.9511839548746744
F-2.1948714786105685
tp12419
sS"import sys\nsys.path.insert(0, '/path/to/application/app/folder')\nimport file"
p12420
(F-1.3878412246704102
F-2.1630596584743924
tp12421
sS'from application.app.folder.file import func_name'
p12422
(F-4.523520333426339
F-2.2316536373562283
tp12423
ssI4641765
(dp12424
S'foo.append(4)'
p12425
(F-2.210073709487915
F-2.9302518367767334
tp12426
sS'things_to_add = [0, 1, 1, 0]'
p12427
(F-2.354238173540901
F-2.901625394821167
tp12428
sS'fooList.append(3)\nfooList.append(2734)\nprint fooList'
p12429
(F-2.2061894734700522
F-2.860337018966675
tp12430
sS'things_to_add = [0, 1, 1, 0]\nfor idx, amount in enumerate(things_to_add):\n    pass'
p12431
(F-2.311769061618381
F-2.6501145362854004
tp12432
sS'print fooList'
p12433
(F-4.66937484741211
F-3.084296226501465
tp12434
sS'things_to_add = [0, 1, 1, 0]\nfor idx, amount in enumerate(things_to_add):\n    L[idx] += amount'
p12435
(F-2.3298559421446265
F-2.650707960128784
tp12436
sS'foo.append(4)\nfoo.append([8, 7])\nprint foo'
p12437
(F-1.8727968389337712
F-2.801142454147339
tp12438
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]'
p12439
(F-1.8597612052128232
F-2.7520668506622314
tp12440
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor idx, amount in enumerate(things_to_add):\n    pass'
p12441
(F-1.9967327117919922
F-2.6984524726867676
tp12442
sS'foo = [1, 2, 3, 4, 5]\nfoo[3] = foo[3] + 4'
p12443
(F-1.4990108631275318
F-2.7368314266204834
tp12444
sS'foo = [1, 2, 3, 4, 5]\nfoo[3] = foo[3] + 4\nprint foo'
p12445
(F-1.5362073262532552
F-2.7903623580932617
tp12446
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)\nprint fooList'
p12447
(F-1.9416171803193933
F-2.807380199432373
tp12448
sS'fooList.append(3)'
p12449
(F-2.7707748413085938
F-2.8817343711853027
tp12450
sS'for idx, amount in things_to_add:\n    pass'
p12451
(F-3.2328623603372013
F-2.6415629386901855
tp12452
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])'
p12453
(F-1.3717459476355351
F-2.6849474906921387
tp12454
sS"L = [0, 0, 0, 0]\nthings_to_add = {'idx': 1, 'amount': 1}, {'idx': 2, 'amount': 1}\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12455
(F-1.92001909198183
F-2.93747878074646
tp12456
sS'foo.append([8, 7])\nprint foo'
p12457
(F-2.1473429361979166
F-2.8132245540618896
tp12458
sS"things_to_add = {'idx': 1, 'amount': 1}, {'idx': 2, 'amount': 1}\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12459
(F-2.008251331470631
F-2.9945430755615234
tp12460
sS'for idx, amount in things_to_add:\n    L[idx] += amount\nL'
p12461
(F-3.2346267700195312
F-2.6382381916046143
tp12462
sS'things_to_add = [(1, 1), (2, 1)]\nfor idx, amount in things_to_add:\n    pass'
p12463
(F-2.3260110391152873
F-2.6717700958251953
tp12464
sS"L = [0, 0, 0, 0]\nthings_to_add = {'idx': 1, 'amount': 1}, {'idx': 2, 'amount': 1}\nfor item in things_to_add:\n    pass"
p12465
(F-1.9407799198942364
F-2.7759461402893066
tp12466
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor idx, amount in enumerate(things_to_add):\n    L[idx] += amount'
p12467
(F-1.9837754447505158
F-2.6941168308258057
tp12468
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)'
p12469
(F-1.929031499226888
F-2.78999662399292
tp12470
sS'print foo'
p12471
(F-3.9285764694213867
F-3.3442461490631104
tp12472
sS'foo[3] = foo[3] + 4'
p12473
(F-2.327440701998197
F-2.8388030529022217
tp12474
sS"L = [0, 0, 0, 0]\nthings_to_add = {'idx': 1, 'amount': 1}, {'idx': 2, 'amount': 1}\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p12475
(F-1.838728904724121
F-2.9088640213012695
tp12476
sS'foo = [1, 2, 3, 4, 5]'
p12477
(F-1.2175938924153646
F-2.7282702922821045
tp12478
sS'print x'
p12479
(F-3.367473602294922
F-3.0379788875579834
tp12480
sS"L = [0, 0, 0, 0]\nthings_to_add = {'idx': 1, 'amount': 1}, {'idx': 2, 'amount': 1}"
p12481
(F-1.7867435553135016
F-2.7883386611938477
tp12482
sS'fooList = [1, 3, 348, 2]'
p12483
(F-2.445901325770787
F-2.7931511402130127
tp12484
sS"things_to_add = {'idx': 1, 'amount': 1}, {'idx': 2, 'amount': 1}"
p12485
(F-1.9031923082139757
F-3.2830722332000732
tp12486
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)'
p12487
(F-1.2969049973921343
F-2.7225875854492188
tp12488
sS'fooList.append(3)\nfooList.append(2734)'
p12489
(F-2.1369543636546418
F-2.8587048053741455
tp12490
sS'L[idx] += amount'
p12491
(F-3.397134304046631
F-2.7130985260009766
tp12492
sS'foo.append([8, 7])'
p12493
(F-2.0256471633911133
F-2.7528162002563477
tp12494
sS'for idx, amount in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12495
(F-2.8300597579390914
F-2.651289939880371
tp12496
sg8166
(F-5.17510986328125
F-3.023892879486084
tp12497
sS"things_to_add = {'idx': 1, 'amount': 1}, {'idx': 2, 'amount': 1}\nfor item in things_to_add:\n    pass"
p12498
(F-2.038120921065168
F-2.8562309741973877
tp12499
sS'foo.append(4)\nfoo.append([8, 7])'
p12500
(F-1.8366879914936267
F-2.744828701019287
tp12501
sS'things_to_add = [0, 1, 1, 0]\nfor idx, amount in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12502
(F-2.495445074037064
F-2.6822996139526367
tp12503
sS'things_to_add = [(1, 1), (2, 1)]\nfor idx, amount in things_to_add:\n    L[idx] += amount\nL'
p12504
(F-2.5176877108487217
F-2.6968376636505127
tp12505
sS'x = [2, 5, 10]\nx.insert(2, 77)'
p12506
(F-2.2054367065429688
F-2.747499704360962
tp12507
sS'things_to_add = [(1, 1), (2, 1)]\nfor idx, amount in things_to_add:\n    L[idx] += amount'
p12508
(F-2.366886502220517
F-2.6659960746765137
tp12509
sS"for item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p12510
(F-2.4916300092424666
F-2.963014602661133
tp12511
sS'L[:] = [sum(i) for i in zip(L, things_to_add)]'
p12512
(F-2.2865336491511417
F-2.782529354095459
tp12513
sS'x.insert(2, 77)\nprint x'
p12514
(F-2.8796204787034254
F-2.8485007286071777
tp12515
sS'things_to_add = [(1, 1), (2, 1)]'
p12516
(F-2.0419520423525857
F-2.753755569458008
tp12517
sS'for idx, amount in enumerate(things_to_add):\n    L[idx] += amount'
p12518
(F-2.6140087890625
F-2.6222290992736816
tp12519
sS"for item in things_to_add:\n    L[item['idx']] += item['amount']"
p12520
(F-2.2826951833871694
F-2.9384310245513916
tp12521
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor idx, amount in enumerate(things_to_add):\n    L[idx] += amount\nL'
p12522
(F-2.1061365300958808
F-2.721409559249878
tp12523
sS'for item in things_to_add:\n    pass'
p12524
(F-2.8926775614420572
F-2.7704758644104004
tp12525
sS'for idx, amount in enumerate(things_to_add):\n    pass'
p12526
(F-2.6813175201416017
F-2.62626051902771
tp12527
sS"L[item['idx']] += item['amount']"
p12528
(F-2.398738588605608
F-3.0424065589904785
tp12529
sS"things_to_add = {'idx': 1, 'amount': 1}, {'idx': 2, 'amount': 1}\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p12530
(F-1.8855995765099158
F-2.9706053733825684
tp12531
sS'x = [2, 5, 10]'
p12532
(F-1.8997657082297585
F-2.7354679107666016
tp12533
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])\nprint foo'
p12534
(F-1.3892528745863173
F-2.731644868850708
tp12535
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)'
p12536
(F-2.21421987360174
F-2.779778003692627
tp12537
sS'x.insert(2, 77)'
p12538
(F-3.0500648498535154
F-2.8681390285491943
tp12539
sS'L = [0, 0, 0, 0]'
p12540
(F-1.4845206920917218
F-2.752033233642578
tp12541
sS'foo[3] = foo[3] + 4\nprint foo'
p12542
(F-2.3564653396606445
F-2.8821842670440674
tp12543
sS'x = [2, 5, 10]\nx.insert(2, 77)\nprint x'
p12544
(F-2.0964178002398945
F-2.7299206256866455
tp12545
sS'fooList.append(2734)'
p12546
(F-2.44049432542589
F-2.9115848541259766
tp12547
sS'for idx, amount in things_to_add:\n    L[idx] += amount'
p12548
(F-3.0330096158114346
F-2.608682632446289
tp12549
sS'fooList.append(2734)\nprint fooList'
p12550
(F-2.627339583176833
F-2.8978068828582764
tp12551
ssI1747817
(dp12552
S'def key_value_gen(k):\n    yield chr(k + 65)'
p12553
(F-2.918037761341442
F-2.0850879669189455
tp12554
sS'yield chr((k + 13) % 26 + 65)\nd = dict(map(key_value_gen, range(26)))'
p12555
(F-3.4400628033806298
F-2.252494049072266
tp12556
sS'dict(gen)'
p12557
(F-2.8838723500569663
F-1.8400869369506836
tp12558
sS'yield chr((k + 13) % 26 + 65)'
p12559
(F-3.7490030924479165
F-2.8166730880737303
tp12560
sS'd = {key: value for key, value in iterable}'
p12561
(F-1.596135965983073
F-1.7350309371948243
tp12562
sS'dict(ts)\ngen = ((i, i + 1) for i in range(1, 6, 2))\ngen'
p12563
(F-2.455172138829385
F-1.8218727111816406
tp12564
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, i + 1) for i in range(1, 6, 2))\ngen'
p12565
(F-1.9510004295493073
F-1.9339071273803712
tp12566
sS'd = dict(map(key_value_gen, range(26)))'
p12567
(F-3.060896301269531
F-1.8435630798339844
tp12568
sS'def key_value_gen(k):\n    yield chr(k + 65)\nyield chr((k + 13) % 26 + 65)'
p12569
(F-3.293724695841471
F-2.37635498046875
tp12570
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, i + 1) for i in range(1, 6, 2))\ngen\ndict(gen)'
p12571
(F-2.1637741615032327
F-1.9010772705078125
tp12572
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)'
p12573
(F-1.7260229928152901
F-1.9351198196411132
tp12574
sS'dict(ts)\ngen = ((i, i + 1) for i in range(1, 6, 2))\ngen\ndict(gen)'
p12575
(F-2.708343505859375
F-1.8139215469360352
tp12576
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, i + 1) for i in range(1, 6, 2))'
p12577
(F-1.7478806738759958
F-1.9355318069458007
tp12578
sS'gen = ((i, i + 1) for i in range(1, 6, 2))'
p12579
(F-1.6431482632954915
F-2.0933483123779295
tp12580
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr(k + 65)'
p12581
(F-3.076375916946766
F-1.8058887481689454
tp12582
sS'def key_value_gen(k):\n    pass'
p12583
(F-2.5596418380737305
F-1.9157419204711914
tp12584
sS'ts = [(1, 2), (3, 4), (5, 6)]'
p12585
(F-1.4492001740828804
F-2.0531284332275392
tp12586
sS'd = {k: v for k, v in iterable}'
p12587
(F-1.2975573221842447
F-1.7321687698364259
tp12588
sS'dict(ts)'
p12589
(F-2.977386474609375
F-1.9309856414794921
tp12590
sS'gen\ndict(gen)'
p12591
(F-4.845013618469238
F-1.820656967163086
tp12592
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr(k + 65)\nyield chr((k + 13) % 26 + 65)\nd = dict(map(key_value_gen, range(26)))'
p12593
(F-3.2614822387695312
F-1.9249654769897462
tp12594
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr(k + 65)\nyield chr((k + 13) % 26 + 65)'
p12595
(F-3.276881167763158
F-1.958941650390625
tp12596
sS'gen'
p12597
(F-6.0470937093098955
F-2.116245651245117
tp12598
sS'd = {value: foo(value) for value in sequence if bar(value)}'
p12599
(F-3.125667027064732
F-1.7175310134887696
tp12600
sS'd = dict((key, value) for key, value in iterable)'
p12601
(F-1.4695327546861436
F-1.7989437103271484
tp12602
sS'gen = ((i, i + 1) for i in range(1, 6, 2))\ngen\ndict(gen)'
p12603
(F-2.4819294098884828
F-1.9960779190063476
tp12604
sS'gen = ((i, i + 1) for i in range(1, 6, 2))\ngen'
p12605
(F-2.1121802696814904
F-2.090623664855957
tp12606
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    pass'
p12607
(F-2.9367985081028296
F-1.7326364517211914
tp12608
sS'def key_value_gen(k):\n    yield chr(k + 65)\nyield chr((k + 13) % 26 + 65)\nd = dict(map(key_value_gen, range(26)))'
p12609
(F-3.271074329723011
F-2.162554168701172
tp12610
sS'yield chr(k + 65)'
p12611
(F-4.391042073567708
F-2.795133590698242
tp12612
sS'dict(ts)\ngen = ((i, i + 1) for i in range(1, 6, 2))'
p12613
(F-2.09472682558257
F-1.8268875122070312
tp12614
ssI2793324
(dp12615
S'a = [1, 2, 3, 4]'
p12616
(F-1.040475845336914
F-1.8981987448299633
tp12617
sS'a = [x for x in a if x != 2]\nprint a'
p12618
(F-1.123176680670844
F-1.8869754566865808
tp12619
sS'if 6 in a:\n    pass'
p12620
(F-2.228763233531605
F-1.9541002161362593
tp12621
sS'a.remove(c)'
p12622
(F-1.9578745365142822
F-1.9386331894818474
tp12623
sS'pass'
p12624
(F-3.1888793309529624
F-2.1410668317009423
tp12625
sS'a = [1, 2, 3, 4]\nif 6 in a:\n    pass'
p12626
(F-1.3999720034391985
F-1.9198415419634651
tp12627
sS'print a'
p12628
(F-2.8421244621276855
F-2.0424907908720127
tp12629
sS"a.remove('b')"
p12630
(F-1.650203824043274
F-1.9874227187212776
tp12631
sS'a.remove(6)'
p12632
(F-2.3985095024108887
F-1.9452303718118107
tp12633
sS'a = [x for x in a if x != 2]'
p12634
(F-1.0899754842122396
F-1.8881604811724495
tp12635
sS"a.remove('b')\nprint a"
p12636
(F-1.47172043540261
F-1.9874563778147978
tp12637
sS'a = [1, 2, 3, 4]\nif 6 in a:\n    a.remove(6)'
p12638
(F-1.540912355695452
F-1.9160277422736673
tp12639
sS"a = ['a', 'b', 'c', 'd']\na.remove('b')"
p12640
(F-1.1037982940673827
F-1.9304472979377298
tp12641
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if x != 2]'
p12642
(F-1.154729989858774
F-1.9431856940774357
tp12643
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]'
p12644
(F-1.3098356628417969
F-1.9283070283777572
tp12645
sS'try:\n    a.remove(6)\nexcept:\n    pass'
p12646
(F-1.4504060745239258
F-2.1098673203412224
tp12647
sS'try:\n    a.remove(c)\nexcept ValueError:\n    pass'
p12648
(F-1.1114628531716086
F-2.001973769244026
tp12649
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if x != 2]\nprint a'
p12650
(F-1.1381525312151228
F-1.9521006415872013
tp12651
sS'if 6 in a:\n    a.remove(6)'
p12652
(F-2.3149185180664062
F-1.934987236471737
tp12653
sS'if c in a:\n    pass'
p12654
(F-1.9230012026700107
F-1.9435007431927849
tp12655
sS"a = ['a', 'b', 'c', 'd']"
p12656
(F-0.8819791353665866
F-1.9077168632956112
tp12657
sS'if c in a:\n    a.remove(c)'
p12658
(F-1.686537504196167
F-1.9211324803969438
tp12659
sS"a = ['a', 'b', 'c', 'd']\na.remove('b')\nprint a"
p12660
(F-0.9782382301662279
F-1.932097266702091
tp12661
ssI3523048
(dp12662
S'my_choices.insert(0, another_choice)'
p12663
(F-3.151414326259068
F-2.7967155456542967
tp12664
sS'foo'
p12665
(F-4.694631576538086
F-2.8638671875
tp12666
sS'foo = (1,), (2,), (3,)\nfoo = ((0,),) + foo\nfoo'
p12667
(F-2.383673667907715
F-2.5506511688232423
tp12668
sS'foo = (1,), (2,), (3,)'
p12669
(F-1.9606812795003254
F-2.5940622329711913
tp12670
sS'foo = (1,), (2,), (3,)\nfoo = ((0,),) + foo'
p12671
(F-2.2312601725260417
F-2.5589494705200195
tp12672
sS'foo = ((0,),) + foo'
p12673
(F-2.75400396493765
F-2.679843521118164
tp12674
sS'final_choices = (another_choice,) + my_choices'
p12675
(F-3.6697914600372314
F-2.5241397857666015
tp12676
sS"my_choices = [('1', 'first choice'), ('2', 'second choice'), ('3',\n    'third choice')]"
p12677
(F-1.1845119182880108
F-2.8455081939697267
tp12678
sS'foo = ((0,),) + foo\nfoo'
p12679
(F-3.067496744791667
F-2.668113899230957
tp12680
ssI123198
(dp12681
S'from shutil import copyfile\ncopyfile(src, dst)'
p12682
(F-1.9462996262770433
F-1.1704662496393377
tp12683
sS'from shutil import copyfile'
p12684
(F-1.8660901387532551
F-1.0926550951871006
tp12685
sS"shutil.copy2('/dir/file.ext', '/new/dir')"
p12686
(F-1.4222610473632813
F-1.19000920382413
tp12687
sS"import shutil\nshutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p12688
(F-1.1676217592679536
F-1.1766990314830432
tp12689
sS"shutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p12690
(F-1.4222610473632813
F-1.19000920382413
tp12691
sS'copyfile(src, dst)'
p12692
(F-2.736502170562744
F-1.4156641526655718
tp12693
sS'import shutil'
p12694
(F-2.7094931602478027
F-1.0817304091020064
tp12695
ssI1602934
(dp12696
S'd[i % 10] += 1'
p12697
(F-3.0681789398193358
F-2.7478583653767905
tp12698
sS"if 'key1' in dict:\n    pass"
p12699
(F-1.3830047954212537
F-2.272815545399984
tp12700
sS'from collections import defaultdict\nd = defaultdict(lambda : 0)'
p12701
(F-1.561489741007487
F-2.386796315511068
tp12702
sS"if 'key1' in dict:\n    pass\n"
p12703
(F-1.3830046220259233
F-2.272815545399984
tp12704
sS"'a' in d"
p12705
(F-3.204233169555664
F-2.5044260025024414
tp12706
sS'd[key] = d.get(key, 0) + 1'
p12707
(F-1.8010446885052849
F-2.4483009974161782
tp12708
sS'd = dict()\nfor i in xrange(100):\n    key = i % 10\nif key in d:\n    d[key] += 1\nelse:\n    d[key] = 1'
p12709
(F-1.2831111234777115
F-2.340939203898112
tp12710
sS'd = dict()\nfor i in xrange(100):\n    pass'
p12711
(F-1.4230093002319335
F-2.3137184778849282
tp12712
sS'if key in d:\n    pass'
p12713
(F-1.4789525812322444
F-2.2438348134358725
tp12714
sS"if 'key1' in dict:\n    print 'blah'\nelse:\n    print 'boo'"
p12715
(F-0.6767025470733643
F-2.2859891255696616
tp12716
sS'd = dict()\nfor i in xrange(100):\n    key = i % 10'
p12717
(F-1.5582923889160156
F-2.39593505859375
tp12718
sS'for i in xrange(100):\n    key = i % 10\nif key in d:\n    d[key] += 1\nelse:\n    d[key] = 1'
p12719
(F-1.3858932495117187
F-2.3726229667663574
tp12720
sS'from collections import defaultdict\nd = defaultdict(lambda : 0)\nfor i in xrange(100):\n    pass'
p12721
(F-1.4496006284441267
F-2.340394655863444
tp12722
sS'd = defaultdict(lambda : 0)\nfor i in xrange(100):\n    pass'
p12723
(F-1.753949372664742
F-2.352242946624756
tp12724
sS"if 'key1' in dict:\n    print 'blah'\nelse:\n    pass"
p12725
(F-0.896268041510331
F-2.273535410563151
tp12726
sS'd[key] += 1'
p12727
(F-2.210707426071167
F-2.371586481730143
tp12728
sS'if key in d:\n    d[key] += 1\nelse:\n    pass'
p12729
(F-1.1419470413871433
F-2.2660853068033853
tp12730
sS'for i in xrange(100):\n    d[i % 10] += 1'
p12731
(F-1.6250554039364768
F-2.7566308975219727
tp12732
sS'for i in xrange(100):\n    key = i % 10\nif key in d:\n    d[key] += 1'
p12733
(F-1.5755594426935369
F-2.398550351460775
tp12734
sS'd = dict()'
p12735
(F-1.7846828188214983
F-2.46785036722819
tp12736
sS'if key in d:\n    d[key] += 1\nelse:\n    d[key] = 1'
p12737
(F-1.0942495209830148
F-2.3119572003682456
tp12738
sS'd = dict()\nfor i in xrange(100):\n    key = i % 10\nif key in d:\n    d[key] += 1\nelse:\n    pass'
p12739
(F-1.3494866412618887
F-2.3172852198282876
tp12740
sS'd = dict()\nfor i in xrange(100):\n    key = i % 10\nif key in d:\n    pass'
p12741
(F-1.5536512487074907
F-2.3268152872721353
tp12742
sS'for i in xrange(100):\n    key = i % 10\nif key in d:\n    d[key] += 1\nelse:\n    pass'
p12743
(F-1.451731300354004
F-2.380136171976725
tp12744
sS"d = {'a': 1, 'b': 2}"
p12745
(F-1.2161672298724835
F-2.468528429667155
tp12746
sS'from collections import defaultdict\nd = defaultdict(lambda : 0)\nfor i in xrange(100):\n    d[i % 10] += 1'
p12747
(F-1.5593887329101563
F-2.370411237080892
tp12748
sS'd = defaultdict(lambda : 0)\nfor i in xrange(100):\n    d[i % 10] += 1'
p12749
(F-1.7767127990722655
F-2.398038864135742
tp12750
sS'd = dict()\nfor i in xrange(100):\n    key = i % 10\nd[key] = d.get(key, 0) + 1'
p12751
(F-1.6001981735229491
F-2.3665987650553384
tp12752
sS'from collections import defaultdict'
p12753
(F-2.3281304041544595
F-2.364309628804525
tp12754
sS'd[key] = 1'
p12755
(F-2.2224888801574707
F-2.3803234100341797
tp12756
sS"'a' in d\n'c' in d"
p12757
(F-3.788191901312934
F-2.475504716237386
tp12758
sS'for i in xrange(100):\n    pass'
p12759
(F-1.3830204010009766
F-2.746941566467285
tp12760
sS'd = defaultdict(lambda : 0)'
p12761
(F-2.4439682006835937
F-2.4127675692240396
tp12762
sS"d = {'a': 1, 'b': 2}\n'a' in d"
p12763
(F-1.9025248359231388
F-2.4107085863749185
tp12764
sS'for i in xrange(100):\n    key = i % 10\nif key in d:\n    pass'
p12765
(F-1.682370322091239
F-2.523145834604899
tp12766
sS"print 'blah'"
p12767
(F-2.3211917877197266
F-2.9693737030029297
tp12768
sS'for i in xrange(100):\n    key = i % 10\nd[key] = d.get(key, 0) + 1'
p12769
(F-1.722161236931296
F-2.5288678805033364
tp12770
sS'd = dict()\nfor i in xrange(100):\n    key = i % 10\nif key in d:\n    d[key] += 1'
p12771
(F-1.4486073224972456
F-2.336945374806722
tp12772
sS'key = i % 10'
p12773
(F-3.484363283429827
F-3.1317580540974936
tp12774
sS"'c' in d"
p12775
(F-3.204233169555664
F-2.504425843556722
tp12776
sS"d = {'a': 1, 'b': 2}\n'a' in d\n'c' in d"
p12777
(F-2.3310183570498513
F-2.4022048314412436
tp12778
sS'if key in d:\n    d[key] += 1'
p12779
(F-1.3133015632629395
F-2.3023905754089355
tp12780
sS"print 'boo'"
p12781
(F-2.3211917877197266
F-2.9693737030029297
tp12782
sS'for i in xrange(100):\n    key = i % 10'
p12783
(F-1.6030388938056097
F-2.9281622568766275
tp12784
ssI9573244
(dp12785
S'if not some_string:\n    pass'
p12786
(F-1.447801907857259
F-1.9427268981933594
tp12787
sS"bool('')\nbool('   ')"
p12788
(F-2.9197710210626777
F-2.086993408203125
tp12789
sS'if some_string:\n    pass'
p12790
(F-1.7461117831143467
F-1.9939094543457032
tp12791
sS'if not my_string:\n    pass'
p12792
(F-1.3357677459716797
F-1.9277820587158203
tp12793
sS"bool('   ')\nbool('   '.strip())"
p12794
(F-2.588501230875651
F-2.065247344970703
tp12795
sS'pass'
p12796
(F-2.7502435048421225
F-2.2314414978027344
tp12797
sS"bool('')\nbool('   ')\nbool('   '.strip())"
p12798
(F-2.6240102767944338
F-2.0814904530843097
tp12799
sS"bool('   '.strip())"
p12800
(F-2.4034427642822265
F-2.050731404622396
tp12801
sS'if not myString:\n    pass'
p12802
(F-1.6213665008544922
F-1.980079142252604
tp12803
sS"bool('   ')"
p12804
(F-2.8717371622721353
F-2.0638387044270834
tp12805
sS"bool('')"
p12806
(F-2.8717368443806968
F-2.0638384501139324
tp12807
ssI743806
(dp12808
S"words = text.split(',')"
p12809
(F-1.7612857818603516
F-1.386752234564887
tp12810
sS"line = 'a sentence with a few words'\nline.split()"
p12811
(F-1.77172175320712
F-1.542713377210829
tp12812
sS'words = text.split()'
p12813
(F-2.0034395853678384
F-1.3731088638305664
tp12814
sS'line.split()'
p12815
(F-1.5738236563546317
F-1.510532061258952
tp12816
sS'word.append(words)'
p12817
(F-2.6666412353515625
F-1.5280494689941406
tp12818
sS"line = 'a sentence with a few words'"
p12819
(F-2.403769874572754
F-1.707325193617079
tp12820
sS'words.append(word)'
p12821
(F-2.077935218811035
F-1.5043042500813801
tp12822
sS'text.split()'
p12823
(F-1.5390180860246931
F-1.4905946519639757
tp12824
ssI518021
(dp12825
S'len(l)\nlen(s)'
p12826
(F-2.0973587036132812
F-1.7497417449951171
tp12827
sS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)\nlen(s)"
p12828
(F-1.3920221681948062
F-1.7481517791748047
tp12829
sS"s = 'abcde'"
p12830
(F-2.2345249176025392
F-1.9424863815307618
tp12831
sS'len(l)'
p12832
(F-1.912654717763265
F-1.7042295455932617
tp12833
sS"s = 'abcde'\nlen(l)\nlen(s)"
p12834
(F-1.558343505859375
F-1.8346607208251953
tp12835
sS'len(s)'
p12836
(F-1.9207027753194172
F-1.757634735107422
tp12837
sS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)"
p12838
(F-1.369887265292081
F-1.7305330276489257
tp12839
sS"l = [1, 2, 3, 4]\ns = 'abcde'"
p12840
(F-1.4454728294821346
F-1.7177101135253907
tp12841
sS'len(my_list)'
p12842
(F-1.7030987739562988
F-1.6778850555419922
tp12843
sS"s = 'abcde'\nlen(l)"
p12844
(F-1.6372007369995116
F-1.8517671585083009
tp12845
sS'my_tuple = 1, 2, 3, 4, 5\nlen(my_tuple)'
p12846
(F-2.713475834239613
F-1.7042442321777345
tp12847
sS"my_string = 'hello world'"
p12848
(F-2.394374029976981
F-1.9809789657592773
tp12849
sS"my_string = 'hello world'\nlen(my_string)"
p12850
(F-1.901113646371024
F-1.9368293762207032
tp12851
sS'my_list = [1, 2, 3, 4, 5]'
p12852
(F-1.1197584937600529
F-1.674881362915039
tp12853
sS'my_tuple = 1, 2, 3, 4, 5'
p12854
(F-3.060280609130859
F-1.7140316009521483
tp12855
sS'len(my_string)'
p12856
(F-2.3386688232421875
F-1.8439781188964843
tp12857
sS'l = [1, 2, 3, 4]'
p12858
(F-1.2943800412691557
F-1.6805391311645508
tp12859
sS'len(my_tuple)'
p12860
(F-2.5709118843078613
F-1.6525457382202149
tp12861
sS'my_list = [1, 2, 3, 4, 5]\nlen(my_list)'
p12862
(F-1.1189827919006348
F-1.6794315338134767
tp12863
ssI19339
(dp12864
S"zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])"
p12865
(F-1.2229583528306749
F-4.862850824991862
tp12866
sS'result = (a for a, b in original), (b for a, b in original)'
p12867
(F-3.039029328719429
F-5.089358647664388
tp12868
sS"zip(('a', 1), ('b', 2), ('c', 3), ('d', 4))"
p12869
(F-1.2664993831089564
F-4.918321927388509
tp12870
sS"map(None, *[('a', 1), ('b', 2), ('c', 3), ('d', 4), ('e',)])"
p12871
(F-1.6171180323550576
F-5.043503443400065
tp12872
sS'result = [a for a, b in original], [b for a, b in original]'
p12873
(F-2.9982893570609717
F-5.052004496256511
tp12874
sS"zip(*[('a', 1), ('b', 2), ('c', 3), ('d', 4)])"
p12875
(F-1.1379272707047001
F-4.8606570561726885
tp12876
ssI510348
(dp12877
S"import time\nwhile True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p12878
(F-0.9885202407836914
F-1.7048630714416504
tp12879
sS'time.sleep(60)'
p12880
(F-0.7199621796607971
F-1.7569915453592937
tp12881
sS'import time\ntime.sleep(60)'
p12882
(F-0.716746677051891
F-1.6217864354451497
tp12883
sS'from time import sleep'
p12884
(F-1.1671396096547444
F-1.7687575022379558
tp12885
sS"print 'This prints once a minute.'"
p12886
(F-2.1391048431396484
F-2.123205820719401
tp12887
sS'import time'
p12888
(F-2.0514907836914062
F-1.8153225580851238
tp12889
sS'time.sleep(5)'
p12890
(F-0.7755425572395325
F-1.7291696866353352
tp12891
sS'sleep(0.1)'
p12892
(F-1.8146586418151855
F-2.017641544342041
tp12893
sS'import time\nwhile True:\n    pass\n'
p12894
(F-1.1567407449086506
F-1.7631948788960774
tp12895
sS'import time\ntime.sleep(5)'
p12896
(F-0.7612154700539329
F-1.5659464200337727
tp12897
sS'from time import sleep\nsleep(0.1)'
p12898
(F-0.9966258135708895
F-1.6497259140014648
tp12899
sS'while True:\n    pass'
p12900
(F-1.562520768907335
F-1.9251484870910645
tp12901
sS'import time\ntime.sleep(0.1)'
p12902
(F-0.9301379810680043
F-1.5439287821451824
tp12903
sS"while True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p12904
(F-1.1977224910960478
F-1.8324974377950032
tp12905
sS'while True:\n    pass\n'
p12906
(F-1.562520768907335
F-1.9251484870910645
tp12907
sS'time.sleep(0.1)'
p12908
(F-0.936195969581604
F-1.7047290802001953
tp12909
sS'import time\nwhile True:\n    pass'
p12910
(F-1.1567407449086506
F-1.7631948788960774
tp12911
sS'time.sleep(time.localtime(time.time())[5])'
p12912
(F-1.551130485534668
F-1.6165428161621094
tp12913
ssI2151517
(dp12914
S'results_list = [[1, 2, 3], [1, 2, 4]]\nresults_union = set().union(*results_list)'
p12915
(F-1.8113002288035858
F-3.371168409075056
tp12916
sS'results_union = set().union(*results_list)'
p12917
(F-2.719436196719899
F-3.1899544852120534
tp12918
sS'print results_union'
p12919
(F-4.782887140909831
F-3.662512642996652
tp12920
sS'results_list = [[1, 2, 3], [1, 2, 4]]\nresults_union = set().union(*results_list)\nprint results_union'
p12921
(F-1.9051558754660867
F-3.3668975830078125
tp12922
sS'import itertools'
p12923
(F-2.790351390838623
F-3.579451152256557
tp12924
sS'results_list = [[1, 2, 3], [1, 2, 4]]'
p12925
(F-1.3346842890200408
F-3.4505443572998047
tp12926
sS'return list(set(itertools.chain(*result_list)))'
p12927
(F-1.9486736721462674
F-3.42185183933803
tp12928
sS'results_union = set().union(*results_list)\nprint results_union'
p12929
(F-2.716931949962269
F-3.204358237130301
tp12930
ssI82831
(dp12931
S"print os.path.isfile('/etc/password.txt')"
p12932
(F-1.4218924262306907
F-1.4984400822566106
tp12933
sS"print os.path.isfile('/etc')"
p12934
(F-1.4218924262306907
F-1.4984400822566106
tp12935
sS"my_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p12936
(F-1.9174924997182994
F-1.6178920452411358
tp12937
sS"print os.path.exists('/etc/password.txt')"
p12938
(F-1.2928925427523525
F-1.475539280818059
tp12939
sS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p12940
(F-1.106345494588216
F-1.4797210693359375
tp12941
sS'import os.path'
p12942
(F-1.8230174382527669
F-1.5175434992863581
tp12943
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p12944
(F-1.2475842067173548
F-1.522324488713191
tp12945
sS'import os.path\nos.path.exists(file_path)'
p12946
(F-1.3017373926499312
F-1.5017201350285456
tp12947
sS'pass'
p12948
(F-3.3650776545206704
F-1.7400090144230769
tp12949
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p12950
(F-1.1210772606634325
F-1.5097618103027344
tp12951
sS"from pathlib import Path\nmy_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p12952
(F-2.0488790696667087
F-1.5679848010723407
tp12953
sS"print os.path.isfile('/does/not/exist')"
p12954
(F-1.4218924262306907
F-1.498439935537485
tp12955
sS"from pathlib import Path\nmy_file = Path('/path/to/file')"
p12956
(F-2.536876424153646
F-1.6251522944523737
tp12957
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p12958
(F-1.0562228691287157
F-1.5003395080566406
tp12959
sS'from pathlib import Path'
p12960
(F-3.514451344807943
F-1.6705959026630108
tp12961
sS'os.path.isfile(fname)'
p12962
(F-1.544205665588379
F-1.516265869140625
tp12963
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12964
(F-1.0123377781288296
F-1.4941626328688402
tp12965
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')"
p12966
(F-1.2475842067173548
F-1.522324488713191
tp12967
sS"print os.path.exists('/etc')"
p12968
(F-1.2928925427523525
F-1.475539280818059
tp12969
sS"my_file = Path('/path/to/file')"
p12970
(F-2.5300014495849608
F-1.731821060180664
tp12971
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p12972
(F-1.1816064743768602
F-1.4882125854492188
tp12973
sS'if my_file.is_file():\n    pass'
p12974
(F-1.842431012321921
F-1.5743678166316106
tp12975
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p12976
(F-1.0820227592222151
F-1.4835445697490985
tp12977
sS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12978
(F-1.0250642838016633
F-1.482014876145583
tp12979
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12980
(F-1.00161868236104
F-1.5052463824932392
tp12981
sS"print os.path.exists('/does/not/exist')"
p12982
(F-1.2928925427523525
F-1.475539280818059
tp12983
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p12984
(F-1.1671359154485887
F-1.5355563530555139
tp12985
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12986
(F-1.0245481351526773
F-1.4814498607928936
tp12987
sS'import os.path\nos.path.isfile(fname)'
p12988
(F-1.347360865275065
F-1.503446285541241
tp12989
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p12990
(F-1.085190005418731
F-1.523661393385667
tp12991
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p12992
(F-1.0370182710535385
F-1.513079129732572
tp12993
sS'os.path.exists(file_path)'
p12994
(F-1.3170171578725178
F-1.5091448563795824
tp12995
sS"print os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12996
(F-1.106345494588216
F-1.4797210693359375
tp12997
ssI510357
(dp12998
S'class _Getch:\n    """Gets a single character from standard input.  Does not echo to the\nscreen."""\n\ndef __init__(self):\n    pass'
p12999
(F-1.2275379844333814
F-2.863423728942871
tp13000
sS'def _find_getch():\n    pass'
p13001
(F-2.056459720318134
F-2.9158519744873046
tp13002
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p13003
(F-1.7438295909336634
F-3.044270706176758
tp13004
sS'"""Gets a single character from standard input.  Does not echo to the screen."""'
p13005
(F-2.346340815226237
F-2.938503074645996
tp13006
sS'tty.setraw(sys.stdin.fileno())'
p13007
(F-1.2209172930036272
F-2.562287521362305
tp13008
sS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p13009
(F-1.4653186798095703
F-2.677650260925293
tp13010
sS'def _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p13011
(F-1.6285806020100912
F-2.7424156188964846
tp13012
sS'def __init__(self):\n    pass'
p13013
(F-1.2549738202776228
F-3.13651123046875
tp13014
sS'return ch'
p13015
(F-3.6186912059783936
F-2.9135791778564455
tp13016
sS'class _Getch:\n    """Gets a single character from standard input.  Does not echo to the screen."""'
p13017
(F-1.6952616373697917
F-2.8700944900512697
tp13018
sS'sys.stdin.read(1)'
p13019
(F-1.5809919357299804
F-2.814817428588867
tp13020
sS'tty.setraw(fd)'
p13021
(F-2.653564929962158
F-2.8326488494873048
tp13022
sS'return self.impl()'
p13023
(F-2.21954607963562
F-4.071046447753906
tp13024
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p13025
(F-1.2539482116699219
F-2.956973075866699
tp13026
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p13027
(F-1.1094607791385136
F-2.9651973724365233
tp13028
sS'ch = sys.stdin.read(1)'
p13029
(F-1.6974523862202961
F-2.844666862487793
tp13030
sS'old_settings = termios.tcgetattr(fd)'
p13031
(F-2.2779385248819985
F-2.81807861328125
tp13032
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p13033
(F-1.9189157253358422
F-2.6787185668945312
tp13034
sS'def __call__(self):\n    import sys, tty, termios'
p13035
(F-1.3695241024619655
F-2.8959617614746094
tp13036
sS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p13037
(F-1.277575225830078
F-2.6517059326171877
tp13038
sS'def __init__(self):\n    import tty, sys'
p13039
(F-1.6751659617704504
F-2.774887275695801
tp13040
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p13041
(F-1.1551013653094953
F-2.5946252822875975
tp13042
sS'def __call__(self):\n    import msvcrt'
p13043
(F-1.6246963500976563
F-3.1207122802734375
tp13044
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p13045
(F-1.1610597398546008
F-2.907204437255859
tp13046
sS'def __init__(self):\n    import msvcrt'
p13047
(F-1.630199178059896
F-3.3179115295410155
tp13048
sS'getch = _find_getch()'
p13049
(F-3.788795895046658
F-3.1835725784301756
tp13050
sS'def _getch():\n    pass'
p13051
(F-1.554170088334517
F-2.904943084716797
tp13052
sS'return _getch\ngetch = _find_getch()'
p13053
(F-4.5729780197143555
F-3.1973203659057616
tp13054
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p13055
(F-1.0074656009674072
F-2.9628837585449217
tp13056
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p13057
(F-1.418728206468665
F-3.0403079986572266
tp13058
sS'def __call__(self):\n    pass'
p13059
(F-1.1874374662126814
F-3.1028202056884764
tp13060
sS'class _Getch:\n    """Gets a single character from standard input.  Does not echo to the\nscreen."""'
p13061
(F-1.6952614254421658
F-2.8700946807861327
tp13062
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        pass'
p13063
(F-0.9584704807826451
F-3.1077747344970703
tp13064
sS'import sys, tty\n\ndef _getch():\n    pass'
p13065
(F-1.457478691549862
F-2.670283317565918
tp13066
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p13067
(F-1.0238664089105067
F-2.796955680847168
tp13068
sS'class _Getch:\n    """Gets a single character from standard input.  Does not echo to the screen."""\n\ndef __init__(self):\n    pass'
p13069
(F-1.2275379844333814
F-2.863423728942871
tp13070
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p13071
(F-1.1291738439489294
F-2.5694206237792967
tp13072
sS'class _GetchWindows:\n\n    def __init__(self):\n        pass'
p13073
(F-1.236150394786488
F-3.061174201965332
tp13074
sS'import termios'
p13075
(F-4.162899494171143
F-3.1530834197998048
tp13076
sS'self.impl = _GetchWindows()'
p13077
(F-1.6954906463623047
F-3.3612335205078123
tp13078
sS'class _GetchUnix:\n    pass'
p13079
(F-1.658517837524414
F-2.8590410232543944
tp13080
sS'return ch\n\n\nclass _GetchWindows:\n    pass'
p13081
(F-2.301330057779948
F-3.0593433380126953
tp13082
sS'getch = _Getch()'
p13083
(F-3.5741729736328125
F-2.784564971923828
tp13084
sS'class _GetchUnix:\n\n    def __init__(self):\n        pass'
p13085
(F-1.0836861350319602
F-2.8805564880371093
tp13086
sS'import msvcrt'
p13087
(F-3.36285662651062
F-3.094388008117676
tp13088
sS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p13089
(F-1.2837872505187988
F-2.6974563598632812
tp13090
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p13091
(F-1.3760313415527343
F-2.823373794555664
tp13092
sS'fd = sys.stdin.fileno()'
p13093
(F-1.7009988264604048
F-2.7921169281005858
tp13094
sS'return ch\nreturn _getch\ngetch = _find_getch()'
p13095
(F-4.549172973632812
F-3.212885284423828
tp13096
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p13097
(F-1.4214637606751686
F-2.7925334930419923
tp13098
sS'return msvcrt.getch'
p13099
(F-3.7464844385782876
F-3.317597198486328
tp13100
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    pass'
p13101
(F-2.278275403109464
F-2.7492904663085938
tp13102
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p13103
(F-1.4781237757483194
F-2.9343421936035154
tp13104
sS'fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p13105
(F-1.549352299083363
F-2.7428333282470705
tp13106
sS'def _getch():\n    fd = sys.stdin.fileno()'
p13107
(F-1.4499288860120272
F-2.7638174057006837
tp13108
sS'import sys, tty'
p13109
(F-2.822004954020182
F-2.780356788635254
tp13110
sS'self.impl = _GetchUnix()'
p13111
(F-1.542490291595459
F-3.505771255493164
tp13112
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p13113
(F-1.9337167104085287
F-2.64068603515625
tp13114
sS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p13115
(F-1.2832004941742996
F-2.6803256988525392
tp13116
sS'return msvcrt.getch\nimport sys, tty'
p13117
(F-3.5818262967196377
F-2.8003135681152345
tp13118
sS'def __call__(self):\n    return self.impl()'
p13119
(F-0.9164231952868009
F-3.561721420288086
tp13120
sS'return msvcrt.getch()'
p13121
(F-1.7758657932281494
F-3.2658592224121095
tp13122
sS'import tty, sys'
p13123
(F-3.206852595011393
F-2.754070854187012
tp13124
sS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p13125
(F-1.3104900880293413
F-3.065151023864746
tp13126
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p13127
(F-1.351176761445545
F-2.9507720947265623
tp13128
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p13129
(F-1.349198760986328
F-2.8880237579345702
tp13130
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p13131
(F-1.1316483391655816
F-3.0408746719360353
tp13132
sS'class _GetchWindows:\n    pass'
p13133
(F-1.8769506454467773
F-3.063223648071289
tp13134
sS'import sys, tty, termios'
p13135
(F-2.208009719848633
F-2.7681724548339846
tp13136
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p13137
(F-1.0458167823585305
F-2.616745948791504
tp13138
sS'class _Getch:\n    pass'
p13139
(F-1.4145435757107205
F-2.866139030456543
tp13140
sS'return ch\nreturn _getch'
p13141
(F-4.7322202410016745
F-2.937189292907715
tp13142
sS'termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)'
p13143
(F-1.3697707653045654
F-2.967255783081055
tp13144
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        pass'
p13145
(F-1.5730231956199363
F-3.0668121337890626
tp13146
sS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p13147
(F-1.7589891978672572
F-2.8602882385253907
tp13148
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p13149
(F-1.0754032808191636
F-2.6197561264038085
tp13150
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n    pass'
p13151
(F-1.0511278788248697
F-3.0926170349121094
tp13152
sS'return msvcrt.getch()\ngetch = _Getch()'
p13153
(F-2.5818593161446706
F-2.947311592102051
tp13154
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p13155
(F-1.572617530822754
F-2.7779266357421877
tp13156
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p13157
(F-0.9509462259583554
F-3.008679962158203
tp13158
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p13159
(F-1.0937930020419033
F-2.7721797943115236
tp13160
sS'return _getch'
p13161
(F-4.692654132843018
F-3.134005546569824
tp13162
ssI1450393
(dp13163
S'for line in fileinput.input():\n    pass'
p13164
(F-1.191378402709961
F-2.072437286376953
tp13165
sS'import sys'
p13166
(F-2.410162925720215
F-2.3987435427579014
tp13167
sS'print line'
p13168
(F-1.8173385858535767
F-2.0333597009832207
tp13169
sS'for line in sys.stdin:\n    pass\n'
p13170
(F-1.2369895348182092
F-1.709740552035245
tp13171
sS'for line in sys.stdin:\n    pass'
p13172
(F-1.2369895348182092
F-1.709740552035245
tp13173
sS'import fileinput\nfor line in fileinput.input():\n    pass'
p13174
(F-1.096902847290039
F-1.980146581476385
tp13175
sS'import sys\nfor line in sys.stdin:\n    pass\n'
p13176
(F-1.0184805393218994
F-1.702269120649858
tp13177
sS'import fileinput'
p13178
(F-3.030478000640869
F-1.7851905822753906
tp13179
sS'pass'
p13180
(F-2.7495911916097007
F-2.6845054626464844
tp13181
sS'import sys\nfor line in sys.stdin:\n    pass'
p13182
(F-1.0184805393218994
F-1.702269120649858
tp13183
ssI2759067
(dp13184
S'from os import rename, listdir'
p13185
(F-3.0028324127197266
F-1.4756139119466145
tp13186
sS"for filename in os.listdir('.'):\n    pass"
p13187
(F-0.9709982872009277
F-1.3714200655619304
tp13188
sS'if fname.startswith(badprefix * 2):\n    pass'
p13189
(F-2.5287203788757324
F-2.5457763671875
tp13190
sS'rename(fname, fname[8:])'
p13191
(F-3.1559006373087564
F-1.7406679789225261
tp13192
sS"from os import rename, listdir\nbadprefix = 'cheese_'\nfnames = listdir('.')"
p13193
(F-2.739537891588713
F-1.4769967397054036
tp13194
sS"fnames = listdir('.')\nfor fname in fnames:\n    pass"
p13195
(F-2.730154037475586
F-2.0610926946004233
tp13196
sS"badprefix = 'cheese_'\nfnames = listdir('.')\nfor fname in fnames:\n    if fname.startswith(badprefix * 2):\n        pass"
p13197
(F-2.340349905831473
F-2.0272083282470703
tp13198
sS"badprefix = 'cheese_'"
p13199
(F-1.656837272644043
F-2.662520090738932
tp13200
sS"import os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        pass"
p13201
(F-0.7289110819498698
F-1.4152167638142903
tp13202
sS"ls\npython\nimport os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        pass"
p13203
(F-1.8247598760268267
F-1.5305307706197102
tp13204
sS"for fname in fnames:\n    if fname.startswith(badprefix * 2):\n        rename(fname, fname.replace(badprefix, '', 1))"
p13205
(F-2.0562794334010075
F-2.475532054901123
tp13206
sS"python\nimport os\nfor filename in os.listdir('.'):\n    pass"
p13207
(F-1.5422850109281994
F-1.4784372647603352
tp13208
sS"badprefix = 'cheese_'\nfnames = listdir('.')"
p13209
(F-2.983225186665853
F-2.0156126022338867
tp13210
sS"for filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        os.rename(filename, filename[7:])"
p13211
(F-0.8412597053929379
F-1.238216241200765
tp13212
sS"if fname.startswith(badprefix * 2):\n    rename(fname, fname.replace(badprefix, '', 1))"
p13213
(F-2.3455795288085937
F-2.2216501235961914
tp13214
sS'os.rename(filename, filename[7:])'
p13215
(F-1.768503189086914
F-1.3138949076334636
tp13216
sS"from os import rename, listdir\nbadprefix = 'cheese_'\nfnames = listdir('.')\nfor fname in fnames:\n    pass"
p13217
(F-2.3861249726394127
F-1.5236263275146484
tp13218
sS"ls\npython\nimport os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        os.rename(filename, filename[7:])\nls"
p13219
(F-2.001761903154089
F-1.4120327631632488
tp13220
sS"import os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        os.rename(filename, filename[7:])"
p13221
(F-0.7995618494545541
F-1.2884511947631836
tp13222
sS"fnames = listdir('.')"
p13223
(F-3.6517465114593506
F-2.062343120574951
tp13224
sS"badprefix = 'cheese_'\nfnames = listdir('.')\nfor fname in fnames:\n    if fname.startswith(badprefix * 2):\n        rename(fname, fname.replace(badprefix, '', 1))"
p13225
(F-2.2288762306680483
F-2.0287486712137857
tp13226
sS'python\nimport os'
p13227
(F-4.029741287231445
F-2.0866665840148926
tp13228
sS"import os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        os.rename(filename, filename[7:])\nls"
p13229
(F-1.2583183466002
F-1.324506362279256
tp13230
sS'ls'
p13231
(F-7.120354334513347
F-2.999423344930013
tp13232
sS'for fname in fnames:\n    if fname.startswith(badprefix * 2):\n        pass'
p13233
(F-2.101085662841797
F-2.5464282035827637
tp13234
sS"python\nimport os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        os.rename(filename, filename[7:])"
p13235
(F-1.1353887513626453
F-1.3050121466318767
tp13236
sS"ls\npython\nimport os\nfor filename in os.listdir('.'):\n    pass"
p13237
(F-2.4728841366975205
F-1.5706397692362468
tp13238
sS"for fname in glob('*.prj'):\n    pass"
p13239
(F-1.557746342250279
F-1.8562053044637044
tp13240
sS"rename(fname, fname.replace(badprefix, '', 1))"
p13241
(F-2.614650950712316
F-1.8840476671854656
tp13242
sS'python'
p13243
(F-4.879915555318196
F-2.4505030314127603
tp13244
sS"python\nimport os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        pass"
p13245
(F-1.1856073141098022
F-1.4381426175435383
tp13246
sS"fnames = listdir('.')\nfor fname in fnames:\n    if fname.startswith(badprefix * 2):\n        pass"
p13247
(F-2.473961614793347
F-2.065251350402832
tp13248
sS'ls\npython'
p13249
(F-7.5932258605957035
F-2.8936246236165366
tp13250
sS'for fname in fnames:\n    pass'
p13251
(F-2.060959902676669
F-2.5282387733459473
tp13252
sS'from glob import glob\nfrom os import rename'
p13253
(F-1.297180869362571
F-1.510675589243571
tp13254
sS"if filename.startswith('cheese_'):\n    pass"
p13255
(F-1.3395818982805525
F-1.8135040601094563
tp13256
sS'import os'
p13257
(F-2.0880966186523438
F-2.073164780934652
tp13258
sS"from glob import glob\nfrom os import rename\nfor fname in glob('*.prj'):\n    rename(fname, fname[8:])"
p13259
(F-1.7565716830166904
F-1.3991891543070476
tp13260
sS"for filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        pass"
p13261
(F-0.777425624706127
F-1.355532964070638
tp13262
sS"ls\npython\nimport os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        os.rename(filename, filename[7:])"
p13263
(F-1.6288448757595486
F-1.3774356842041016
tp13264
sS"for fname in glob('*.prj'):\n    rename(fname, fname[8:])"
p13265
(F-1.9296311088230298
F-1.6178083419799805
tp13266
sS"from os import rename, listdir\nbadprefix = 'cheese_'\nfnames = listdir('.')\nfor fname in fnames:\n    if fname.startswith(badprefix * 2):\n        pass"
p13267
(F-2.3153953552246094
F-1.5298698743184407
tp13268
sS"from os import rename\nfor fname in glob('*.prj'):\n    pass"
p13269
(F-1.5660121315403988
F-1.504411220550537
tp13270
sS'from glob import glob'
p13271
(F-1.8392688433329265
F-1.6334271430969238
tp13272
sS"fnames = listdir('.')\nfor fname in fnames:\n    if fname.startswith(badprefix * 2):\n        rename(fname, fname.replace(badprefix, '', 1))"
p13273
(F-2.318701680501302
F-2.061849594116211
tp13274
sS"for filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        os.rename(filename, filename[7:])\nls"
p13275
(F-1.326512908935547
F-1.2802051703135173
tp13276
sS'from os import rename'
p13277
(F-1.5301342010498047
F-1.5830313364664714
tp13278
sS"from os import rename, listdir\nbadprefix = 'cheese_'\nfnames = listdir('.')\nfor fname in fnames:\n    if fname.startswith(badprefix * 2):\n        rename(fname, fname.replace(badprefix, '', 1))"
p13279
(F-2.2303079877580916
F-1.5751845041910808
tp13280
sS"if filename.startswith('cheese_'):\n    os.rename(filename, filename[7:])"
p13281
(F-1.2507456970214843
F-1.376428445180257
tp13282
sS"from os import rename\nfor fname in glob('*.prj'):\n    rename(fname, fname[8:])"
p13283
(F-1.9109514781406947
F-1.3790499369303386
tp13284
sS"badprefix = 'cheese_'\nfnames = listdir('.')\nfor fname in fnames:\n    pass"
p13285
(F-2.479993126609109
F-2.0219995180765786
tp13286
sS"python\nimport os\nfor filename in os.listdir('.'):\n    if filename.startswith('cheese_'):\n        os.rename(filename, filename[7:])\nls"
p13287
(F-1.5523913913302951
F-1.3409579594930012
tp13288
sS"from os import rename, listdir\nbadprefix = 'cheese_'"
p13289
(F-2.460958480834961
F-1.4913654327392578
tp13290
sS"from glob import glob\nfrom os import rename\nfor fname in glob('*.prj'):\n    pass"
p13291
(F-1.409908612569173
F-1.4754468599955242
tp13292
sS"import os\nfor filename in os.listdir('.'):\n    pass"
p13293
(F-0.8423666703073602
F-1.4496469497680664
tp13294
sS'ls\npython\nimport os'
p13295
(F-6.031284332275391
F-2.2518165906270347
tp13296
ssI15411107
(dp13297
S'for key in keys_to_remove:\n    pass'
p13298
(F-1.7853398640950522
F-2.6327638626098633
tp13299
sS'new_dict = {k: mydict[k] for k in keys_to_keep}'
p13300
(F-1.831542275168679
F-2.648241424560547
tp13301
sS'try:\n    del mydict[key]\nexcept KeyError:\n    pass'
p13302
(F-0.9963818504696801
F-2.515515899658203
tp13303
sS'for key in keys_to_remove:\n    del mydict[key]'
p13304
(F-1.6492733202482526
F-2.559516716003418
tp13305
sS'del mydict[key]'
p13306
(F-1.8056844983782088
F-2.4831012725830077
tp13307
sS'keys_to_keep = set(mydict.keys()) - set(keys)\nnew_dict = {k: v for k, v in mydict.iteritems() if k in keys_to_keep}'
p13308
(F-1.9608322454958547
F-2.6602020263671875
tp13309
sS'new_dict = {k: v for k, v in mydict.iteritems() if k in keys_to_keep}'
p13310
(F-1.5614897629310345
F-2.6258548736572265
tp13311
sS'keys_to_keep = set(mydict.keys()) - set(keys)\nnew_dict = {k: mydict[k] for k in keys_to_keep}'
p13312
(F-2.2213407244001115
F-2.668624687194824
tp13313
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    pass'
p13314
(F-1.9686098600688733
F-2.686107635498047
tp13315
sS'pass'
p13316
(F-3.020268758138021
F-3.4889015197753905
tp13317
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))'
p13318
(F-2.217490832010905
F-2.700873374938965
tp13319
sS'keys_to_keep = set(mydict.keys()) - set(keys)'
p13320
(F-2.82889157249814
F-2.719394874572754
tp13321
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    del mydict[key]'
p13322
(F-1.9063938685825892
F-2.654400444030762
tp13323
sS"mydict.pop('key', None)"
p13324
(F-1.8136295318603515
F-2.6939807891845704
tp13325
ssI2150739
(dp13326
S'import datetime'
p13327
(F-2.113182544708252
F-3.740169871937145
tp13328
sS"from datetime import datetime\ndatetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p13329
(F-0.5745250701904296
F-3.4228023182262075
tp13330
sS'def utcoffset(self, dt):\n    pass'
p13331
(F-1.6267329624720983
F-4.221827073530718
tp13332
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p13333
(F-1.329506574358259
F-3.555233695290305
tp13334
sS'class TZ(tzinfo):\n    pass'
p13335
(F-1.43722931543986
F-4.487068523060191
tp13336
sS'return timedelta(minutes=-399)'
p13337
(F-3.2497650146484376
F-3.726308649236506
tp13338
sS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=-399)'
p13339
(F-1.4978070412912676
F-4.19049765846946
tp13340
sS'from datetime import tzinfo, timedelta, datetime'
p13341
(F-2.0060756683349608
F-3.4696793989701704
tp13342
sS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p13343
(F-1.1374901135762532
F-4.335111097856001
tp13344
sS'datetime.fromtimestamp(x)'
p13345
(F-2.0082695484161377
F-3.735287406227805
tp13346
sS"from time import strftime\nstrftime('%Y-%m-%d %H:%M:%S')"
p13347
(F-1.5444928949529475
F-3.4430791681463067
tp13348
sS"x = ParseDateTimeUTC('2010-06-04 21:08:12')"
p13349
(F-3.589452362060547
F-4.064434051513672
tp13350
sS'def utcoffset(self, dt):\n    return timedelta(minutes=-399)'
p13351
(F-2.0359202793666293
F-3.967123205011541
tp13352
sS"from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=-399)\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p13353
(F-1.9433609747117566
F-3.4060710560191763
tp13354
sS"class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=-399)\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p13355
(F-1.9524515189376532
F-3.840198516845703
tp13356
sS'from mx.DateTime.ISO import ParseDateTimeUTC'
p13357
(F-4.459737924429087
F-3.6900957280939277
tp13358
sS'import datetime\ndatetime.datetime.now().isoformat()'
p13359
(F-0.6350079774856567
F-3.49190278486772
tp13360
sS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p13361
(F-3.43275875515408
F-3.5806156505237925
tp13362
sS'import datetime\ndatetime.datetime.utcnow().isoformat()'
p13363
(F-0.8149758577346802
F-3.4706736477938565
tp13364
sS'datetime.datetime.now().isoformat()'
p13365
(F-0.6804374548105093
F-3.3856055519797583
tp13366
sS'from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime'
p13367
(F-3.609661102294922
F-3.654979705810547
tp13368
sS'datetime.datetime.utcnow().isoformat()'
p13369
(F-0.9047078352708083
F-3.3600807189941406
tp13370
sS'from datetime import datetime'
p13371
(F-1.5367056528727214
F-3.5829377607865767
tp13372
sS"datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p13373
(F-2.3435338338216147
F-3.386099035089666
tp13374
sS"datetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p13375
(F-0.7623429298400879
F-3.3793875954367896
tp13376
sS"strftime('%Y-%m-%d %H:%M:%S')"
p13377
(F-1.6254979769388835
F-3.480428522283381
tp13378
sS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p13379
(F-2.0805317271839487
F-3.491286191073331
tp13380
sS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p13381
(F-2.923465504365809
F-3.5622468428178267
tp13382
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n    pass'
p13383
(F-1.6174578459366509
F-3.6160878268155185
tp13384
sS"x = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p13385
(F-2.614287432502298
F-3.859018845991655
tp13386
sS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p13387
(F-2.5775428771972657
F-3.4899174083362925
tp13388
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=-399)'
p13389
(F-1.5655579339890253
F-3.5275982943448154
tp13390
sS'from time import strftime'
p13391
(F-2.238940397898356
F-3.685235456986861
tp13392
ssI466345
(dp13393
S"dt = parser.parse('Aug 28 1999 12:00AM')"
p13394
(F-1.9266876220703124
F-1.9482434590657551
tp13395
sS'from dateutil import parser'
p13396
(F-2.3168814977010093
F-2.0398643811543784
tp13397
sS'from datetime import datetime'
p13398
(F-1.4426980018615723
F-2.181285540262858
tp13399
sS"from datetime import datetime\ndate_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p13400
(F-1.1628345690275494
F-1.9313440322875977
tp13401
sS"date_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p13402
(F-1.6862918308803014
F-1.934292157491048
tp13403
sS"from dateutil import parser\ndt = parser.parse('Aug 28 1999 12:00AM')"
p13404
(F-1.6418350219726563
F-1.820400555928548
tp13405
ssI10973614
(dp13406
S"print data['fruits']"
p13407
(F-1.5697119576590401
F-2.128159761428833
tp13408
sS'array = \'{"fruits": ["apple", "banana", "orange"]}\'\ndata = json.loads(array)\nprint data[\'fruits\']'
p13409
(F-1.689839744567871
F-1.8363852500915527
tp13410
sS'print fruits_list'
p13411
(F-3.6948572794596353
F-3.1673476696014404
tp13412
sS'array = \'{"fruits": ["apple", "banana", "orange"]}\'\ndata = json.loads(array)\nfruits_list = data[\'fruits\']\nprint fruits_list'
p13413
(F-2.3994388580322266
F-1.8653676509857178
tp13414
sS"fruits_list = data['fruits']\nprint fruits_list"
p13415
(F-2.66681391398112
F-2.6658809185028076
tp13416
sS"data = json.loads(array)\nfruits_list = data['fruits']\nprint fruits_list"
p13417
(F-2.299845536549886
F-1.9327964782714844
tp13418
sS'array = \'{"fruits": ["apple", "banana", "orange"]}\''
p13419
(F-3.3563678741455076
F-2.3409767150878906
tp13420
sS'import json'
p13421
(F-1.8094600439071655
F-2.2475223541259766
tp13422
sS'import json\narray = \'{"fruits": ["apple", "banana", "orange"]}\'\ndata = json.loads(array)'
p13423
(F-1.59903200934915
F-1.923814058303833
tp13424
sS'data = json.loads(array)'
p13425
(F-1.7286714553833007
F-1.9778549671173096
tp13426
sS'import json\narray = \'{"fruits": ["apple", "banana", "orange"]}\'\ndata = json.loads(array)\nfruits_list = data[\'fruits\']'
p13427
(F-1.9340476989746094
F-1.8836820125579834
tp13428
sS"data = json.loads(array)\nprint data['fruits']"
p13429
(F-1.3739676475524902
F-1.9102509021759033
tp13430
sS'import json\narray = \'{"fruits": ["apple", "banana", "orange"]}\'\ndata = json.loads(array)\nfruits_list = data[\'fruits\']\nprint fruits_list'
p13431
(F-2.079688287550403
F-1.8865242004394531
tp13432
sS'import json\narray = \'{"fruits": ["apple", "banana", "orange"]}\''
p13433
(F-2.3779873847961426
F-2.0027565956115723
tp13434
sS'import json\narray = \'{"fruits": ["apple", "banana", "orange"]}\'\ndata = json.loads(array)\nprint data[\'fruits\']'
p13435
(F-1.3507410132366677
F-1.8750920295715332
tp13436
sS"fruits_list = data['fruits']"
p13437
(F-2.712001991271973
F-2.5868120193481445
tp13438
sS"data = json.loads(array)\nfruits_list = data['fruits']"
p13439
(F-2.123947344328228
F-1.9321131706237793
tp13440
sS'array = \'{"fruits": ["apple", "banana", "orange"]}\'\ndata = json.loads(array)'
p13441
(F-2.0767465318952287
F-1.8819775581359863
tp13442
sS'array = \'{"fruits": ["apple", "banana", "orange"]}\'\ndata = json.loads(array)\nfruits_list = data[\'fruits\']'
p13443
(F-2.3035964965820312
F-1.8587357997894287
tp13444
ssI4135344
(dp13445
S'import pdfkit'
p13446
(F-3.486236095428467
F-3.6179428100585938
tp13447
sS"with open(input_filename, 'r') as f:\n    pass"
p13448
(F-1.2948369979858398
F-3.7537765502929688
tp13449
sS"input_filename = 'README.md'"
p13450
(F-2.9004309517996654
F-3.6548665364583335
tp13451
sS'pdfkit.from_string(html_text, output_filename)'
p13452
(F-2.0676565170288086
F-3.520604451497396
tp13453
sS'from markdown import markdown'
p13454
(F-2.013275464375814
F-3.658404541015625
tp13455
sS"input_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')\npdfkit.from_string(html_text, output_filename)"
p13456
(F-1.9512603513656124
F-3.56803461710612
tp13457
sS"output_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')"
p13458
(F-1.830978951803068
F-3.6266860961914062
tp13459
sS"output_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    pass"
p13460
(F-1.6148564020792644
F-3.6700668334960938
tp13461
sS"html_text = markdown(f.read(), output_format='html4')"
p13462
(F-2.3137989044189453
F-3.588372294108073
tp13463
sS"from markdown import markdown\nimport pdfkit\ninput_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')"
p13464
(F-1.925724931196733
F-3.5422846476236978
tp13465
sS"input_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    pass"
p13466
(F-1.6234554290771483
F-3.6889241536458335
tp13467
sS"from markdown import markdown\nimport pdfkit\ninput_filename = 'README.md'\noutput_filename = 'README.pdf'"
p13468
(F-2.4780789329892112
F-3.5309438069661456
tp13469
sS"input_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')"
p13470
(F-1.8451288101520944
F-3.642586263020833
tp13471
sS"import pdfkit\ninput_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')\npdfkit.from_string(html_text, output_filename)"
p13472
(F-1.9891150841346155
F-3.546281941731771
tp13473
sS"from markdown import markdown\nimport pdfkit\ninput_filename = 'README.md'"
p13474
(F-2.776908111572266
F-3.536315155029297
tp13475
sS"with open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')\npdfkit.from_string(html_text, output_filename)"
p13476
(F-1.8850347900390625
F-3.5776278177897134
tp13477
sS'from markdown import markdown\nimport pdfkit'
p13478
(F-2.772371080186632
F-3.528338623046875
tp13479
sS"with open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')"
p13480
(F-1.687053026471819
F-3.658857727050781
tp13481
sS"output_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')\npdfkit.from_string(html_text, output_filename)"
p13482
(F-1.9517533438546317
F-3.5573265075683596
tp13483
sS"from markdown import markdown\nimport pdfkit\ninput_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    pass"
p13484
(F-1.8118679648951481
F-3.5263465881347655
tp13485
sS"import pdfkit\ninput_filename = 'README.md'\noutput_filename = 'README.pdf'"
p13486
(F-2.535426139831543
F-3.5788609822591146
tp13487
sS"input_filename = 'README.md'\noutput_filename = 'README.pdf'"
p13488
(F-2.461435758150541
F-3.6361989339192706
tp13489
sS"from markdown import markdown\nimport pdfkit\ninput_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')\npdfkit.from_string(html_text, output_filename)"
p13490
(F-1.9961613246372767
F-3.513170369466146
tp13491
sS"output_filename = 'README.pdf'"
p13492
(F-2.7802140372140065
F-3.5676617940266926
tp13493
sS"import pdfkit\ninput_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    html_text = markdown(f.read(), output_format='html4')"
p13494
(F-1.9031570434570313
F-3.5924410502115887
tp13495
sS"import pdfkit\ninput_filename = 'README.md'\noutput_filename = 'README.pdf'\nwith open(input_filename, 'r') as f:\n    pass"
p13496
(F-1.7169189453125
F-3.5869216918945312
tp13497
sS"import pdfkit\ninput_filename = 'README.md'"
p13498
(F-2.9673698425292967
F-3.597742207845052
tp13499
ssI19602931
(dp13500
S'testfile = urllib.URLopener()'
p13501
(F-3.9297744750976564
F-3.6582984924316406
tp13502
sS'file_name = wget.download(file_url)'
p13503
(F-2.326812744140625
F-3.5062616788423977
tp13504
sS'import urllib\ntestfile = urllib.URLopener()'
p13505
(F-3.326154562143179
F-3.5967401357797475
tp13506
sS"testfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p13507
(F-3.479639956825658
F-3.4816753680889425
tp13508
sS"import wget\nfile_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p13509
(F-2.0736533455226733
F-3.499844184288612
tp13510
sS"urllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p13511
(F-0.8531660079956055
F-3.330608367919922
tp13512
sS"file_url = 'http://johndoe.com/download.zip'"
p13513
(F-2.2070974622453963
F-3.5514552776630106
tp13514
sS'import wget'
p13515
(F-2.8130240440368652
F-4.202496748704177
tp13516
sS"testfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p13517
(F-3.2511356353759764
F-3.5432234544020433
tp13518
sS"file_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p13519
(F-1.9920772552490233
F-3.4491122319148135
tp13520
sS"import wget\nfile_url = 'http://johndoe.com/download.zip'"
p13521
(F-2.4518669128417967
F-3.6951704758864183
tp13522
sS'import urllib'
p13523
(F-2.2408974170684814
F-3.8261014498197117
tp13524
sS"import urllib\nurllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p13525
(F-0.6863112082848182
F-3.3479370704064
tp13526
sS"import urllib\ntestfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p13527
(F-3.1748473427512427
F-3.4371420053335338
tp13528
ssI8177079
(dp13529
S'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p13530
(F-1.764106549714741
F-2.2062644958496094
tp13531
sS'del list1'
p13532
(F-3.706355094909668
F-1.8985317945480347
tp13533
sS'c.extend(a)'
p13534
(F-2.5466699600219727
F-2.0473453998565674
tp13535
sS"if any(True for line in list1 if 'string' in line):\n    list2.extend(list1)\ndel list1"
p13536
(F-2.4262888772147044
F-2.098562240600586
tp13537
sS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p13538
(F-1.4278044700622559
F-2.2372119426727295
tp13539
sS'a = range(5)'
p13540
(F-2.4561991691589355
F-2.371596336364746
tp13541
sS'pass'
p13542
(F-3.379514694213867
F-2.461146354675293
tp13543
sS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p13544
(F-1.9174361690398185
F-2.1553680896759033
tp13545
sS"q = ['d', 'e', 'f']"
p13546
(F-1.3432677008888938
F-2.349031448364258
tp13547
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p13548
(F-1.0768164466409123
F-2.163198471069336
tp13549
sS'for logs in mydir:\n    for line in mylog:\n        list1.append(line)'
p13550
(F-2.6448779106140137
F-2.0554909706115723
tp13551
sS'list1.append(line)'
p13552
(F-2.2902088165283203
F-1.930189609527588
tp13553
sS'b.append(a)\nb'
p13554
(F-2.3532283782958983
F-2.0677146911621094
tp13555
sS'b\nc.extend(a)'
p13556
(F-3.0106670379638674
F-2.023937225341797
tp13557
sS"import itertools\np = ['a', 'b', 'c']"
p13558
(F-1.5553688321794783
F-2.1208691596984863
tp13559
sS'for logs in mydir:\n    pass'
p13560
(F-3.5308602072975854
F-2.0210812091827393
tp13561
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any(True for line in list1 if 'string' in line):\n    pass"
p13562
(F-2.3588565560274346
F-2.107513904571533
tp13563
sS'b = range(3)\nc = range(2)\nb.append(a)'
p13564
(F-1.9562606811523438
F-2.2479584217071533
tp13565
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p13566
(F-1.0041392541700793
F-2.3110790252685547
tp13567
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)'
p13568
(F-1.7746288694184402
F-2.323190689086914
tp13569
sS'for line in mylog:\n    pass'
p13570
(F-2.78758413141424
F-2.212467670440674
tp13571
sS'c = range(2)\nb.append(a)\nb\nc.extend(a)'
p13572
(F-1.9786109924316406
F-2.163672685623169
tp13573
sS'b.append(a)\nb\nc.extend(a)'
p13574
(F-2.1242240456973804
F-2.022709608078003
tp13575
sS'c = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p13576
(F-2.095685812143179
F-2.174154758453369
tp13577
sS'for x in itertools.chain(p, q, r):\n    pass'
p13578
(F-2.158046531677246
F-2.1708297729492188
tp13579
sS"r = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p13580
(F-1.6470932006835937
F-2.214067220687866
tp13581
sS'c = range(2)\nb.append(a)'
p13582
(F-1.9967374165852865
F-2.2860662937164307
tp13583
sS'a = range(5)\nb = range(3)'
p13584
(F-2.1192899068196613
F-2.358159065246582
tp13585
sS"p = ['a', 'b', 'c']"
p13586
(F-1.3633948239413174
F-2.2343173027038574
tp13587
sS'list1.extend(mylog)'
p13588
(F-4.384248733520508
F-2.020817279815674
tp13589
sS'for line in mylog:\n    list1.append(line)'
p13590
(F-2.212446451187134
F-2.096104860305786
tp13591
sS'b\nc.extend(a)\nc'
p13592
(F-3.2408084869384766
F-2.0369162559509277
tp13593
sS"if any(True for line in list1 if 'string' in line):\n    list2.extend(list1)"
p13594
(F-2.345345306396484
F-2.1175708770751953
tp13595
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any(True for line in list1 if 'string' in line):\n    list2.extend(list1)\ndel list1"
p13596
(F-2.429286283605239
F-2.0741233825683594
tp13597
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p13598
(F-1.8200439453125
F-2.2158913612365723
tp13599
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb'
p13600
(F-1.7724151611328125
F-2.3077428340911865
tp13601
sS'c.extend(a)\nc'
p13602
(F-3.153024673461914
F-2.0612680912017822
tp13603
sS'list2.extend(list1)'
p13604
(F-2.368156909942627
F-1.9460031986236572
tp13605
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p13606
(F-1.3051783723651238
F-2.1985104084014893
tp13607
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p13608
(F-1.2753682708740235
F-2.2191896438598633
tp13609
sS"if any(True for line in list1 if 'string' in line):\n    pass"
p13610
(F-2.0646419525146484
F-2.23028564453125
tp13611
sS'list2.append(list1)'
p13612
(F-2.218916893005371
F-1.971022129058838
tp13613
sS'c = range(2)\nb.append(a)\nb'
p13614
(F-2.1006557240205654
F-2.2693397998809814
tp13615
sS'b = range(3)\nc = range(2)\nb.append(a)\nb'
p13616
(F-1.9795843760172527
F-2.23516583442688
tp13617
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any(True for line in list1 if 'string' in line):\n    list2.extend(list1)"
p13618
(F-2.391865094502767
F-2.081735372543335
tp13619
sS'b.append(a)'
p13620
(F-1.989956021308899
F-2.0643112659454346
tp13621
sS'import itertools'
p13622
(F-2.5685055255889893
F-2.15356707572937
tp13623
sS"r = ['g', 'h', 'i']"
p13624
(F-1.258252577348189
F-2.3819029331207275
tp13625
sS'c'
p13626
(F-5.769432067871094
F-2.5174953937530518
tp13627
sS'b'
p13628
(F-5.314655303955078
F-2.2647030353546143
tp13629
sS'b = range(3)'
p13630
(F-2.681381940841675
F-2.269836902618408
tp13631
sS'c = range(2)'
p13632
(F-2.9297525882720947
F-2.468520402908325
tp13633
sS'b = range(3)\nc = range(2)'
p13634
(F-2.5408899943033854
F-2.3197062015533447
tp13635
sS'b.append(a)\nb\nc.extend(a)\nc'
p13636
(F-2.3012615003083883
F-2.031395196914673
tp13637
sS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p13638
(F-1.084653763543992
F-2.3864710330963135
tp13639
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p13640
(F-1.1312232244582403
F-2.271782398223877
tp13641
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p13642
(F-1.2449146111806233
F-2.144183874130249
tp13643
sS'a = range(5)\nb = range(3)\nc = range(2)'
p13644
(F-2.137979334050959
F-2.381850242614746
tp13645
sS'for logs in mydir:\n    for line in mylog:\n        pass'
p13646
(F-3.087086326197574
F-2.0721325874328613
tp13647
sS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p13648
(F-1.9911011204575046
F-2.1648831367492676
tp13649
ssI455612
(dp13650
S"print '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13651
(F-1.4769724527994792
F-4.58258056640625
tp13652
sS"a = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)"
p13653
(F-1.843490473429362
F-4.636926174163818
tp13654
sS'x == g\nh = round(x, 2)'
p13655
(F-3.3626376560756137
F-4.518566608428955
tp13656
sS"125650429603636838 / 2 ** 53\n234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p13657
(F-2.2420753600105408
F-4.539235591888428
tp13658
sS"print a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)"
p13659
(F-1.7930637808407055
F-4.628692626953125
tp13660
sS'h = round(x, 2)\nh\nx == h'
p13661
(F-3.138746500015259
F-4.632187843322754
tp13662
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng"
p13663
(F-2.490313938685826
F-4.499660015106201
tp13664
sS"print '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)"
p13665
(F-1.8052473991147933
F-4.567778587341309
tp13666
sS"print '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13667
(F-1.4318758283342634
F-4.6685791015625
tp13668
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)\nh"
p13669
(F-2.8601455688476562
F-4.429202556610107
tp13670
sS"125650429603636838 / 2 ** 53\n234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13671
(F-2.0911993729440788
F-4.529917240142822
tp13672
sS'a = 13.946\nprint a'
p13673
(F-2.296550750732422
F-5.300212860107422
tp13674
sS"a = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13675
(F-1.5192712545394897
F-4.605027675628662
tp13676
sS"x\ng = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)"
p13677
(F-2.918928019205729
F-4.418731212615967
tp13678
sS'g\nx == g\nh = round(x, 2)\nh'
p13679
(F-3.8989965650770397
F-4.558099269866943
tp13680
sS"print '{0:.2f}'.format(round(a, 2))"
p13681
(F-1.4733427592686243
F-4.585532188415527
tp13682
sS"x\ng = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)\nh"
p13683
(F-2.9808847904205322
F-4.433427333831787
tp13684
sS'x == g'
p13685
(F-5.243215179443359
F-5.081722736358643
tp13686
sS'x == g\nh = round(x, 2)\nh'
p13687
(F-3.4877681732177734
F-4.557369709014893
tp13688
sS'h'
p13689
(F-5.152623812357585
F-5.528580665588379
tp13690
sS'x == h'
p13691
(F-4.586492919921875
F-5.150104522705078
tp13692
sS'x'
p13693
(F-4.409924189249675
F-5.105738639831543
tp13694
sS"a = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)"
p13695
(F-2.010683059692383
F-4.733559608459473
tp13696
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))"
p13697
(F-2.140196549265008
F-4.479947566986084
tp13698
sS"'%.2f' % 3.14159"
p13699
(F-2.652931022644043
F-5.070006370544434
tp13700
sS"g = float('{0:.2f}'.format(x))\ng"
p13701
(F-2.368028259277344
F-4.520102024078369
tp13702
sS'g\nx == g\nh = round(x, 2)\nh\nx == h'
p13703
(F-3.8786787553267046
F-4.601684093475342
tp13704
sS'125650429603636838 / 2 ** 53\n234042163 / 2 ** 24\na = 13.946\nprint a'
p13705
(F-3.9511932373046874
F-4.914301872253418
tp13706
sS"234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13707
(F-1.8339556012834821
F-4.53081750869751
tp13708
sS"g = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)\nh\nx == h"
p13709
(F-3.025078493006089
F-4.473304271697998
tp13710
sS"a = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)"
p13711
(F-1.6549116435803866
F-4.667186737060547
tp13712
sS"'%.2f' % 13.9499999"
p13713
(F-2.652931022644043
F-5.070006370544434
tp13714
sS'125650429603636838 / 2 ** 53\n234042163 / 2 ** 24\na = 13.946'
p13715
(F-4.3211804558249085
F-4.977700233459473
tp13716
sS"print a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p13717
(F-1.6463897380423038
F-4.601861476898193
tp13718
sS'234042163 / 2 ** 24'
p13719
(F-4.289974757603237
F-4.729297637939453
tp13720
sS"print a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13721
(F-1.590609614054362
F-4.587080955505371
tp13722
sS'125650429603636838 / 2 ** 53\n234042163 / 2 ** 24'
p13723
(F-4.348635746882512
F-4.976632118225098
tp13724
sS"print '%.2f' % a"
p13725
(F-2.593815485636393
F-5.0609636306762695
tp13726
sS"125650429603636838 / 2 ** 53\n234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)"
p13727
(F-2.7997298467726934
F-4.542000770568848
tp13728
sS"print '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13729
(F-1.4807497660319011
F-4.559077739715576
tp13730
sS'g'
p13731
(F-5.16148312886556
F-5.4741530418396
tp13732
sS'x = 13.95\nx'
p13733
(F-2.7857584272112166
F-5.083539009094238
tp13734
sS"print a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)"
p13735
(F-2.050268319936899
F-4.583704948425293
tp13736
sS'x = 13.95'
p13737
(F-2.468065643310547
F-5.150503158569336
tp13738
sS"234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)"
p13739
(F-2.745242485633263
F-4.5353312492370605
tp13740
sS"print '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13741
(F-1.5888218126798932
F-4.556479454040527
tp13742
sS'125650429603636838 / 2 ** 53'
p13743
(F-4.448204585484096
F-5.2325334548950195
tp13744
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)\nh\nx == h"
p13745
(F-2.9608230590820312
F-4.463523864746094
tp13746
sS"g = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)\nh"
p13747
(F-2.9162523905436197
F-4.439980506896973
tp13748
sS"a = 13.946\nprint a\nprint '%.2f' % a"
p13749
(F-1.9584498772254357
F-5.18195104598999
tp13750
sS"print '{0:.15f}'.format(round(a, 2))"
p13751
(F-1.4733427592686243
F-4.585532188415527
tp13752
sS"x\ng = float('{0:.2f}'.format(x))\ng\nx == g"
p13753
(F-3.082462855747768
F-4.525956630706787
tp13754
sS"x\ng = float('{0:.2f}'.format(x))\ng"
p13755
(F-2.6201257144703582
F-4.5061421394348145
tp13756
sS'"""{0:.2f}""".format(13.95)'
p13757
(F-1.3267369270324707
F-5.051020622253418
tp13758
sS"234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a"
p13759
(F-2.944930628726357
F-4.744597911834717
tp13760
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\nx == g"
p13761
(F-2.881943359375
F-4.517597198486328
tp13762
sS"x\ng = float('{0:.2f}'.format(x))"
p13763
(F-2.1848599751790365
F-4.483672618865967
tp13764
sS"float('{0:.2f}'.format(13.95))"
p13765
(F-1.425031141801314
F-4.557306289672852
tp13766
sS"print '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p13767
(F-1.646235552701083
F-4.561431884765625
tp13768
sS'x == g\nh = round(x, 2)\nh\nx == h'
p13769
(F-3.564061737060547
F-4.601855278015137
tp13770
sS"print '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)"
p13771
(F-2.0832577580991
F-4.504020690917969
tp13772
sS"print '%.2f' % a\nround(a, 2)"
p13773
(F-2.3719796400803785
F-4.5564446449279785
tp13774
sS"g = float('{0:.2f}'.format(x))"
p13775
(F-1.838322712824895
F-4.4954681396484375
tp13776
sS"round(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p13777
(F-1.5198212648049378
F-4.463443756103516
tp13778
sS"print a\nprint '%.2f' % a\nround(a, 2)"
p13779
(F-2.338456630706787
F-4.663350582122803
tp13780
sS"125650429603636838 / 2 ** 53\n234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)"
p13781
(F-3.197070837020874
F-4.607333183288574
tp13782
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)"
p13783
(F-2.7953271304859832
F-4.412365436553955
tp13784
sS"print '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p13785
(F-1.500603437423706
F-4.596397399902344
tp13786
sS"round(a, 2)\nprint '%.2f' % round(a, 2)"
p13787
(F-1.8642429775661893
F-4.377293109893799
tp13788
sS"234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)"
p13789
(F-2.1417036923495205
F-4.538084030151367
tp13790
sS'234042163 / 2 ** 24\na = 13.946'
p13791
(F-3.9843680641867896
F-4.76559591293335
tp13792
sS'a = 13.946'
p13793
(F-2.5094959259033205
F-5.349602699279785
tp13794
sS'h\nx == h'
p13795
(F-4.877368927001953
F-5.2310357093811035
tp13796
sS'g\nx == g\nh = round(x, 2)'
p13797
(F-3.886880397796631
F-4.517790794372559
tp13798
sS'h = round(x, 2)'
p13799
(F-2.4469650268554686
F-4.54246711730957
tp13800
sS'print a'
p13801
(F-3.4304285049438477
F-5.34799337387085
tp13802
sS"x\ng = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)\nh\nx == h"
p13803
(F-3.0786187913682728
F-4.466854095458984
tp13804
sS"print '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)"
p13805
(F-1.6561295358758223
F-4.615422248840332
tp13806
sS"234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p13807
(F-1.9381451523094846
F-4.533708572387695
tp13808
sS"'%.2f' % 3.14159\n'%.2f' % 13.9499999"
p13809
(F-2.927881876627604
F-4.993958473205566
tp13810
sS"g = float('{0:.2f}'.format(x))\ng\nx == g"
p13811
(F-3.0131030835603414
F-4.540809154510498
tp13812
sS"print '%.2f' % round(a, 2)"
p13813
(F-2.049734115600586
F-4.4969482421875
tp13814
sS"round(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)"
p13815
(F-1.6353865403395433
F-4.432873725891113
tp13816
sS"125650429603636838 / 2 ** 53\n234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)"
p13817
(F-2.5055888366699217
F-4.563271522521973
tp13818
sS"round(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))\nprint '{0:.15f}'.format(round(a, 2))"
p13819
(F-1.4947957258958082
F-4.476842880249023
tp13820
sS'g\nx == g'
p13821
(F-5.74006598336356
F-5.205385208129883
tp13822
sS'round(a, 2)'
p13823
(F-1.9657819271087646
F-4.479155540466309
tp13824
sS"print '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p13825
(F-1.4145651730624111
F-4.74400520324707
tp13826
sS"g = float('{0:.2f}'.format(x))\ng\nx == g\nh = round(x, 2)"
p13827
(F-2.849087578909738
F-4.42512321472168
tp13828
sS"print a\nprint '%.2f' % a"
p13829
(F-2.4714569515652127
F-5.15800142288208
tp13830
sS"234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)"
p13831
(F-2.4078197479248047
F-4.491294860839844
tp13832
sS"print '{0:.2f}'.format(a)"
p13833
(F-1.441096093919542
F-5.067551136016846
tp13834
sS'234042163 / 2 ** 24\na = 13.946\nprint a'
p13835
(F-3.4891965048653737
F-4.749870777130127
tp13836
sS"125650429603636838 / 2 ** 53\n234042163 / 2 ** 24\na = 13.946\nprint a\nprint '%.2f' % a"
p13837
(F-3.4577096557617186
F-4.80877161026001
tp13838
sS'h = round(x, 2)\nh'
p13839
(F-2.8252360026041665
F-4.589908599853516
tp13840
sS"a = 13.946\nprint a\nprint '%.2f' % a\nround(a, 2)\nprint '%.2f' % round(a, 2)\nprint '{0:.2f}'.format(a)\nprint '{0:.2f}'.format(round(a, 2))"
p13841
(F-1.5530598958333333
F-4.626624584197998
tp13842
ssI73663
(dp13843
S'sys.exit()'
p13844
(F-1.2743887220110213
F-2.237727165222168
tp13845
sS'import sys'
p13846
(F-2.5925636291503906
F-2.099048614501953
tp13847
sS'import sys\nsys.exit()'
p13848
(F-0.9497365951538086
F-2.2068092028299966
tp13849
sS'if this == that:\n    quit()'
p13850
(F-3.322427896352915
F-2.2523744901021323
tp13851
sS'if this == that:\n    pass'
p13852
(F-3.847958304665305
F-2.4602104822794595
tp13853
sS'quit()'
p13854
(F-2.4170415878295897
F-2.0576537450154624
tp13855
sS'raise SystemExit'
p13856
(F-3.9355262756347655
F-2.377348264058431
tp13857
ssI319426
(dp13858
S"s = open('unicode.txt', encoding='utf8').read()\nprint s\nfirst, second = s.splitlines()\nprint first.lower()\nprint second.lower()"
p13859
(F-1.868745670762173
F-2.111219678606306
tp13860
sS"import unicodedata\n\ndef normalize_caseless(text):\n    return unicodedata.normalize('NFKD', text.casefold())"
p13861
(F-1.8310811360677084
F-2.178858075823103
tp13862
sS"string1 = 'Hello'\nstring2 = 'hello'\nif string1.lower() == string2.lower():\n    print 'The strings are the same (case insensitive)'\nelse:\n    pass"
p13863
(F-1.033692387172154
F-2.0261071068899974
tp13864
sS'print first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()'
p13865
(F-2.063878377278646
F-2.0134288242885043
tp13866
sS'print s\nfirst, second = s.splitlines()\nprint first.lower()\nprint second.lower()'
p13867
(F-2.239967482430594
F-2.013295991080148
tp13868
sS"string2 = 'hello'\nif string1.lower() == string2.lower():\n    print 'The strings are the same (case insensitive)'\nelse:\n    print 'The strings are not the same (case insensitive)'"
p13869
(F-1.123321771621704
F-2.0428145272391185
tp13870
sS"print repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()"
p13871
(F-2.8695211207613034
F-2.209155355181013
tp13872
sS'if string1.lower() == string2.lower():\n    pass'
p13873
(F-1.4256533572548313
F-2.039095606122698
tp13874
sS"string1 = 'Hello'"
p13875
(F-2.412075424194336
F-2.026590211050851
tp13876
sS"print repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')"
p13877
(F-3.358287811279297
F-2.542105266026088
tp13878
sS"'\\xc3\\xaa' == 'e\\xcc\\x82'"
p13879
(F-2.0750329971313475
F-2.2705535888671875
tp13880
sS'first, second = s.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()'
p13881
(F-2.066180170798788
F-2.0133052553449358
tp13882
sS"[unicodedata.name(char) for char in '\\xc3\\xaa']"
p13883
(F-2.8036787850516185
F-2.053943089076451
tp13884
sS"utf8_bytes = open('unicode.txt', 'r').read()\nprint repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()"
p13885
(F-2.6056211604628454
F-2.1381653376988004
tp13886
sS"print repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()"
p13887
(F-3.0729724884033205
F-2.298231397356306
tp13888
sS'print u\nfirst, second = u.splitlines()'
p13889
(F-3.7547198704310825
F-2.264857700892857
tp13890
sS'print s\nfirst, second = s.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()'
p13891
(F-2.2279151916503905
F-2.002875873020717
tp13892
sS'first, second = s.splitlines()\nprint first.lower()\nprint second.lower()'
p13893
(F-1.942388458251953
F-2.0134078434535434
tp13894
sS"if string1.lower() == string2.lower():\n    print 'The strings are the same (case insensitive)'\nelse:\n    print 'The strings are not the same (case insensitive)'"
p13895
(F-0.9034475599016462
F-2.0396134512765065
tp13896
sS'first, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()'
p13897
(F-2.246855910943479
F-2.034351485116141
tp13898
sS'def normalize_caseless(text):\n    pass'
p13899
(F-1.7015737806047713
F-2.1878425053187778
tp13900
sS'import unicodedata'
p13901
(F-3.44541597366333
F-2.115462984357561
tp13902
sS"def normalize_caseless(text):\n    return unicodedata.normalize('NFKD', text.casefold())\n\ndef caseless_equal(left, right):\n    pass"
p13903
(F-1.9024447486514138
F-2.1887741088867188
tp13904
sS"string1 = 'Hello'\nstring2 = 'hello'"
p13905
(F-1.8351989322238498
F-2.0438574382237027
tp13906
sS'print s\nfirst, second = s.splitlines()'
p13907
(F-2.9590546744210378
F-2.1206081935337613
tp13908
sS"return unicodedata.normalize('NFKD', text.casefold())"
p13909
(F-2.28809814453125
F-2.2210919516427174
tp13910
sS"import unicodedata\n[unicodedata.name(char) for char in '\\xc3\\xaa']"
p13911
(F-2.7342461978687957
F-2.0295889718191966
tp13912
sS"string2 = 'hello'\nif string1.lower() == string2.lower():\n    print 'The strings are the same (case insensitive)'\nelse:\n    pass"
p13913
(F-1.2696234180081276
F-2.0422774723597934
tp13914
sS"string1 = 'Hello'\nstring2 = 'hello'\nif string1.lower() == string2.lower():\n    pass"
p13915
(F-1.3281251412850839
F-2.0250485283987865
tp13916
sS"print repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u"
p13917
(F-3.3107313073199727
F-2.540330614362444
tp13918
sS'print first.lower()'
p13919
(F-2.069589614868164
F-1.9858549662998743
tp13920
sS"utf8_bytes = open('unicode.txt', 'r').read()"
p13921
(F-2.0505619049072266
F-2.434734344482422
tp13922
sS"s = open('unicode.txt', encoding='utf8').read()\nprint s"
p13923
(F-1.5472681145918996
F-2.3559701102120534
tp13924
sS'print second.lower()'
p13925
(F-2.1771984100341797
F-2.040480204990932
tp13926
sS'print first.lower()\nprint second.lower()\nfirst.lower() == second.lower()'
p13927
(F-1.9709540473090277
F-2.002680097307478
tp13928
sS'print second.lower()\nfirst.lower() == second.lower()'
p13929
(F-2.27218074798584
F-2.017336300441197
tp13930
sS"string2 = 'hello'\nif string1.lower() == string2.lower():\n    pass\n"
p13931
(F-1.657757800558339
F-2.040703092302595
tp13932
sS'help(str.casefold)'
p13933
(F-3.3006253242492676
F-2.231444767543248
tp13934
sS"string2 = 'hello'\nif string1.lower() == string2.lower():\n    pass"
p13935
(F-1.657757800558339
F-2.040703092302595
tp13936
sS'"""\xc3\x9f""".lower()'
p13937
(F-1.8022809709821428
F-2.064337594168527
tp13938
sS"u = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()"
p13939
(F-2.614870101686508
F-2.0378759929112027
tp13940
sS"unicodedata.normalize('NFKD', '\\xc3\\xaa') == unicodedata.normalize('NFKD',\n    'e\\xcc\\x82')"
p13941
(F-2.046406555175781
F-2.209841319492885
tp13942
sS"print 'The strings are not the same (case insensitive)'"
p13943
(F-1.9628170728683472
F-2.234341621398926
tp13944
sS"import unicodedata\n\ndef normalize_caseless(text):\n    return unicodedata.normalize('NFKD', text.casefold())\n\ndef caseless_equal(left, right):\n    return normalize_caseless(left) == normalize_caseless(right)"
p13945
(F-2.121835740946107
F-2.177849360874721
tp13946
sS'print u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()'
p13947
(F-2.578902816772461
F-2.0506040028163364
tp13948
sS"s = open('unicode.txt', encoding='utf8').read()"
p13949
(F-1.67020583152771
F-2.360908235822405
tp13950
sS'print u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()'
p13951
(F-2.543299748347356
F-2.0469943455287387
tp13952
sS'import unicodedata\n\ndef normalize_caseless(text):\n    pass'
p13953
(F-1.8168091244167752
F-2.145984649658203
tp13954
sS'first, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()'
p13955
(F-2.221579680571685
F-2.036578042166574
tp13956
sS"u = utf8_bytes.decode('utf8')"
p13957
(F-3.175746281941732
F-2.5059713636125838
tp13958
sS'first, second = s.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()'
p13959
(F-1.9909294747017525
F-2.0094094957624162
tp13960
sS'first, second = u.splitlines()\nprint first.lower()'
p13961
(F-2.517051272922092
F-2.0611610412597656
tp13962
sS'print second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()'
p13963
(F-2.2891430854797363
F-2.02514226096017
tp13964
sS'first, second = u.splitlines()'
p13965
(F-3.1840341741388496
F-2.2234589712960378
tp13966
sS"print repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()"
p13967
(F-2.7856812557931674
F-2.106115068708147
tp13968
sS'print repr(utf8_bytes)'
p13969
(F-3.138796912299262
F-2.414167949131557
tp13970
sS"print repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()"
p13971
(F-2.7404578840228875
F-2.0739203861781528
tp13972
sS'"""\xc3\x9f""".lower()\n"""\xc3\x9f""".upper().lower()'
p13973
(F-2.1234857895795036
F-2.06765924181257
tp13974
sS'"""\xc3\x9f""".upper().lower()'
p13975
(F-1.5734221718528054
F-2.070906230381557
tp13976
sS"print 'The strings are the same (case insensitive)'"
p13977
(F-1.9628170728683472
F-2.234341621398926
tp13978
sS"def normalize_caseless(text):\n    return unicodedata.normalize('NFKD', text.casefold())\n\ndef caseless_equal(left, right):\n    return normalize_caseless(left) == normalize_caseless(right)"
p13979
(F-2.1674686778675425
F-2.2026147842407227
tp13980
sS'def caseless_equal(left, right):\n    return normalize_caseless(left) == normalize_caseless(right)'
p13981
(F-2.505102749528556
F-2.3354320526123047
tp13982
sS'def caseless_equal(left, right):\n    pass'
p13983
(F-1.989527702331543
F-2.2635131563459123
tp13984
sS'first, second = s.splitlines()\nprint first.lower()'
p13985
(F-2.1238085428873696
F-2.0276761736188615
tp13986
sS"string2 = 'hello'"
p13987
(F-3.1158695220947266
F-2.0850797380719865
tp13988
sS"utf8_bytes = open('unicode.txt', 'r').read()\nprint repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()"
p13989
(F-2.6140369724582984
F-2.1792193821498325
tp13990
sS"utf8_bytes = open('unicode.txt', 'r').read()\nprint repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()"
p13991
(F-2.933413823445638
F-2.4971226283482144
tp13992
sS'string1.lower() == string2.lower()'
p13993
(F-1.8354198749248798
F-2.0154075622558594
tp13994
sS'print u\nfirst, second = u.splitlines()\nprint first.lower()'
p13995
(F-3.0049271356491816
F-2.082571029663086
tp13996
sS"[unicodedata.name(char) for char in '\\xc3\\xaa']\n[unicodedata.name(char) for char in 'e\\xcc\\x82']"
p13997
(F-2.7869209006980613
F-2.0582761764526367
tp13998
sS"s = open('unicode.txt', encoding='utf8').read()\nprint s\nfirst, second = s.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()"
p13999
(F-1.9590198863636363
F-2.0601461955479214
tp14000
sS'first.lower() == second.lower()\nfirst.upper() == second.upper()'
p14001
(F-2.2559527587890624
F-2.0224043982369557
tp14002
sS'first, second = s.splitlines()'
p14003
(F-2.5357291481711646
F-2.14333370753697
tp14004
sS"utf8_bytes = open('unicode.txt', 'r').read()\nprint repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')"
p14005
(F-2.7165352957589284
F-2.5520727975027904
tp14006
sS"import unicodedata\n[unicodedata.name(char) for char in '\\xc3\\xaa']\n[unicodedata.name(char) for char in 'e\\xcc\\x82']"
p14007
(F-2.8022300720214846
F-2.0351646968296597
tp14008
sS"utf8_bytes = open('unicode.txt', 'r').read()\nprint repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()"
p14009
(F-2.637790310767389
F-2.2834445408412387
tp14010
sS"s = open('unicode.txt', encoding='utf8').read()\nprint s\nfirst, second = s.splitlines()\nprint first.lower()"
p14011
(F-1.9195548163519964
F-2.1557224818638394
tp14012
sS"string1 = 'Hello'\nstring2 = 'hello'\nif string1.lower() == string2.lower():\n    pass\n"
p14013
(F-1.3281251412850839
F-2.0250485283987865
tp14014
sS"u = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()"
p14015
(F-2.933830738067627
F-2.1822754996163503
tp14016
sS'return normalize_caseless(left) == normalize_caseless(right)'
p14017
(F-3.8292322158813477
F-2.3275078364780972
tp14018
sS"def normalize_caseless(text):\n    return unicodedata.normalize('NFKD', text.casefold())"
p14019
(F-1.7899877108060396
F-2.2038224084036693
tp14020
sS'first.upper() == second.upper()'
p14021
(F-2.4633926978478065
F-2.0750815527779713
tp14022
sS"print repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()"
p14023
(F-3.4108500625147964
F-2.4753546033586775
tp14024
sS'print s\nfirst, second = s.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()'
p14025
(F-2.260928227351262
F-2.009775161743164
tp14026
sS'if string1.lower() == string2.lower():\n    pass\n'
p14027
(F-1.4256533572548313
F-2.0390957423618863
tp14028
sS'print s'
p14029
(F-3.124091148376465
F-2.1951362064906528
tp14030
sS'print u'
p14031
(F-4.208065032958984
F-2.3203770773751393
tp14032
sS"if string1.lower() == string2.lower():\n    print 'The strings are the same (case insensitive)'\nelse:\n    pass"
p14033
(F-1.0740376931649667
F-2.0406981876918246
tp14034
sS"utf8_bytes = open('unicode.txt', 'r').read()\nprint repr(utf8_bytes)"
p14035
(F-2.315224806467692
F-2.47614015851702
tp14036
sS'print s\nfirst, second = s.splitlines()\nprint first.lower()'
p14037
(F-2.470353807721819
F-2.029437746320452
tp14038
sS'print u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()'
p14039
(F-2.6787727900913785
F-2.0642242431640625
tp14040
sS"[unicodedata.name(char) for char in 'e\\xcc\\x82']"
p14041
(F-2.8036787850516185
F-2.053943089076451
tp14042
sS"s = open('unicode.txt', encoding='utf8').read()\nprint s\nfirst, second = s.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()\nfirst.upper() == second.upper()"
p14043
(F-2.0416250655900186
F-2.0517886025565013
tp14044
sS"import unicodedata\n\ndef normalize_caseless(text):\n    return unicodedata.normalize('NFKD', text.casefold())\n\ndef caseless_equal(left, right):\n    pass"
p14045
(F-1.8543084186056387
F-2.1653714861188615
tp14046
sS"utf8_bytes = open('unicode.txt', 'r').read()\nprint repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u"
p14047
(F-2.7239934017783716
F-2.552558353969029
tp14048
sS"u = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()"
p14049
(F-3.33224365234375
F-2.429674965994699
tp14050
sS"string1 = 'Hello'\nstring2 = 'hello'\nif string1.lower() == string2.lower():\n    print 'The strings are the same (case insensitive)'\nelse:\n    print 'The strings are not the same (case insensitive)'"
p14051
(F-0.9117400911119249
F-2.0288332530430386
tp14052
sS'first, second = u.splitlines()\nprint first.lower()\nprint second.lower()'
p14053
(F-2.2474819946289064
F-2.043718065534319
tp14054
sS"utf8_bytes = open('unicode.txt', 'r').read()\nprint repr(utf8_bytes)\nu = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()"
p14055
(F-2.7528045654296873
F-2.359649658203125
tp14056
sS'print first.lower()\nprint second.lower()'
p14057
(F-1.8365253448486327
F-1.997264998299735
tp14058
sS"u = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()\nfirst.lower() == second.lower()"
p14059
(F-2.6481610466452206
F-2.0443079812186107
tp14060
sS"s = open('unicode.txt', encoding='utf8').read()\nprint s\nfirst, second = s.splitlines()"
p14061
(F-2.026532929519127
F-2.264092581612723
tp14062
sS"u = utf8_bytes.decode('utf8')\nprint u"
p14063
(F-3.108301289876302
F-2.5023915427071706
tp14064
sS'first.lower() == second.lower()'
p14065
(F-2.1654933049128604
F-2.0105787004743303
tp14066
sS"u = utf8_bytes.decode('utf8')\nprint u\nfirst, second = u.splitlines()\nprint first.lower()\nprint second.lower()"
p14067
(F-2.7167737911909056
F-2.1070954459054128
tp14068
ssI1476
(dp14069
S"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))"
p14070
(F-2.7201143900553384
F-3.648599451238459
tp14071
sS"int('010101', 2)"
p14072
(F-2.465574264526367
F-3.3367843627929688
tp14073
sS'21'
p14074
(F-5.309263229370117
F-3.6090389598499644
tp14075
sS"int('10101', 0)\nint('0b10101', 0)"
p14076
(F-2.827562713623047
F-3.374934109774503
tp14077
sS'bin(21)'
p14078
(F-3.809175491333008
F-3.3973066156560723
tp14079
sS'47'
p14080
(F-6.619342803955078
F-3.4909896850585938
tp14081
sS"int('0b10101', 0)"
p14082
(F-2.8187246322631836
F-3.3660722212357954
tp14083
sS"print int('01010101111', 2)"
p14084
(F-2.7798902723524304
F-3.3694704229181465
tp14085
sS"int('0b0010101010', 2)"
p14086
(F-2.465574026107788
F-3.3367843627929688
tp14087
sS"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))\nformat(int('010101', 2), '010b')"
p14088
(F-2.699827194213867
F-3.6536681435324927
tp14089
sS'170\n21'
p14090
(F-6.2002910614013675
F-3.591244090687145
tp14091
sS'bin(173)'
p14092
(F-2.989477793375651
F-3.3851661682128906
tp14093
sS"int('10101', 0)"
p14094
(F-2.8187241554260254
F-3.3660722212357954
tp14095
sS"format(int('010101', 2), '010b')"
p14096
(F-2.4283155294565053
F-3.527285489169034
tp14097
sS"bin(int('010101', 2))"
p14098
(F-2.3598168113014917
F-3.354945096102628
tp14099
sS"print int('01010101111', 2)\nprint int('11111111', 2)"
p14100
(F-2.5485310274011947
F-3.4004589427601206
tp14101
sS"print int('11111111', 2)"
p14102
(F-2.7798902723524304
F-3.3694704229181465
tp14103
sS'170'
p14104
(F-6.218173980712891
F-3.427123329856179
tp14105
ssI42950
(dp14106
S'import datetime'
p14107
(F-2.0937671661376953
F-1.960787582397461
tp14108
sS'calendar.monthrange(2002, 1)\ncalendar.monthrange(2008, 2)'
p14109
(F-2.6655528419896175
F-1.9143100738525392
tp14110
sS'def last_day_of_month(any_day):\n    next_month = any_day.replace(day=28) + datetime.timedelta(days=4)'
p14111
(F-2.0666903541201638
F-2.0463233947753907
tp14112
sS'calendar.monthrange(2002, 1)\ncalendar.monthrange(2008, 2)\ncalendar.monthrange(2100, 2)'
p14113
(F-2.499761308942522
F-1.949542236328125
tp14114
sS'for month in range(1, 13):\n    pass'
p14115
(F-1.8178305625915527
F-2.754904937744141
tp14116
sS'print last_day_of_month(datetime.date(2012, month, 1))'
p14117
(F-2.3420096310702236
F-1.8646425247192382
tp14118
sS'import datetime\n\ndef last_day_of_month(any_day):\n    pass'
p14119
(F-1.7343673706054688
F-1.7793209075927734
tp14120
sS'datetime.date(2000, 2, 1) - datetime.timedelta(days=1)'
p14121
(F-1.5393013727097284
F-1.7851882934570313
tp14122
sS'import calendar\ncalendar.monthrange(2002, 1)\ncalendar.monthrange(2008, 2)\ncalendar.monthrange(2100, 2)'
p14123
(F-2.1371570710212953
F-1.9113731384277344
tp14124
sS'monthrange(2012, 2)'
p14125
(F-2.5435938835144043
F-2.41951904296875
tp14126
sS'for month in range(1, 13):\n    pass\n'
p14127
(F-1.8178305625915527
F-2.754904937744141
tp14128
sS'calendar.monthrange(2002, 1)'
p14129
(F-2.648499298095703
F-1.8756752014160156
tp14130
sS'calendar.monthrange(2008, 2)\ncalendar.monthrange(2100, 2)'
p14131
(F-2.3280133699115955
F-1.9634632110595702
tp14132
sS'import calendar\ncalendar.monthrange(2002, 1)'
p14133
(F-2.2143405033991885
F-1.8711475372314452
tp14134
sS'calendar.monthrange(2100, 2)'
p14135
(F-2.000724220275879
F-1.8965734481811523
tp14136
sS'import calendar'
p14137
(F-2.7297496795654297
F-2.0092594146728517
tp14138
sS'import datetime\n\ndef last_day_of_month(any_day):\n    next_month = any_day.replace(day=28) + datetime.timedelta(days=4)'
p14139
(F-1.9477228911026665
F-1.9039215087890624
tp14140
sS'def last_day_of_month(any_day):\n    pass'
p14141
(F-1.9100921630859375
F-1.9674037933349608
tp14142
sS'from calendar import monthrange'
p14143
(F-1.5554176966349285
F-1.8641799926757812
tp14144
sS'calendar.monthrange(2008, 2)'
p14145
(F-2.321849822998047
F-1.9287033081054688
tp14146
sS'def last_day_of_month(any_day):\n    next_month = any_day.replace(day=28) + datetime.timedelta(days=4)\nreturn next_month - datetime.timedelta(days=next_month.day)'
p14147
(F-2.2042004903157553
F-2.0505313873291016
tp14148
sS'import calendar\ncalendar.monthrange(2002, 1)\ncalendar.monthrange(2008, 2)'
p14149
(F-2.2177434401078657
F-1.885794448852539
tp14150
sS'from calendar import monthrange\nmonthrange(2012, 2)'
p14151
(F-1.1465728466327374
F-1.922507095336914
tp14152
sS'calendar.monthrange(year, month)[1]'
p14153
(F-1.79902957035945
F-1.8335958480834962
tp14154
sS'next_month = any_day.replace(day=28) + datetime.timedelta(days=4)'
p14155
(F-2.3656356811523436
F-1.9502447128295899
tp14156
sS'import datetime\ndatetime.date(2000, 2, 1) - datetime.timedelta(days=1)'
p14157
(F-1.191144307454427
F-1.7721607208251953
tp14158
sS'return next_month - datetime.timedelta(days=next_month.day)'
p14159
(F-2.44583491275185
F-1.894548225402832
tp14160
sS'import datetime\n\ndef last_day_of_month(any_day):\n    next_month = any_day.replace(day=28) + datetime.timedelta(days=4)\nreturn next_month - datetime.timedelta(days=next_month.day)'
p14161
(F-2.093440055847168
F-1.9544910430908202
tp14162
ssI761804
(dp14163
S'""" Hello """.strip()\n""" Hello""".strip()\n"""Bob has a cat""".strip()\n"""          Hello        """.strip()'
p14164
(F-2.4113055419921876
F-1.7198332377842493
tp14165
sS"strip_one_space('   Hello ')"
p14166
(F-3.154204559326172
F-1.6173151561192103
tp14167
sS"title = title.strip(',.-')"
p14168
(F-2.2785037994384765
F-1.83079651423863
tp14169
sS'"""  Hello\n"""'
p14170
(F-1.6942688624064128
F-1.6342157636369978
tp14171
sS'""" Hello """.strip()\n""" Hello""".strip()\n"""Bob has a cat""".strip()'
p14172
(F-2.380792316637541
F-1.6928223201206751
tp14173
sS'"""  Hello\n""".strip(\' \')'
p14174
(F-1.832566738128662
F-1.6207564217703683
tp14175
sS'"""Bob has a cat""".strip()\n"""          Hello        """.strip()'
p14176
(F-2.3236007690429688
F-1.6537892477852958
tp14177
sS'""" Hello """.strip()'
p14178
(F-1.896155902317592
F-1.587876319885254
tp14179
sS'"""Bob has a cat""".strip()'
p14180
(F-1.896155902317592
F-1.587876319885254
tp14181
sS'""" Hello""".strip()\n"""Bob has a cat""".strip()'
p14182
(F-2.3236007690429688
F-1.6537892477852958
tp14183
sS'""" Hello""".strip()\n"""Bob has a cat""".strip()\n"""          Hello        """.strip()'
p14184
(F-2.380792316637541
F-1.6928223201206751
tp14185
sS'"""          Hello        """.strip()'
p14186
(F-1.896155902317592
F-1.587876319885254
tp14187
sS'myString.strip()'
p14188
(F-1.7563962936401367
F-1.6223046439034599
tp14189
sS'""" Hello""".strip()'
p14190
(F-1.896155902317592
F-1.587876319885254
tp14191
sS'""" Hello """.strip()\n""" Hello""".strip()'
p14192
(F-2.3236007690429688
F-1.6537893840244837
tp14193
ssI4476373
(dp14194
S'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p14195
(F-1.338409228202624
F-3.546336364746094
tp14196
sS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar'}\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p14197
(F-1.4482696208548038
F-3.5331878662109375
tp14198
sS'r = requests.post(url, data=payload)\nimport json'
p14199
(F-1.6939122817095589
F-3.4952629089355467
tp14200
sS'resp'
p14201
(F-4.883715947469075
F-3.7162994384765624
tp14202
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\nresp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))\nresp"
p14203
(F-2.343901758608611
F-3.3998703002929687
tp14204
sS"payload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p14205
(F-1.0287093071088398
F-3.5349925994873046
tp14206
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\nresp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))"
p14207
(F-2.527021750425681
F-3.4854881286621096
tp14208
sS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p14209
(F-1.6144883632659912
F-3.535007858276367
tp14210
sS"resp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))"
p14211
(F-2.5879756927490236
F-3.5427616119384764
tp14212
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p14213
(F-1.2343931931715746
F-3.523999786376953
tp14214
sS"post_data = {'username': 'joeb', 'password': 'foobar'}"
p14215
(F-1.231849161783854
F-3.620716094970703
tp14216
sS"payload = {'key1': 'value1', 'key2': 'value2'}"
p14217
(F-0.9679361490102915
F-3.5606555938720703
tp14218
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p14219
(F-1.1780412946428571
F-3.534964752197266
tp14220
sS'r = requests.post(url, data=json.dumps(payload))'
p14221
(F-0.9908780549701891
F-3.533403778076172
tp14222
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p14223
(F-1.1051881313323975
F-3.5262989044189452
tp14224
sS"payload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p14225
(F-1.1432245954682556
F-3.5334625244140625
tp14226
sS"resp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))\nresp"
p14227
(F-2.772051204334606
F-3.5355545043945313
tp14228
sS"payload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p14229
(F-1.045797161027497
F-3.509294128417969
tp14230
sS"def URLRequest(url, params, method='GET'):\n    if method == 'POST':\n        pass"
p14231
(F-2.1643750226056135
F-3.3855323791503906
tp14232
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)"
p14233
(F-0.7500051301101158
F-3.4403690338134765
tp14234
sS'from httplib2 import Http\nfrom urllib import urlencode\nh = Http()'
p14235
(F-2.8635491763844207
F-3.327901840209961
tp14236
sS'import requests'
p14237
(F-2.3281307220458984
F-3.76464958190918
tp14238
sS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar'}"
p14239
(F-1.5775172369820731
F-3.4856235504150392
tp14240
sS"import requests\nurl = 'https://...'"
p14241
(F-1.5941121578216553
F-3.4589523315429687
tp14242
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)"
p14243
(F-0.8117916400615985
F-3.417554473876953
tp14244
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p14245
(F-0.9102152994234268
F-3.498204803466797
tp14246
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p14247
(F-1.4974234686957466
F-3.5428798675537108
tp14248
sS"url = 'https://...'"
p14249
(F-1.41981201171875
F-3.3827606201171876
tp14250
sS"post_data = {'username': 'joeb', 'password': 'foobar'}\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p14251
(F-1.2551931493422563
F-3.551605224609375
tp14252
sS'from httplib2 import Http'
p14253
(F-2.7524452209472656
F-3.477731704711914
tp14254
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p14255
(F-1.1124091090926205
F-3.51351318359375
tp14256
sS'r = requests.post(url, data=json.dumps(payload))\nr.text'
p14257
(F-1.3260047746741253
F-3.5414360046386717
tp14258
sS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.\n    dumps(post_data))"
p14259
(F-2.1240999945278825
F-3.5234054565429687
tp14260
sS'r = requests.get(url, params=payload)'
p14261
(F-0.9711815289088658
F-3.547467041015625
tp14262
sS'r = requests.post(url, data=payload)'
p14263
(F-0.9853224754333496
F-3.5473304748535157
tp14264
sS"def URLRequest(url, params, method='GET'):\n    pass"
p14265
(F-2.444258037366365
F-3.4015674591064453
tp14266
sS'from urllib import urlencode\nh = Http()'
p14267
(F-2.380232810974121
F-3.3508224487304688
tp14268
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p14269
(F-2.162686004638672
F-3.3713512420654297
tp14270
sS"return urllib2.Request(url + '?' + urllib.urlencode(params))"
p14271
(F-1.6286754608154297
F-3.372736358642578
tp14272
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p14273
(F-0.7431292447176847
F-3.4982643127441406
tp14274
sS'r = requests.get(url)\nr = requests.get(url, params=payload)'
p14275
(F-0.9210808795431386
F-3.567578125
tp14276
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\nresp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))\nresp"
p14277
(F-2.476511936561734
F-3.3562057495117186
tp14278
sS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.\n    dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p14279
(F-2.0726903279622397
F-3.562822723388672
tp14280
sS'r.text\nr.status_code'
p14281
(F-2.4363157098943535
F-3.8551197052001953
tp14282
sS"post_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p14283
(F-1.6678625106811524
F-3.552219772338867
tp14284
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p14285
(F-1.1506797915599385
F-3.5455581665039064
tp14286
sS"if method == 'POST':\n    return urllib2.Request(url, data=urllib.urlencode(params))"
p14287
(F-1.2734828362098107
F-3.359651565551758
tp14288
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\nresp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))"
p14289
(F-2.4284454657106984
F-3.3679229736328127
tp14290
sS"data = dict(name='Joe', comment='A test comment')\nresp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))\nresp"
p14291
(F-2.4165841238839287
F-3.5292423248291014
tp14292
sS"payload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)"
p14293
(F-0.7706938656893644
F-3.5004627227783205
tp14294
sS"post_response = requests.post(url='http://httpbin.org/post', data=json.\n    dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p14295
(F-2.132532416449653
F-3.578024673461914
tp14296
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p14297
(F-0.9757094206633391
F-3.546588134765625
tp14298
sS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar'}"
p14299
(F-1.4893600709976689
F-3.484610748291016
tp14300
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p14301
(F-0.7812788547613682
F-3.4751407623291017
tp14302
sS"payload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p14303
(F-0.9341901696246603
F-3.5203598022460936
tp14304
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p14305
(F-1.2277227548452525
F-3.5397628784179687
tp14306
sS"if method == 'POST':\n    pass"
p14307
(F-1.7594972090287642
F-3.7823631286621096
tp14308
sS"payload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p14309
(F-0.7834205627441406
F-3.526287078857422
tp14310
sS'r.text'
p14311
(F-2.168478775024414
F-4.078857040405273
tp14312
sS"import requests\nget_response = requests.get(url='http://google.com')"
p14313
(F-1.7874979131362017
F-3.489815902709961
tp14314
sS'from httplib2 import Http\nfrom urllib import urlencode'
p14315
(F-2.821298772638494
F-3.2732078552246096
tp14316
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p14317
(F-1.3627645558324353
F-3.537911224365234
tp14318
sS"post_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p14319
(F-2.066828727722168
F-3.520941162109375
tp14320
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p14321
(F-2.4450503031412762
F-3.3380626678466796
tp14322
sS'import json\nr = requests.post(url, data=json.dumps(payload))'
p14323
(F-1.1591249812733044
F-3.530733108520508
tp14324
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p14325
(F-1.274845294098356
F-3.5444847106933595
tp14326
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p14327
(F-0.9592454910278321
F-3.50714111328125
tp14328
sS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p14329
(F-1.399373274583083
F-3.5423999786376954
tp14330
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p14331
(F-0.9225600560506185
F-3.560941696166992
tp14332
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p14333
(F-1.0676093877748
F-3.5069610595703127
tp14334
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p14335
(F-0.7332336789085752
F-3.4807861328125
tp14336
sS'return urllib2.Request(url, data=urllib.urlencode(params))'
p14337
(F-1.266185548570421
F-3.3801654815673827
tp14338
sS'import json'
p14339
(F-2.7977428436279297
F-3.7655834197998046
tp14340
sS"payload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p14341
(F-0.8026236693064371
F-3.539869689941406
tp14342
sS'r = requests.get(url)'
p14343
(F-0.969429874420166
F-3.589150619506836
tp14344
sS"post_response = requests.post(url='http://httpbin.org/post', data=json.\n    dumps(post_data))"
p14345
(F-2.2102132943960338
F-3.532748794555664
tp14346
sS"get_response = requests.get(url='http://google.com')"
p14347
(F-1.9628509793962752
F-3.482782745361328
tp14348
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\nresp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))"
p14349
(F-2.2750504233620386
F-3.4114410400390627
tp14350
sS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar'}\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p14351
(F-1.3776443481445313
F-3.504351806640625
tp14352
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p14353
(F-1.00091552734375
F-3.5141761779785154
tp14354
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')"
p14355
(F-2.6121135711669923
F-3.5960838317871096
tp14356
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}"
p14357
(F-1.0587649625890396
F-3.385758972167969
tp14358
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p14359
(F-1.0454432169596355
F-3.531504821777344
tp14360
sS"data = dict(name='Joe', comment='A test comment')\nresp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))"
p14361
(F-2.307676835493608
F-3.541632080078125
tp14362
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p14363
(F-1.0097779707475143
F-3.4744850158691407
tp14364
sS'h = Http()'
p14365
(F-3.454804011753627
F-3.549652862548828
tp14366
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}"
p14367
(F-0.9602728843688965
F-3.4251644134521486
tp14368
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p14369
(F-0.7840111805842473
F-3.5042171478271484
tp14370
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\nresp, content = h.request('http://bitworking.org/news/223/Meet-Ares',\n    'POST', urlencode(data))\nresp"
p14371
(F-2.5989781821646343
F-3.468097686767578
tp14372
sS'from urllib import urlencode'
p14373
(F-1.9586435953776042
F-3.296688461303711
tp14374
sS"def URLRequest(url, params, method='GET'):\n    if method == 'POST':\n        return urllib2.Request(url, data=urllib.urlencode(params))"
p14375
(F-1.6601193745930989
F-3.3675765991210938
tp14376
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p14377
(F-0.8734414953934518
F-3.491019058227539
tp14378
sS"data = dict(name='Joe', comment='A test comment')"
p14379
(F-2.029414313180106
F-3.9648368835449217
tp14380
sS'r.status_code'
p14381
(F-2.368725095476423
F-3.760347366333008
tp14382
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2'}\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p14383
(F-0.9614146660114157
F-3.4647613525390626
tp14384
sS'r = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p14385
(F-1.5383699351343616
F-3.538942337036133
tp14386
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p14387
(F-1.3766983032226563
F-3.5067420959472657
tp14388
ssI247770
(dp14389
S'import inspect\ninspect.getfile(os)'
p14390
(F-2.403055364435369
F-4.4096120198567705
tp14391
sS'print bar.__file__'
p14392
(F-2.7095208168029785
F-4.368054072062175
tp14393
sS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p14394
(F-2.7837912241617837
F-4.509312629699707
tp14395
sS'print os.getcwd()'
p14396
(F-1.701452374458313
F-4.290690739949544
tp14397
sS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p14398
(F-2.4737098330543157
F-4.457522074381511
tp14399
sS'inspect.getfile(os)\ninspect.getfile(inspect)'
p14400
(F-3.656084187825521
F-4.603763580322266
tp14401
sS'inspect.getfile(os)'
p14402
(F-3.3191232681274414
F-4.535943667093913
tp14403
sS'import inspect'
p14404
(F-2.9384779930114746
F-4.046346028645833
tp14405
sS'print __file__'
p14406
(F-2.4606226285298667
F-4.576436996459961
tp14407
sS'os.path.dirname(inspect.getfile(inspect))'
p14408
(F-1.6096717834472656
F-3.9609527587890625
tp14409
sS'import bar\nprint bar.__file__'
p14410
(F-2.5304912220348013
F-4.29270617167155
tp14411
sS'path = os.path.abspath(amodule.__file__)'
p14412
(F-1.343780755996704
F-3.9968105951944985
tp14413
sS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p14414
(F-2.407197952270508
F-4.314317385355632
tp14415
sS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p14416
(F-2.22693110874721
F-4.293965021769206
tp14417
sS'import bar'
p14418
(F-3.179425001144409
F-4.014386494954427
tp14419
sS'path = os.path.dirname(amodule.__file__)'
p14420
(F-1.3604544401168823
F-4.03939946492513
tp14421
sS'import a_module'
p14422
(F-2.8829466501871743
F-3.855009396870931
tp14423
sS'import os'
p14424
(F-1.5555819272994995
F-4.223990758260091
tp14425
sS'import os\nimport inspect'
p14426
(F-2.169659069606236
F-4.129262606302897
tp14427
sS'inspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p14428
(F-2.433287187056108
F-4.246853828430176
tp14429
sS'import a_module\nprint a_module.__file__'
p14430
(F-2.422144826253255
F-4.107865651448567
tp14431
sS'import os\nprint os.getcwd()\nprint __file__'
p14432
(F-1.251175880432129
F-4.336435317993164
tp14433
sS'import os\npath = os.path.dirname(amodule.__file__)'
p14434
(F-1.0420016238563938
F-4.136741956075032
tp14435
sS'print a_module.__file__'
p14436
(F-2.7105688095092773
F-4.113449732462565
tp14437
sS'import os\nprint os.getcwd()'
p14438
(F-0.9952400380914862
F-4.332485198974609
tp14439
sS'inspect.getfile(inspect)'
p14440
(F-3.1893858909606934
F-4.659241358439128
tp14441
sS'import os\nimport inspect\ninspect.getfile(os)'
p14442
(F-2.142721176147461
F-4.383063952128093
tp14443
sS'inspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p14444
(F-2.8513107299804688
F-4.3284956614176435
tp14445
sS'print os.getcwd()\nprint __file__'
p14446
(F-1.7872076768141527
F-4.317094167073567
tp14447
ssI4906977
(dp14448
S'print os.environ'
p14449
(F-2.6035963694254556
F-2.6321909768240794
tp14450
sS"print os.environ.get('KEY_THAT_MIGHT_EXIST')\nprint os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p14451
(F-1.9886458023734714
F-2.700723103114537
tp14452
sS'import sys'
p14453
(F-2.019691228866577
F-2.638584954398019
tp14454
sS"print os.environ.get('KEY_THAT_MIGHT_EXIST')"
p14455
(F-1.3503908677534624
F-2.692079816545759
tp14456
sS'import os\nprint os.environ'
p14457
(F-1.634826448228624
F-2.646428789411272
tp14458
sS"print os.environ.get('HOME', '/home/username/')"
p14459
(F-1.148336043724647
F-2.7085582188197543
tp14460
sS'print sys.prefix'
p14461
(F-2.5734523137410483
F-2.69167845589774
tp14462
sS"import os\nprint os.environ['HOME']"
p14463
(F-0.7829460302988688
F-2.6974059513636996
tp14464
sS'import sys\nprint sys.prefix'
p14465
(F-1.454927232530382
F-2.671311514718192
tp14466
sS"os.environ.has_key('HOME')"
p14467
(F-1.5624624888102214
F-2.7154219491141185
tp14468
sS'import os'
p14469
(F-1.9945135116577148
F-2.7286483219691684
tp14470
sS"print os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p14471
(F-2.550464630126953
F-2.7798208509172713
tp14472
sS"'HOME' in os.environ"
p14473
(F-3.1361476353236606
F-2.7116404942103793
tp14474
sS"print os.environ['HOME']"
p14475
(F-1.2016180886162653
F-2.718949454171317
tp14476
sS'os.environ'
p14477
(F-1.7745288848876952
F-2.61163330078125
tp14478
ssI1186789
(dp14479
S"def service_func():\n    print 'service func'\nif __name__ == '__main__':\n    pass"
p14480
(F-1.2241184528057392
F-1.6558895111083984
tp14481
sS"def service_func():\n    print 'service func'\nif __name__ == '__main__':\n    service_func()"
p14482
(F-1.30614013671875
F-1.6939261941348804
tp14483
sS"import test1\n\ndef service_func():\n    print 'service func'\nif __name__ == '__main__':\n    service_func()"
p14484
(F-1.6118893342859604
F-1.4802157458137064
tp14485
sS'import subprocess'
p14486
(F-1.9290547370910645
F-1.3921666986802046
tp14487
sS"def service_func():\n    print 'service func'"
p14488
(F-1.6679791041782923
F-1.6964442309211283
tp14489
sS'def service_func():\n    pass'
p14490
(F-1.8119876568134015
F-1.668601765352137
tp14491
sS"if __name__ == '__main__':\n    service_func()"
p14492
(F-1.283315995160271
F-1.68799108617446
tp14493
sS'service_func()'
p14494
(F-2.408846173967634
F-1.7064188788918888
tp14495
sS"def some_func():\n    print 'in test 1, unproductive'\nif __name__ == '__main__':\n    some_func()"
p14496
(F-0.9557787577311198
F-1.9459717694450827
tp14497
sS"if __name__ == '__main__':\n    service_func()\ntest1.some_func()"
p14498
(F-1.9882008361816406
F-1.7656449710621553
tp14499
sS"print 'in test 1, unproductive'"
p14500
(F-1.7578980922698975
F-1.5773613873650045
tp14501
sS"if __name__ == '__main__':\n    pass"
p14502
(F-0.9657929493830755
F-1.5639996248133041
tp14503
sS'import test1'
p14504
(F-4.338782787322998
F-1.508674845975988
tp14505
sS'def some_func():\n    pass'
p14506
(F-1.4039459228515625
F-1.8487662147073185
tp14507
sS"subprocess.call('test1.py', shell=True)"
p14508
(F-0.819810708363851
F-1.5905395956600414
tp14509
sS"execfile('test2.py')"
p14510
(F-2.0279194513956704
F-1.488807902616613
tp14511
sS"import test1\n\ndef service_func():\n    print 'service func'"
p14512
(F-2.1332872178819446
F-1.4798384273753447
tp14513
sS"print 'test1.py'"
p14514
(F-1.7578980922698975
F-1.5773613873650045
tp14515
sS'import test1\n\ndef service_func():\n    pass'
p14516
(F-2.27582348094267
F-1.4743371851304
tp14517
sS"print 'service func'"
p14518
(F-1.7578980922698975
F-1.5773613873650045
tp14519
sS"import test1\n\ndef service_func():\n    print 'service func'\nif __name__ == '__main__':\n    service_func()\ntest1.some_func()"
p14520
(F-1.9791168939499628
F-1.5314895405488855
tp14521
sS"def some_func():\n    print 'in test 1, unproductive'\nif __name__ == '__main__':\n    pass"
p14522
(F-0.9997216004591721
F-1.8438627579632927
tp14523
sS"import subprocess\nsubprocess.call('test1.py', shell=True)"
p14524
(F-0.5238462448120117
F-1.5274615568273209
tp14525
sS"def service_func():\n    print 'service func'\nif __name__ == '__main__':\n    service_func()\ntest1.some_func()"
p14526
(F-1.807757528204667
F-1.7302412145278032
tp14527
sS'some_func()'
p14528
(F-1.635669163295201
F-1.864477045395795
tp14529
sS'test1.some_func()'
p14530
(F-2.7129669189453125
F-1.6522488313562729
tp14531
sS"import test1\n\ndef service_func():\n    print 'service func'\nif __name__ == '__main__':\n    pass"
p14532
(F-1.5541090647379556
F-1.4731931125416475
tp14533
sS"def some_func():\n    print 'in test 1, unproductive'"
p14534
(F-1.2707644871303014
F-1.9257938160615808
tp14535
sS"if __name__ == '__main__':\n    some_func()"
p14536
(F-0.9484093609978171
F-1.9019582411822151
tp14537
ssI2407398
(dp14538
S'zip(list_a, list_b)'
p14539
(F-1.9891290664672852
F-1.3574517113821847
tp14540
sS'list_b = [5, 6, 7, 8]'
p14541
(F-1.7337448120117187
F-1.5917339324951172
tp14542
sS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]'
p14543
(F-1.2605501372238685
F-1.5183147702898299
tp14544
sS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p14545
(F-1.2998799324035644
F-1.4110234124319894
tp14546
sS'list_a = [1, 2, 3, 4]'
p14547
(F-1.4106244405110677
F-1.569993019104004
tp14548
sS'list_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p14549
(F-1.6111724560077374
F-1.402994019644601
tp14550
ssI364519
(dp14551
S"d = {'x': 2, 'h': 15, 'a': 2222}\nfor key, value in sorted(d.iteritems()):\n    pass\n"
p14552
(F-1.4699213239881728
F-1.9248943328857422
tp14553
sS'for key, value in sorted(d.iteritems()):\n    pass'
p14554
(F-1.062759780883789
F-1.9371109008789062
tp14555
sS'print k, v'
p14556
(F-2.5067822138468423
F-2.1631360054016113
tp14557
sS"d = {'x': 2, 'h': 15, 'a': 2222}\nit = iter(sorted(d.iteritems()))\nit.next()\nit.next()"
p14558
(F-2.1893060373705486
F-1.8930113315582275
tp14559
sS'for k, v in sorted(foo.items()):\n    pass\n'
p14560
(F-1.1784797668457032
F-1.8893306255340576
tp14561
sS'for key, value in sorted(d.iteritems()):\n    pass\n'
p14562
(F-1.062759780883789
F-1.9371109008789062
tp14563
sS'it = iter(sorted(d.iteritems()))\nit.next()\nit.next()'
p14564
(F-2.295888830114294
F-1.9107739925384521
tp14565
sS"{'a': 1, 'c': 3, 'b': 2}"
p14566
(F-1.1358901977539062
F-2.3046083450317383
tp14567
sS'print (key, value)'
p14568
(F-1.3455355167388916
F-2.1830897331237793
tp14569
sS"d = {'x': 2, 'h': 15, 'a': 2222}\nit = iter(sorted(d.iteritems()))\nit.next()\nit.next()\nit.next()"
p14570
(F-2.198308516521843
F-1.8823028802871704
tp14571
sS'it.next()'
p14572
(F-3.0757691519601003
F-2.069751739501953
tp14573
sS'it = iter(sorted(d.iteritems()))'
p14574
(F-2.1140199025472004
F-1.9313255548477173
tp14575
sS'for k in sorted(foo.keys()):\n    pass\n'
p14576
(F-1.5274702707926433
F-1.9252519607543945
tp14577
sS'print k, foo[k]'
p14578
(F-2.7522445254855685
F-2.0673506259918213
tp14579
sS"{'a': 1, 'c': 3, 'b': 2}\n[('a', 1), ('c', 3), ('b', 2)]"
p14580
(F-1.0704480852399554
F-2.232644557952881
tp14581
sS'return sorted(dict.iteritems())'
p14582
(F-1.950242129239169
F-1.9134016036987305
tp14583
sS"[('a', 1), ('b', 2), ('c', 3)]"
p14584
(F-0.9962736765543619
F-2.203141689300537
tp14585
sS"d = {'x': 2, 'h': 15, 'a': 2222}\nfor key, value in sorted(d.iteritems()):\n    pass"
p14586
(F-1.4699213239881728
F-1.9248943328857422
tp14587
sS'for k in sorted(foo.keys()):\n    pass'
p14588
(F-1.5274702707926433
F-1.9252519607543945
tp14589
sS"[('a', 1), ('c', 3), ('b', 2)]"
p14590
(F-1.0179235367547899
F-2.2042441368103027
tp14591
sS"d = {'x': 2, 'h': 15, 'a': 2222}\nit = iter(sorted(d.iteritems()))"
p14592
(F-1.998932869203629
F-1.956310749053955
tp14593
sS"[('a', 1), ('c', 3), ('b', 2)]\n[('a', 1), ('b', 2), ('c', 3)]"
p14594
(F-0.9822377460758861
F-2.20112943649292
tp14595
sS"{'a': 1, 'c': 3, 'b': 2}\n[('a', 1), ('c', 3), ('b', 2)]\n[('a', 1), ('b', 2), ('c', 3)]"
p14596
(F-1.037392148104581
F-2.2071533203125
tp14597
sS'for k, v in sorted(foo.items()):\n    pass'
p14598
(F-1.1784797668457032
F-1.8893306255340576
tp14599
sS"d = {'x': 2, 'h': 15, 'a': 2222}"
p14600
(F-2.138448378619026
F-2.151240825653076
tp14601
sS'it = iter(sorted(d.iteritems()))\nit.next()\nit.next()\nit.next()'
p14602
(F-2.2817230224609375
F-1.9117977619171143
tp14603
sS'it.next()\nit.next()\nit.next()'
p14604
(F-2.73238794427169
F-2.0359749794006348
tp14605
sS"d = {'x': 2, 'h': 15, 'a': 2222}\nit = iter(sorted(d.iteritems()))\nit.next()"
p14606
(F-2.1635659707559123
F-1.9154627323150635
tp14607
sS'it = iter(sorted(d.iteritems()))\nit.next()'
p14608
(F-2.312180836995443
F-1.9149622917175293
tp14609
sS'return iter(sorted(dict.iteritems()))'
p14610
(F-2.083846228463309
F-1.9564027786254883
tp14611
sS'it.next()\nit.next()'
p14612
(F-2.946178729717548
F-2.0424771308898926
tp14613
ssI1038824
(dp14614
S"import re\nurl = 'abcdc.com'\nurl = re.sub('\\\\.com$', '', url)"
p14615
(F-1.4930478050595237
F-1.5393992031321806
tp14616
sS'if not text.endswith(suffix):\n    pass'
p14617
(F-2.2472134908040364
F-1.474563149844899
tp14618
sS"url = 'abcdc.com'\nif url.endswith('.com'):\n    pass"
p14619
(F-1.502112282647027
F-1.5908126831054688
tp14620
sS'import re'
p14621
(F-2.6288790702819824
F-1.4337961533490349
tp14622
sS'return text[:len(text) - len(suffix)]'
p14623
(F-2.3809473514556885
F-1.4945707882151884
tp14624
sS'url = url[:-4]'
p14625
(F-2.792875862121582
F-1.8316469753489775
tp14626
sS"url = 'abcdc.com'\nif url.endswith('.com'):\n    url = url[:-4]"
p14627
(F-1.6193289184570312
F-1.687295352711397
tp14628
sS"if url.endswith('.com'):\n    url = url[:-4]"
p14629
(F-1.7130010695684523
F-1.6390587301815258
tp14630
sS"url = re.sub('\\\\.com$', '', url)"
p14631
(F-1.578263282775879
F-1.525962605195887
tp14632
sS'if not text.endswith(suffix):\n    return text'
p14633
(F-2.3177828788757324
F-1.4935802010928882
tp14634
sS'def strip_end(text, suffix):\n    if not text.endswith(suffix):\n        return text'
p14635
(F-1.8361190269733298
F-1.484511655919692
tp14636
sS'def strip_end(text, suffix):\n    if not text.endswith(suffix):\n        pass'
p14637
(F-1.9768810272216797
F-1.475466111127068
tp14638
sS"if url.endswith('.com'):\n    pass"
p14639
(F-1.4557809829711914
F-1.529225517721737
tp14640
sS"import re\nurl = 'abcdc.com'"
p14641
(F-2.1928696632385254
F-1.5480222141041475
tp14642
sS'def strip_end(text, suffix):\n    if not text.endswith(suffix):\n        return text\nreturn text[:len(text) - len(suffix)]'
p14643
(F-2.0117263793945312
F-1.4969928965849035
tp14644
sS"url = 'abcdc.com'"
p14645
(F-2.60943717956543
F-1.9190191381117876
tp14646
sS'return text'
p14647
(F-3.679293155670166
F-1.642868490780101
tp14648
sS'def strip_end(text, suffix):\n    pass'
p14649
(F-2.294375419616699
F-1.457816853242762
tp14650
sS"url = 'abcdc.com'\nprint url.replace('.com', '')"
p14651
(F-1.2943819681803386
F-1.62286376953125
tp14652
sS"print url.replace('.com', '')"
p14653
(F-1.3832245740023525
F-1.5188672682818245
tp14654
sS"url = 'abcdc.com'\nurl = re.sub('\\\\.com$', '', url)"
p14655
(F-1.5330419540405273
F-1.575796463910271
tp14656
ssI13368659
(dp14657
S"print '192.168.{0}.{1}'.format(i, j)"
p14658
(F-1.606285962191495
F-2.869024423452524
tp14659
sS"for i in range(256):\n    for j in range(256):\n        ip = '192.168.%d.%d' % (i, j)\nprint ip"
p14660
(F-1.280694431728787
F-2.517515329214243
tp14661
sS'for i in range(256):\n    for j in range(256):\n        pass'
p14662
(F-1.32989501953125
F-2.670826251690204
tp14663
sS'for j in range(256):\n    pass'
p14664
(F-1.6515333993094308
F-2.7455887427696815
tp14665
sS'for i in range(256):\n    pass'
p14666
(F-1.4030614580426897
F-2.7358615581805887
tp14667
sS"for j in range(256):\n    ip = '192.168.%d.%d' % (i, j)"
p14668
(F-1.3854103088378906
F-2.562139951265775
tp14669
sS"from netaddr import iter_iprange\ngenerator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)\ngenerator.next()"
p14670
(F-3.111394158725081
F-2.7160524221567006
tp14671
sS"ip = '192.168.%d.%d' % (i, j)"
p14672
(F-2.109566081653942
F-2.5815998957707333
tp14673
sS"for i in range(256):\n    for j in range(256):\n        ip = '192.168.%d.%d' % (i, j)"
p14674
(F-1.220546260024562
F-2.57752198439378
tp14675
sS"generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)"
p14676
(F-2.994694948196411
F-2.783147958608774
tp14677
sS"generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)\ngenerator.next()"
p14678
(F-3.105834267356179
F-2.7439422607421875
tp14679
sS'from netaddr import iter_iprange'
p14680
(F-3.677996873855591
F-2.9486075181227465
tp14681
sS"from netaddr import iter_iprange\ngenerator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)\ngenerator.next()\ngenerator.next()"
p14682
(F-3.1273472377232143
F-2.696605682373047
tp14683
sS"generator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)\ngenerator.next()\ngenerator.next()"
p14684
(F-3.0844454084123885
F-2.7520168011005106
tp14685
sS'generator.next()\ngenerator.next()'
p14686
(F-3.242937528170072
F-2.815175276536208
tp14687
sS'for i, j in product(range(256), range(256)):\n    pass\n'
p14688
(F-1.8717509905497234
F-2.76387698833759
tp14689
sS'for i, j in product(range(256), range(256)):\n    pass'
p14690
(F-1.8717509905497234
F-2.76387698833759
tp14691
sS'print ip'
p14692
(F-3.2987060546875
F-2.570002922644982
tp14693
sS'generator.next()'
p14694
(F-3.1010134560721263
F-2.8372550377478967
tp14695
sS"from netaddr import iter_iprange\ngenerator = iter_iprange('192.168.1.1', '192.168.255.255', step=1)"
p14696
(F-2.9953407619310464
F-2.7689173771784854
tp14697
ssI4588628
(dp14698
S'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\nx == 0'
p14699
(F-1.4861399332682292
F-3.5026184717814126
tp14700
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])'
p14701
(F-1.267462134361267
F-3.49812920888265
tp14702
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\nx == 0\nnumpy.nonzero(x == 0)[0]'
p14703
(F-1.5361294746398926
F-3.3586438496907554
tp14704
sS'a = np.asarray([0, 1, 2, 3, 4])\na == 0'
p14705
(F-1.5784104665120442
F-3.3407119115193686
tp14706
sS'numpy.nonzero(x == 0)[0]'
p14707
(F-1.8371091989370494
F-3.2915627161661782
tp14708
sS'x == 0'
p14709
(F-3.51209716796875
F-4.187070846557617
tp14710
sS'a = np.asarray([0, 1, 2, 3, 4])'
p14711
(F-1.2490280151367188
F-3.339319864908854
tp14712
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\nnumpy.where(x == 0)[0]'
p14713
(F-1.4099322232333096
F-3.3661588033040366
tp14714
sS'numpy.where(x == 0)[0]'
p14715
(F-1.6780008169320912
F-3.345261891682943
tp14716
sS'x == 0\nnumpy.nonzero(x == 0)[0]'
p14717
(F-2.1587968714096966
F-3.371392250061035
tp14718
sS'a == 0'
p14719
(F-3.5906219482421875
F-4.260088920593262
tp14720
ssI16387069
(dp14721
S"if location == a2:\n    img = Image.open('picture.jpg')\nImg.show"
p14722
(F-2.7127538160844282
F-3.5486831665039062
tp14723
sS"img = Image.open('picture.jpg')\nimg.show()"
p14724
(F-0.9660167098045349
F-3.1771504084269204
tp14725
sS'img.show()'
p14726
(F-1.7706975936889648
F-3.3163461685180664
tp14727
sS'Img.show'
p14728
(F-4.709712219238281
F-3.6766179402669272
tp14729
sS"from PIL import Image\nimg = Image.open('picture.jpg')"
p14730
(F-0.5770936965942383
F-3.38206418355306
tp14731
sS'Image.open(picture.jpg)'
p14732
(F-2.8493778228759767
F-3.141224225362142
tp14733
sS'Image.open(picture.jpg)\nImg.show'
p14734
(F-3.3859242030552457
F-3.1779181162516275
tp14735
sS'from PIL import Image'
p14736
(F-1.523103396097819
F-3.5168078740437827
tp14737
sS"img = Image.open('picture.jpg')"
p14738
(F-0.9621089935302735
F-3.214975357055664
tp14739
sS"from PIL import Image\nimg = Image.open('picture.jpg')\nimg.show()"
p14740
(F-0.6531260354178292
F-3.328392664591471
tp14741
sS'if location == a2:\n    pass'
p14742
(F-3.2326465953480112
F-5.38105583190918
tp14743
sS"if location == a2:\n    img = Image.open('picture.jpg')"
p14744
(F-2.2146212259928384
F-3.63653564453125
tp14745
ss.