(dp0
I379906
(dp1
S'int(float(a))'
p2
(F9.10717519124349
F3.248246908187866
tp3
sS'def num(s):\n    pass'
p4
(F9.936227162679037
F3.9018993377685547
tp5
sS'return float(s)'
p6
(F10.598141261509486
F3.36610746383667
tp7
sS'def isfloat(value):\n    pass'
p8
(F9.850573221842447
F3.997361898422241
tp9
sS'float(a)\nint(float(a))'
p10
(F9.995623997279576
F3.296966075897217
tp11
sS"a = '545.2222'\nfloat(a)\nint(float(a))"
p12
(F9.184019300672743
F3.255868434906006
tp13
sS'return True'
p14
(F12.290060997009277
F4.0999250411987305
tp15
sS'float(value)'
p16
(F9.023171742757162
F3.4580044746398926
tp17
sS'float(a)'
p18
(F8.82377815246582
F3.420773506164551
tp19
sS"a = '545.2222'\nfloat(a)"
p20
(F8.09520263671875
F3.3730854988098145
tp21
sS'return int(s)'
p22
(F10.724403381347656
F3.2797112464904785
tp23
sS'return False'
p24
(F12.290060997009277
F4.0999250411987305
tp25
sS"a = '545.2222'"
p26
(F8.047177124023438
F3.752088785171509
tp27
ssI3437059
(dp28
S"if ('blah' not in somestring):\n    pass"
p29
(F9.713060651506696
F3.6796465787020596
tp30
sS"if (s.find('is') == (-1)):\n    pass"
p31
(F7.996073404947917
F3.802087263627486
tp32
sS"if ('blah' not in somestring):\n    continue"
p33
(F9.896462576729911
F3.661113739013672
tp34
sS's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    pass'
p35
(F7.674299297910748
F3.768194718794389
tp36
sS's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p37
(F7.342189564424403
F3.7552954933860083
tp38
sS'print "No \'is\' here!"'
p39
(F8.088695526123047
F3.816634785045277
tp40
sS'continue'
p41
(F9.535104751586914
F3.90353046764027
tp42
sS"s = 'This be a string'\nif (s.find('is') == (-1)):\n    pass"
p43
(F8.154803466796874
F3.7667728770862925
tp44
sS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    print "Found \'is\' in the string."'
p45
(F7.160325113932291
F3.7804031372070312
tp46
sS"s = 'This be a string'"
p47
(F7.182677459716797
F3.7547718394886362
tp48
sS'print "Found \'is\' in the string."'
p49
(F8.088695526123047
F3.816634785045277
tp50
sS's = \'This be a string\'\nif (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"'
p51
(F7.7440056434044475
F3.750801780007102
tp52
sS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"\nelse:\n    pass'
p53
(F7.528212974811423
F3.7953317815607246
tp54
sS'if (s.find(\'is\') == (-1)):\n    print "No \'is\' here!"'
p55
(F7.527266068892046
F3.7842788696289062
tp56
ssI4265988
(dp57
S'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob'
p58
(F12.363912892896076
F3.6980514526367188
tp59
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p60
(F11.712171666762409
F3.8101819356282554
tp61
sS'numpy.random.choice(numpy.arange(1, 7), p=[0.1, 0.05, 0.05, 0.2, 0.4, 0.2])'
p62
(F9.33446063417377
F3.8263959884643555
tp63
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p64
(F12.379808830492424
F3.876588821411133
tp65
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]\nR = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p66
(F11.90210293856534
F3.75555419921875
tp67
sS'cdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]'
p68
(F14.578360892630911
F3.7355257670084634
tp69
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p70
(F12.145417811506885
F3.680375417073568
tp71
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]'
p72
(F6.973142298256478
F3.7874911626180015
tp73
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item\nreturn item'
p74
(F11.964758795660895
F3.817100207010905
tp75
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    pass'
p76
(F12.236757604087272
F3.698880195617676
tp77
sS'return item'
p78
(F14.130115509033203
F4.407072067260742
tp79
sS's = 0\nfor (item, prob) in l:\n    pass'
p80
(F12.036781712582236
F3.8475424448649087
tp81
sS'pdf = [(1, 0.1), (2, 0.05), (3, 0.05), (4, 0.2), (5, 0.4), (6, 0.2)]\ncdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]'
p82
(F10.760551948051948
F3.743989944458008
tp83
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p84
(F11.913790998787716
F3.8595406214396157
tp85
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p86
(F12.007053920200892
F3.6750218073527017
tp87
sS's = 0\nfor (item, prob) in l:\n    s += prob'
p88
(F12.3690185546875
F3.8563410441080728
tp89
sS'for (item, prob) in l:\n    s += prob\nif (s >= r):\n    return item'
p90
(F12.120787556966146
F3.8735020955403647
tp91
sS'if (s >= r):\n    return item'
p92
(F10.27252197265625
F4.001956621805827
tp93
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0'
p94
(F12.133942780671296
F3.7426182428995767
tp95
sS's = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p96
(F11.52143536191998
F3.799936294555664
tp97
sS's += prob'
p98
(F13.471229553222656
F4.282682100931804
tp99
sS'if (s >= r):\n    return item\nreturn item'
p100
(F11.143606746897978
F4.003987630208333
tp101
sS'R = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p102
(F14.247990327722887
F3.7026828130086265
tp103
sS'for (item, prob) in l:\n    pass'
p104
(F12.676242065429687
F3.938309987386068
tp105
sS'r = random.uniform(0, 1)'
p106
(F9.640575408935547
F3.81343142191569
tp107
sS'def random_distr(l):\n    pass'
p108
(F12.721426827566964
F3.7838493982950845
tp109
sS'cdf = [(i, sum((p for (j, p) in pdf if (j < i)))) for (i, _) in pdf]\nR = max((i for r in [random.random()] for (i, c) in cdf if (c <= r)))'
p110
(F14.633794294084822
F3.737964312235514
tp111
sS'def random_distr(l):\n    r = random.uniform(0, 1)\ns = 0\nfor (item, prob) in l:\n    s += prob\nif (s >= r):\n    pass'
p112
(F11.89927978515625
F3.6773929595947266
tp113
sS'for (item, prob) in l:\n    s += prob'
p114
(F13.16841574276195
F3.942153294881185
tp115
sS's = 0'
p116
(F10.653871154785156
F4.198609352111816
tp117
sS'sorted((max((i for r in [random.random()] for (i, c) in cdf if (c <= r))) for _ in range(1000)))'
p118
(F14.87203624636628
F3.8897314071655273
tp119
sS'def random_distr(l):\n    r = random.uniform(0, 1)'
p120
(F11.758440100628397
F3.728219668070475
tp121
sS'if (s >= r):\n    pass'
p122
(F9.50018545297476
F4.026253382364909
tp123
ssI843277
(dp124
S'my_variable = None'
p125
(F15.179223196847099
F1.7354146784002131
tp126
sS'def InitMyVariable():\n    global my_variable\nif (my_variable is None):\n    pass'
p127
(F13.737879435221354
F1.6282794258811257
tp128
sS'my_variable = None\n\ndef InitMyVariable():\n    pass'
p129
(F12.057221984863281
F1.6683458848433061
tp130
sS'def InitMyVariable():\n    global my_variable'
p131
(F12.653989791870117
F1.6737240878018467
tp132
sS'try:\n    myVar\nexcept NameError:\n    myVar = None'
p133
(F11.165566580636161
F1.631513075395064
tp134
sS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable'
p135
(F13.471995478091033
F1.6590780778364702
tp136
sS"if ('myVar' in globals()):\n    pass"
p137
(F8.637876383463542
F1.587184559215199
tp138
sS'myVar = None'
p139
(F15.675702412923178
F1.8027062849564985
tp140
sS'if (my_variable is None):\n    pass'
p141
(F13.216513061523438
F1.6121075370094993
tp142
sS'try:\n    myVar\nexcept NameError:\n    pass'
p143
(F9.647478739420572
F1.6275163130326704
tp144
sS'global my_variable'
p145
(F16.265074412027996
F1.6786103682084517
tp146
sS'def InitMyVariable():\n    pass'
p147
(F10.344393216646635
F1.688798037442294
tp148
sS'myVar'
p149
(F17.010793685913086
F1.7477014715021306
tp150
sS"if ('myVar' in locals()):\n    pass"
p151
(F8.167580159505208
F1.6290135817094282
tp152
sS'my_variable = None\n\ndef InitMyVariable():\n    global my_variable\nif (my_variable is None):\n    pass'
p153
(F14.0716272302576
F1.627085425636985
tp154
sS'pass'
p155
(F9.680909474690756
F1.7259226712313565
tp156
sS"if hasattr(obj, 'attr_name'):\n    pass"
p157
(F7.915383475167411
F1.6160715276544744
tp158
ssI546321
(dp159
S'import datetime'
p160
(F14.7239990234375
F2.9726287841796877
tp161
sS'from datetime import date'
p162
(F18.92188898722331
F2.660370445251465
tp163
sS'print((datetime.date.today() + datetime.timedelta(((6 * 365) / 12)))).isoformat()'
p164
(F10.975640499230588
F2.6876073837280274
tp165
sS'six_months = (date.today() + relativedelta(months=(+ 6)))'
p166
(F10.067503555961277
F2.9510986328125
tp167
sS'(day, month, year) = (day, ((month + 6) % 12), (year + ((month + 6) / 12)))'
p168
(F9.843975170238599
F3.137858581542969
tp169
sS'from datetime import date\nfrom dateutil.relativedelta import relativedelta'
p170
(F17.972608126126804
F2.7811491012573244
tp171
sS'(date(2010, 12, 31) + relativedelta(months=(+ 1)))'
p172
(F8.396372708407315
F3.059250259399414
tp173
sS'(date(2010, 12, 31) + relativedelta(months=(+ 2)))'
p174
(F8.418893987482244
F3.0626983642578125
tp175
sS'date += datetime.timedelta((6 * 30))'
p176
(F10.870985848563057
F2.700043296813965
tp177
sS'from dateutil.relativedelta import relativedelta\nsix_months = (date.today() + relativedelta(months=(+ 6)))'
p178
(F12.356146240234375
F3.1523670196533202
tp179
sS'(date(2010, 12, 31) + relativedelta(months=(+ 1)))\n(date(2010, 12, 31) + relativedelta(months=(+ 2)))'
p180
(F8.587264659792877
F3.061073875427246
tp181
sS'from dateutil.relativedelta import relativedelta'
p182
(F16.009817123413086
F3.4713298797607424
tp183
sS'from datetime import date\nfrom dateutil.relativedelta import relativedelta\nsix_months = (date.today() + relativedelta(months=(+ 6)))'
p184
(F13.376038469587053
F2.8072975158691404
tp185
sS'import datetime\nprint((datetime.date.today() + datetime.timedelta(((6 * 365) / 12)))).isoformat()'
p186
(F11.211909823947483
F2.6464117050170897
tp187
ssI237079
(dp188
S'def modification_date(filename):\n    pass'
p189
(F13.107530866350446
F3.735772959391276
tp190
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p191
(F14.109471130371094
F3.7674352010091146
tp192
sS"if (platform.system() == 'Windows'):\n    pass"
p193
(F9.479639389935661
F3.8652051289876304
tp194
sS'import datetime'
p195
(F15.158063888549805
F3.7682759602864584
tp196
sS"print(('created: %s' % time.ctime(os.path.getctime(file))))"
p197
(F11.965777310458096
F3.7615936279296873
tp198
sS'return datetime.datetime.fromtimestamp(t)'
p199
(F13.541562167080967
F3.768199157714844
tp200
sS'print repr(d)'
p201
(F11.973831176757812
F3.7298906962076823
tp202
sS"d = modification_date('/var/log/syslog')"
p203
(F12.500230407714843
F3.7695460001627605
tp204
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p205
(F13.141014547909007
F3.822004699707031
tp206
sS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p207
(F13.86876781566723
F3.758978525797526
tp208
sS'"\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p209
(F2.8554150263468423
F3.743604532877604
tp210
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p211
(F14.4617041015625
F3.8265716552734377
tp212
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p213
(F15.440302734375
F3.780316162109375
tp214
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p215
(F13.93440055847168
F3.7782567342122397
tp216
sS"print(('last modified: %s' % time.ctime(os.path.getmtime(file))))\nprint(('created: %s' % time.ctime(os.path.getctime(file))))"
p217
(F12.447366403978924
F3.757149251302083
tp218
sS'import os.path, time'
p219
(F17.399906158447266
F3.797953796386719
tp220
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p221
(F14.062085978190105
F3.751109822591146
tp222
sS"print(('last modified: %s' % time.ctime(os.path.getmtime(file))))"
p223
(F11.965777310458096
F3.7615936279296873
tp224
sS'import os, time'
p225
(F16.18356196085612
F3.7794507344563804
tp226
sS'stat = os.stat(path_to_file)'
p227
(F13.884412493024554
F3.768024190266927
tp228
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)"
p229
(F12.932591215093085
F3.7862622578938803
tp230
sS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p231
(F11.186731409143519
F3.7975494384765627
tp232
sS"import os.path, time\nprint(('last modified: %s' % time.ctime(os.path.getmtime(file))))\nprint(('created: %s' % time.ctime(os.path.getctime(file))))"
p233
(F13.2769970703125
F3.7729260762532553
tp234
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p235
(F13.617792497601425
F3.8192621866861978
tp236
sS'import platform\n\ndef creation_date(path_to_file):\n    pass'
p237
(F16.149856567382812
F3.8120956420898438
tp238
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p239
(F13.626082257526678
F3.8312253316243488
tp240
sS'import datetime\n\ndef modification_date(filename):\n    pass'
p241
(F13.102423773871529
F3.7358685811360677
tp242
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p243
(F14.354506782863451
F3.7927406311035154
tp244
sS'try:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p245
(F10.189485029740768
F3.7716761271158856
tp246
sS'import os\nimport datetime'
p247
(F16.05758558000837
F3.7677813212076825
tp248
sS'return stat.st_mtime'
p249
(F13.861644744873047
F3.948405965169271
tp250
sS'def modification_date(filename):\n    t = os.path.getmtime(filename)'
p251
(F13.848868992017662
F3.747650655110677
tp252
sS'(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)'
p253
(F12.55365702311198
F3.81843999226888
tp254
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    pass'
p255
(F16.170177001953125
F3.7856839497884116
tp256
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p257
(F14.02062359978171
F3.805670674641927
tp258
sS'import datetime\n\ndef modification_date(filename):\n    t = os.path.getmtime(filename)'
p259
(F13.771821198640046
F3.7374588012695313
tp260
sS"print(('last modified: %s' % time.ctime(mtime)))"
p261
(F9.17357177734375
F3.759966023763021
tp262
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p263
(F13.076141716452206
F3.7708531697591146
tp264
sS'def creation_date(path_to_file):\n    pass'
p265
(F16.289886474609375
F3.752880350748698
tp266
sS"import os, time\n(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)\nprint(('last modified: %s' % time.ctime(mtime)))"
p267
(F12.444429358657526
F3.7681798299153644
tp268
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p269
(F15.306572808159721
F3.7540311177571613
tp270
sS'return os.path.getctime(path_to_file)'
p271
(F15.441084798177084
F3.771546173095703
tp272
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)"
p273
(F13.038705760035022
F3.809334309895833
tp274
sS'import os'
p275
(F15.434067726135254
F3.776355489095052
tp276
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p277
(F13.302242197888964
F3.7900433858235676
tp278
sS'import platform'
p279
(F16.680692672729492
F3.934826151529948
tp280
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)'
p281
(F14.55272746535967
F3.813615163167318
tp282
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    pass'
p283
(F13.41444236353824
F3.8575121561686196
tp284
sS't = os.path.getmtime(filename)'
p285
(F13.21755599975586
F3.789862569173177
tp286
sS'return stat.st_birthtime'
p287
(F13.861644744873047
F3.948405965169271
tp288
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p289
(F13.470509655070755
F3.7900736490885416
tp290
sS'print d\nprint repr(d)'
p291
(F13.069549560546875
F3.749481455485026
tp292
sS'import os\nimport datetime\n\ndef modification_date(filename):\n    pass'
p293
(F13.630217052641369
F3.744950612386068
tp294
sS'print d'
p295
(F12.944318771362305
F3.7532277425130207
tp296
sS"import os.path, time\nprint(('last modified: %s' % time.ctime(os.path.getmtime(file))))"
p297
(F13.507216881061423
F3.779084014892578
tp298
sS'import os\nimport platform'
p299
(F16.98401859828404
F3.857172139485677
tp300
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass"
p301
(F12.216335521024817
F3.7771985371907553
tp302
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "'
p303
(F15.33583623712713
F3.8070022583007814
tp304
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime"
p305
(F12.468039316673801
F3.770794677734375
tp306
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p307
(F13.411292636517397
F3.785364786783854
tp308
sS"d = modification_date('/var/log/syslog')\nprint d"
p309
(F13.015394944411058
F3.742169952392578
tp310
sS'def creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    return stat.st_mtime'
p311
(F13.212954372829861
F3.7660430908203124
tp312
sS"if (platform.system() == 'Windows'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass"
p313
(F11.992796156141493
F3.803765869140625
tp314
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p315
(F13.293112049932065
F3.788660176595052
tp316
sS'import os, time\n(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)'
p317
(F13.289878627232143
F3.7752863566080728
tp318
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)'
p319
(F14.115869656415052
F3.799302927652995
tp320
sS'import platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    stat = os.stat(path_to_file)\ntry:\n    return stat.st_birthtime\nexcept AttributeError:\n    pass'
p321
(F13.179362436358849
F3.7941253662109373
tp322
sS'import os\nimport platform\n\ndef creation_date(path_to_file):\n    "\\n    Try to get the date that a file was created, falling back to when it was\\n    last modified if that isn\'t possible.\\n    See http://stackoverflow.com/a/39501288/1709587 for explanation.\\n    "\nif (platform.system() == \'Windows\'):\n    return os.path.getctime(path_to_file)\nelse:\n    pass'
p323
(F13.737132771809895
F3.8081270853678384
tp324
sS'def modification_date(filename):\n    t = os.path.getmtime(filename)\nreturn datetime.datetime.fromtimestamp(t)'
p325
(F13.945965391216856
F3.7628100077311197
tp326
sS"(mode, ino, dev, nlink, uid, gid, size, atime, mtime, ctime) = os.stat(file)\nprint(('last modified: %s' % time.ctime(mtime)))"
p327
(F11.959075927734375
F3.7870361328125
tp328
sS"d = modification_date('/var/log/syslog')\nprint d\nprint repr(d)"
p329
(F13.141130146227384
F3.7214678446451823
tp330
ssI6159900
(dp331
S"f.write(('hi there' + os.linesep))\nf.close()"
p332
(F10.587310791015625
F2.479786612770774
tp333
sS"f.write(('hi there' + os.linesep))"
p334
(F10.806398664202009
F2.5279130068692295
tp335
sS"f.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p336
(F9.987267278855846
F2.419228293678977
tp337
sS"with open('somefile.txt', 'a') as the_file:\n    pass"
p338
(F12.008224487304688
F2.40881364995783
tp339
sS'f.close()'
p340
(F8.334080287388392
F2.501867814497514
tp341
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p342
(F9.908482360839844
F2.4344024658203125
tp343
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p344
(F10.457207573784721
F2.4466467770663174
tp345
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p346
(F9.491226196289062
F2.405668258666992
tp347
sS'os.linesep'
p348
(F14.124794006347656
F2.6271403919566763
tp349
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p350
(F9.498770577566964
F2.412596442482688
tp351
sS"f = open('myfile', 'w')"
p352
(F7.149871063232422
F2.33553730357777
tp353
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p354
(F10.755038239235102
F2.453150662508878
tp355
sS"f = open('myfile', 'w')\nf.write('hi there\\n')"
p356
(F8.028221579159007
F2.353965412486683
tp357
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p358
(F10.049173691693474
F2.4414085041392934
tp359
sS"with open('somefile.txt', 'a') as the_file:\n    the_file.write('Hello\\n')"
p360
(F12.464139404296875
F2.371419906616211
tp361
sS"open('myfile', 'rb').read()"
p362
(F7.424864451090495
F2.374452590942383
tp363
sS"os.linesep\nf = open('myfile', 'w')"
p364
(F9.751623971121651
F2.4283821799538354
tp365
sS"f.close()\nopen('myfile', 'rb').read()"
p366
(F8.259713066948784
F2.376631823453036
tp367
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')"
p368
(F10.62294069925944
F2.452219182794744
tp369
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p370
(F10.85913828256968
F2.4630825736305932
tp371
sS"import os\nos.linesep\nf = open('myfile', 'w')"
p372
(F11.194913078756894
F2.5005266016179863
tp373
sS"print('hi there', file=f)"
p374
(F8.906900787353516
F2.584004142067649
tp375
sS"from __future__ import print_function\nprint('hi there', file=f)"
p376
(F14.528146844161185
F2.6916864568536933
tp377
sS'import os'
p378
(F16.189468383789062
F2.6584446646950464
tp379
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.close()"
p380
(F8.243564771569293
F2.362865447998047
tp381
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()"
p382
(F9.544252183702257
F2.403710451993075
tp383
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p384
(F9.98122767398232
F2.4129066467285156
tp385
sS"import os\nos.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p386
(F10.392702455873843
F2.4283653606068003
tp387
sS"f.write('hi there\\n')\nf.close()"
p388
(F9.015505109514509
F2.422645915638317
tp389
sS"f = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p390
(F9.372377436211769
F2.3829661282626065
tp391
sS"the_file.write('Hello\\n')"
p392
(F12.115923309326172
F2.438993800770153
tp393
sS"f.write('hi there\\n')\nf.write(('hi there' + os.linesep))"
p394
(F10.675069173177084
F2.4618419300426138
tp395
sS'from __future__ import print_function'
p396
(F19.423126220703125
F2.7896159778941763
tp397
sS"f.write('hi there\\n')"
p398
(F8.76105785369873
F2.45261643149636
tp399
sS'import os\nos.linesep'
p400
(F16.156158447265625
F2.655762932517312
tp401
sS"os.linesep\nf = open('myfile', 'w')\nf.write('hi there\\n')\nf.write(('hi there' + os.linesep))\nf.close()\nopen('myfile', 'rb').read()"
p402
(F9.636433919270834
F2.41602238741788
tp403
ssI899103
(dp404
S"for item in thelist:\n    thefile.write(('%s\\n' % item))"
p405
(F11.183633422851562
F1.4994799613952636
tp406
sS'pickle.dump(itemlist, outfile)'
p407
(F10.7478515625
F2.048134613037109
tp408
sS'print  >> thefile, item'
p409
(F12.906924656459264
F1.9255537033081054
tp410
sS'itemlist = pickle.load(infile)'
p411
(F11.732677459716797
F1.7504796981811523
tp412
sS'for item in thelist:\n    pass'
p413
(F12.264708085493607
F1.7704631805419921
tp414
sS'import pickle'
p415
(F16.902721405029297
F1.931077766418457
tp416
sS"outfile.write('\\n'.join(itemlist))"
p417
(F10.122950627253605
F1.7186038970947266
tp418
sS'for item in thelist:\n    print  >> thefile, item'
p419
(F12.104983520507812
F1.8149215698242187
tp420
sS"thefile.write(('%s\\n' % item))"
p421
(F9.372726440429688
F1.6768260955810548
tp422
sS'import pickle\npickle.dump(itemlist, outfile)'
p423
(F12.627042330228365
F1.96763916015625
tp424
ssI3939361
(dp425
S"string = 'ab1cd1ef'"
p426
(F7.5574897766113285
F1.4999429702758789
tp427
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p428
(F11.069234540385585
F1.3349554061889648
tp429
sS"line = 'abc#@!?efg12;:?'"
p430
(F8.05179443359375
F1.7080770492553712
tp431
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p432
(F10.899163382393974
F1.3309260368347169
tp433
sS"string.replace('1', '')"
p434
(F7.750155639648438
F1.3448734283447266
tp435
sS"b = '!@#$'"
p436
(F8.116868591308593
F1.7962989807128906
tp437
sS"a = 'a!b@c#d$'"
p438
(F8.077119445800781
F1.75062255859375
tp439
sS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)"
p440
(F11.74043836091694
F1.9598003387451173
tp441
sS"''.join((c for c in line if (c not in '?:!/;')))"
p442
(F14.427638462611608
F1.414405059814453
tp443
sS"b = '!@#$'\nfor char in b:\n    pass"
p444
(F11.508536783854167
F1.3683601379394532
tp445
sS"import string\nline = line.translate(string.maketrans('', ''), '!@#$')"
p446
(F10.703326832164418
F1.3858007431030273
tp447
sS"for char in b:\n    a = a.replace(char, '')\nprint a"
p448
(F12.285426927649457
F1.3575210571289062
tp449
sS'import re'
p450
(F15.280088424682617
F1.423835563659668
tp451
sS"line = line.translate(string.maketrans('', ''), '!@#$')"
p452
(F9.37919697008635
F1.4025022506713867
tp453
sS"import re\nline = re.sub('[!@#$]', '', line)"
p454
(F10.186106962316176
F1.4115317344665528
tp455
sS"a = 'a!b@c#d$'\nb = '!@#$'\nfor char in b:\n    pass"
p456
(F10.533491435803866
F1.379053783416748
tp457
sS'print a'
p458
(F11.448930740356445
F1.7332317352294921
tp459
sS"string = 'ab1cd1ef'\nstring.replace('1', '')"
p460
(F8.253560202462333
F1.3546996116638184
tp461
sS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')"
p462
(F11.561203002929688
F1.3304893493652343
tp463
sS'import string'
p464
(F15.734115600585938
F1.6123470306396483
tp465
sS"translation_table = dict.fromkeys(map(ord, '!@#$'), None)\nunicode_line = unicode_line.translate(translation_table)"
p466
(F14.493095846737132
F1.7425664901733398
tp467
sS'for char in b:\n    pass'
p468
(F12.642822265625
F1.4468581199645996
tp469
sS"line = 'abc#@!?efg12;:?'\n''.join((c for c in line if (c not in '?:!/;')))"
p470
(F13.7963232421875
F1.4091517448425293
tp471
sS"line = re.sub('[!@#$]', '', line)"
p472
(F9.06718499319894
F1.417105484008789
tp473
sS"for char in b:\n    a = a.replace(char, '')"
p474
(F12.165745544433594
F1.3464216232299804
tp475
sS"b = '!@#$'\nfor char in b:\n    a = a.replace(char, '')\nprint a"
p476
(F11.686186613859954
F1.3361015319824219
tp477
sS"unicode_line = unicode_line.translate({ord(c): None for c in '!@#$'})"
p478
(F13.9234326171875
F1.4301830291748048
tp479
sS'unicode_line = unicode_line.translate(translation_table)'
p480
(F15.216944694519043
F1.5461133003234864
tp481
sS"a = 'a!b@c#d$'\nb = '!@#$'"
p482
(F7.9985504150390625
F1.7399946212768556
tp483
sS"a = a.replace(char, '')"
p484
(F10.353317260742188
F1.3741938591003418
tp485
sS"line = line.translate(None, '!@#$')"
p486
(F9.254192988077799
F1.3950197219848632
tp487
ssI9001509
(dp488
S"for key in sorted(mydict):\n    print(('%s: %s' % (key, mydict[key])))"
p489
(F10.296102251325335
F1.8139190673828125
tp490
sS'od[1]\nod[3]\nfor (k, v) in od.iteritems():\n    pass'
p491
(F10.079682448814655
F2.11303052035245
tp492
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))"
p493
(F10.718164688501602
F1.7361547296697444
tp494
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))'
p495
(F8.776227119641426
F1.844242962923917
tp496
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }"
p497
(F8.749448503766741
F1.9497046037153765
tp498
sS'print k, v'
p499
(F12.108966827392578
F2.4289295890114526
tp500
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))"
p501
(F8.841602081948139
F1.7734149586070667
tp502
sS'od[1]\nod[3]\nfor (k, v) in od.iteritems():\n    print k, v'
p503
(F10.235519409179688
F2.0862034884366123
tp504
sS'for key in sorted(mydict):\n    pass'
p505
(F11.992843627929688
F1.8162002563476562
tp506
sS'for (k, v) in od.items():\n    print(k, v)'
p507
(F10.937456766764322
F2.0243169611150567
tp508
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }'
p509
(F6.546761946244673
F2.1321223865855825
tp510
sS'od[3]\nfor (k, v) in od.iteritems():\n    print k, v'
p511
(F10.90911865234375
F2.0924751975319604
tp512
sS'print(k, v)'
p513
(F9.31068229675293
F2.399248816750266
tp514
sS'for key in keylist:\n    pass'
p515
(F11.571198896928268
F2.177763332020153
tp516
sS'keylist.sort()\nfor key in keylist:\n    pass'
p517
(F12.033173504997702
F1.7261850183660334
tp518
sS'keylist = mydict.keys()\nkeylist.sort()'
p519
(F10.221061197916667
F1.8022355166348545
tp520
sS"keylist.sort()\nfor key in keylist:\n    print(('%s: %s' % (key, mydict[key])))"
p521
(F10.60421654485887
F1.7591635964133523
tp522
sS'keylist = mydict.keys()'
p523
(F9.122360229492188
F2.3624836314808237
tp524
sS'od[1]\nod[3]'
p525
(F7.349828546697443
F2.228636308149858
tp526
sS'od = collections.OrderedDict(sorted(d.items()))\nod'
p527
(F11.658661651611329
F1.7729563279585405
tp528
sS'from __future__ import print_function\nfor (k, v) in od.items():\n    print(k, v)'
p529
(F13.622952547940342
F2.297669670798562
tp530
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p531
(F11.899080300632912
F1.7198517539284446
tp532
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))'
p533
(F9.410432361421131
F1.7818898287686435
tp534
sS"print(('%s: %s' % (key, mydict[key])))"
p535
(F8.873810712028952
F2.0960955186323686
tp536
sS'OrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p537
(F11.932133115571121
F1.7301247336647727
tp538
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))'
p539
(F11.944011546947339
F1.7180453213778408
tp540
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))"
p541
(F10.45070556640625
F1.7335565740411931
tp542
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))"
p543
(F9.812320285373264
F1.7372332486239346
tp544
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[1])))'
p545
(F11.461212158203125
F1.7158782265403054
tp546
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }"
p547
(F6.086631774902344
F2.2226715087890625
tp548
sS"for key in keylist:\n    print(('%s: %s' % (key, mydict[key])))"
p549
(F9.866018676757813
F2.011117761785334
tp550
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))'
p551
(F11.459852952223558
F1.7254711497913708
tp552
sS'for (k, v) in od.items():\n    pass'
p553
(F11.643119410464639
F2.0314452431418677
tp554
sS'keylist = mydict.keys()\nkeylist.sort()\nfor key in keylist:\n    pass'
p555
(F11.3388671875
F1.7831486788662998
tp556
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))"
p557
(F10.117620504127359
F1.7630374214865945
tp558
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }\nfor key in sorted(mydict):\n    pass"
p559
(F8.662134660993303
F1.8675602999600498
tp560
sS'OrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))'
p561
(F11.651500028722426
F1.7114545648748225
tp562
sS"from collections import OrderedDict\nd = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }\nOrderedDict(sorted(d.items(), key=(lambda t: t[0])))\nOrderedDict(sorted(d.items(), key=(lambda t: t[1])))\nOrderedDict(sorted(d.items(), key=(lambda t: len(t[0]))))"
p563
(F11.191172473835495
F1.7349231026389382
tp564
sS"keylist = mydict.keys()\nkeylist.sort()\nfor key in keylist:\n    print(('%s: %s' % (key, mydict[key])))"
p565
(F10.520387307191507
F1.7728105024857954
tp566
sS'od[3]\nfor (k, v) in od.iteritems():\n    pass'
p567
(F10.81961186726888
F2.125624743374911
tp568
sS'od[3]'
p569
(F8.00117047627767
F2.270979794588956
tp570
sS'from collections import OrderedDict'
p571
(F18.850755964006698
F2.0077261491255327
tp572
sS'od = collections.OrderedDict(sorted(d.items()))'
p573
(F11.305452134874132
F1.7543733770197087
tp574
sS'keylist.sort()'
p575
(F10.2860107421875
F1.6719675931063565
tp576
sS"d = {'banana': 3, 'apple': 4, 'pear': 1, 'orange': 2, }"
p577
(F5.843095259232954
F2.0945382551713423
tp578
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))\nod'
p579
(F9.562889792702414
F1.7859621914950283
tp580
sS'od'
p581
(F12.896255493164062
F2.6443634033203125
tp582
sS'for (k, v) in od.iteritems():\n    print k, v'
p583
(F11.430056485262783
F2.1832440116188745
tp584
sS'from __future__ import print_function'
p585
(F19.416802978515626
F2.8372684825550425
tp586
sS'od[1]'
p587
(F8.057275772094727
F2.259468425403942
tp588
sS"mydict = {'carl': 40, 'alan': 2, 'bob': 1, 'danny': 3, }\nfor key in sorted(mydict):\n    print(('%s: %s' % (key, mydict[key])))"
p589
(F8.629460548867984
F1.8525862260298296
tp590
sS'for (k, v) in od.iteritems():\n    pass'
p591
(F11.408409520199424
F2.230425227772106
tp592
sS'import collections\nd = {2: 3, 1: 89, 4: 5, 3: 0, }'
p593
(F7.695758666992187
F1.8574905395507812
tp594
sS'd = {2: 3, 1: 89, 4: 5, 3: 0, }\nod = collections.OrderedDict(sorted(d.items()))\nod'
p595
(F8.9785610292016
F1.8517736955122515
tp596
sS'import collections'
p597
(F16.5529727935791
F1.904570839621804
tp598
sS'from __future__ import print_function\nfor (k, v) in od.items():\n    pass'
p599
(F14.611861092703682
F2.361250790682706
tp600
ssI2990121
(dp601
S'for i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p602
(F10.942490521599264
F1.8637127509483924
tp603
sS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p604
(F11.501280351118607
F1.8739329117995043
tp605
sS'return izip_longest(fillvalue=fillvalue, *args)'
p606
(F11.741209847586495
F1.8505023075984075
tp607
sS'for (item1, item2) in grouper(2, l):\n    pass'
p608
(F11.74739990234375
F1.8260842836820161
tp609
sS'"grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p610
(F4.595794677734375
F2.047011008629432
tp611
sS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)'
p612
(F10.712429908014112
F1.877081064077524
tp613
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]'
p614
(F5.60434326171875
F1.8867476536677434
tp615
sS'print i,'
p616
(F11.861042785644532
F1.9451571244459887
tp617
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p618
(F13.648422241210938
F1.777827189518855
tp619
sS'from __future__ import print_function\nfor i in range(0, 10, 2):\n    print(i)'
p620
(F13.211846923828125
F1.908531482403095
tp621
sS'for i in xrange(0, 10, 2):\n    pass'
p622
(F10.231847127278646
F1.8557727520282452
tp623
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    print i,'
p624
(F8.984188842773438
F1.8939320490910456
tp625
sS'for i in mylist[::2]:\n    print i,'
p626
(F10.4091796875
F1.87236448434683
tp627
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    pass'
p628
(F7.733197784423828
F1.8861095721905048
tp629
sS'for i in mylist[1::2]:\n    pass'
p630
(F10.767708273494945
F1.849318577693059
tp631
sS'for i in range(0, 10, 2):\n    print(i)'
p632
(F9.996455601283483
F1.8786585881159856
tp633
sS'def grouper(n, iterable, fillvalue=None):\n    pass'
p634
(F11.894180297851562
F1.9089745741624098
tp635
sS'for i in mylist[::2]:\n    pass'
p636
(F10.378837585449219
F1.857625227708083
tp637
sS'pass'
p638
(F10.39926020304362
F2.075015288132888
tp639
sS'print(i)'
p640
(F8.604185104370117
F1.929373521071214
tp641
sS'for i in mylist[1::2]:\n    print i,'
p642
(F10.759606612356086
F1.8629103440504808
tp643
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    pass'
p644
(F8.9070992305361
F1.8939241262582631
tp645
sS'from itertools import izip_longest'
p646
(F19.76470184326172
F1.7948109553410456
tp647
sS'mylist = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\nfor i in mylist[::2]:\n    print i,'
p648
(F7.918519519624256
F1.8880929213303785
tp649
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    pass'
p650
(F14.341877863957333
F1.7712675241323619
tp651
sS'def grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"'
p652
(F10.970706515842014
F1.8985179020808294
tp653
sS'from __future__ import print_function\nfor i in xrange(0, 10, 2):\n    pass'
p654
(F13.798702663845486
F1.9028685643122747
tp655
sS'from __future__ import print_function\nfor i in xrange(0, 10, 2):\n    print(i)'
p656
(F13.114548746744791
F1.9051148341252253
tp657
sS'args = ([iter(iterable)] * n)'
p658
(F9.526610238211495
F1.8455807612492487
tp659
sS'for i in xrange(0, 10, 2):\n    print(i)'
p660
(F9.814538864862351
F1.8697367448073168
tp661
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p662
(F12.792487511268028
F1.7905776684100811
tp663
sS'from __future__ import print_function'
p664
(F19.29599609375
F1.9922818403977613
tp665
sS'from __future__ import print_function\nfor i in range(0, 10, 2):\n    pass'
p666
(F13.878379539207176
F1.9069921053372896
tp667
sS'for i in mylist[::2]:\n    print i,\nfor i in mylist[1::2]:\n    print i,'
p668
(F10.937218560112846
F1.8685233776385968
tp669
sS'from itertools import izip_longest\n\ndef grouper(n, iterable, fillvalue=None):\n    "grouper(3, \'ABCDEFG\', \'x\') --> ABC DEF Gxx"\nargs = ([iter(iterable)] * n)'
p670
(F12.58313457782452
F1.781595963698167
tp671
sS'args = ([iter(iterable)] * n)\nreturn izip_longest(fillvalue=fillvalue, *args)'
p672
(F11.376493100766782
F1.8623469426081731
tp673
sS'for i in range(0, 10, 2):\n    pass'
p674
(F10.394357469346788
F1.8667693504920373
tp675
ssI26443308
(dp676
S"'abcd}def}'.rfind('}')"
p677
(F6.701115608215332
F3.177132225036621
tp678
ssI4174941
(dp679
S'l.sort(key=(lambda x: x[2]))'
p680
(F11.549719916449654
F1.8812010023328993
tp681
sS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p682
(F8.139021710651678
F1.9489546881781683
tp683
sS'sorted(l, key=(lambda x: x[2]))'
p684
(F10.784366183810764
F1.888577143351237
tp685
sS"L = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p686
(F6.833009390995421
F2.034340116712782
tp687
sS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p688
(F9.183644911822151
F2.049638960096571
tp689
sS"from operator import itemgetter\nL = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nsorted(L, key=itemgetter(2))"
p690
(F9.743980076002037
F1.9339779747856989
tp691
sS'sorted_list = sorted(list_to_sort, key=itemgetter(2, 0, 1))'
p692
(F13.781671142578125
F1.9402991400824652
tp693
sS'from operator import itemgetter'
p694
(F19.735361735026043
F2.561753590901693
tp695
sS'sorted(L, key=itemgetter(2))'
p696
(F10.813042273888222
F1.9467252095540364
tp697
sS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]"
p698
(F6.397967108364763
F2.01220703125
tp699
sS"l = [[0, 1, 'f'], [4, 2, 't'], [9, 4, 'afsd']]\nl.sort(key=(lambda x: x[2]))"
p700
(F8.476880944293478
F1.9127345614963107
tp701
ssI3207219
(dp702
S"os.listdir('somedirectory')"
p703
(F9.989998817443848
F2.1345976193745932
tp704
sS'onlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p705
(F13.083604176839193
F2.402003606160482
tp706
sS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = (q + w)\nq'
p707
(F9.472089213709678
F2.543290138244629
tp708
sS"print glob.glob('/home/adam/*.txt')"
p709
(F10.995912339952257
F2.1556544303894043
tp710
sS"import os\nos.listdir('somedirectory')"
p711
(F11.89092323996804
F2.0976096789042153
tp712
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p713
(F11.99365234375
F2.4674744606018066
tp714
sS'q = (q + w)\nq'
p715
(F13.324912331321023
F2.5910253524780273
tp716
sS'from os.path import isfile, join'
p717
(F18.39836730957031
F2.188081741333008
tp718
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p719
(F13.566245414115286
F1.9112504323323567
tp720
sS'from os import listdir'
p721
(F20.200753529866535
F2.1928277015686035
tp722
sS'from os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p723
(F14.731822620738637
F1.9334815343221028
tp724
sS'w = [4, 5, 6]'
p725
(F8.15675076571378
F2.5035130182902017
tp726
sS'from os import walk'
p727
(F20.270100911458332
F2.2176570892333984
tp728
sS'q = (q + w)'
p729
(F11.479685465494791
F2.603888670603434
tp730
sS"import glob\nprint glob.glob('/home/adam/*.txt')"
p731
(F12.697625478108725
F2.109206199645996
tp732
sS'from os import listdir\nfrom os.path import isfile, join'
p733
(F19.162884521484376
F2.1199262936909995
tp734
sS'w = [4, 5, 6]\nq = (q + w)\nq'
p735
(F10.533678327287946
F2.5627946853637695
tp736
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p737
(F12.340450032552083
F2.396888097127279
tp738
sS'q = [1, 2, 3]\nw = [4, 5, 6]'
p739
(F8.027788434709821
F2.5022284189860025
tp740
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p741
(F13.25017578125
F2.208648999532064
tp742
sS'break'
p743
(F11.673014322916666
F2.534646193186442
tp744
sS'import os'
p745
(F15.849788665771484
F2.26094659169515
tp746
sS'f = []'
p747
(F6.070889155069987
F2.472759564717611
tp748
sS'f = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p749
(F12.568130493164062
F2.3935025533040366
tp750
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)\nbreak'
p751
(F13.466794614438657
F2.217944939931234
tp752
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p753
(F13.368393961588541
F1.9611759185791016
tp754
sS'from os import listdir\nfrom os.path import isfile, join\nonlyfiles = [f for f in listdir(mypath) if isfile(join(mypath, f))]'
p755
(F15.525800203022204
F1.9082549413045247
tp756
sS'for (dirpath, dirnames, filenames) in walk(mypath):\n    pass'
p757
(F12.984906005859376
F2.3283583323160806
tp758
sS'f.extend(filenames)'
p759
(F11.7326078414917
F2.417758305867513
tp760
sS'q'
p761
(F16.124317169189453
F2.5964404741923013
tp762
sS'from os import walk\nf = []'
p763
(F13.312924471768467
F2.1182525952657065
tp764
sS'w = [4, 5, 6]\nq = (q + w)'
p765
(F9.60039640727796
F2.553467114766439
tp766
sS'q = [1, 2, 3]'
p767
(F7.51919208873402
F2.544898192087809
tp768
sS'import glob'
p769
(F16.68059730529785
F2.234022299448649
tp770
sS'from os import walk\nf = []\nfor (dirpath, dirnames, filenames) in walk(mypath):\n    f.extend(filenames)'
p771
(F13.45600847516741
F1.900436560312907
tp772
sS'q = [1, 2, 3]\nw = [4, 5, 6]\nq = (q + w)'
p773
(F8.830536941002155
F2.5398613611857095
tp774
ssI2972212
(dp775
sI3964681
(dp776
S"import glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p777
(F12.634317670549665
F3.059674483079177
tp778
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    pass"
p779
(F13.241365966796875
F3.0668760446401744
tp780
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p781
(F13.358875621448863
F3.044759016770583
tp782
sS'import glob, os'
p783
(F16.862889607747395
F3.291702857384315
tp784
sS"if file.endswith('.txt'):\n    print(file)"
p785
(F8.965182136086856
F3.3566067035381613
tp786
sS"os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    print(file)"
p787
(F11.226285494290865
F3.0628189673790565
tp788
sS"for file in os.listdir('/mydir'):\n    pass"
p789
(F12.172754287719727
F3.107934805063101
tp790
sS"for file in glob.glob('*.txt'):\n    pass"
p791
(F11.884870529174805
F3.130171849177434
tp792
sS"import glob\nglob.glob('./*.txt')"
p793
(F11.841272527521307
F3.136687938983624
tp794
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            print(os.path.join(root, file))"
p795
(F12.748974391392299
F3.041809375469501
tp796
sS'from __future__ import print_function\nimport glob, os'
p797
(F19.576617431640624
F3.4923761807955227
tp798
sS'print(os.path.join(root, file))'
p799
(F12.917578125
F3.356226994441106
tp800
sS"os.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p801
(F11.592115319293478
F3.072466630202073
tp802
sS"from __future__ import print_function\nimport os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            print(os.path.join(root, file))"
p803
(F13.906122295673077
F3.0394680316631613
tp804
sS"for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        print(file)"
p805
(F10.58416035970052
F3.074329376220703
tp806
sS"from __future__ import print_function\nimport os\nfor (root, dirs, files) in os.walk('/mydir'):\n    pass"
p807
(F15.321303423713236
F3.090530982384315
tp808
sS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p809
(F11.941180717654344
F3.048240955059345
tp810
sS"import os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        print(file)"
p811
(F11.054349032315342
F3.0631942749023438
tp812
sS"from __future__ import print_function\nimport os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p813
(F13.512360401642628
F3.1015425461989183
tp814
sS"from __future__ import print_function\nimport glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    print(file)"
p815
(F14.277854919433594
F3.0698946439302883
tp816
sS'for file in files:\n    pass'
p817
(F12.661093971946023
F3.2521558908315806
tp818
sS"for file in files:\n    if file.endswith('.txt'):\n        print(os.path.join(root, file))"
p819
(F12.0304152544807
F3.1934650127704325
tp820
sS"if file.endswith('.txt'):\n    print(os.path.join(root, file))"
p821
(F11.40497060922476
F3.295947735126202
tp822
sS"import os\nfor file in os.listdir('/mydir'):\n    pass"
p823
(F12.738954242907072
F3.0961632361778846
tp824
sS"for (root, dirs, files) in os.walk('/mydir'):\n    pass"
p825
(F12.90560496937145
F3.0836926973783054
tp826
sS"from __future__ import print_function\nimport os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p827
(F13.729774331146816
F3.04151358971229
tp828
sS"for file in files:\n    if file.endswith('.txt'):\n        pass"
p829
(F10.7052959095348
F3.213641826923077
tp830
sS"import os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            pass"
p831
(F12.228313099254262
F3.041492462158203
tp832
sS'import os'
p833
(F15.730100631713867
F3.428325653076172
tp834
sS"for file in glob.glob('*.txt'):\n    print(file)"
p835
(F11.33315718801398
F3.1402954688439
tp836
sS"os.chdir('/mydir')"
p837
(F9.414050102233887
F3.456493084247296
tp838
sS"from __future__ import print_function\nimport glob, os\nos.chdir('/mydir')"
p839
(F16.3761249889027
F3.372680370624249
tp840
sS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        if file.endswith('.txt'):\n            print(os.path.join(root, file))"
p841
(F12.568646125073704
F3.0473462618314304
tp842
sS"from __future__ import print_function\nimport os\nfor (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p843
(F15.000956217447916
F3.046465066763071
tp844
sS'from __future__ import print_function\nimport os'
p845
(F19.403671264648438
F3.600916935847356
tp846
sS"if file.endswith('.txt'):\n    pass"
p847
(F8.900013514927455
F3.3607855576735277
tp848
sS"from __future__ import print_function\nimport glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    pass"
p849
(F14.774879249366554
F3.0845894446739783
tp850
sS"for file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p851
(F10.664128056278935
F3.0899379436786356
tp852
sS"glob.glob('./*.txt')"
p853
(F9.66258430480957
F3.265482095571665
tp854
sS'from __future__ import print_function'
p855
(F19.42170867919922
F3.8077457134540262
tp856
sS"import os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        pass"
p857
(F11.185750325520834
F3.076427166278546
tp858
sS"from __future__ import print_function\nimport os\nfor file in os.listdir('/mydir'):\n    pass"
p859
(F15.47305188860212
F3.1356236384465146
tp860
sS'import glob'
p861
(F16.618173599243164
F3.3427214989295373
tp862
sS'print(file)'
p863
(F9.120792388916016
F3.5491415170522838
tp864
sS"import glob, os\nos.chdir('/mydir')\nfor file in glob.glob('*.txt'):\n    print(file)"
p865
(F12.232602027154737
F3.049714601956881
tp866
sS"import glob, os\nos.chdir('/mydir')"
p867
(F12.561967116135817
F3.2667925908015323
tp868
sS"from __future__ import print_function\nimport os\nfor file in os.listdir('/mydir'):\n    if file.endswith('.txt'):\n        print(file)"
p869
(F13.21643793015253
F3.0870106036846456
tp870
sS"for (root, dirs, files) in os.walk('/mydir'):\n    for file in files:\n        pass"
p871
(F13.069115193684896
F3.0578431349534254
tp872
ssI1514553
(dp873
S'f = []\nfor i in range(30):\n    pass'
p874
(F10.063772904245477
F1.5461148262023925
tp875
sS'for i in range(30):\n    f.append(0)'
p876
(F10.95193079898232
F1.5732485771179199
tp877
sS'for i in range(30):\n    pass'
p878
(F10.972576686314174
F1.613068199157715
tp879
sS'f = []\nfor i in range(30):\n    f.append(0)'
p880
(F10.053018569946289
F1.5251066207885742
tp881
sS'f = []'
p882
(F5.502979914347331
F1.540765380859375
tp883
sS'from array import array'
p884
(F19.48140589396159
F1.516319465637207
tp885
sS'variable = []'
p886
(F7.203776041666667
F1.5821124076843263
tp887
sS"from array import array\nintarray = array('i')"
p888
(F12.81948735163762
F1.526365089416504
tp889
sS"intarray = array('i')"
p890
(F7.463484287261963
F1.564844799041748
tp891
sS'f.append(0)'
p892
(F9.005776405334473
F1.6597417831420898
tp893
ssI2612802
(dp894
S"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p895
(F11.381609962100075
F3.373701477050781
tp896
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p897
(F11.996136359448704
F3.294988250732422
tp898
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p899
(F11.901939978966347
F3.3791500091552735
tp900
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p901
(F11.310177319670377
F3.269790267944336
tp902
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p903
(F12.401167674731182
F3.378977966308594
tp904
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p905
(F10.955960633324795
F3.3009971618652343
tp906
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p907
(F12.11743694802989
F3.349397659301758
tp908
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p909
(F12.55820094273743
F3.348937225341797
tp910
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p911
(F10.884138743082682
F3.2955432891845704
tp912
sS"a = ['foo', foo]"
p913
(F7.333309597439236
F3.1594127655029296
tp914
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p915
(F12.245621337890626
F3.2874290466308596
tp916
sS't = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p917
(F13.767733666204638
F3.3300537109375
tp918
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p919
(F12.242998543432204
F3.4069358825683596
tp920
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p921
(F11.88068807190953
F3.2921524047851562
tp922
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p923
(F12.265601848733835
F3.335912322998047
tp924
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p925
(F12.290414451656485
F3.3454795837402345
tp926
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p927
(F12.336688156444502
F3.4154876708984374
tp928
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p929
(F12.251862010316986
F3.3182937622070314
tp930
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p931
(F12.580908990675404
F3.3033084869384766
tp932
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p933
(F12.346028172692588
F3.3070987701416015
tp934
sS"\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p935
(F12.164856430171996
F3.274995803833008
tp936
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p937
(F12.270611056047885
F3.3294559478759767
tp938
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p939
(F12.995645274286685
F3.3180641174316405
tp940
sS'if (t == tuple):\n    pass'
p941
(F9.368892963115986
F3.3034893035888673
tp942
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p943
(F12.33127243454392
F3.3553714752197266
tp944
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p945
(F12.28893506002566
F3.3403648376464843
tp946
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p947
(F12.466951715866191
F3.3230239868164064
tp948
sS'if (t == tuple):\n    is_tuple = True'
p949
(F11.540731991038603
F3.2764816284179688
tp950
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p951
(F12.16834684902019
F3.3172382354736327
tp952
sS"print 'Custom Copy:', (time() - t)\nt = time()"
p953
(F9.443826463487413
F3.4363166809082033
tp954
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p955
(F12.471648857455206
F3.331502151489258
tp956
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p957
(F12.56495584467406
F3.39879150390625
tp958
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p959
(F10.307087824894833
F3.3047760009765623
tp960
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p961
(F12.367240905761719
F3.3210369110107423
tp962
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p963
(F12.456699656016792
F3.3099811553955076
tp964
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000"
p965
(F13.905296043113426
F3.3089473724365233
tp966
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p967
(F12.243935977711397
F3.348685455322266
tp968
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p969
(F12.548147583007813
F3.3353107452392576
tp970
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p971
(F12.496780960648149
F3.339030456542969
tp972
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p973
(F12.120874146121231
F3.3692092895507812
tp974
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p975
(F11.981053207859848
F3.40323486328125
tp976
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p977
(F12.733569729712702
F3.3384647369384766
tp978
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p979
(F12.520728701636905
F3.292545700073242
tp980
sS"print 'Custom Copy:', (time() - t)"
p981
(F9.017016728719076
F3.433888244628906
tp982
sS'class old_class:\n\n    def __init__(self):\n        pass'
p983
(F13.865144149116848
F3.4035274505615236
tp984
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p985
(F12.018590735109061
F3.317369079589844
tp986
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p987
(F12.717104783698694
F3.3482337951660157
tp988
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p989
(F11.332771994850852
F3.301500701904297
tp990
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p991
(F12.366801234654018
F3.3405075073242188
tp992
sS'from __future__ import print_function'
p993
(F18.849911499023438
F3.4354198455810545
tp994
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p995
(F12.31776266875944
F3.344796371459961
tp996
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p997
(F12.153916676839193
F3.359588623046875
tp998
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p999
(F12.143377774003623
F3.3038814544677733
tp1000
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1001
(F12.141852170426324
F3.379860687255859
tp1002
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1003
(F12.104865579044118
F3.305573272705078
tp1004
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1005
(F12.265763519503546
F3.3725791931152345
tp1006
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1007
(F12.031995753786262
F3.3387119293212892
tp1008
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1009
(F10.301298079952117
F3.297926330566406
tp1010
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1011
(F12.509535845588236
F3.288325881958008
tp1012
sS"print 'list append:', (time() - t)\nt = time()"
p1013
(F9.443826463487413
F3.4363166809082033
tp1014
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1015
(F12.25201521248653
F3.350236511230469
tp1016
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1017
(F12.572574013157896
F3.388739013671875
tp1018
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1019
(F11.595442199707032
F3.299341583251953
tp1020
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1021
(F10.992783118938577
F3.2974174499511717
tp1022
sS"for i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1023
(F12.825669399527616
F3.292095184326172
tp1024
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1025
(F12.587644466683884
F3.355549621582031
tp1026
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1027
(F12.349128723144531
F3.4285736083984375
tp1028
sS"a.append('baz')\nfoo.val = 5"
p1029
(F10.788055419921875
F3.278199005126953
tp1030
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1031
(F12.296027981505102
F3.3488239288330077
tp1032
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1033
(F12.45559550910596
F3.407468795776367
tp1034
sS'pass'
p1035
(F9.824727376302084
F3.4873409271240234
tp1036
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1037
(F12.608894006529852
F3.3793827056884767
tp1038
sS'copy.copy(L)'
p1039
(F10.82553482055664
F3.253580093383789
tp1040
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1041
(F12.497667814555921
F3.3888229370117187
tp1042
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1043
(F12.563853388247283
F3.3182140350341798
tp1044
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p1045
(F12.838321864047897
F3.3132259368896486
tp1046
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1047
(F12.636520086550245
F3.3271549224853514
tp1048
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1049
(F12.49564453125
F3.38306884765625
tp1050
sS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1051
(F11.62638523267663
F3.2939922332763674
tp1052
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass'
p1053
(F12.248763084411621
F3.378546142578125
tp1054
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass'
p1055
(F12.539163442758413
F3.319676971435547
tp1056
sS'if is_tuple:\n    pass'
p1057
(F11.942381425337357
F3.2823261260986327
tp1058
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1059
(F12.663520280704942
F3.434156799316406
tp1060
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1061
(F12.042479719852377
F3.385504150390625
tp1062
sS"return obj\nif (__name__ == '__main__'):\n    import copy"
p1063
(F12.943001195004111
F3.3484405517578124
tp1064
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1065
(F12.563037448459202
F3.3125782012939453
tp1066
sS"return obj\nif (__name__ == '__main__'):\n    pass"
p1067
(F11.675408257378471
F3.3836273193359374
tp1068
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1069
(F12.155048370361328
F3.3072669982910154
tp1070
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1071
(F10.735078568892046
F3.3084217071533204
tp1072
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1073
(F11.978487744743441
F3.4062294006347655
tp1074
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1075
(F11.992472330729166
F3.2871227264404297
tp1076
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1077
(F12.101263552295919
F3.318048095703125
tp1078
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1079
(F12.337490322353604
F3.346761703491211
tp1080
sS"from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p1081
(F13.242873566060126
F3.3612709045410156
tp1082
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1083
(F11.811674419202303
F3.2774188995361326
tp1084
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1085
(F12.26368408203125
F3.314391326904297
tp1086
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1087
(F11.848165562090356
F3.3025856018066406
tp1088
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1089
(F12.267574869791666
F3.368998718261719
tp1090
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1091
(F12.448387036483254
F3.356927490234375
tp1092
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1093
(F12.367332917093579
F3.369862747192383
tp1094
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1095
(F12.423582884642455
F3.358960723876953
tp1096
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1097
(F11.209658358959441
F3.3970973968505858
tp1098
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p1099
(F12.943408421107701
F3.224832534790039
tp1100
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1101
(F11.730958276865433
F3.392566680908203
tp1102
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1103
(F12.326048219358766
F3.36591796875
tp1104
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1105
(F11.325123408069349
F3.303470230102539
tp1106
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1107
(F12.03783916226394
F3.339396667480469
tp1108
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1109
(F12.43518352508545
F3.2568164825439454
tp1110
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p1111
(F12.454766845703125
F3.385457229614258
tp1112
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p1113
(F8.708092222822474
F3.3010353088378905
tp1114
sS"print 'list expression(L):', (time() - t)\nt = time()"
p1115
(F9.443826463487413
F3.4363166809082033
tp1116
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1117
(F12.21763888272372
F3.342079925537109
tp1118
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1119
(F12.401527806332236
F3.3515598297119142
tp1120
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1121
(F10.184873999618903
F3.294635772705078
tp1122
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1123
(F11.927715879498106
F3.318111801147461
tp1124
sS't = time()\nfor i in xrange(num_times):\n    L[:]'
p1125
(F12.153612060546875
F3.3001262664794924
tp1126
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1127
(F12.90220783666237
F3.336569976806641
tp1128
sS'for i in xrange(num_times):\n    a = []\na.extend((i for i in L))'
p1129
(F13.70488166809082
F3.3344352722167967
tp1130
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass'
p1131
(F12.234705725381541
F3.369047164916992
tp1132
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1133
(F11.751452450824873
F3.2888065338134767
tp1134
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1135
(F12.493006896972656
F3.3315494537353514
tp1136
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1137
(F12.046730324074074
F3.3579032897949217
tp1138
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1139
(F12.17949141855315
F3.310647201538086
tp1140
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1141
(F12.092249319094037
F3.361395263671875
tp1142
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1143
(F12.471894782455788
F3.3908042907714844
tp1144
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1145
(F12.597364342730978
F3.300061798095703
tp1146
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1147
(F13.25716335974007
F3.3237213134765624
tp1148
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p1149
(F11.679903470552885
F3.296396255493164
tp1150
sS'def __init__(self, val):\n    pass'
p1151
(F12.848258972167969
F3.462725830078125
tp1152
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1153
(F12.358947533562725
F3.4010169982910154
tp1154
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1155
(F11.682477912646812
F3.3237125396728517
tp1156
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        pass'
p1157
(F12.437206637474798
F3.405791473388672
tp1158
sS"print 'list(L):', (time() - t)"
p1159
(F9.017016728719076
F3.433888244628906
tp1160
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1161
(F12.499935926894796
F3.315940093994141
tp1162
sS'Copy(L, use_deepcopy=False)'
p1163
(F12.49575678507487
F3.5418411254882813
tp1164
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1165
(F11.981053207859848
F3.40323486328125
tp1166
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1167
(F11.611253614549513
F3.2985866546630858
tp1168
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1169
(F12.042784780010622
F3.3077552795410154
tp1170
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1171
(F12.134391816325207
F3.3284461975097654
tp1172
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p1173
(F11.592796812666224
F3.2970916748046877
tp1174
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1175
(F12.649530079739153
F3.370892333984375
tp1176
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1177
(F11.393015543619791
F3.3445812225341798
tp1178
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1179
(F12.566290072737068
F3.3707469940185546
tp1180
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1181
(F12.183843773531626
F3.362936782836914
tp1182
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1183
(F12.446103050595237
F3.29064826965332
tp1184
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1185
(F12.114881385784004
F3.3144390106201174
tp1186
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1187
(F12.320531020929783
F3.2860809326171876
tp1188
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1189
(F12.714780428224064
F3.3513462066650392
tp1190
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1191
(F12.311218542986751
F3.320839691162109
tp1192
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1193
(F12.540518925107758
F3.3862342834472656
tp1194
sS'b = a[:]\nc = list(a)'
p1195
(F9.263365681966146
F3.2697521209716798
tp1196
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1197
(F12.430356233016305
F3.3268997192382814
tp1198
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1199
(F12.421548982945884
F3.3103103637695312
tp1200
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1201
(F12.054262540525936
F3.306608200073242
tp1202
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1203
(F12.488351581901904
F3.429016876220703
tp1204
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1205
(F12.29315399705318
F3.328054428100586
tp1206
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1207
(F12.049984177645905
F3.3367725372314454
tp1208
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1209
(F13.077012969226372
F3.3241508483886717
tp1210
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1211
(F12.464822317807728
F3.3762779235839844
tp1212
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1213
(F12.601153157552083
F3.381212615966797
tp1214
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1215
(F12.272814606967037
F3.3737113952636717
tp1216
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1217
(F12.393910095754977
F3.3475013732910157
tp1218
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1219
(F12.267737295113358
F3.3214389801025392
tp1220
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p1221
(F12.51501739159059
F3.2741294860839845
tp1222
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue'
p1223
(F11.737393465909092
F3.2685256958007813
tp1224
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1225
(F11.993629006778493
F3.4078086853027343
tp1226
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1227
(F11.778960503472222
F3.3007648468017576
tp1228
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1229
(F12.48967706088362
F3.3544384002685548
tp1230
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1231
(F12.510609200330284
F3.3681758880615233
tp1232
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p1233
(F12.449349312160326
F3.284136962890625
tp1234
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p1235
(F8.353817079125381
F3.2957576751708983
tp1236
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1237
(F12.226395316745924
F3.3545032501220704
tp1238
sS'return obj'
p1239
(F13.857848167419434
F3.416339874267578
tp1240
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1241
(F12.238731906838613
F3.3765804290771486
tp1242
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1243
(F12.834320068359375
F3.2848842620849608
tp1244
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1245
(F12.296219308035715
F3.344526672363281
tp1246
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1247
(F12.229930130476804
F3.347357177734375
tp1248
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1249
(F12.329261292802526
F3.3620948791503906
tp1250
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1251
(F12.379779780676605
F3.3920074462890626
tp1252
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1253
(F12.329260706018518
F3.3679264068603514
tp1254
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1255
(F12.382993706597222
F3.326307678222656
tp1256
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1257
(F11.722980700041118
F3.301909255981445
tp1258
sS'def __repr__(self):\n    pass'
p1259
(F12.53752681187221
F3.3042625427246093
tp1260
sS'class old_class:\n    pass'
p1261
(F13.116879549893467
F3.3444591522216798
tp1262
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1263
(F12.371788287984915
F3.321072006225586
tp1264
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p1265
(F12.86293210265457
F3.315398406982422
tp1266
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1267
(F12.274512816011235
F3.339926910400391
tp1268
sS't = time()\nfor i in xrange(num_times):\n    a = []'
p1269
(F11.83743408203125
F3.276727294921875
tp1270
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1271
(F12.4865478515625
F3.329598236083984
tp1272
sS'b = a[:]'
p1273
(F8.228399276733398
F3.279413604736328
tp1274
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }'
p1275
(F11.544488525390625
F3.3999359130859377
tp1276
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1277
(F12.097891773897059
F3.329724884033203
tp1278
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1279
(F12.629648966961597
F3.31639404296875
tp1280
sS'from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        pass'
p1281
(F14.237493896484375
F3.3614879608154298
tp1282
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1283
(F12.479394983362269
F3.3335765838623046
tp1284
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1285
(F12.319040082358374
F3.344491958618164
tp1286
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1287
(F12.417125355113637
F3.4010562896728516
tp1288
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1289
(F12.424889366905969
F3.3455963134765625
tp1290
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1291
(F12.700336456298828
F3.3467552185058596
tp1292
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1293
(F12.516172605140186
F3.3548351287841798
tp1294
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1295
(F12.620874105089882
F3.349631500244141
tp1296
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1297
(F12.62451319391994
F3.3580482482910154
tp1298
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1299
(F12.298005432641807
F3.3572834014892576
tp1300
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1301
(F11.88699382625214
F3.310580825805664
tp1302
sS"print 'list append:', (time() - t)"
p1303
(F9.017016728719076
F3.433888244628906
tp1304
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1305
(F12.164466594827585
F3.3324825286865236
tp1306
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1307
(F12.493743510185917
F3.355754089355469
tp1308
sS'class new_class(object):\n\n    def __init__(self):\n        pass'
p1309
(F13.675980788010817
F3.4428245544433596
tp1310
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1311
(F12.408736379523026
F3.347098159790039
tp1312
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1313
(F12.594203139796402
F3.291941833496094
tp1314
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1315
(F12.824489427649457
F3.3461235046386717
tp1316
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1317
(F12.645282786087634
F3.3583045959472657
tp1318
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1319
(F11.641961960565476
F3.395555114746094
tp1320
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p1321
(F12.891107347276476
F3.3166603088378905
tp1322
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1323
(F12.58899135044643
F3.400259780883789
tp1324
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1325
(F12.349502805679563
F3.3321296691894533
tp1326
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1327
(F11.436674329969618
F3.2809463500976563
tp1328
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1329
(F12.254048056231287
F3.342116928100586
tp1330
sS"from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p1331
(F12.751652543262768
F3.3016689300537108
tp1332
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1333
(F12.24074733003657
F3.364813232421875
tp1334
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1335
(F12.379773615056818
F3.3613559722900392
tp1336
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1337
(F12.30176055565309
F3.3854648590087892
tp1338
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1339
(F12.206430288461538
F3.3381584167480467
tp1340
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1341
(F12.280710202838304
F3.3859512329101564
tp1342
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1343
(F11.78252513988598
F3.2598239898681642
tp1344
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1345
(F12.292885972706545
F3.3597389221191407
tp1346
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1347
(F12.389186145413307
F3.3435672760009765
tp1348
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p1349
(F12.934623024680398
F3.2758827209472656
tp1350
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1351
(F11.855904319069602
F3.2945728302001953
tp1352
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1353
(F12.375654332778034
F3.2934906005859377
tp1354
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1355
(F10.949372281733247
F3.297515106201172
tp1356
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1357
(F11.74360976108285
F3.2872764587402346
tp1358
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1359
(F12.854882626133112
F3.3574462890625
tp1360
sS't = time()\nfor i in xrange(num_times):\n    Copy(L)'
p1361
(F12.2192919921875
F3.3101696014404296
tp1362
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1363
(F12.35724826388889
F3.362779998779297
tp1364
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1365
(F13.048413473462302
F3.384935760498047
tp1366
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p1367
(F10.653081188463185
F3.3081451416015626
tp1368
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1369
(F12.102460488505747
F3.311416244506836
tp1370
sS'e = copy.deepcopy(a)'
p1371
(F11.311087799072265
F3.2989696502685546
tp1372
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1373
(F12.19446684400134
F3.3429645538330077
tp1374
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1375
(F12.378008504552165
F3.3109840393066405
tp1376
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1377
(F11.453709193638392
F3.414930725097656
tp1378
sS"print 'copy.copy:', (time() - t)"
p1379
(F9.017016728719076
F3.433888244628906
tp1380
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1381
(F12.625063563239644
F3.3710563659667967
tp1382
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1383
(F12.545692443847656
F3.3159461975097657
tp1384
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1385
(F12.601986792779737
F3.412053680419922
tp1386
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1387
(F12.48222948157269
F3.2965736389160156
tp1388
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1389
(F12.025045531711498
F3.330144500732422
tp1390
sS'for i in xrange(num_times):\n    copy.deepcopy(L)'
p1391
(F12.754613967168899
F3.257745361328125
tp1392
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p1393
(F12.185040642233457
F3.2516769409179687
tp1394
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p1395
(F13.043984840029761
F3.325459671020508
tp1396
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1397
(F11.738087474049388
F3.300260543823242
tp1398
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1399
(F12.25327828630286
F3.354130172729492
tp1400
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1401
(F12.332961565597467
F3.4263145446777346
tp1402
sS'L[:]'
p1403
(F6.573051452636719
F3.2665538787841797
tp1404
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p1405
(F13.178848266601562
F3.408976364135742
tp1406
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1407
(F12.554835328268348
F3.357487106323242
tp1408
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1409
(F12.583700245824353
F3.4226707458496093
tp1410
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1411
(F12.50233203125
F3.3945037841796877
tp1412
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1413
(F12.183543150906736
F3.3126594543457033
tp1414
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1415
(F12.176321295243275
F3.3423816680908205
tp1416
sS'def __init__(self, val):\n    self.val = val'
p1417
(F13.01002197265625
F3.4216209411621095
tp1418
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1419
(F12.854640706380208
F3.3187965393066405
tp1420
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1421
(F12.709128850623022
F3.389203643798828
tp1422
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1423
(F12.555721816196236
F3.3129837036132814
tp1424
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue'
p1425
(F12.431013840895433
F3.250356674194336
tp1426
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1427
(F11.208873660065407
F3.2930606842041015
tp1428
sS"foo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p1429
(F11.240929236778847
F3.279380035400391
tp1430
sS'new_list = copy.deepcopy(old_list)'
p1431
(F14.5577392578125
F3.232138824462891
tp1432
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1433
(F12.68089496658509
F3.359571838378906
tp1434
sS'from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p1435
(F13.99920022898707
F3.400049591064453
tp1436
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1437
(F12.375557585685485
F3.3494491577148438
tp1438
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1439
(F12.711895191727054
F3.3523197174072266
tp1440
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1441
(F12.245685983211436
F3.342011642456055
tp1442
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1443
(F12.624305817018072
F3.3501781463623046
tp1444
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1445
(F12.199838738692435
F3.2670108795166017
tp1446
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1447
(F11.516155666775173
F3.323637771606445
tp1448
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1449
(F12.607637845552885
F3.3579219818115233
tp1450
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1451
(F12.742865058813202
F3.300445556640625
tp1452
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1453
(F12.191580636160714
F3.3412704467773438
tp1454
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1455
(F12.307248757102272
F3.3739933013916015
tp1456
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1457
(F12.549945728198901
F3.439529037475586
tp1458
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1459
(F12.006441441977897
F3.3275825500488283
tp1460
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1461
(F11.776475922400211
F3.2962974548339843
tp1462
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1463
(F11.410119192940849
F3.292500305175781
tp1464
sS'for y in L:\n    a.append(y)'
p1465
(F12.321499824523926
F3.278568649291992
tp1466
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1467
(F12.562484596805994
F3.3309417724609376
tp1468
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1469
(F12.358369108918426
F3.314372253417969
tp1470
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1471
(F12.033724184389468
F3.310712432861328
tp1472
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p1473
(F9.03211082602447
F3.2934364318847655
tp1474
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1475
(F12.475471449194487
F3.3853271484375
tp1476
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1477
(F11.997596153846153
F3.2997222900390626
tp1478
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1479
(F12.44253858879431
F3.307290267944336
tp1480
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1481
(F12.327366807725694
F3.4242156982421874
tp1482
sS'if (type(obj[x]) in dignore):\n    pass'
p1483
(F10.613425806949014
F3.251900482177734
tp1484
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1485
(F11.910266507056452
F3.3243030548095702
tp1486
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1487
(F12.469711559444832
F3.3221336364746095
tp1488
sS't = time()\nfor i in xrange(num_times):\n    [i for i in L]'
p1489
(F13.444725036621094
F3.2724769592285154
tp1490
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1491
(F12.55981550545528
F3.3516815185546873
tp1492
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1493
(F12.366375177556819
F3.369618606567383
tp1494
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1495
(F11.588558959960938
F3.289968490600586
tp1496
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1497
(F12.027750651041666
F3.3186199188232424
tp1498
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1499
(F12.473697722904266
F3.306780242919922
tp1500
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1501
(F12.328357026777194
F3.3152694702148438
tp1502
sS'c = list(a)'
p1503
(F9.028249740600586
F3.2299346923828125
tp1504
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1505
(F12.3419830630524
F3.362995910644531
tp1506
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1507
(F12.273952796810963
F3.353120040893555
tp1508
sS'import copy\n\n\nclass Foo(object):\n    pass'
p1509
(F10.483466653262868
F3.379743957519531
tp1510
sS"foo = Foo(1)\na = ['foo', foo]"
p1511
(F8.556699752807617
F3.161442184448242
tp1512
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1513
(F12.27581155711207
F3.3011154174804687
tp1514
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1515
(F10.954432218977548
F3.2894153594970703
tp1516
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1517
(F11.86371340696839
F3.3015953063964845
tp1518
sS'from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p1519
(F14.196598399769176
F3.4019916534423826
tp1520
sS'for i in xrange(num_times):\n    L[:]'
p1521
(F12.176928871556333
F3.3357925415039062
tp1522
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p1523
(F11.668111165364584
F3.2719608306884767
tp1524
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p1525
(F12.126109730113637
F3.281291198730469
tp1526
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1527
(F12.820917302911932
F3.333979034423828
tp1528
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1529
(F12.090793305793694
F3.3250473022460936
tp1530
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1531
(F12.81462718822338
F3.309881591796875
tp1532
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1533
(F11.9642158203125
F3.2988937377929686
tp1534
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1535
(F12.456626892089844
F3.3210960388183595
tp1536
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1537
(F12.088799304496952
F3.3726791381835937
tp1538
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1539
(F12.471518936471194
F3.325531768798828
tp1540
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p1541
(F12.322294347426471
F3.3677268981933595
tp1542
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1543
(F12.672251674107143
F3.403722381591797
tp1544
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1545
(F10.2437744140625
F3.286954879760742
tp1546
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1547
(F12.56146240234375
F3.3146873474121095
tp1548
sS'from time import time\nnum_times = 100000'
p1549
(F16.028050740559895
F3.405426788330078
tp1550
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1551
(F11.514283211000505
F3.320909118652344
tp1552
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)'
p1553
(F10.826911926269531
F3.3190120697021483
tp1554
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1555
(F12.295051803916309
F3.3645603179931642
tp1556
sS'if is_tuple:\n    obj = tuple(obj)'
p1557
(F12.141697883605957
F3.2659740447998047
tp1558
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1559
(F12.019453620031681
F3.3245059967041017
tp1560
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1561
(F12.490561119595865
F3.356056976318359
tp1562
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1563
(F12.112888620860542
F3.308177947998047
tp1564
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1565
(F12.726245698474703
F3.356864166259766
tp1566
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1567
(F12.584705441497093
F3.299619674682617
tp1568
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1569
(F12.622011353369473
F3.3500598907470702
tp1570
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1571
(F12.108865958492773
F3.301075744628906
tp1572
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1573
(F12.373619079589844
F3.409790802001953
tp1574
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1575
(F12.19906805630388
F3.3933437347412108
tp1576
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1577
(F12.275855531083776
F3.3443038940429686
tp1578
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1579
(F13.060714721679688
F3.3078407287597655
tp1580
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1581
(F12.029450416564941
F3.346028137207031
tp1582
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1583
(F11.139446906323704
F3.407184600830078
tp1584
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1585
(F12.150215222997574
F3.3221099853515623
tp1586
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1587
(F12.166370971040577
F3.318099594116211
tp1588
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1589
(F12.589694634169161
F3.362883758544922
tp1590
sS'for i in xrange(num_times):\n    list(L)'
p1591
(F12.419343647203947
F3.285913848876953
tp1592
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1593
(F12.148628566576088
F3.3328651428222655
tp1594
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1595
(F11.998476028442383
F3.2640060424804687
tp1596
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1597
(F12.303776493778935
F3.288983917236328
tp1598
sS'c = list(a)\nd = copy.copy(a)'
p1599
(F11.4569091796875
F3.323155975341797
tp1600
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1601
(F12.155717468261718
F3.3409454345703127
tp1602
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1603
(F12.227942013046116
F3.31806640625
tp1604
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1605
(F12.062651867002952
F3.358005142211914
tp1606
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1607
(F12.106324114118303
F3.3997238159179686
tp1608
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1609
(F12.505590232021838
F3.320194625854492
tp1610
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1611
(F12.285857024016204
F3.3112472534179687
tp1612
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1613
(F12.260521801097973
F3.3402050018310545
tp1614
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1615
(F12.177835538242404
F3.374043273925781
tp1616
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1617
(F12.747115225162146
F3.291658401489258
tp1618
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1619
(F11.568402690272178
F3.3174781799316406
tp1620
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1621
(F12.392856882579292
F3.365660858154297
tp1622
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1623
(F12.57134441115101
F3.406017303466797
tp1624
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1625
(F12.65546658672864
F3.4069957733154297
tp1626
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1627
(F12.10905152904597
F3.3155891418457033
tp1628
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1629
(F12.236208074763594
F3.347854995727539
tp1630
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1631
(F12.189943976151316
F3.3136665344238283
tp1632
sS'import copy\nnew_list = copy.deepcopy(old_list)'
p1633
(F15.589116713579964
F3.1920955657958983
tp1634
sS'class Foo(object):\n    pass'
p1635
(F9.312983194986979
F3.3979053497314453
tp1636
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p1637
(F12.097497684439434
F3.2835983276367187
tp1638
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1639
(F11.423139464180425
F3.300080108642578
tp1640
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1641
(F12.525832002386084
F3.320588302612305
tp1642
sS't = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)'
p1643
(F12.60653347439236
F3.3217559814453126
tp1644
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1645
(F12.488536487926137
F3.303047943115234
tp1646
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1647
(F12.349461213322996
F3.333856201171875
tp1648
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1649
(F12.889594845655488
F3.3287025451660157
tp1650
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1651
(F12.663731988870873
F3.3351654052734374
tp1652
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1653
(F11.874229117615583
F3.3558189392089846
tp1654
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1655
(F11.64123977439991
F3.304981994628906
tp1656
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1657
(F12.515468052455358
F3.3603752136230467
tp1658
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1659
(F12.410747821514423
F3.3302448272705076
tp1660
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1661
(F12.440488542829241
F3.2864048004150392
tp1662
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p1663
(F12.698442195012019
F3.288873291015625
tp1664
sS'num_times = 100000'
p1665
(F11.190690176827568
F3.4789405822753907
tp1666
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1667
(F12.534874770220588
F3.382013702392578
tp1668
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1669
(F12.25734379606427
F3.3101757049560545
tp1670
sS'a.append(y)'
p1671
(F11.094636917114258
F3.2697917938232424
tp1672
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1673
(F11.393015543619791
F3.3445812225341798
tp1674
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1675
(F12.015771653917101
F3.3045257568359374
tp1676
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1677
(F12.43301878689943
F3.4064865112304688
tp1678
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1679
(F11.484167619185014
F3.3794834136962892
tp1680
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p1681
(F12.869505382719494
F3.390572357177734
tp1682
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p1683
(F12.823774065290179
F3.3147438049316404
tp1684
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1685
(F12.466831961077844
F3.363037872314453
tp1686
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p1687
(F11.123130798339844
F3.2962181091308596
tp1688
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1689
(F12.243917929159629
F3.3333984375
tp1690
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1691
(F13.039291669737619
F3.2795692443847657
tp1692
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1693
(F11.455449422200521
F3.293329620361328
tp1694
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1695
(F12.583244216274208
F3.3665496826171877
tp1696
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1697
(F11.877852245043682
F3.2875244140625
tp1698
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1699
(F12.433115404705669
F3.3524757385253907
tp1700
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1701
(F11.812886298457279
F3.3620601654052735
tp1702
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1703
(F12.181597309727822
F3.321241760253906
tp1704
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1705
(F12.511209671585648
F3.3304779052734377
tp1706
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1707
(F12.57116796875
F3.3203498840332033
tp1708
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1709
(F12.404615971080045
F3.3396644592285156
tp1710
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p1711
(F11.98529052734375
F3.3832889556884767
tp1712
sS'for i in xrange(num_times):\n    a = []\na.extend(L)'
p1713
(F12.237663855919472
F3.283777618408203
tp1714
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1715
(F12.607672180792298
F3.33044319152832
tp1716
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1717
(F12.335025271853885
F3.3664554595947265
tp1718
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1719
(F12.3781605286357
F3.3845779418945314
tp1720
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1721
(F12.491865871263586
F3.4009532928466797
tp1722
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)"
p1723
(F8.691065249235734
F3.256143569946289
tp1724
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1725
(F13.115831163194445
F3.287353515625
tp1726
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1727
(F12.621888290495562
F3.3521080017089844
tp1728
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1729
(F12.645610010901162
F3.408799743652344
tp1730
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1731
(F12.801761376596716
F3.4162593841552735
tp1732
sS"if (__name__ == '__main__'):\n    pass"
p1733
(F9.993803914388021
F3.323352813720703
tp1734
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1735
(F12.471196528081293
F3.3496982574462892
tp1736
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1737
(F12.186227864583334
F3.3113685607910157
tp1738
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1739
(F12.223665289922591
F3.353446197509766
tp1740
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1741
(F12.48834716796875
F3.3412544250488283
tp1742
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1743
(F11.6330603774713
F3.300714874267578
tp1744
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1745
(F11.799861941717367
F3.2973712921142577
tp1746
sS"print 'copy.copy:', (time() - t)\nt = time()"
p1747
(F9.443826463487413
F3.4363166809082033
tp1748
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1749
(F12.250516708583048
F3.3561920166015624
tp1750
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1751
(F12.151218865507392
F3.3574508666992187
tp1752
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1753
(F12.485432942708334
F3.3944732666015627
tp1754
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1755
(F12.134444986979167
F3.3671470642089845
tp1756
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1757
(F12.162183220003858
F3.377622604370117
tp1758
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1759
(F12.418455718665994
F3.4070106506347657
tp1760
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p1761
(F10.973228536626344
F3.2987937927246094
tp1762
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1763
(F12.026923862754876
F3.3045997619628906
tp1764
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1765
(F12.220904387880825
F3.3315658569335938
tp1766
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1767
(F10.747181396484375
F3.364344024658203
tp1768
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1769
(F12.28961932842548
F3.377531814575195
tp1770
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1771
(F12.496180250155215
F3.376054382324219
tp1772
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1773
(F12.042765741762908
F3.332254409790039
tp1774
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p1775
(F11.98543105014535
F3.411246490478516
tp1776
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1777
(F12.53592073074495
F3.3181533813476562
tp1778
sS'foo.val = 5'
p1779
(F10.159480503627233
F3.3602523803710938
tp1780
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1781
(F12.278160921327627
F3.3364917755126955
tp1782
sS'obj[k] = Copy(obj[k], use_deepcopy)'
p1783
(F12.0692138671875
F3.220845031738281
tp1784
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1785
(F12.533799317936912
F3.367639923095703
tp1786
sS"a = ['foo', foo]\nb = a[:]"
p1787
(F7.936751842498779
F3.236984634399414
tp1788
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p1789
(F12.14880038174716
F3.274273681640625
tp1790
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p1791
(F11.89934353298611
F3.2942138671875
tp1792
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }"
p1793
(F13.28902409585674
F3.3194015502929686
tp1794
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p1795
(F12.44711705258018
F3.315937042236328
tp1796
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1797
(F11.511207317483835
F3.326341247558594
tp1798
sS"def __init__(self):\n    self.blah = 'blah'"
p1799
(F12.220041910807291
F3.429165267944336
tp1800
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1801
(F12.163835364194652
F3.325992202758789
tp1802
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1803
(F12.501674759053738
F3.3571426391601564
tp1804
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1805
(F12.533502180724932
F3.3658885955810547
tp1806
sS't = type(obj)'
p1807
(F10.163156509399414
F3.3396316528320313
tp1808
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1809
(F11.71094799041748
F3.3096107482910155
tp1810
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1811
(F12.372493061266447
F3.352193069458008
tp1812
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p1813
(F12.241315038071066
F3.424677276611328
tp1814
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1815
(F12.578894981971153
F3.307174301147461
tp1816
sS'from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p1817
(F13.614402233714788
F3.384804534912109
tp1818
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1819
(F12.098861694335938
F3.3317970275878905
tp1820
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p1821
(F12.120954842403018
F3.3764720916748048
tp1822
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1823
(F12.174397039850918
F3.344826889038086
tp1824
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1825
(F12.050909189077524
F3.2712501525878905
tp1826
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p1827
(F13.050225376097623
F3.319637680053711
tp1828
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1829
(F12.5586652386913
F3.326786422729492
tp1830
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p1831
(F12.315605513546444
F3.287174606323242
tp1832
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1833
(F12.180219567340353
F3.3105369567871095
tp1834
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1835
(F12.679353766485091
F3.3068801879882814
tp1836
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1837
(F12.313940576760166
F3.3216480255126952
tp1838
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1839
(F12.424907569502508
F3.3618350982666017
tp1840
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1841
(F12.175174134036144
F3.317669677734375
tp1842
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1843
(F12.294089577414773
F3.3401630401611326
tp1844
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p1845
(F9.017016728719076
F3.433888244628906
tp1846
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p1847
(F11.838040803608141
F3.313322067260742
tp1848
sS"self.blah = 'blah'"
p1849
(F9.9215087890625
F3.3704944610595704
tp1850
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p1851
(F13.743808521943933
F3.336558532714844
tp1852
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p1853
(F12.824842418323863
F3.364732360839844
tp1854
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1855
(F11.71184934065646
F3.2914772033691406
tp1856
sS'for i in xrange(num_times):\n    copy.copy(L)'
p1857
(F13.315451485770089
F3.2765228271484377
tp1858
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1859
(F12.465074136223592
F3.3576316833496094
tp1860
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1861
(F11.769810384114583
F3.3315895080566404
tp1862
sS'from copy import deepcopy\n\n\nclass old_class:\n    pass'
p1863
(F14.143920050726997
F3.294622039794922
tp1864
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p1865
(F12.348114796173878
F3.2852603912353517
tp1866
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1867
(F12.255366835483285
F3.3499420166015623
tp1868
sS'for x in xrange(len(obj)):\n    pass'
p1869
(F12.3296095904182
F3.2408981323242188
tp1870
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1871
(F12.434357547377008
F3.3609287261962892
tp1872
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1873
(F12.143030569094037
F3.362211227416992
tp1874
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p1875
(F11.392144097222221
F3.305607223510742
tp1876
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1877
(F12.356880984322391
F3.3579383850097657
tp1878
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1879
(F11.838223300137363
F3.301980972290039
tp1880
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1881
(F11.981053207859848
F3.40323486328125
tp1882
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1883
(F10.196531714462653
F3.2877971649169924
tp1884
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1885
(F12.276293708282767
F3.308564376831055
tp1886
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1887
(F12.195783630875516
F3.383850860595703
tp1888
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1889
(F12.590796884864268
F3.2954620361328124
tp1890
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p1891
(F12.230588087395056
F3.2644512176513674
tp1892
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1893
(F12.492983646716102
F3.3689735412597654
tp1894
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p1895
(F12.475797172214675
F3.285844421386719
tp1896
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p1897
(F12.15482883278383
F3.267131805419922
tp1898
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p1899
(F11.941274789663462
F3.3060508728027345
tp1900
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1901
(F12.254335265228713
F3.3343555450439455
tp1902
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p1903
(F12.562223546645221
F3.372663116455078
tp1904
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1905
(F12.504390716552734
F3.4142608642578125
tp1906
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p1907
(F12.018428942830267
F3.3043746948242188
tp1908
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1909
(F12.628510714909218
F3.351807403564453
tp1910
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n    pass"
p1911
(F13.23178785674426
F3.3653636932373048
tp1912
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1913
(F12.575596400669642
F3.382557678222656
tp1914
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p1915
(F12.501156577581092
F3.383228302001953
tp1916
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1917
(F12.384837163880814
F3.395032501220703
tp1918
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1919
(F12.604335639312977
F3.362400436401367
tp1920
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1921
(F12.26375554467711
F3.343534469604492
tp1922
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p1923
(F10.042254325671074
F3.3126689910888674
tp1924
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p1925
(F13.136048260857077
F3.370719146728516
tp1926
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p1927
(F11.996430830522018
F3.3474536895751954
tp1928
sS'dignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1929
(F12.301136505909454
F3.377846527099609
tp1930
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1931
(F12.589049736417174
F3.3638519287109374
tp1932
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1933
(F13.170033237390351
F3.309400177001953
tp1934
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1935
(F12.632506265805636
F3.331334686279297
tp1936
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1937
(F11.929955051369863
F3.3856529235839843
tp1938
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1939
(F12.180781314247533
F3.3333202362060548
tp1940
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1941
(F12.118336995442709
F3.3020984649658205
tp1942
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1943
(F11.936204698350695
F3.3225494384765626
tp1944
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1945
(F12.604608099962908
F3.3864013671875
tp1946
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p1947
(F12.508304050990514
F3.4099346160888673
tp1948
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p1949
(F12.25322265625
F3.320676803588867
tp1950
sS"print(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p1951
(F11.090921020507812
F3.324266815185547
tp1952
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1953
(F12.61840188914332
F3.3419330596923826
tp1954
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1955
(F12.289819234634336
F3.328095245361328
tp1956
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p1957
(F12.79171794734589
F3.315825653076172
tp1958
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p1959
(F11.558848063151041
F3.335086441040039
tp1960
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p1961
(F11.899854793105014
F3.317670440673828
tp1962
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p1963
(F11.98071412365846
F3.331696319580078
tp1964
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1965
(F12.622655569468641
F3.39183349609375
tp1966
sS'foo = Foo(1)'
p1967
(F7.702162265777588
F3.369715118408203
tp1968
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p1969
(F12.314325780044367
F3.31856689453125
tp1970
sS"print 'copy.deepcopy:', (time() - t)\nt = time()"
p1971
(F9.443826463487413
F3.4363166809082033
tp1972
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p1973
(F12.260927587523497
F3.43966064453125
tp1974
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True'
p1975
(F12.550459951724646
F3.299945831298828
tp1976
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1977
(F12.339622667100695
F3.339069366455078
tp1978
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1979
(F11.668278893759084
F3.2617233276367186
tp1980
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1981
(F11.966460558832908
F3.3395633697509766
tp1982
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p1983
(F12.543024718997035
F3.323591613769531
tp1984
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p1985
(F10.141596743935033
F3.29322509765625
tp1986
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p1987
(F11.678504052100244
F3.3466537475585936
tp1988
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p1989
(F12.050449162463977
F3.3077743530273436
tp1990
sS'new_list = old_list[:]'
p1991
(F12.465684254964193
F3.201676940917969
tp1992
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p1993
(F12.60380713619403
F3.366230773925781
tp1994
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p1995
(F11.656976800215872
F3.2810317993164064
tp1996
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p1997
(F12.444153527192483
F3.349338150024414
tp1998
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p1999
(F11.45733755606192
F3.346647262573242
tp2000
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2001
(F12.426401709295382
F3.4332912445068358
tp2002
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2003
(F12.574665949894833
F3.3333766937255858
tp2004
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2005
(F12.009074505110432
F3.3630416870117186
tp2006
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2007
(F12.216490745544434
F3.2681407928466797
tp2008
sS'class new_class(object):\n    pass'
p2009
(F12.210013253348214
F3.418048858642578
tp2010
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2011
(F12.359187534877233
F3.403629684448242
tp2012
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2013
(F12.553368848241018
F3.3543163299560548
tp2014
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2015
(F10.730910882717225
F3.2969615936279295
tp2016
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2017
(F11.858350313626802
F3.3429336547851562
tp2018
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2019
(F11.57602847915098
F3.2909332275390626
tp2020
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2021
(F12.27345751152664
F3.364781951904297
tp2022
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2023
(F11.837522694762324
F3.3472347259521484
tp2024
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2025
(F12.140706666758362
F3.340993881225586
tp2026
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000"
p2027
(F14.515101114908854
F3.339214324951172
tp2028
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2029
(F12.088997505806589
F3.3444087982177733
tp2030
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2031
(F12.330989327017717
F3.435308074951172
tp2032
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2033
(F12.31706865648379
F3.3435420989990234
tp2034
sS'from time import time'
p2035
(F19.581864674886067
F3.4292320251464843
tp2036
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2037
(F12.282744258283133
F3.409893035888672
tp2038
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2039
(F11.538855575933688
F3.3716045379638673
tp2040
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2041
(F11.54973574037905
F3.303187942504883
tp2042
sS'import copy'
p2043
(F16.71896743774414
F3.3455772399902344
tp2044
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2045
(F11.871955871582031
F3.2984844207763673
tp2046
sS'if (t in (list, tuple)):\n    pass'
p2047
(F10.756379071403952
F3.3073368072509766
tp2048
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2049
(F11.324420020693825
F3.318149948120117
tp2050
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2051
(F12.189210333218233
F3.3102691650390623
tp2052
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2053
(F12.432649524006623
F3.4251632690429688
tp2054
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2055
(F12.204100729255545
F3.3423343658447267
tp2056
sS'self.val = val'
p2057
(F12.078887939453125
F3.4025978088378905
tp2058
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)'
p2059
(F12.65876225062779
F3.266482925415039
tp2060
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2061
(F12.291120662245639
F3.3718544006347657
tp2062
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2063
(F12.417590833690069
F3.3232276916503904
tp2064
sS'list(L)'
p2065
(F7.96202278137207
F3.19268913269043
tp2066
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2067
(F12.160220783986864
F3.3478954315185545
tp2068
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2069
(F12.339723605086752
F3.3352584838867188
tp2070
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2071
(F11.392901466006325
F3.3420486450195312
tp2072
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2073
(F12.30233801416604
F3.3481704711914064
tp2074
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2075
(F12.39994229403409
F3.3311290740966797
tp2076
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2077
(F11.997423486802184
F3.3839736938476563
tp2078
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2079
(F12.693182321175637
F3.376604461669922
tp2080
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2081
(F12.501662986865941
F3.366385650634766
tp2082
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2083
(F12.614341634114583
F3.3006072998046876
tp2084
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2085
(F11.856818599977355
F3.325373077392578
tp2086
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p2087
(F12.851607228053435
F3.3202590942382812
tp2088
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2089
(F12.070547972910504
F3.3227306365966798
tp2090
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2091
(F12.308494975548664
F3.336795425415039
tp2092
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2093
(F12.260210191881335
F3.295319747924805
tp2094
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2095
(F12.394269178142656
F3.3448158264160157
tp2096
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p2097
(F13.287460853313577
F3.391203689575195
tp2098
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2099
(F12.435391438802084
F3.285640335083008
tp2100
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2101
(F11.599955240885416
F3.3997249603271484
tp2102
sS"from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p2103
(F12.735844111942745
F3.27509765625
tp2104
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2105
(F11.782152303059895
F3.28625373840332
tp2106
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2107
(F12.256617090723536
F3.3219024658203127
tp2108
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2109
(F12.325713575932017
F3.3821044921875
tp2110
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2111
(F11.621842278374565
F3.296064758300781
tp2112
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'"
p2113
(F13.313845033998843
F3.3676395416259766
tp2114
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2115
(F12.219600282866379
F3.3266639709472656
tp2116
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2117
(F12.02254070621906
F3.321888732910156
tp2118
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2119
(F11.105812884391622
F3.357160949707031
tp2120
sS'[i for i in L]'
p2121
(F13.362484402126736
F3.251226806640625
tp2122
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2123
(F11.929667154947916
F3.3704532623291015
tp2124
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2125
(F11.929371425083705
F3.2806015014648438
tp2126
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2127
(F11.981053207859848
F3.40323486328125
tp2128
sS't = time()'
p2129
(F8.825889587402344
F3.4251449584960936
tp2130
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2131
(F11.800422765031646
F3.2845733642578123
tp2132
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2133
(F12.16570288897281
F3.3413848876953125
tp2134
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2135
(F11.578380057482216
F3.316358184814453
tp2136
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2137
(F12.299574497767857
F3.348323440551758
tp2138
sS"d = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p2139
(F12.081298828125
F3.2716243743896483
tp2140
sS'for y in L:\n    pass'
p2141
(F11.876887928355824
F3.2288528442382813
tp2142
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2143
(F12.363506401909722
F3.3719810485839843
tp2144
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2145
(F12.223756951800848
F3.3810707092285157
tp2146
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2147
(F12.243711118344907
F3.428297424316406
tp2148
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2149
(F12.38868631342406
F3.4261238098144533
tp2150
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2151
(F11.752619140625
F3.3986297607421876
tp2152
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p2153
(F12.850495990953947
F3.309928131103516
tp2154
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2155
(F12.199602912454043
F3.2703922271728514
tp2156
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2157
(F12.124792710790095
F3.3590736389160156
tp2158
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2159
(F12.26862308896821
F3.3117835998535154
tp2160
sS'for i in xrange(num_times):\n    [i for i in L]'
p2161
(F13.834247935901988
F3.3189579010009767
tp2162
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2163
(F12.56022736210151
F3.3194637298583984
tp2164
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2165
(F12.57885110789332
F3.2793060302734376
tp2166
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2167
(F10.217799729567307
F3.300883102416992
tp2168
sS'copy.deepcopy(L)'
p2169
(F10.013012886047363
F3.3323596954345702
tp2170
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2171
(F12.470166374655332
F3.391383743286133
tp2172
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2173
(F12.61917323920563
F3.3088043212890623
tp2174
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2175
(F11.388642205132378
F3.2900054931640623
tp2176
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p2177
(F12.342126128870413
F3.2900569915771483
tp2178
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2179
(F12.62674075610017
F3.320852279663086
tp2180
sS'd = copy.copy(a)\ne = copy.deepcopy(a)'
p2181
(F12.334042197779604
F3.2756507873535154
tp2182
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2183
(F12.350921055056014
F3.3802581787109376
tp2184
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2185
(F12.5830322265625
F3.397278594970703
tp2186
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2187
(F12.199407060016958
F3.3351341247558595
tp2188
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2189
(F12.228714494515728
F3.3144683837890625
tp2190
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2191
(F12.572608304310995
F3.2780609130859375
tp2192
sS'from copy import deepcopy'
p2193
(F19.752784729003906
F3.289779281616211
tp2194
sS"e = copy.deepcopy(a)\na.append('baz')"
p2195
(F11.172001558191637
F3.2760658264160156
tp2196
sS'class Foo(object):\n\n    def __init__(self, val):\n        pass'
p2197
(F12.298302283653847
F3.4207233428955077
tp2198
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2199
(F12.078323305795019
F3.3319778442382812
tp2200
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2201
(F11.620295854048296
F3.401105499267578
tp2202
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2203
(F11.218189270515753
F3.302322006225586
tp2204
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2205
(F12.092748305376839
F3.2955108642578126
tp2206
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2207
(F11.903906780740488
F3.417467498779297
tp2208
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2209
(F12.513577306694664
F3.3280284881591795
tp2210
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2211
(F12.415717754584943
F3.406525421142578
tp2212
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2213
(F12.328118199425488
F3.338334655761719
tp2214
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2215
(F12.412207742339199
F3.3152366638183595
tp2216
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2217
(F12.115540702387971
F3.416737365722656
tp2218
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2219
(F12.4665489975287
F3.3330810546875
tp2220
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2221
(F12.191727189828228
F3.3530399322509767
tp2222
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2223
(F12.330985113746761
F3.3438758850097656
tp2224
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2225
(F10.28382637131382
F3.2999805450439452
tp2226
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2227
(F12.204058478860293
F3.3287078857421877
tp2228
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2229
(F12.446217940301121
F3.3985000610351563
tp2230
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2231
(F12.492085456848145
F3.3119121551513673
tp2232
sS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)'
p2233
(F12.236445426940918
F3.2674633026123048
tp2234
sS'for i in xrange(num_times):\n    pass'
p2235
(F13.135677337646484
F3.2643585205078125
tp2236
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2237
(F12.77318115234375
F3.3117313385009766
tp2238
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2239
(F12.409458705357142
F3.3228378295898438
tp2240
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p2241
(F12.619510773689516
F3.3615882873535154
tp2242
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2243
(F12.56874287923177
F3.330548858642578
tp2244
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2245
(F12.655540882457386
F3.3447032928466798
tp2246
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2247
(F11.825609394148284
F3.3013343811035156
tp2248
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2249
(F11.801079767400568
F3.348036193847656
tp2250
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2251
(F12.3982626953125
F3.3153587341308595
tp2252
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2253
(F11.981053207859848
F3.40323486328125
tp2254
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2255
(F12.471943915644779
F3.3884490966796874
tp2256
sS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p2257
(F12.359218821806067
F3.3334239959716796
tp2258
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)'
p2259
(F12.297997516134512
F3.378021240234375
tp2260
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2261
(F12.277961869673295
F3.316843795776367
tp2262
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2263
(F12.478007868144587
F3.3682846069335937
tp2264
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2265
(F12.203418932462993
F3.3608375549316407
tp2266
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2267
(F12.302181162732714
F3.3149009704589845
tp2268
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2269
(F12.49655069769385
F3.354328155517578
tp2270
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2271
(F11.61415506998698
F3.285108947753906
tp2272
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2273
(F12.685418164879707
F3.361991119384766
tp2274
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2275
(F12.533645784011995
F3.2980361938476563
tp2276
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2277
(F12.247913221373175
F3.3381519317626953
tp2278
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2279
(F11.498908547794118
F3.3284305572509765
tp2280
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2281
(F12.473637525639479
F3.414702224731445
tp2282
sS'from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n    pass'
p2283
(F13.947569627028246
F3.416485595703125
tp2284
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2285
(F12.445605961963384
F3.3654624938964846
tp2286
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2287
(F11.904246651785714
F3.299477767944336
tp2288
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2289
(F12.087979403409092
F3.3139896392822266
tp2290
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2291
(F12.311644888166244
F3.3421161651611326
tp2292
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p2293
(F12.186070033482142
F3.266435241699219
tp2294
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2295
(F12.680815360915492
F3.394490051269531
tp2296
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2297
(F12.451792399088541
F3.3732704162597655
tp2298
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2299
(F11.950818230124082
F3.3688568115234374
tp2300
sS'def __repr__(self):\n    return str(self.val)'
p2301
(F12.523628234863281
F3.288365936279297
tp2302
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2303
(F9.443826463487413
F3.4363166809082033
tp2304
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2305
(F12.550592370935389
F3.428373336791992
tp2306
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2307
(F12.376074487036401
F3.2927001953125
tp2308
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2309
(F12.48352693256579
F3.3057323455810548
tp2310
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2311
(F11.451621791294643
F3.2468048095703126
tp2312
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2313
(F12.242156982421875
F3.3387435913085937
tp2314
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2315
(F12.34669109594042
F3.4181438446044923
tp2316
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2317
(F12.202013739224139
F3.426870346069336
tp2318
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2319
(F12.51730310492836
F3.3748687744140624
tp2320
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2321
(F11.951456148330479
F3.297720718383789
tp2322
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2323
(F12.2564697265625
F3.3542770385742187
tp2324
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2325
(F12.347053144620434
F3.3502052307128904
tp2326
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2327
(F12.363243782874381
F3.3416656494140624
tp2328
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2329
(F12.380894252232142
F3.2854610443115235
tp2330
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2331
(F11.853691186797754
F3.300625228881836
tp2332
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2333
(F12.735736892884036
F3.380023193359375
tp2334
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2335
(F11.37794189453125
F3.3586524963378905
tp2336
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2337
(F12.63460524064781
F3.3779743194580076
tp2338
sS't = time()\nfor i in xrange(num_times):\n    copy.copy(L)'
p2339
(F13.06842154043692
F3.317209243774414
tp2340
sS't = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))'
p2341
(F13.486604389391447
F3.327312469482422
tp2342
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2343
(F12.493576213877688
F3.2838790893554686
tp2344
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2345
(F12.455413108648257
F3.404351806640625
tp2346
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2347
(F12.061796932276392
F3.307018280029297
tp2348
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2349
(F12.72721935453869
F3.3536865234375
tp2350
sS'b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p2351
(F11.390226421934186
F3.289373016357422
tp2352
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2353
(F11.032658627158717
F3.292578125
tp2354
sS'new_list = copy.copy(old_list)'
p2355
(F15.272916521344866
F3.2646251678466798
tp2356
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2357
(F12.601710878569504
F3.4085838317871096
tp2358
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2359
(F12.503171353726774
F3.3662559509277346
tp2360
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2361
(F12.543449454471983
F3.4029937744140626
tp2362
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2363
(F12.55847804857337
F3.327963638305664
tp2364
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2365
(F11.799689797794118
F3.3942886352539063
tp2366
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2367
(F12.122291420990566
F3.309335708618164
tp2368
sS'from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        pass'
p2369
(F14.242550659179688
F3.4284423828125
tp2370
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2371
(F11.124771683304399
F3.2831443786621093
tp2372
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2373
(F12.185958158052884
F3.334870529174805
tp2374
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2375
(F12.23967194215616
F3.3413352966308594
tp2376
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2377
(F11.936163884943182
F3.3152420043945314
tp2378
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2379
(F12.128896885702055
F3.3095203399658204
tp2380
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2381
(F12.181729159512363
F3.3349533081054688
tp2382
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2383
(F8.76366278465758
F3.2938869476318358
tp2384
sS'obj = tuple(obj)'
p2385
(F9.958839416503906
F3.2566699981689453
tp2386
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2387
(F12.11537088373656
F3.3313064575195312
tp2388
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2389
(F12.378345723054847
F3.33520393371582
tp2390
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2391
(F12.35712946588467
F3.342958450317383
tp2392
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2393
(F11.981053207859848
F3.40323486328125
tp2394
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2395
(F12.251350091801559
F3.346453094482422
tp2396
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2397
(F11.766694810655382
F3.358502197265625
tp2398
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2399
(F12.259274764799736
F3.404776763916016
tp2400
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2401
(F12.607927925979034
F3.3724716186523436
tp2402
sS'd = copy.copy(a)'
p2403
(F11.890960693359375
F3.292613220214844
tp2404
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2405
(F12.11748934659091
F3.3225143432617186
tp2406
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2407
(F12.3145751953125
F3.372766876220703
tp2408
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2409
(F12.62206151463964
F3.4311267852783205
tp2410
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2411
(F11.97627461751302
F3.365093231201172
tp2412
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2413
(F12.453120410890508
F3.3990242004394533
tp2414
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2415
(F12.597321390454235
F3.3697330474853517
tp2416
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2417
(F12.422399520874023
F3.3248485565185546
tp2418
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2419
(F12.29582821645067
F3.3367874145507814
tp2420
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2421
(F11.788484770676185
F3.298230743408203
tp2422
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2423
(F11.995701811238789
F3.326560211181641
tp2424
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2425
(F12.329292534722223
F3.3777870178222655
tp2426
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2427
(F12.419165108618234
F3.3894378662109377
tp2428
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2429
(F11.72413731288243
F3.321763610839844
tp2430
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2431
(F12.470907198782823
F3.3466930389404297
tp2432
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2433
(F12.219090483113789
F3.327885055541992
tp2434
sS'a = []'
p2435
(F6.858683904012044
F3.1690126419067384
tp2436
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2437
(F11.981053207859848
F3.40323486328125
tp2438
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2439
(F12.100576244571961
F3.3153514862060547
tp2440
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2441
(F11.755406621676773
F3.312944030761719
tp2442
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        pass'
p2443
(F11.640408602627842
F3.265300750732422
tp2444
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2445
(F12.78338105799788
F3.3570281982421877
tp2446
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2447
(F12.683063707853618
F3.290655517578125
tp2448
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2449
(F12.3312744140625
F3.3525100708007813
tp2450
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2451
(F12.09449948546707
F3.3297649383544923
tp2452
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2453
(F12.489261511600379
F3.3568695068359373
tp2454
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2455
(F12.110833909776476
F3.360900115966797
tp2456
sS'def __init__(self):\n    pass'
p2457
(F12.754457746233259
F3.481984329223633
tp2458
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2459
(F11.233138234991776
F3.3056453704833983
tp2460
sS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p2461
(F12.377314104352678
F3.2858047485351562
tp2462
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2463
(F12.350990988991477
F3.299482727050781
tp2464
sS"from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p2465
(F12.77693305581303
F3.279336166381836
tp2466
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2467
(F12.397494229403408
F3.334759521484375
tp2468
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p2469
(F12.80029296875
F3.377324676513672
tp2470
sS't = time()\nfor i in xrange(num_times):\n    list(L)'
p2471
(F12.3827783203125
F3.279213714599609
tp2472
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2473
(F12.396840085265456
F3.3634620666503907
tp2474
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p2475
(F13.712515408875513
F3.3882217407226562
tp2476
sS'def Copy(obj, use_deepcopy=True):\n    pass'
p2477
(F12.48600345187717
F3.4110797882080077
tp2478
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p2479
(F11.391995516690342
F3.314179611206055
tp2480
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2481
(F12.121677943638392
F3.3051300048828125
tp2482
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2483
(F12.155459484422064
F3.335516357421875
tp2484
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2485
(F12.554584341989436
F3.325640106201172
tp2486
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2487
(F12.207959915701634
F3.3413196563720704
tp2488
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2489
(F12.599501312756148
F3.3797801971435546
tp2490
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2491
(F12.543512861858042
F3.3240848541259767
tp2492
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    pass"
p2493
(F10.360660328584558
F3.297495651245117
tp2494
sS"print 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2495
(F11.931920590608016
F3.301800537109375
tp2496
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2497
(F11.734638383235838
F3.290262985229492
tp2498
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2499
(F12.05652483771829
F3.3370800018310547
tp2500
sS"from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2501
(F12.834910673253676
F3.2905670166015626
tp2502
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2503
(F11.352815755208333
F3.296770477294922
tp2504
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2505
(F12.442055912341102
F3.3238365173339846
tp2506
sS"for y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2507
(F11.4267657244647
F3.283051300048828
tp2508
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2509
(F12.450033180501931
F3.3564422607421873
tp2510
sS'from __future__ import print_function\nimport copy'
p2511
(F19.405982384314903
F3.424158477783203
tp2512
sS'for k in obj:\n    pass'
p2513
(F12.240585327148438
F3.255088043212891
tp2514
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2515
(F12.155513748468136
F3.365665054321289
tp2516
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p2517
(F12.928511186079545
F3.2267921447753904
tp2518
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2519
(F12.456452931072695
F3.343535614013672
tp2520
sS"from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2521
(F12.838249944871471
F3.2750850677490235
tp2522
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2523
(F12.474137739701705
F3.295063781738281
tp2524
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2525
(F12.224376929734282
F3.340699005126953
tp2526
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2527
(F11.995954016780546
F3.30501708984375
tp2528
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2529
(F12.511309382891413
F3.3231334686279297
tp2530
sS"print 'copy.deepcopy:', (time() - t)"
p2531
(F9.017016728719076
F3.433888244628906
tp2532
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2533
(F12.2042529296875
F3.354537582397461
tp2534
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2535
(F11.908182423017179
F3.3178531646728517
tp2536
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2537
(F11.998999780462693
F3.3328617095947264
tp2538
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p2539
(F11.978846056707974
F3.283406066894531
tp2540
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2541
(F12.658648557079081
F3.400716018676758
tp2542
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)'
p2543
(F12.902524276518486
F3.274515151977539
tp2544
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2545
(F11.923776221087598
F3.407374954223633
tp2546
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2547
(F11.981197781032986
F3.362256622314453
tp2548
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p2549
(F13.16106071728188
F3.311053466796875
tp2550
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2551
(F12.554412694368962
F3.426329803466797
tp2552
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2553
(F12.105674201673498
F3.3592605590820312
tp2554
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2555
(F12.837240529614826
F3.364376449584961
tp2556
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2557
(F12.56375023626512
F3.393484878540039
tp2558
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2559
(F12.082247399980096
F3.3817047119140624
tp2560
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2561
(F12.56141023262919
F3.3490535736083986
tp2562
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2563
(F12.64843120771585
F3.3885780334472657
tp2564
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2565
(F12.338686385244694
F3.349618148803711
tp2566
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2567
(F12.619731702302632
F3.3471778869628905
tp2568
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2569
(F12.443067206711065
F3.427294921875
tp2570
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2571
(F12.46453902633102
F3.3470428466796873
tp2572
sS'obj = deepcopy(obj)'
p2573
(F9.819225311279297
F3.397418212890625
tp2574
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2575
(F12.494118705253483
F3.366666793823242
tp2576
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2577
(F12.201160868660349
F3.2822593688964843
tp2578
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2579
(F12.144340297154018
F3.419961166381836
tp2580
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2581
(F12.509442429315476
F3.4190048217773437
tp2582
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2583
(F12.555701304290254
F3.3836292266845702
tp2584
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2585
(F12.531319754464286
F3.3263553619384765
tp2586
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2587
(F12.35189612989324
F3.363784408569336
tp2588
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p2589
(F10.639843385611007
F3.311728668212891
tp2590
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2591
(F12.59974915747549
F3.3867202758789063
tp2592
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2593
(F12.083017459393997
F3.3055824279785155
tp2594
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2595
(F12.206632561639909
F3.3104766845703124
tp2596
sS"a = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2597
(F10.070228576660156
F3.305512619018555
tp2598
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2599
(F12.20026135053791
F3.3398460388183593
tp2600
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p2601
(F12.334118954284452
F3.4032764434814453
tp2602
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2603
(F11.802239706349928
F3.3155704498291017
tp2604
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2605
(F12.964290771484375
F3.402606964111328
tp2606
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2607
(F12.369140625
F3.424089813232422
tp2608
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2609
(F12.902231316817435
F3.2837474822998045
tp2610
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2611
(F11.981053207859848
F3.40323486328125
tp2612
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2613
(F12.403565772804054
F3.3486061096191406
tp2614
sS'a.extend((i for i in L))'
p2615
(F14.90796879359654
F3.3121376037597656
tp2616
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2617
(F12.35750729536052
F3.351143646240234
tp2618
sS'a.extend(L)'
p2619
(F11.022198677062988
F3.245575714111328
tp2620
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2621
(F12.472197630695094
F3.3591346740722656
tp2622
sS'for i in xrange(num_times):\n    a = []'
p2623
(F11.780394704718338
F3.3016326904296873
tp2624
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    pass'
p2625
(F13.352451490319293
F3.224468231201172
tp2626
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2627
(F11.879782743232195
F3.329092788696289
tp2628
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2629
(F12.388574059700733
F3.3781288146972654
tp2630
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2631
(F11.853246444310898
F3.341594696044922
tp2632
sS'if (type(obj[k]) in dignore):\n    continue'
p2633
(F10.975774664627878
F3.242043685913086
tp2634
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2635
(F12.264206252731643
F3.3742340087890623
tp2636
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2637
(F13.053091430664063
F3.300303268432617
tp2638
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2639
(F12.129957682291666
F3.310529327392578
tp2640
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2641
(F12.374751519097222
F3.3562637329101563
tp2642
sS'for i in xrange(num_times):\n    a = []\nfor y in L:\n    pass'
p2643
(F12.424401645002694
F3.3083740234375
tp2644
sS't = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)'
p2645
(F12.392593383789062
F3.3102142333984377
tp2646
sS'c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)'
p2647
(F11.976213895357573
F3.2988170623779296
tp2648
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2649
(F12.646927845628955
F3.3248008728027343
tp2650
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2651
(F11.940181408898304
F3.4259571075439452
tp2652
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p2653
(F12.099661878360216
F3.2753124237060547
tp2654
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()"
p2655
(F11.661281301014458
F3.312317657470703
tp2656
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2657
(F12.417086437136629
F3.3793495178222654
tp2658
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2659
(F11.92016715116279
F3.2962966918945313
tp2660
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2661
(F12.664529184194711
F3.34954948425293
tp2662
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2663
(F11.583880615234374
F3.278009033203125
tp2664
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2665
(F12.14594891319977
F3.307395172119141
tp2666
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2667
(F12.000512374074836
F3.376953887939453
tp2668
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2669
(F12.19338851436492
F3.3402244567871096
tp2670
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2671
(F11.09829771752451
F3.311064910888672
tp2672
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2673
(F12.280040540193257
F3.344765472412109
tp2674
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2675
(F11.769909496038732
F3.301211929321289
tp2676
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    pass'
p2677
(F12.740092884410512
F3.382505416870117
tp2678
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2679
(F12.700291224888392
F3.4155803680419923
tp2680
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2681
(F12.280149683459051
F3.312982177734375
tp2682
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2683
(F12.388722806831066
F3.3485260009765625
tp2684
sS"from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p2685
(F12.895458132721657
F3.3233280181884766
tp2686
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2687
(F12.654846492072044
F3.357769775390625
tp2688
sS'obj = obj[:]'
p2689
(F8.505949020385742
F3.2515029907226562
tp2690
sS"print 'list slicing [:]:', (time() - t)\nt = time()"
p2691
(F9.443826463487413
F3.4363166809082033
tp2692
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2693
(F12.369596437420077
F3.3443572998046873
tp2694
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2695
(F12.561657817423844
F3.361891174316406
tp2696
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2697
(F11.569523564091435
F3.264299774169922
tp2698
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2699
(F12.507765826056986
F3.304138946533203
tp2700
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2701
(F12.260121547551252
F3.3216453552246095
tp2702
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p2703
(F12.26449924045139
F3.2491527557373048
tp2704
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2705
(F12.812257366415896
F3.3371742248535154
tp2706
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2707
(F8.991408284505209
F3.270976257324219
tp2708
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2709
(F11.967685834099266
F3.371773529052734
tp2710
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p2711
(F11.227244307355184
F3.292506790161133
tp2712
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2713
(F12.331945082720589
F3.3446788787841797
tp2714
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2715
(F12.216849949048912
F3.35552978515625
tp2716
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p2717
(F12.405034739500397
F3.4105812072753907
tp2718
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time"
p2719
(F14.561086018880209
F3.308107376098633
tp2720
sS"for i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2721
(F12.720450309327411
F3.3370532989501953
tp2722
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p2723
(F12.100922455658784
F3.3383647918701174
tp2724
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2725
(F12.509895766076962
F3.425994110107422
tp2726
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2727
(F12.303575032552084
F3.3034507751464846
tp2728
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        pass"
p2729
(F13.49969595449942
F3.409539794921875
tp2730
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2731
(F12.326447002704327
F3.3600383758544923
tp2732
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2733
(F12.44622802734375
F3.375962829589844
tp2734
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2735
(F12.657230551725899
F3.3306045532226562
tp2736
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2737
(F12.623044259207589
F3.3037445068359377
tp2738
sS"\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p2739
(F11.985609266493055
F3.2949562072753906
tp2740
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2741
(F12.466737166694973
F3.3271419525146486
tp2742
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)"
p2743
(F11.064719686702807
F3.2801048278808596
tp2744
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]"
p2745
(F12.31138916015625
F3.337571716308594
tp2746
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2747
(F12.198580467094809
F3.3604156494140627
tp2748
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2749
(F12.516077756143575
F3.3582191467285156
tp2750
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2751
(F12.496917724609375
F3.3143333435058593
tp2752
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2753
(F12.498824368990384
F3.4007949829101562
tp2754
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2755
(F12.013493290653935
F3.3799537658691405
tp2756
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        pass'
p2757
(F12.349897335737179
F3.2583892822265623
tp2758
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2759
(F11.75224807661802
F3.2947574615478517
tp2760
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p2761
(F12.442210896809895
F3.422551727294922
tp2762
sS'from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p2763
(F13.913629531860352
F3.387571334838867
tp2764
sS'import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val'
p2765
(F12.570384870256696
F3.377541351318359
tp2766
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2767
(F12.52841077532087
F3.398265838623047
tp2768
sS"a.append('baz')"
p2769
(F9.098584175109863
F3.24774169921875
tp2770
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2771
(F12.255218800241158
F3.341103363037109
tp2772
sS'if (type(obj[x]) in dignore):\n    continue'
p2773
(F10.81272406327097
F3.24566650390625
tp2774
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2775
(F12.608670748197115
F3.37685546875
tp2776
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2777
(F12.1768994140625
F3.395418167114258
tp2778
sS'def Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)'
p2779
(F12.528089396158855
F3.2973743438720704
tp2780
sS"print 'list(L):', (time() - t)\nt = time()"
p2781
(F9.443826463487413
F3.4363166809082033
tp2782
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        pass'
p2783
(F12.146040482954545
F3.2670482635498046
tp2784
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2785
(F12.536872414981618
F3.374512481689453
tp2786
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p2787
(F11.080047607421875
F3.3123878479003905
tp2788
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2789
(F11.638537863026494
F3.265952301025391
tp2790
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2791
(F12.131443956163194
F3.3030860900878904
tp2792
sS"a.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p2793
(F11.41240067915483
F3.264215087890625
tp2794
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2795
(F12.370015171595982
F3.341398239135742
tp2796
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2797
(F12.975689512310606
F3.328927230834961
tp2798
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2799
(F11.976430350487385
F3.2919261932373045
tp2800
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p2801
(F12.39451156123992
F3.4183189392089846
tp2802
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2803
(F12.058226872011613
F3.3161773681640625
tp2804
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2805
(F12.551893352640086
F3.334894561767578
tp2806
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2807
(F12.416227409638553
F3.3620201110839845
tp2808
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2809
(F12.407915126777695
F3.3673877716064453
tp2810
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2811
(F12.372837421021174
F3.387117385864258
tp2812
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2813
(F12.383716362847222
F3.3493587493896486
tp2814
sS"print 'list slicing [:]:', (time() - t)"
p2815
(F9.017016728719076
F3.433888244628906
tp2816
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2817
(F12.445639377170139
F3.3603374481201174
tp2818
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]"
p2819
(F11.060558210100446
F3.2943836212158204
tp2820
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2821
(F12.196449016702585
F3.3346893310546877
tp2822
sS"c = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p2823
(F12.043608054136618
F3.289442443847656
tp2824
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2825
(F12.212104089481315
F3.392558288574219
tp2826
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2827
(F11.906857589790723
F3.2929450988769533
tp2828
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2829
(F12.319803602430556
F3.357129669189453
tp2830
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2831
(F12.102492947048612
F3.304492950439453
tp2832
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p2833
(F12.462776346409575
F3.346732330322266
tp2834
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2835
(F13.045576379654255
F3.3354106903076173
tp2836
sS'def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p2837
(F11.990089699074074
F3.2952430725097654
tp2838
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2839
(F12.277583499606564
F3.322887420654297
tp2840
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2841
(F12.488613055019306
F3.3578350067138674
tp2842
sS"from __future__ import print_function\nimport copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p2843
(F12.865069415118244
F3.284241485595703
tp2844
sS"e = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p2845
(F11.706617809477306
F3.279926300048828
tp2846
sS"for i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2847
(F11.676111557904411
F3.2953948974609375
tp2848
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2849
(F12.326988260582011
F3.3732933044433593
tp2850
sS't = time()\nfor i in xrange(num_times):\n    pass'
p2851
(F12.811304265802557
F3.326316070556641
tp2852
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2853
(F12.510529103632951
F3.4094112396240233
tp2854
sS'continue'
p2855
(F10.742631276448568
F3.4448070526123047
tp2856
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2857
(F12.485081432711693
F3.3448867797851562
tp2858
sS'Copy(L)'
p2859
(F7.693436940511067
F3.3215091705322264
tp2860
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2861
(F12.368624293550532
F3.4132457733154298
tp2862
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2863
(F12.31103265224359
F3.3288349151611327
tp2864
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2865
(F12.456836969080106
F3.2974323272705077
tp2866
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2867
(F12.356162314658409
F3.393990325927734
tp2868
sS"if (__name__ == '__main__'):\n    import copy"
p2869
(F11.630715370178223
F3.2871353149414064
tp2870
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2871
(F12.777330713364684
F3.4046913146972657
tp2872
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2873
(F12.361452058981394
F3.3517024993896483
tp2874
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2875
(F12.259352650808458
F3.3544178009033203
tp2876
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2877
(F12.176053133877842
F3.3721939086914063
tp2878
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p2879
(F12.436295219089674
F3.2943801879882812
tp2880
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2881
(F12.146397477489407
F3.3562240600585938
tp2882
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2883
(F12.704285913584183
F3.3012317657470702
tp2884
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)"
p2885
(F13.205707005092076
F3.3216514587402344
tp2886
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2887
(F12.181785606971154
F3.3395843505859375
tp2888
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p2889
(F11.86309063251202
F3.2975784301757813
tp2890
sS'obj = list(obj)'
p2891
(F9.655896186828613
F3.3039009094238283
tp2892
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2893
(F12.354391043526785
F3.3094329833984375
tp2894
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2895
(F12.010017770235656
F3.303818130493164
tp2896
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2897
(F12.542068481445312
F3.344049072265625
tp2898
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2899
(F12.05086919312836
F3.3291641235351563
tp2900
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p2901
(F12.003458792264345
F3.305205535888672
tp2902
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p2903
(F12.639202079387626
F3.2780040740966796
tp2904
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p2905
(F12.708673386346726
F3.3145267486572267
tp2906
sS'import copy\nnew_list = copy.copy(old_list)'
p2907
(F16.098990047679226
F3.218021011352539
tp2908
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p2909
(F13.151027625715228
F3.3131362915039064
tp2910
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True"
p2911
(F13.017211009837963
F3.315460968017578
tp2912
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2913
(F12.122327565537084
F3.3149459838867186
tp2914
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2915
(F12.428180711384911
F3.344931793212891
tp2916
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p2917
(F12.415116269364317
F3.34688720703125
tp2918
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2919
(F12.302406972543352
F3.3436599731445313
tp2920
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5\nprint(('original: %r\\n slice: %r\\n list(): %r\\n copy: %r\\n deepcopy: %r' % (a, b, c, d, e)))"
p2921
(F11.679171048677885
F3.255902862548828
tp2922
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p2923
(F12.820279121398926
F3.2887996673583983
tp2924
sS'is_tuple = False\nfor x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2925
(F12.554043856534092
F3.28739013671875
tp2926
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()"
p2927
(F10.384341535897091
F3.299737548828125
tp2928
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p2929
(F11.881361219618055
F3.2980026245117187
tp2930
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p2931
(F12.343634636847527
F3.311345672607422
tp2932
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2933
(F12.18367378285389
F3.355670166015625
tp2934
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p2935
(F12.660489266378837
F3.3173149108886717
tp2936
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2937
(F12.035802129489273
F3.292594146728516
tp2938
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p2939
(F12.354959690824469
F3.272679901123047
tp2940
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p2941
(F12.925711796201508
F3.2737598419189453
tp2942
sS"print 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2943
(F11.393015543619791
F3.3445808410644533
tp2944
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p2945
(F12.30827606390722
F3.3506633758544924
tp2946
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p2947
(F12.559151785714286
F3.4235294342041014
tp2948
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    pass'
p2949
(F12.69762471516927
F3.289849853515625
tp2950
sS"print 'list extend:', (time() - t)\nt = time()"
p2951
(F9.443826463487413
F3.4363166809082033
tp2952
sS"a.extend(L)\nprint 'list extend:', (time() - t)"
p2953
(F10.808319091796875
F3.3349117279052733
tp2954
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p2955
(F12.021097162718414
F3.3112861633300783
tp2956
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)"
p2957
(F11.31099357185783
F3.3155494689941407
tp2958
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2959
(F11.648947975852273
F3.3720108032226563
tp2960
sS'is_tuple = True'
p2961
(F14.26593998500279
F3.2874801635742186
tp2962
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2963
(F12.305374786633404
F3.3503700256347657
tp2964
sS"print 'generator expression extend:', (time() - t)"
p2965
(F9.017016728719076
F3.433888244628906
tp2966
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2967
(F12.24593009529533
F3.362051010131836
tp2968
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p2969
(F11.967117687887397
F3.404379653930664
tp2970
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2971
(F12.236383277249624
F3.3452781677246093
tp2972
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p2973
(F13.257225774949596
F3.3002944946289063
tp2974
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p2975
(F12.228102650808458
F3.357473373413086
tp2976
sS'return str(self.val)'
p2977
(F12.059032864040798
F3.2948223114013673
tp2978
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2979
(F12.59263218470982
F3.4159351348876954
tp2980
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p2981
(F11.888917236328124
F3.338748550415039
tp2982
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2983
(F12.495533662683824
F3.2884098052978517
tp2984
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p2985
(F12.519569798519736
F3.4172760009765626
tp2986
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    pass"
p2987
(F13.09364501953125
F3.32706298828125
tp2988
sS"for i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2989
(F12.465693721064815
F3.318639373779297
tp2990
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p2991
(F12.86817978367661
F3.3766548156738283
tp2992
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p2993
(F12.334640216571715
F3.3464099884033205
tp2994
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)"
p2995
(F11.518788655598959
F3.357196044921875
tp2996
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p2997
(F12.259636874222636
F3.3470233917236327
tp2998
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p2999
(F11.364023659446023
F3.4243011474609375
tp3000
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p3001
(F12.5379392183744
F3.318524932861328
tp3002
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p3003
(F12.43031736466078
F3.328847885131836
tp3004
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p3005
(F11.77150482657068
F3.293931579589844
tp3006
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3007
(F12.395928054559427
F3.3271942138671875
tp3008
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    if (type(obj[k]) in dignore):\n        continue'
p3009
(F11.836172485351563
F3.283681106567383
tp3010
sS'if (t in (list, tuple)):\n    if (t == tuple):\n        pass'
p3011
(F10.515724464699074
F3.340376281738281
tp3012
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3013
(F11.981053207859848
F3.40323486328125
tp3014
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3015
(F12.443214733195754
F3.4168968200683594
tp3016
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p3017
(F12.233931223551432
F3.4294761657714843
tp3018
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)"
p3019
(F12.127605646306819
F3.3059715270996093
tp3020
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3021
(F11.773360963851687
F3.303656005859375
tp3022
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p3023
(F12.63699465613383
F3.3264095306396486
tp3024
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')\nfoo.val = 5"
p3025
(F12.249978770380435
F3.263414764404297
tp3026
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    pass"
p3027
(F12.554648145988805
F3.395553207397461
tp3028
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p3029
(F12.021257449419071
F3.4032379150390626
tp3030
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p3031
(F12.468767844165283
F3.3713104248046877
tp3032
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3033
(F12.902569289434524
F3.3949825286865236
tp3034
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3035
(F12.796898685284514
F3.358409118652344
tp3036
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p3037
(F12.519890887920672
F3.3533405303955077
tp3038
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p3039
(F12.317753586813668
F3.3220794677734373
tp3040
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p3041
(F12.280170641447368
F3.360393524169922
tp3042
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3043
(F12.411572559770331
F3.3823944091796876
tp3044
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p3045
(F12.68194739856021
F3.361920928955078
tp3046
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p3047
(F11.748474980743838
F3.338159942626953
tp3048
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p3049
(F11.7886910274111
F3.294956588745117
tp3050
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3051
(F12.32665771484375
F3.3901424407958984
tp3052
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)"
p3053
(F11.793171129728618
F3.355902099609375
tp3054
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]"
p3055
(F12.545092205668604
F3.3636398315429688
tp3056
sS'obj[x] = Copy(obj[x], use_deepcopy)'
p3057
(F12.032623291015625
F3.234200286865234
tp3058
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p3059
(F11.952492713928223
F3.2971832275390627
tp3060
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p3061
(F11.997506948617788
F3.3246326446533203
tp3062
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p3063
(F12.262682326296543
F3.3497413635253905
tp3064
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3065
(F12.219694380326704
F3.3166229248046877
tp3066
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3067
(F11.983358873208992
F3.298506164550781
tp3068
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p3069
(F12.57263583096591
F3.3494102478027346
tp3070
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3071
(F12.09159923735119
F3.3959537506103517
tp3072
sS"t = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3073
(F12.360915021198553
F3.326523208618164
tp3074
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3075
(F12.158354063291807
F3.331368255615234
tp3076
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3077
(F12.205136149453475
F3.365568923950195
tp3078
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3079
(F12.343556186609101
F3.3541114807128904
tp3080
sS"print 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p3081
(F12.801756566884567
F3.3017436981201174
tp3082
sS'for i in xrange(num_times):\n    Copy(L)'
p3083
(F12.255108481959292
F3.2854660034179686
tp3084
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3085
(F12.6191775004069
F3.3813411712646486
tp3086
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p3087
(F12.12067281788793
F3.3362274169921875
tp3088
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)"
p3089
(F12.191257240032328
F3.37609748840332
tp3090
sS"t = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3091
(F12.436163160536024
F3.310963439941406
tp3092
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p3093
(F12.288641122671274
F3.312082290649414
tp3094
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()"
p3095
(F11.320252014710023
F3.299183654785156
tp3096
sS"print 'list expression(L):', (time() - t)"
p3097
(F9.017016728719076
F3.433888244628906
tp3098
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3099
(F11.777885437011719
F3.3516666412353517
tp3100
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p3101
(F11.443240356445312
F3.296009826660156
tp3102
sS'obj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p3103
(F12.404813172387295
F3.2586231231689453
tp3104
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)'
p3105
(F12.500341582716556
F3.363453674316406
tp3106
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3107
(F12.43325664191846
F3.3581527709960937
tp3108
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p3109
(F12.226111972454897
F3.3536636352539064
tp3110
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3111
(F12.561215682768486
F3.3533512115478517
tp3112
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3113
(F12.483995120958012
F3.377294921875
tp3114
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p3115
(F12.203920161923882
F3.3440219879150392
tp3116
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p3117
(F12.33688739167542
F3.3233882904052736
tp3118
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3119
(F12.408950957745017
F3.3966217041015625
tp3120
sS"for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p3121
(F12.52090080015121
F3.3536300659179688
tp3122
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3123
(F12.407082658473069
F3.3176124572753904
tp3124
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3125
(F12.366668881749261
F3.318621063232422
tp3126
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    pass"
p3127
(F13.191133499145508
F3.317519760131836
tp3128
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3129
(F11.085389335200471
F3.3678417205810547
tp3130
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3131
(F12.499271716101696
F3.3738372802734373
tp3132
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time"
p3133
(F15.233804066975912
F3.3493942260742187
tp3134
sS'for x in xrange(len(obj)):\n    if (type(obj[x]) in dignore):\n        continue\nobj[x] = Copy(obj[x], use_deepcopy)\nif is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p3135
(F12.342708725527109
F3.281319427490234
tp3136
sS'if (type(obj[k]) in dignore):\n    pass'
p3137
(F10.7650291041324
F3.2461578369140627
tp3138
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p3139
(F12.430853352147578
F3.349620819091797
tp3140
sS'for i in xrange(num_times):\n    Copy(L, use_deepcopy=False)'
p3141
(F13.7830908203125
F3.285566711425781
tp3142
sS'class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)'
p3143
(F12.7407470703125
F3.3672767639160157
tp3144
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)"
p3145
(F12.199000158975291
F3.3139717102050783
tp3146
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()\nfor k in obj:\n    pass'
p3147
(F11.959111993963068
F3.286771774291992
tp3148
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3149
(F12.321524393927191
F3.345276641845703
tp3150
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3151
(F12.40477955669438
F3.426296615600586
tp3152
sS"for i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3153
(F12.490776099968905
F3.3236751556396484
tp3154
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    pass'
p3155
(F11.451925005231585
F3.3057785034179688
tp3156
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()"
p3157
(F12.516124287589651
F3.4144004821777343
tp3158
sS'obj = obj.copy()'
p3159
(F10.208361307779947
F3.3749866485595703
tp3160
sS"a.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3161
(F12.402145385742188
F3.374071502685547
tp3162
sS"num_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3163
(F12.219220759195574
F3.318034362792969
tp3164
sS"print 'list extend:', (time() - t)"
p3165
(F9.017016728719076
F3.433888244628906
tp3166
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)"
p3167
(F12.319971329126602
F3.2925674438476564
tp3168
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3169
(F12.742697482638889
F3.4250892639160155
tp3170
sS'new_list = list(old_list)'
p3171
(F14.199211120605469
F3.1783397674560545
tp3172
sS"t = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3173
(F12.424476807820048
F3.366220474243164
tp3174
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3175
(F12.364510906937653
F3.3421058654785156
tp3176
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3177
(F11.11238025483631
F3.266736602783203
tp3178
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p3179
(F12.445418392319278
F3.359477233886719
tp3180
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3181
(F12.554825367647059
F3.393843078613281
tp3182
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)"
p3183
(F11.995916193181818
F3.290784454345703
tp3184
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3185
(F12.550144897901625
F3.3719181060791015
tp3186
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3187
(F12.234255883001513
F3.3473461151123045
tp3188
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3189
(F12.219067182697234
F3.32642822265625
tp3190
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)"
p3191
(F10.589624404907227
F3.307890701293945
tp3192
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)"
p3193
(F12.623887803819445
F3.351162338256836
tp3194
sS"class Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3195
(F12.05374028132512
F3.2799129486083984
tp3196
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3197
(F12.007403589570472
F3.332624816894531
tp3198
sS"class old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        is_tuple = True\nobj = list(obj)"
p3199
(F13.026456591109154
F3.312975311279297
tp3200
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3201
(F12.305683547901996
F3.34942626953125
tp3202
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)"
p3203
(F12.128739420572916
F3.314591979980469
tp3204
sS"a.extend((i for i in L))\nprint 'generator expression extend:', (time() - t)"
p3205
(F12.894827880859374
F3.298780822753906
tp3206
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3207
(F12.463502854567308
F3.353525161743164
tp3208
sS"class new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'\ndignore = {str: None, unicode: None, int: None, type(None): None, }\n\ndef Copy(obj, use_deepcopy=True):\n    t = type(obj)\nif (t in (list, tuple)):\n    if (t == tuple):\n        pass"
p3209
(F12.625594944629855
F3.318502426147461
tp3210
sS'is_tuple = False'
p3211
(F14.26593998500279
F3.2874801635742186
tp3212
sS'if is_tuple:\n    obj = tuple(obj)\nelif (t == dict):\n    obj = obj.copy()'
p3213
(F11.473012587603401
F3.2941715240478517
tp3214
sS"for i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3215
(F12.77640151977539
F3.296019744873047
tp3216
sS"for i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()"
p3217
(F12.298132491438356
F3.313603973388672
tp3218
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()"
p3219
(F12.201939174107142
F3.430517578125
tp3220
sS"def __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3221
(F11.756331160261825
F3.309480667114258
tp3222
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)"
p3223
(F12.70622820172991
F3.4192710876464845
tp3224
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)"
p3225
(F11.2402834117922
F3.3011405944824217
tp3226
sS'for k in obj:\n    if (type(obj[k]) in dignore):\n        continue\nobj[k] = Copy(obj[k], use_deepcopy)'
p3227
(F12.26342079856179
F3.2826839447021485
tp3228
sS"print 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3229
(F12.194802024147727
F3.3982372283935547
tp3230
sS"from time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]"
p3231
(F12.153763222483407
F3.3270259857177735
tp3232
sS"from copy import deepcopy\n\n\nclass old_class:\n\n    def __init__(self):\n        self.blah = 'blah'\n\n\nclass new_class(object):\n\n    def __init__(self):\n        self.blah = 'blah'"
p3233
(F13.514380821814903
F3.372583770751953
tp3234
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3235
(F12.486519013475252
F3.402814483642578
tp3236
sS"import copy\n\n\nclass Foo(object):\n\n    def __init__(self, val):\n        self.val = val\n\ndef __repr__(self):\n    return str(self.val)\nfoo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3237
(F12.009787819602273
F3.299268341064453
tp3238
sS"print 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3239
(F12.374713172210505
F3.350286102294922
tp3240
sS"print 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)"
p3241
(F12.785311744326638
F3.3885631561279297
tp3242
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3243
(F12.139671097258608
F3.3179275512695314
tp3244
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()"
p3245
(F12.533418354235197
F3.3575782775878906
tp3246
sS"return obj\nif (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()"
p3247
(F12.28015996368838
F3.3460723876953127
tp3248
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)"
p3249
(F12.46838552795584
F3.396686553955078
tp3250
sS"foo = Foo(1)\na = ['foo', foo]\nb = a[:]"
p3251
(F8.621292777683424
F3.253433609008789
tp3252
sS"print 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend((i for i in L))"
p3253
(F12.451882102272727
F3.357122802734375
tp3254
sS"t = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)"
p3255
(F12.2058833040149
F3.3450801849365233
tp3256
sS"L = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3257
(F12.089620773268189
F3.305947113037109
tp3258
sS"t = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3259
(F12.535656114564325
F3.3462696075439453
tp3260
sS"for i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)\nprint 'list append:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []"
p3261
(F12.372347897046232
F3.333307647705078
tp3262
sS"print 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p3263
(F12.007534935360862
F3.361672210693359
tp3264
sS"t = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()"
p3265
(F12.190142050556753
F3.315749740600586
tp3266
sS"t = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    pass"
p3267
(F12.575932452068237
F3.410305404663086
tp3268
sS"b = a[:]\nc = list(a)\nd = copy.copy(a)\ne = copy.deepcopy(a)\na.append('baz')"
p3269
(F11.419915771484375
F3.280996322631836
tp3270
sS"print 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    [i for i in L]\nprint 'list expression(L):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\na.extend(L)\nprint 'list extend:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    a = []\nfor y in L:\n    a.append(y)"
p3271
(F12.310238022402109
F3.349867248535156
tp3272
sS"for i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p3273
(F12.37714092548077
F3.3819347381591798
tp3274
sS"t = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    list(L)\nprint 'list(L):', (time() - t)\nt = time()"
p3275
(F11.924822890967654
F3.3678836822509766
tp3276
sS"if (__name__ == '__main__'):\n    import copy\nfrom time import time\nnum_times = 100000\nL = [None, 'blah', 1, 543.4532, ['foo'], ('bar',), {'blah': 'blah', }, old_class(), new_class()]\nt = time()\nfor i in xrange(num_times):\n    Copy(L)\nprint 'Custom Copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    Copy(L, use_deepcopy=False)\nprint 'Custom Copy Only Copying Lists/Tuples/Dicts (no classes):', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.copy(L)\nprint 'copy.copy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    copy.deepcopy(L)\nprint 'copy.deepcopy:', (time() - t)\nt = time()\nfor i in xrange(num_times):\n    L[:]\nprint 'list slicing [:]:', (time() - t)"
p3277
(F12.016229538690476
F3.3308536529541017
tp3278
ssI402504
(dp3279
S'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)'
p3280
(F11.158215840657553
F2.2477670149369673
tp3281
sS'(type(i) is float)'
p3282
(F11.407646942138673
F2.321107864379883
tp3283
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3284
(F11.703183641620711
F2.213476701216264
tp3285
sS'type(i)\n(type(i) is long)\ni = 123.456'
p3286
(F11.079350521689967
F2.262796228582209
tp3287
sS'(type(i) is long)'
p3288
(F11.005130004882812
F2.294195521961559
tp3289
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3290
(F11.422573020241478
F2.2117096294056284
tp3291
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3292
(F11.367891311645508
F2.240161895751953
tp3293
sS"v = 'hi'"
p3294
(F7.943202972412109
F2.480124733664773
tp3295
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3296
(F11.182199838999155
F2.2175839164040307
tp3297
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3298
(F11.512814113071986
F2.2344032634388316
tp3299
sS'i = 123'
p3300
(F7.059272003173828
F2.4269384904341265
tp3301
sS'v = 10\ntype(v)'
p3302
(F9.711245727539062
F2.2733912034468218
tp3303
sS'i = 123.456\ntype(i)'
p3304
(F8.842381286621094
F2.330049514770508
tp3305
sS'v = 100000000000000'
p3306
(F7.877616119384766
F2.4680300625887783
tp3307
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)'
p3308
(F10.734412057059151
F2.2392297224564985
tp3309
sS'i = 123\ntype(i)'
p3310
(F8.842381286621094
F2.330049514770508
tp3311
sS'(type(i) is long)\ni = 123.456'
p3312
(F10.898514883858818
F2.3002355748956855
tp3313
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3314
(F10.626630700152853
F2.2551149888472124
tp3315
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L'
p3316
(F10.630849423615828
F2.2566531788219106
tp3317
sS'v = 100000000000000\ntype(v)'
p3318
(F9.109351348876952
F2.3843895305286753
tp3319
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3320
(F11.088407190834603
F2.222441933371804
tp3321
sS'(type(i) is int)\ni = 123456789L'
p3322
(F10.954254150390625
F2.308544158935547
tp3323
sS'(type(i) is long)\ni = 123.456\ntype(i)'
p3324
(F11.036398636667352
F2.265859777277166
tp3325
sS'type(i)\n(type(i) is long)'
p3326
(F11.162918090820312
F2.256816864013672
tp3327
sS'type(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3328
(F11.70130781693892
F2.2250581221147017
tp3329
sS'type(i)\n(type(i) is int)'
p3330
(F11.4658447265625
F2.2598696621981533
tp3331
sS'i = 123456789L\ntype(i)\n(type(i) is long)'
p3332
(F10.661834716796875
F2.252791491421786
tp3333
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3334
(F11.41504632859003
F2.218314777721058
tp3335
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3336
(F11.391877045502534
F2.2276404987681997
tp3337
sS'i = 123456789L\ntype(i)'
p3338
(F8.842381286621094
F2.330049514770508
tp3339
sS'type(v)'
p3340
(F9.308072408040365
F2.3544661782004614
tp3341
sS'i = 123.456'
p3342
(F7.059272003173828
F2.4269384904341265
tp3343
sS'print type(variable_name)'
p3344
(F13.17592027452257
F2.206273165616122
tp3345
sS'v = (-10)\ntype(v)'
p3346
(F8.617188673753004
F2.345494877208363
tp3347
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)'
p3348
(F11.520010283499053
F2.2218461470170454
tp3349
sS'type(i)\n(type(i) is int)\ni = 123456789L'
p3350
(F11.094193307976974
F2.2677201357754795
tp3351
sS'type(i)'
p3352
(F8.8789431254069
F2.3354918740012427
tp3353
sS'i = 123.456\ntype(i)\n(type(i) is float)'
p3354
(F10.82300447162829
F2.2635035081343218
tp3355
sS'v = (-10)'
p3356
(F6.841032981872559
F2.389631444757635
tp3357
sS'(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3358
(F11.662769862583705
F2.2380156083540483
tp3359
sS'type(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3360
(F11.18490982055664
F2.2417760328813032
tp3361
sS'type(i)\n(type(i) is float)'
p3362
(F11.5047119140625
F2.2729327461936255
tp3363
sS'(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3364
(F11.704239555027174
F2.2203859849409624
tp3365
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3366
(F10.740252903529576
F2.2364437796852807
tp3367
sS'(type(i) is int)'
p3368
(F11.334828186035157
F2.301161679354581
tp3369
sS'i = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)\n(type(i) is float)'
p3370
(F11.30160275021115
F2.2223691073330967
tp3371
sS'(type(i) is int)\ni = 123456789L\ntype(i)'
p3372
(F11.058209067896792
F2.2737268968061968
tp3373
sS'v = 10'
p3374
(F9.103556823730468
F2.35589616948908
tp3375
sS'type(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456'
p3376
(F11.39847791517103
F2.2272219224409624
tp3377
sS'i = 123456789L'
p3378
(F7.059272003173828
F2.4269384904341265
tp3379
sS'i = 123\ntype(i)\n(type(i) is int)'
p3380
(F10.827140406558389
F2.252586538141424
tp3381
sS'i = 123\ntype(i)\n(type(i) is int)\ni = 123456789L\ntype(i)\n(type(i) is long)\ni = 123.456\ntype(i)'
p3382
(F11.111413043478262
F2.2148874456232246
tp3383
sS"v = 'hi'\ntype(v)"
p3384
(F8.979712677001952
F2.4342606284401636
tp3385
ssI275018
(dp3386
S's.strip()'
p3387
(F10.057873317173549
F2.2593727111816406
tp3388
sS's.rstrip()'
p3389
(F9.606351579938616
F2.373119354248047
tp3390
sS"'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p3391
(F7.146231651306152
F2.381183351789202
tp3392
sS"s = ' \\n  abc   def   '"
p3393
(F8.62136001586914
F2.3273230961390903
tp3394
sS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'\ntext.splitlines()"
p3395
(F9.444907448508523
F2.325956072126116
tp3396
sS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Unix EOL\\n'.rstrip('\\r\\n')"
p3397
(F7.766908819025213
F2.362175532749721
tp3398
sS"'Mac EOL\\r'.rstrip('\\r\\n')\n'Windows EOL\\r\\n'.rstrip('\\r\\n')"
p3399
(F7.625522867838542
F2.3676155635288785
tp3400
sS's.strip()\ns.rstrip()\ns.lstrip()'
p3401
(F10.140905279862253
F2.2875913892473494
tp3402
sS'text.splitlines()'
p3403
(F9.79593985421317
F2.3810814448765347
tp3404
sS"'Hello\\n\\n\\n'.rstrip('\\n')"
p3405
(F7.146231651306152
F2.381183351789202
tp3406
sS's.rstrip()\ns.lstrip()'
p3407
(F9.877370981069712
F2.377796173095703
tp3408
sS"'test string\\n'.rstrip()"
p3409
(F7.322861807686942
F2.396935599190848
tp3410
sS"text = 'line 1\\nline 2\\r\\nline 3\\nline 4'"
p3411
(F8.313780212402344
F2.335206985473633
tp3412
sS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()"
p3413
(F9.677781048943014
F2.244443348475865
tp3414
sS"s = ' \\n  abc   def   '\ns.strip()"
p3415
(F9.25786105069247
F2.2180350167410716
tp3416
sS"s = ' \\n  abc   def   '\ns.strip()\ns.rstrip()\ns.lstrip()"
p3417
(F9.79326861837636
F2.2624736513410295
tp3418
sS's.lstrip()'
p3419
(F9.606351579938616
F2.373119354248047
tp3420
sS's.strip()\ns.rstrip()'
p3421
(F10.280224139873798
F2.279971258980887
tp3422
sS"'Windows EOL\\r\\n'.rstrip('\\r\\n')\n'Unix EOL\\n'.rstrip('\\r\\n')"
p3423
(F7.625522867838542
F2.3676155635288785
tp3424
sS"'Mac EOL\\r'.rstrip('\\r\\n')"
p3425
(F7.146231651306152
F2.381183351789202
tp3426
sS"'test string \\n\\n'.rstrip('\\n')"
p3427
(F7.146231651306152
F2.381183351789202
tp3428
sS"'Unix EOL\\n'.rstrip('\\r\\n')"
p3429
(F7.146231651306152
F2.381183351789202
tp3430
ssI276052
(dp3431
S'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3432
(F12.723437049971198
F2.7533807020920973
tp3433
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3434
(F12.84498789612676
F3.05494132408729
tp3435
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3436
(F12.048780381944445
F3.0823152982271633
tp3437
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p3438
(F10.811219159294577
F3.05764653132512
tp3439
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3440
(F11.387046350838657
F3.0821609497070312
tp3441
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3442
(F13.95941495028409
F3.205988957331731
tp3443
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3444
(F14.921006373355263
F2.8155781672551083
tp3445
sS"eval_str = ('objItem.%s' % attribute)"
p3446
(F11.691139914772727
F2.9563070443960338
tp3447
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3448
(F13.858964626333488
F3.0680982149564304
tp3449
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3450
(F13.093248221544716
F2.89730952336238
tp3451
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3452
(F13.065830454355108
F2.9599673931415262
tp3453
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3454
(F14.443871449615996
F2.9987669724684496
tp3455
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3456
(F14.100037901551573
F3.0354097806490383
tp3457
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3458
(F14.94403076171875
F3.12797605074369
tp3459
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3460
(F14.985757681039663
F2.9996023911696215
tp3461
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3462
(F11.950857881108357
F2.8720160264235277
tp3463
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3464
(F15.43244039601293
F3.000370905949519
tp3465
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3466
(F14.47923085387324
F2.884931124173678
tp3467
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p3468
(F16.04604547674006
F2.5702350323016825
tp3469
sS'import psutil'
p3470
(F14.695377349853516
F2.641386178823618
tp3471
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3472
(F13.255051141036184
F3.026476053091196
tp3473
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p3474
(F9.827281204695554
F2.719846872182993
tp3475
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p3476
(F15.02445894129136
F2.6112644488994894
tp3477
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3478
(F9.886209239130435
F2.9444007873535156
tp3479
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3480
(F14.460550308227539
F3.030260819655198
tp3481
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3482
(F14.579199511133982
F2.8690437903771033
tp3483
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p3484
(F15.004705429077148
F3.230846698467548
tp3485
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p3486
(F12.970102083885063
F2.901129209078275
tp3487
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3488
(F12.358263517680921
F2.8149129427396336
tp3489
sS"pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint('memory use:', memoryUse)"
p3490
(F11.80926513671875
F2.72781254695012
tp3491
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3492
(F12.905258861940299
F3.1105425908015323
tp3493
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3494
(F13.265126576409495
F3.0518162067119894
tp3495
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3496
(F13.948496225717905
F3.0333727323091946
tp3497
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3498
(F12.830521013269472
F2.9924976642315206
tp3499
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3500
(F12.540199985891649
F3.0834371126615086
tp3501
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p3502
(F11.615198992300725
F3.1048093942495494
tp3503
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3504
(F14.851602582789178
F2.893223395714393
tp3505
sS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p3506
(F16.389034756747158
F2.7582115760216346
tp3507
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3508
(F13.520192291777013
F3.0605829679048977
tp3509
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p3510
(F12.948357997796474
F2.9938169626089244
tp3511
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3512
(F13.46650170498207
F3.033764178936298
tp3513
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3514
(F14.380621877657314
F2.8700520442082333
tp3515
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3516
(F12.809130724117036
F2.9938539358285756
tp3517
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3518
(F14.805450939741291
F3.240092057448167
tp3519
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3520
(F14.797814383724619
F2.8528013962965746
tp3521
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3522
(F11.6502685546875
F2.840881054217999
tp3523
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3524
(F14.792670549665178
F2.934353461632362
tp3525
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3526
(F11.996114857258645
F2.904116703913762
tp3527
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3528
(F14.268599789784137
F3.0141331599308896
tp3529
sS'colItems = objSWbemServices.ExecQuery(query_str)'
p3530
(F13.672194480895996
F2.929461259108323
tp3531
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p3532
(F15.364092293432204
F3.1546580974872294
tp3533
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3534
(F13.51752764866825
F3.0119957557091346
tp3535
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3536
(F10.757415771484375
F2.7035496051494894
tp3537
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3538
(F12.695337775735295
F2.927740243765024
tp3539
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p3540
(F15.915434095594618
F2.5772038973294773
tp3541
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3542
(F12.663763508397578
F3.048341604379507
tp3543
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3544
(F13.715912647736378
F3.080084287203275
tp3545
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3546
(F15.884653128829656
F3.156679006723257
tp3547
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3548
(F14.510906078197339
F2.8493399986853967
tp3549
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3550
(F15.813704270582933
F3.250694568340595
tp3551
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3552
(F12.803676194411057
F3.0290926419771633
tp3553
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3554
(F11.971175655241936
F2.9454275277944713
tp3555
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3556
(F12.583653903279467
F3.020250760591947
tp3557
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list"
p3558
(F15.867840576171876
F3.1575995225172777
tp3559
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3560
(F13.490514161501377
F2.9778081453763523
tp3561
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3562
(F15.0377246658237
F2.8532518240121694
tp3563
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p3564
(F8.011190747457837
F3.1732177734375
tp3565
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3566
(F13.205286195081648
F3.0817653949444113
tp3567
sS"if (__name__ == '__main__'):\n    pass"
p3568
(F9.697857666015626
F2.7933725210336537
tp3569
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3570
(F12.22092056274414
F2.836626199575571
tp3571
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3572
(F14.198890016790022
F3.219042264498197
tp3573
sS'return proc_results_list\n\ndef get_sys_stats():\n    pass'
p3574
(F13.68896484375
F2.8634573129507213
tp3575
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p3576
(F11.575990449397937
F3.1000809302696815
tp3577
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3578
(F15.204337565104167
F2.976792262150691
tp3579
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p3580
(F12.807699742268042
F2.9379812387319713
tp3581
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3582
(F11.069985622829861
F2.969792292668269
tp3583
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3584
(F11.825821175759668
F3.106276585505559
tp3585
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3586
(F13.347606898449463
F2.977039630596454
tp3587
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p3588
(F13.447916986431729
F3.031918158897987
tp3589
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p3590
(F12.292464192708334
F2.83266595693735
tp3591
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3592
(F13.179291874529367
F2.991649334247296
tp3593
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p3594
(F13.67694549560547
F2.6057821420522838
tp3595
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p3596
(F14.864763532366071
F2.579478924091046
tp3597
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3598
(F14.832949526675113
F2.7869098369891825
tp3599
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3600
(F13.231224060058594
F3.0088013869065504
tp3601
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3602
(F13.647418301715177
F3.064268258901743
tp3603
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3604
(F14.278144836425781
F2.862034430870643
tp3605
sS'import os\nimport psutil\npid = os.getpid()'
p3606
(F13.33948974609375
F2.6362557044396033
tp3607
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3608
(F13.003044953893443
F3.0755186814528246
tp3609
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3610
(F11.055347260974703
F2.930561359112079
tp3611
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3612
(F13.133168113193328
F2.904283670278696
tp3613
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p3614
(F14.630033052884615
F3.08854000384991
tp3615
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3616
(F13.388671875
F3.062469775860126
tp3617
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3618
(F13.9588525390625
F2.9972138038048377
tp3619
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3620
(F11.272555264559658
F3.0142522958608775
tp3621
sS"import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint('memory use:', memoryUse)"
p3622
(F12.34176216873468
F2.725651374230018
tp3623
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3624
(F14.247413966966713
F2.744394742525541
tp3625
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3626
(F12.87286438604798
F3.0379001910869894
tp3627
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3628
(F8.96795184795673
F3.308908902681791
tp3629
sS'def winmem():\n    x = MEMORYSTATUS()'
p3630
(F7.981406656901042
F2.910836146428035
tp3631
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3632
(F16.844217051630434
F3.06531730064979
tp3633
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3634
(F13.248839646242978
F3.0188076312725363
tp3635
sS'break'
p3636
(F10.203721364339193
F2.714734590970553
tp3637
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p3638
(F15.408625380797956
F3.0373893150916467
tp3639
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p3640
(F11.524267023259943
F2.8881753774789662
tp3641
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3642
(F15.11747527928744
F2.8433758662297177
tp3643
sS'import psutil\nprint(psutil.cpu_percent())\nprint(psutil.virtual_memory())'
p3644
(F13.651209904597355
F2.666319333589994
tp3645
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3646
(F12.983087539672852
F3.1618124154897838
tp3647
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3648
(F13.207591993079339
F2.8367418142465444
tp3649
sS"from __future__ import print_function\nimport os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint('memory use:', memoryUse)"
p3650
(F13.699602399553571
F2.69795901958759
tp3651
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3652
(F13.500327923201107
F3.034432337834285
tp3653
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3654
(F13.520842363037447
F2.956057621882512
tp3655
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3656
(F12.982105592654424
F3.0563709552471456
tp3657
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        for attribute in self.supported_types[counter_type]:\n            eval_str = ('objItem.%s' % attribute)"
p3658
(F14.602178758190524
F2.9070604764498196
tp3659
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3660
(F12.637832810767739
F3.0569478548490086
tp3661
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3662
(F15.048559970543034
F2.8346416766826925
tp3663
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3664
(F13.812908541771673
F3.1728685819185696
tp3665
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3666
(F14.691590542923151
F2.8909873962402344
tp3667
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3668
(F12.545137786865235
F2.9693497877854567
tp3669
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p3670
(F13.141330108379949
F2.945140838623047
tp3671
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict"
p3672
(F14.86708984375
F3.2520247239332933
tp3673
sS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())'
p3674
(F15.443434397379557
F2.6490094111515927
tp3675
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3676
(F13.922576904296875
F2.9657950768103967
tp3677
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3678
(F14.230788373716788
F2.8523533160869894
tp3679
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3680
(F12.198454542503463
F2.9165672889122596
tp3681
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3682
(F13.455504944274475
F3.0095743032602162
tp3683
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3684
(F11.632025690362005
F2.947978679950421
tp3685
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3686
(F14.389158606150794
F2.8626430218036356
tp3687
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p3688
(F15.130616575807005
F3.1160257779634914
tp3689
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict"
p3690
(F14.93184049836882
F3.338856036846454
tp3691
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3692
(F11.973547189721565
F3.057939969576322
tp3693
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3694
(F10.529157939710116
F3.068388425386869
tp3695
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3696
(F13.116765475202802
F3.039056337796725
tp3697
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3698
(F14.360408380681818
F2.9973699129544773
tp3699
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3700
(F12.921744095651727
F2.9999442467322717
tp3701
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p3702
(F9.995980905932049
F2.7163907564603367
tp3703
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3704
(F14.335757533482143
F3.0662706815279446
tp3705
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3706
(F10.151473135318396
F2.7046585083007812
tp3707
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3708
(F12.900796393513916
F3.034226344181941
tp3709
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3710
(F14.697464503599017
F2.8639144897460938
tp3711
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3712
(F13.200140294894366
F2.9092621436485877
tp3713
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p3714
(F13.582812702186853
F3.057144751915565
tp3715
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3716
(F12.737471554257453
F2.8760355435884914
tp3717
sS'pythoncom.CoInitialize()\nx = winmem()'
p3718
(F9.60728018624442
F2.841671870304988
tp3719
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p3720
(F13.221655649038462
F3.031720968393179
tp3721
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3722
(F12.918159572557471
F3.1625102116511417
tp3723
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p3724
(F10.946890024038462
F3.0986237159142127
tp3725
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3726
(F13.401790609335839
F3.02147469153771
tp3727
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3728
(F12.87798046875
F3.0417445256159854
tp3729
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3730
(F11.591444062023628
F2.8146661611703725
tp3731
sS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p3732
(F16.748427170973557
F2.774073674128606
tp3733
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3734
(F11.756975770365711
F2.8876046400803785
tp3735
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3736
(F14.225918638939952
F2.725606771615835
tp3737
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3738
(F12.833779978197674
F2.7641073373647838
tp3739
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p3740
(F13.803208042198504
F3.100253471961388
tp3741
sS'def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3742
(F15.465347681290064
F3.272388751690204
tp3743
sS'import psutil\nprint(psutil.cpu_percent())'
p3744
(F12.477703857421876
F2.64270987877479
tp3745
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3746
(F12.64931959602701
F2.8480506310096154
tp3747
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3748
(F13.539498046875
F3.031911409818209
tp3749
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3750
(F13.663584854579208
F3.0044881380521336
tp3751
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p3752
(F13.607426057280515
F3.067006624661959
tp3753
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3754
(F13.591065523917216
F3.1503201998197117
tp3755
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3756
(F13.43114330150463
F3.019298846905048
tp3757
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3758
(F12.685315185005543
F2.9411395146296573
tp3759
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p3760
(F13.548776355421687
F3.00202384361854
tp3761
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3762
(F11.717734432784763
F2.7989636934720554
tp3763
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3764
(F11.877372211313503
F2.736400897686298
tp3765
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p3766
(F11.01128147072988
F3.105062044583834
tp3767
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3768
(F13.807265170784884
F3.0569293682391825
tp3769
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3770
(F13.835994729971945
F3.04978033212515
tp3771
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3772
(F14.785680213341346
F2.915540255033053
tp3773
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3774
(F13.534875518273957
F3.0068740844726562
tp3775
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3776
(F13.54146312901499
F3.0257609440730167
tp3777
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3778
(F12.911600677809233
F3.069338871882512
tp3779
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3780
(F12.322693972811372
F2.939849560077374
tp3781
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p3782
(F12.910509381975446
F2.87457275390625
tp3783
sS'__revision__ = 3'
p3784
(F10.881840297154017
F2.808868701641376
tp3785
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3786
(F13.077564473054847
F3.033874805157001
tp3787
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p3788
(F12.46083958943685
F3.004383380596454
tp3789
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p3790
(F15.333919420154816
F3.072206350473257
tp3791
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3792
(F11.563753509521485
F2.943125211275541
tp3793
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p3794
(F10.41219140625
F2.745462857759916
tp3795
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3796
(F13.195393880208334
F2.923506810114934
tp3797
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3798
(F13.370391543548886
F3.008287869966947
tp3799
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3800
(F13.963615221854967
F2.8108162513146033
tp3801
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3802
(F12.235109390751008
F2.925333756666917
tp3803
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3804
(F12.871830778301886
F2.9529800415039062
tp3805
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3806
(F14.1653413772583
F3.0886312631460338
tp3807
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3808
(F14.898243151212993
F2.7922979501577525
tp3809
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3810
(F13.806463068181818
F2.8263863783616285
tp3811
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3812
(F15.123156583761867
F2.851969498854417
tp3813
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p3814
(F13.236341516679852
F2.7959949786846456
tp3815
sS'import os'
p3816
(F15.72728157043457
F2.584945091834435
tp3817
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p3818
(F12.43392302973441
F3.0835852989783654
tp3819
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p3820
(F13.567091317012393
F2.917109856238732
tp3821
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p3822
(F13.624135087176066
F2.8561295729417067
tp3823
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3824
(F13.3996379093199
F3.022732661320613
tp3825
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3826
(F12.552802781551932
F2.8795418372521033
tp3827
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()'
p3828
(F10.08466432805647
F2.6671512310321512
tp3829
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p3830
(F14.621807183159722
F2.98736572265625
tp3831
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3832
(F14.998065128504672
F2.8202215341421275
tp3833
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list"
p3834
(F16.59114002046131
F3.1880877568171573
tp3835
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3836
(F15.422463633531441
F3.0177089984600363
tp3837
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p3838
(F14.544900253690036
F2.8904923659104567
tp3839
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3840
(F12.540529361441116
F3.154528397780198
tp3841
sS'for counter_type in perf_object_list:\n    pass'
p3842
(F16.513941147748163
F3.2544300372783956
tp3843
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3844
(F12.36782958984375
F3.1152399503267727
tp3845
sS'def winmem():\n    pass'
p3846
(F7.646704933860085
F2.8304710388183594
tp3847
sS'import datetime'
p3848
(F15.575515747070312
F2.599580324613131
tp3849
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3850
(F11.550902927803456
F2.904865264892578
tp3851
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p3852
(F14.75726669136135
F3.1749276381272535
tp3853
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3854
(F13.04499178310848
F2.7886285048264723
tp3855
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3856
(F13.413261444214358
F2.9727164048414965
tp3857
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3858
(F11.16294204004553
F3.04973631638747
tp3859
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p3860
(F13.225318400065104
F3.1908143850473256
tp3861
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3862
(F13.000243721858919
F3.055299318753756
tp3863
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p3864
(F15.811778880931714
F3.2479705810546875
tp3865
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p3866
(F16.826339721679688
F3.059533926156851
tp3867
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3868
(F13.175494305499189
F2.9263939490685096
tp3869
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p3870
(F13.439741918423397
F3.014402536245493
tp3871
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3872
(F12.46144909441313
F2.9291681142953725
tp3873
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p3874
(F12.826193604793849
F2.991339170015775
tp3875
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p3876
(F14.597612106492159
F2.889104989858774
tp3877
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p3878
(F17.76717278896234
F3.0790176391601562
tp3879
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p3880
(F13.167526935452418
F2.9043584970327525
tp3881
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p3882
(F15.321307712131077
F3.1164720975435696
tp3883
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p3884
(F13.36620554808223
F3.054353273831881
tp3885
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3886
(F13.346745820400677
F3.0054503220778246
tp3887
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p3888
(F15.212696597450657
F2.966237581693209
tp3889
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3890
(F14.973623102361506
F3.0190987220177283
tp3891
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3892
(F11.8933349609375
F2.948024162879357
tp3893
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p3894
(F12.112886405285494
F2.9410101083608775
tp3895
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p3896
(F15.854762027138158
F2.571589836707482
tp3897
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p3898
(F14.963874264039855
F3.16253662109375
tp3899
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p3900
(F11.656003646620091
F2.8462383563701925
tp3901
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p3902
(F13.00579758897188
F3.0606853778545675
tp3903
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p3904
(F11.964054123627092
F3.0829690786508412
tp3905
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p3906
(F10.753939628601074
F2.8441828214205227
tp3907
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p3908
(F12.98057650862069
F3.0623098520132213
tp3909
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p3910
(F12.361526788449755
F2.9196073091947117
tp3911
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3912
(F11.298063579358553
F2.9872665405273438
tp3913
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3914
(F13.436190476190475
F3.0322183462289662
tp3915
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p3916
(F13.857539158241421
F3.0262791560246396
tp3917
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3918
(F13.248958240855824
F3.1472804729755106
tp3919
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3920
(F12.111420355902778
F3.111713409423828
tp3921
sS'pid = os.getpid()\npy = psutil.Process(pid)'
p3922
(F12.085625542534721
F2.6606104924128604
tp3923
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3924
(F13.360279756433824
F3.027653327355018
tp3925
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3926
(F13.579241677989131
F3.0664215087890625
tp3927
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3928
(F11.781858104869633
F3.223077333890475
tp3929
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p3930
(F13.369252400225903
F2.9890301044170675
tp3931
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p3932
(F14.437961059995645
F2.8852565471942606
tp3933
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p3934
(F13.812579254605877
F2.9973983764648438
tp3935
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p3936
(F12.38522603631564
F3.0398841271033654
tp3937
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p3938
(F11.876816891833563
F2.770490206204928
tp3939
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p3940
(F13.367055060078242
F2.9169364342322717
tp3941
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p3942
(F13.370394925458715
F3.0192718505859375
tp3943
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3944
(F14.116157195852987
F2.994132115290715
tp3945
sS'import psutil\npid = os.getpid()'
p3946
(F12.494679768880209
F2.6243074857271633
tp3947
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3948
(F13.25004059866573
F3.0089680598332333
tp3949
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p3950
(F12.873119805897085
F3.0846184950608473
tp3951
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p3952
(F10.854240476623062
F2.6881429232083836
tp3953
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p3954
(F13.111164797473867
F2.9435154841496396
tp3955
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p3956
(F13.550909037103995
F2.94465079674354
tp3957
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p3958
(F14.740232829806171
F3.2806023817795973
tp3959
sS'print this_proc_results'
p3960
(F14.697202682495117
F2.8031205397385817
tp3961
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3962
(F13.282164535635156
F3.045789278470553
tp3963
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p3964
(F13.235936626769746
F3.0623262845552883
tp3965
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3966
(F13.603812188458589
F3.0773224463829627
tp3967
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p3968
(F14.858685772235576
F3.3192593501164365
tp3969
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p3970
(F13.680941495028408
F3.065430861253005
tp3971
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p3972
(F14.796345784992514
F2.925902146559495
tp3973
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p3974
(F13.263927465487898
F3.0538641122671275
tp3975
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict"
p3976
(F15.276410420735678
F3.3076089712289662
tp3977
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p3978
(F11.97368136319247
F3.1534646841195912
tp3979
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p3980
(F14.692291845034246
F2.900179936335637
tp3981
sS'import pywintypes'
p3982
(F14.695377349853516
F2.641386178823618
tp3983
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p3984
(F12.96201155489723
F3.063272622915415
tp3985
sS'if (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p3986
(F12.07746265552662
F3.0996636610764723
tp3987
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p3988
(F13.971550540647645
F2.985041691706731
tp3989
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p3990
(F8.67075862440952
F2.990827413705679
tp3991
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p3992
(F10.2362236328125
F3.1235152024489183
tp3993
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p3994
(F11.451680900224673
F2.923918210543119
tp3995
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p3996
(F12.48994361029731
F3.035801814152644
tp3997
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p3998
(F13.492691962110136
F2.9710326561561
tp3999
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4000
(F14.453171793619791
F2.948455810546875
tp4001
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4002
(F14.743792447176846
F3.132591540996845
tp4003
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p4004
(F10.841762148100754
F2.9175244844876804
tp4005
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p4006
(F9.458627319335937
F2.962977776160607
tp4007
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p4008
(F13.615793228149414
F2.907488015981821
tp4009
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4010
(F13.940356254577637
F3.1543238713191104
tp4011
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4012
(F13.219450378417969
F3.0818440363957333
tp4013
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p4014
(F13.169697442596787
F2.9244912954477162
tp4015
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4016
(F15.003000259399414
F3.1741514939528246
tp4017
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4018
(F10.667267912751312
F2.6798700185922475
tp4019
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4020
(F13.342414096320347
F3.0545035142164965
tp4021
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p4022
(F13.544465612192623
F3.0606888991135817
tp4023
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4024
(F13.782906532287598
F2.8190650939941406
tp4025
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4026
(F14.190381153520331
F2.8804010244516225
tp4027
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4028
(F13.113804575358852
F3.0656441908616285
tp4029
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4030
(F11.990977360652042
F2.721514481764573
tp4031
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4032
(F14.473597084603659
F3.004406268780048
tp4033
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4034
(F14.704710557725694
F3.1174410306490383
tp4035
sS'from __future__ import print_function\nimport os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p4036
(F15.466032085996686
F2.650137974665715
tp4037
sS'import win32com.client'
p4038
(F15.583582560221354
F2.6099962087777944
tp4039
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4040
(F12.01613989373519
F3.155860607440655
tp4041
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4042
(F13.09937519929847
F3.048248291015625
tp4043
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4044
(F13.36434607325073
F2.910665071927584
tp4045
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4046
(F14.208476066589355
F2.860607147216797
tp4047
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4048
(F14.24153468919837
F3.0366827157827525
tp4049
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4050
(F14.944593547952586
F2.9127977811373196
tp4051
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4052
(F13.593446362920169
F3.0593939561110277
tp4053
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4054
(F11.780615234375
F3.0678341205303488
tp4055
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4056
(F14.658177529611896
F2.889225592980018
tp4057
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4058
(F13.365502529456966
F2.9675912123460035
tp4059
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4060
(F15.515218098958334
F3.3584571251502404
tp4061
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4062
(F13.884847138400163
F3.0082547114445615
tp4063
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4064
(F12.22615909576416
F3.087260026198167
tp4065
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p4066
(F15.465534125434028
F2.8075813880333533
tp4067
sS"memoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint('memory use:', memoryUse)"
p4068
(F11.104592600176412
F2.8436255821814904
tp4069
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4070
(F13.425978685461956
F3.007843017578125
tp4071
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4072
(F14.434282990539966
F3.1729451693021336
tp4073
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4074
(F13.446822478991596
F3.036177708552434
tp4075
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4076
(F15.872227894176136
F3.1496605506310096
tp4077
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p4078
(F12.595411028180804
F2.8986232464130106
tp4079
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4080
(F10.197206983379289
F2.6932249802809496
tp4081
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4082
(F12.2759853435797
F2.97810305081881
tp4083
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4084
(F12.41492965986144
F3.0700325599083533
tp4085
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4086
(F14.507898745329484
F3.010579329270583
tp4087
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4088
(F13.537931326116373
F2.903939173771785
tp4089
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4090
(F13.493544523558368
F2.9452784611628604
tp4091
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4092
(F15.142336581615691
F2.8858217092660756
tp4093
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4094
(F14.50543743631114
F2.8431678185096154
tp4095
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4096
(F11.867303859420687
F2.933991945706881
tp4097
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4098
(F13.716267148126658
F3.04646242581881
tp4099
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4100
(F13.579987505117359
F3.067607586200421
tp4101
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4102
(F15.281155873493976
F2.9782741253192606
tp4103
sS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4104
(F15.934884207589286
F2.699904515193059
tp4105
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4106
(F13.14017669040931
F2.9658132699819713
tp4107
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4108
(F13.666744305256225
F3.0217916048490086
tp4109
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4110
(F10.993552723150144
F3.0285609318659854
tp4111
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4112
(F14.315088425239507
F3.075896923358624
tp4113
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4114
(F14.040284501745345
F2.969756786639874
tp4115
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4116
(F12.863814644191576
F2.994915301983173
tp4117
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p4118
(F15.413028114720396
F3.108366159292368
tp4119
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4120
(F13.110130573141165
F3.2006070063664365
tp4121
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4122
(F12.807854839337624
F3.0744109520545373
tp4123
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os'
p4124
(F15.834397670200893
F2.8749160766601562
tp4125
sS'import os\nimport psutil'
p4126
(F15.817860194614955
F2.5997384878305287
tp4127
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4128
(F14.535773782169118
F3.0292833768404446
tp4129
sS'return x'
p4130
(F12.467731475830078
F2.8654295114370494
tp4131
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4132
(F14.365094353170957
F3.228108919583834
tp4133
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4134
(F11.627916048358939
F3.1993819016676683
tp4135
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4136
(F13.252859587716584
F3.0135577275202823
tp4137
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4138
(F12.497971209140436
F3.05868647648738
tp4139
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4140
(F12.878748551510167
F2.799207247220553
tp4141
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4142
(F9.597285679408483
F2.9958865825946512
tp4143
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4144
(F13.00623659620098
F2.9379310607910156
tp4145
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4146
(F14.820194084487275
F3.065442892221304
tp4147
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4148
(F14.57152650122549
F2.8632398752065806
tp4149
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4150
(F14.843745334892516
F3.103393848125751
tp4151
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4152
(F11.031700827858664
F2.83169673039363
tp4153
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p4154
(F9.476391474405924
F2.7502796466533956
tp4155
sS'for result_dict in proc_results:\n    print result_dict'
p4156
(F15.92231920030382
F3.2135963439941406
tp4157
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4158
(F13.569850310114504
F3.044651618370643
tp4159
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4160
(F14.543718009159482
F2.860463655911959
tp4161
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4162
(F13.685008359053498
F3.03285892193134
tp4163
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p4164
(F14.08491913259846
F3.2480633075420675
tp4165
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4166
(F16.32882412997159
F2.7841145442082333
tp4167
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p4168
(F7.642703586154514
F3.3114406879131613
tp4169
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p4170
(F11.983704884847006
F3.0056944627028246
tp4171
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4172
(F13.957973601711783
F3.0284042358398438
tp4173
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4174
(F13.304652014444041
F3.054926945612981
tp4175
sS'def get_pid_stats(self, pid):\n    pass'
p4176
(F14.424367268880209
F2.7046021681565504
tp4177
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4178
(F12.371735677083333
F2.9555740356445312
tp4179
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4180
(F14.846995544433593
F2.787439199594351
tp4181
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4182
(F14.826070785522461
F3.29043696476863
tp4183
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4184
(F13.240174313069476
F3.0408395620492787
tp4185
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4186
(F13.376215508643616
F3.044621100792518
tp4187
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4188
(F14.630361905661962
F2.878305875338041
tp4189
sS"return sys_dict\nif (__name__ == '__main__'):\n    pass"
p4190
(F12.554840850830079
F2.8950814467210035
tp4191
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4192
(F14.661253511235955
F2.8854716374323917
tp4193
sS'from __future__ import print_function'
p4194
(F18.26238098144531
F2.7078628540039062
tp4195
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4196
(F12.692848408116703
F3.167379232553335
tp4197
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4198
(F13.86257595486111
F3.0139066256009617
tp4199
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4200
(F12.781231768719561
F2.9433511587289662
tp4201
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4202
(F13.525967684659092
F3.02751218355619
tp4203
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4204
(F10.655224768944036
F3.1570191016564
tp4205
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4206
(F14.319209135780039
F2.8364325303297777
tp4207
sS'proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4208
(F14.560435225323934
F3.2857979994553785
tp4209
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4210
(F12.500059369184243
F2.933894230769231
tp4211
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4212
(F15.54816623263889
F3.0163612365722656
tp4213
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4214
(F15.162133110894096
F3.1557652400090146
tp4215
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4216
(F13.70298691705707
F3.030636714054988
tp4217
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4218
(F12.66836759868421
F3.0448573185847354
tp4219
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4220
(F12.82572125040167
F2.990077385535607
tp4221
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4222
(F11.253550618489584
F3.115923661452073
tp4223
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4224
(F12.33138677125336
F3.0475105872521033
tp4225
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4226
(F8.778871167607669
F3.0385026198167067
tp4227
sS'if (not self.process_name_list):\n    found_flag = True'
p4228
(F15.008404818448154
F2.9900151766263523
tp4229
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4230
(F15.668322035845588
F3.1296759385329027
tp4231
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()"
p4232
(F11.781380393288352
F2.8289991525503306
tp4233
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4234
(F12.849840538050248
F3.0210638779860277
tp4235
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p4236
(F12.138153076171875
F2.9050862238957333
tp4237
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4238
(F14.534580625336746
F2.9867107684795675
tp4239
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4240
(F13.734498221919221
F2.9809966454139123
tp4241
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4242
(F11.754639398484002
F2.8579993614783654
tp4243
sS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4244
(F14.9397412109375
F2.739498725304237
tp4245
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4246
(F14.307259299538352
F3.2681963993952823
tp4247
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4248
(F11.182423976872931
F3.1412394596980167
tp4249
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4250
(F14.476123951099536
F2.951859400822566
tp4251
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4252
(F13.846308765076754
F3.0424839900090146
tp4253
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4254
(F13.18792093211207
F3.0507563077486477
tp4255
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4256
(F13.113274801002358
F3.0115940387432394
tp4257
sS'if (not self.perf_object_list):\n    pass'
p4258
(F13.761059231228298
F3.0116494985727162
tp4259
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4260
(F12.494449752697841
F3.0934844383826623
tp4261
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4262
(F13.133046875
F3.0375738877516527
tp4263
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4264
(F13.736134449196927
F3.0191670931302586
tp4265
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4266
(F12.57086181640625
F3.03879635150616
tp4267
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4268
(F13.181431361607142
F3.1095941983736477
tp4269
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4270
(F13.396413978623466
F3.074617239145132
tp4271
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4272
(F13.548581924116561
F3.0297930790827823
tp4273
sS'if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p4274
(F15.551825387137276
F3.170755826509916
tp4275
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4276
(F10.501020011255296
F2.738170330341046
tp4277
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4278
(F12.9259530369909
F3.0763080303485575
tp4279
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4280
(F11.338293063256048
F3.094805203951322
tp4281
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4282
(F10.269390815127212
F2.7515792846679688
tp4283
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4284
(F11.89337789601293
F2.765544597919171
tp4285
sS'return proc_results_list'
p4286
(F14.186908721923828
F2.9220410860501804
tp4287
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4288
(F12.754746633558417
F3.064699026254507
tp4289
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4290
(F13.06691050306659
F2.869763887845553
tp4291
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4292
(F15.242560369318182
F2.9530410766601562
tp4293
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4294
(F13.083928817357773
F3.076955355130709
tp4295
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4296
(F12.972731838022687
F3.06015865619366
tp4297
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4298
(F13.339181973071808
F2.806824023907001
tp4299
sS'for proc_name in self.process_name_list:\n    pass'
p4300
(F16.363258763363486
F3.0374808678260217
tp4301
sS"for counter_type in perf_object_list:\n    strComputer = '.'"
p4302
(F16.220970153808594
F3.232509026160607
tp4303
sS"strComputer = '.'"
p4304
(F11.216870625813803
F2.779004317063552
tp4305
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4306
(F14.446488457094052
F2.8774839547964244
tp4307
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4308
(F10.613433368389423
F2.7331939110389123
tp4309
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4310
(F14.412984688545151
F2.870740156907302
tp4311
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4312
(F13.345213591746795
F3.0060336773212137
tp4313
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4314
(F11.886393229166666
F3.060376680814303
tp4315
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4316
(F10.831750186873071
F3.0942506056565504
tp4317
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    for attribute in self.supported_types[counter_type]:\n        pass"
p4318
(F14.452668623490768
F2.8453028752253604
tp4319
sS'pid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p4320
(F11.957360076904298
F2.728179931640625
tp4321
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4322
(F12.251312376482213
F2.953865931584285
tp4323
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4324
(F14.740825607115964
F2.8208480248084435
tp4325
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4326
(F15.0072021484375
F2.855845231276292
tp4327
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4328
(F14.849859064275568
F3.323841388408954
tp4329
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4330
(F11.812342229879127
F2.964489276592548
tp4331
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4332
(F13.414604803856383
F3.031062492957482
tp4333
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p4334
(F15.209183887768818
F3.296940730168269
tp4335
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict"
p4336
(F14.858429211528362
F3.259370657113882
tp4337
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4338
(F12.62939453125
F2.944818056546725
tp4339
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4340
(F14.613250203215317
F2.8042678833007812
tp4341
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4342
(F13.058326043677607
F2.8828626779409556
tp4343
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4344
(F13.726387108508868
F3.069546626164363
tp4345
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4346
(F13.234169407894736
F3.0706569965069113
tp4347
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4348
(F12.211688311688311
F3.0978035560021033
tp4349
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p4350
(F15.20754552770544
F3.183111630953275
tp4351
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4352
(F13.279045595760234
F3.0626211899977465
tp4353
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4354
(F13.027984091154844
F3.102855975811298
tp4355
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p4356
(F13.5167922061753
F3.02625480064979
tp4357
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4358
(F14.642581316380719
F2.8905531076284556
tp4359
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4360
(F13.096109055579216
F2.8941221970778246
tp4361
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p4362
(F15.010032653808594
F2.5915357149564304
tp4363
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p4364
(F10.516667002255154
F2.670196826641376
tp4365
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4366
(F12.13209728627478
F2.960541064922626
tp4367
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4368
(F13.080381163363327
F3.1391707200270433
tp4369
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4370
(F13.392990577376633
F2.9499602684607873
tp4371
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4372
(F14.142430094032806
F2.8467354407677283
tp4373
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p4374
(F12.77219313018176
F2.9718413719764123
tp4375
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4376
(F15.434459339488637
F3.2811258756197414
tp4377
sS'import pywintypes\nimport datetime'
p4378
(F16.356033325195312
F2.569432185246394
tp4379
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p4380
(F8.971974965688345
F2.9356155395507812
tp4381
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass'
p4382
(F15.050886483028018
F2.9008827209472656
tp4383
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4384
(F14.327152391194332
F2.857340592604417
tp4385
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4386
(F14.502234150179856
F2.8914454533503604
tp4387
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4388
(F13.035759033861186
F3.040514725905198
tp4389
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4390
(F14.310977142636139
F2.954235370342548
tp4391
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4392
(F13.698304177989131
F3.0432877173790565
tp4393
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4394
(F11.07403310139974
F3.120919154240535
tp4395
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4396
(F15.115572929382324
F2.836075415978065
tp4397
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4398
(F14.727049382163324
F2.909885993370643
tp4399
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4400
(F12.529516922800164
F2.9921475923978367
tp4401
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4402
(F15.4639579959032
F2.9336653489332933
tp4403
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4404
(F14.681899562026516
F2.7458616403432994
tp4405
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4406
(F14.527027231402101
F2.859320127047025
tp4407
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p4408
(F8.859979135018808
F3.1219632075383115
tp4409
sS'import pythoncom\nimport pywintypes'
p4410
(F15.609848022460938
F2.6153177114633412
tp4411
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4412
(F12.816126598011364
F2.9277132474459133
tp4413
sS'this_proc_results = stats_processor.get_pid_stats(this_pid)'
p4414
(F15.578885165127842
F2.787695077749399
tp4415
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4416
(F12.97172589983259
F3.0611953735351562
tp4417
sS'obj_name = objItem.Name'
p4418
(F16.00323486328125
F2.953631180983323
tp4419
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4420
(F15.472355513139204
F3.0054121751051683
tp4421
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4422
(F13.446595815730616
F2.9661231407752404
tp4423
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p4424
(F14.918253950639205
F3.24986824622521
tp4425
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4426
(F12.849441652375509
F3.0455463115985575
tp4427
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4428
(F15.415030394785504
F3.0193167466383715
tp4429
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4430
(F14.906726298888037
F2.847733424260066
tp4431
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4432
(F14.459522235576923
F2.941508073073167
tp4433
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p4434
(F10.690134295980439
F2.678129636324369
tp4435
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4436
(F13.931988340435606
F3.0738035348745494
tp4437
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4438
(F13.548922584170388
F3.065679696890024
tp4439
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        for attribute in self.supported_types[counter_type]:\n            pass"
p4440
(F14.68789333767361
F2.927327669583834
tp4441
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4442
(F13.527250936208677
F3.04410641009991
tp4443
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4444
(F13.972467958537582
F3.033694634070763
tp4445
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4446
(F14.860765697337962
F3.1216709430401144
tp4447
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4448
(F13.017259803185096
F2.877243922306941
tp4449
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4450
(F11.878436344926076
F3.1808527432955227
tp4451
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p4452
(F12.922583059647028
F2.9040292593149037
tp4453
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4454
(F12.954088553230461
F3.0806644146259012
tp4455
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p4456
(F12.83937223377146
F2.926945612980769
tp4457
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4458
(F11.810785821143616
F3.0741201547475963
tp4459
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4460
(F15.731968643641707
F2.96409665621244
tp4461
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4462
(F12.880349752786277
F3.0801635155311
tp4463
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4464
(F12.725467692752849
F2.9859319833608775
tp4465
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4466
(F14.238085390916511
F2.872118729811448
tp4467
sS'from __future__ import print_function\nimport os\nimport psutil'
p4468
(F18.4285888671875
F2.638262235201322
tp4469
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4470
(F9.32808897925205
F3.171138176551232
tp4471
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4472
(F14.995764992453836
F2.802612011249249
tp4473
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4474
(F12.78405966305866
F2.98718995314378
tp4475
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4476
(F14.418763270361499
F2.9727436945988583
tp4477
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4478
(F12.788660561166159
F3.0633178124061
tp4479
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4480
(F13.059741816244834
F3.176942385160006
tp4481
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4482
(F14.47898383989726
F2.8572775033804088
tp4483
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4484
(F13.217338084446565
F3.070882063645583
tp4485
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4486
(F14.1860390625
F3.033807314359225
tp4487
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4488
(F15.004155503517671
F2.827508779672476
tp4489
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4490
(F14.226065286775915
F3.0927769587590146
tp4491
sS'py = psutil.Process(pid)'
p4492
(F11.357211303710937
F2.767502711369441
tp4493
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p4494
(F13.162158038165119
F2.9010675870455227
tp4495
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4496
(F13.382065978818389
F2.963700221135066
tp4497
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4498
(F14.142414093017578
F2.985565185546875
tp4499
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4500
(F12.148052793560606
F3.1009788513183594
tp4501
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4502
(F11.806533988864942
F2.7658905616173377
tp4503
sS'import os\nthis_pid = os.getpid()'
p4504
(F14.02721187046596
F2.64950444148137
tp4505
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4506
(F14.668475691679935
F2.7685279846191406
tp4507
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4508
(F13.8134984375
F3.0134113018329325
tp4509
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4510
(F12.938505977033133
F2.995765392596905
tp4511
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4512
(F15.333951822916667
F3.1117354172926683
tp4513
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4514
(F15.21258544921875
F2.994521214411809
tp4515
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4516
(F14.24675246904481
F2.9905565701998196
tp4517
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p4518
(F13.638014439174107
F3.0154524583082933
tp4519
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4520
(F13.702785427907674
F3.0480786837064304
tp4521
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4522
(F11.899634072946947
F3.045458280123197
tp4523
sS'pythoncom.CoInitialize()\nproc_results_list = []'
p4524
(F11.354079302619486
F2.88807619535006
tp4525
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4526
(F12.340325834787437
F3.117724198561448
tp4527
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4528
(F13.199011397688356
F2.8961345966045675
tp4529
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4530
(F14.17338621682961
F3.00630129300631
tp4531
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4532
(F13.054584155036407
F2.9242412860576925
tp4533
sS'return this_proc_dict\n\ndef get_stats(self):\n    pass'
p4534
(F13.132973410866477
F2.9314017662635217
tp4535
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4536
(F11.811625162760416
F3.0736409700833836
tp4537
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()"
p4538
(F11.651161193847656
F2.8393161480243387
tp4539
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p4540
(F12.99229005071599
F2.9955949049729567
tp4541
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4542
(F9.559196686076227
F3.0524972768930287
tp4543
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4544
(F13.035123208411655
F3.0342685992901144
tp4545
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4546
(F9.431360547787675
F3.063780271089994
tp4547
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p4548
(F7.654237634995404
F3.0183114271897535
tp4549
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4550
(F10.777942931729983
F3.1827005239633412
tp4551
sS'this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p4552
(F15.991360664367676
F2.7188028188852162
tp4553
sS'windll.kernel32.GlobalMemoryStatus(byref(x))'
p4554
(F11.807035319010417
F2.869985140286959
tp4555
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4556
(F15.266317724212398
F2.80986081636869
tp4557
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4558
(F14.545700209888059
F2.9274330139160156
tp4559
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4560
(F11.949079842403018
F3.083272787240835
tp4561
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4562
(F13.462064834897308
F2.9569303072415867
tp4563
sS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4564
(F15.620676141036185
F2.66587888277494
tp4565
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4566
(F15.787688337053572
F3.024534959059495
tp4567
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4568
(F11.20206104625355
F2.897606189434345
tp4569
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4570
(F13.228916015625
F2.8857457087590146
tp4571
sS"break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4572
(F14.444747121710526
F3.2100680424616885
tp4573
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4574
(F15.003780177382172
F3.236660883976863
tp4575
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4576
(F11.633089144554363
F2.7999117924616885
tp4577
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4578
(F12.920789147111913
F3.0814379178560696
tp4579
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4580
(F12.26061760027384
F3.0805429311899037
tp4581
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p4582
(F9.656808205021237
F2.9322110689603367
tp4583
sS"' Returns a dictionary of the system stats'"
p4584
(F2.8216164906819663
F2.7552452087402344
tp4585
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p4586
(F14.91924522662985
F3.0052061814528246
tp4587
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4588
(F12.401223803323413
F3.0203816340519833
tp4589
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4590
(F12.152601580753505
F3.0948145939753604
tp4591
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4592
(F12.02362060546875
F3.0625586876502404
tp4593
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'"
p4594
(F13.000585141389266
F2.875655247614934
tp4595
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4596
(F13.001940558938418
F3.013814485990084
tp4597
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4598
(F12.362269653867713
F3.155436002291166
tp4599
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4600
(F12.019449422647664
F3.1334988520695615
tp4601
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4602
(F14.399765014648438
F2.997484647310697
tp4603
sS'if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p4604
(F13.618720269972279
F2.896388127253606
tp4605
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4606
(F12.905567089160838
F3.078547551081731
tp4607
sS'for proc_name in self.process_name_list:\n    obj_name = objItem.Name'
p4608
(F16.935206486628605
F3.0629381033090444
tp4609
sS'from __future__ import print_function\nimport psutil'
p4610
(F18.390203622671272
F2.68232668363131
tp4611
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4612
(F13.395184779271288
F2.8427379314716044
tp4613
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4614
(F13.189333285737598
F3.056553473839393
tp4615
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4616
(F13.621047604739012
F3.0626983642578125
tp4617
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4618
(F13.81340183423913
F3.045857943021334
tp4619
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4620
(F13.524017333984375
F2.9140648475060096
tp4621
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4622
(F14.605065548058713
F2.864444145789513
tp4623
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4624
(F15.433850740131579
F3.1458059457632213
tp4625
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4626
(F13.610413015133378
F2.9271797767052283
tp4627
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p4628
(F12.884378653805273
F3.0788973294771633
tp4629
sS'from __future__ import print_function\nimport os'
p4630
(F19.02867713341346
F2.652423565204327
tp4631
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4632
(F13.857696940104166
F3.0263501680814304
tp4633
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4634
(F13.031788564955962
F3.041980743408203
tp4635
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4636
(F13.398358674327355
F2.9217200646033654
tp4637
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4638
(F12.127151150173612
F3.1025094252366285
tp4639
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p4640
(F12.341299438476563
F3.0160578214205227
tp4641
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4642
(F13.379561465010683
F2.9069281357985277
tp4643
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4644
(F14.369974772135416
F2.8567220247708836
tp4645
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass'
p4646
(F10.770214160839162
F2.67805422269381
tp4647
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4648
(F14.355503627232142
F2.866869706373948
tp4649
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4650
(F12.854512758106985
F2.8773926955003004
tp4651
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4652
(F14.256803763929264
F3.061014615572416
tp4653
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4654
(F12.814247427786299
F3.058948223407452
tp4655
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p4656
(F8.93301700206285
F2.952752920297476
tp4657
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4658
(F13.199430458660055
F2.887515434852013
tp4659
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4660
(F12.070239020782767
F3.156844505896935
tp4661
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4662
(F13.09162556276483
F2.959278400127704
tp4663
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4664
(F13.411045087394069
F3.086626493013822
tp4665
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4666
(F13.738352296213625
F3.0863899817833533
tp4667
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4668
(F15.355691135519802
F2.8214756892277646
tp4669
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4670
(F13.347715350324208
F2.9678884652944713
tp4671
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4672
(F12.539884266954788
F3.013522514930138
tp4673
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4674
(F13.63850964997944
F2.9864622262807994
tp4675
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4676
(F13.57205385358146
F3.0176720252403846
tp4677
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3'
p4678
(F9.53122287326389
F2.771087646484375
tp4679
sS'break\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4680
(F13.3174680074056
F2.9080904447115383
tp4681
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4682
(F13.584526458549895
F3.061198894794171
tp4683
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4684
(F14.779668898809524
F2.9086162860576925
tp4685
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4686
(F14.701388549804687
F3.1110443702110877
tp4687
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4688
(F11.470105401400861
F3.068089411808894
tp4689
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4690
(F11.955856169113005
F3.132832747239333
tp4691
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4692
(F13.094371724572982
F2.9706617502065806
tp4693
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4694
(F11.295251424556518
F3.0939207810621996
tp4695
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4696
(F14.72253154507644
F2.804107959453876
tp4697
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p4698
(F8.91519416360294
F2.934404813326322
tp4699
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4700
(F12.318073871707128
F3.086309579702524
tp4701
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4702
(F12.679035919391556
F2.9393257727989783
tp4703
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4704
(F12.427486439443005
F2.8963047907902646
tp4705
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p4706
(F9.66084185850273
F2.961706308218149
tp4707
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p4708
(F15.664731885566086
F3.178020183856671
tp4709
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p4710
(F12.924268748662243
F3.074197915884165
tp4711
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4712
(F15.36126708984375
F3.0638052133413463
tp4713
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4714
(F14.49257443985849
F2.918329092172476
tp4715
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4716
(F13.370430080369971
F3.0442454998309794
tp4717
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p4718
(F9.155417798913044
F3.1784031207744894
tp4719
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4720
(F13.350435251298219
F2.9165493891789365
tp4721
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4722
(F14.68390877016129
F2.908568162184495
tp4723
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4724
(F10.457278667680368
F3.07272221491887
tp4725
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4726
(F14.180403001237623
F3.132401393010066
tp4727
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4728
(F15.32841728102993
F3.1548582223745494
tp4729
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4730
(F13.094284160025168
F2.9837802006648135
tp4731
sS"print('memory use:', memoryUse)"
p4732
(F9.077211168077257
F2.736856607290415
tp4733
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4734
(F11.36100136361471
F2.9941670344426083
tp4735
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4736
(F13.746672555301966
F3.0155252309945912
tp4737
sS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p4738
(F13.056162516276041
F2.655117621788612
tp4739
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4740
(F14.694228135146103
F3.1152566763070912
tp4741
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4742
(F13.695437869510135
F3.0690348698542667
tp4743
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4744
(F12.951803419325087
F2.98263432429387
tp4745
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4746
(F11.949820357270774
F3.1548456045297475
tp4747
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4748
(F14.039730105779867
F3.0082118694598856
tp4749
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4750
(F13.074686387005974
F2.991824223445012
tp4751
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4752
(F15.169679478236608
F2.7716903686523438
tp4753
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4754
(F13.141982421875
F2.881823026216947
tp4755
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p4756
(F13.763047438401442
F2.819093264066256
tp4757
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4758
(F12.95027824415078
F3.074529794546274
tp4759
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4760
(F13.509799439490997
F2.9080804678109975
tp4761
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p4762
(F13.617732411807346
F3.0418040935809794
tp4763
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4764
(F13.555370107323233
F3.0261297959547777
tp4765
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p4766
(F15.5635947265625
F3.038298093355619
tp4767
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p4768
(F12.957353273502067
F3.079683157113882
tp4769
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p4770
(F11.714353242543693
F2.8547997107872596
tp4771
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p4772
(F15.115008911799864
F2.966779562143179
tp4773
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4774
(F12.34289231225458
F2.961399665245643
tp4775
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    pass'
p4776
(F13.569541529605264
F3.114238445575421
tp4777
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4778
(F14.067620399014261
F3.034745143010066
tp4779
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p4780
(F16.653709898603722
F3.177475855900691
tp4781
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4782
(F14.296756535139767
F3.04777585543119
tp4783
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p4784
(F12.905728800912922
F2.903731419489934
tp4785
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p4786
(F12.891732533772787
F2.599713545579177
tp4787
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4788
(F11.809495713975695
F2.73148433978741
tp4789
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4790
(F13.716166889750873
F3.043558560884916
tp4791
sS'x = winmem()'
p4792
(F8.112097603934151
F2.9039864173302283
tp4793
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4794
(F14.041215137768818
F2.9723099928635817
tp4795
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4796
(F14.049397395207333
F2.989665691669171
tp4797
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4798
(F11.461468345240542
F2.843449225792518
tp4799
sS'break\nreturn this_proc_dict'
p4800
(F14.813850402832031
F2.921141110933744
tp4801
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4802
(F12.745490893983005
F2.925425015963041
tp4803
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4804
(F11.684795673076923
F2.720531463623047
tp4805
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4806
(F12.443116138599537
F3.091146028958834
tp4807
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p4808
(F14.824397087097168
F3.0492007915790262
tp4809
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4810
(F14.881737294823232
F2.8095130920410156
tp4811
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4812
(F15.477891593143857
F2.826766087458684
tp4813
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4814
(F14.106554887426181
F2.8615655165452223
tp4815
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4816
(F11.931270076538706
F3.132208017202524
tp4817
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p4818
(F11.474439061330465
F3.102147028996394
tp4819
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4820
(F14.45268605727352
F2.895951197697566
tp4821
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4822
(F11.398920196333743
F2.8335536076472354
tp4823
sS"import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p4824
(F15.928008355034722
F2.676776885986328
tp4825
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p4826
(F12.294220476519337
F3.086535233717698
tp4827
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p4828
(F14.345792729803856
F3.256043654221755
tp4829
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4830
(F13.701302431483958
F3.0208790118877706
tp4831
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4832
(F10.819333224826389
F3.1599185650165262
tp4833
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p4834
(F13.657298977092161
F3.062950427715595
tp4835
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p4836
(F15.206040736607143
F3.264023707463191
tp4837
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p4838
(F11.986119588216146
F3.1331100463867188
tp4839
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4840
(F10.919817119625444
F2.6871734032264123
tp4841
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p4842
(F14.396349402947154
F3.159117478590745
tp4843
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4844
(F12.757431187580542
F2.9859384390024037
tp4845
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p4846
(F11.237086825900608
F2.9375223013070912
tp4847
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p4848
(F15.766577518347537
F2.5786749032827525
tp4849
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p4850
(F13.082016397338403
F2.880738771878756
tp4851
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4852
(F13.310814153135212
F3.0796403151292067
tp4853
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4854
(F12.632819741459215
F3.0585353557880106
tp4855
sS'pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4856
(F14.362105931991186
F2.969034928541917
tp4857
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p4858
(F14.959881406841856
F3.163972707895132
tp4859
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p4860
(F14.680563278469752
F2.90750004695012
tp4861
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p4862
(F13.249836024953359
F2.9104766845703125
tp4863
sS'found_flag = True'
p4864
(F13.83616202218192
F2.819315396822416
tp4865
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4866
(F12.8978740234375
F3.016633547269381
tp4867
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4868
(F13.43787145322086
F3.065922663762019
tp4869
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p4870
(F13.177610407221502
F2.9223128098707933
tp4871
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4872
(F13.268105418411727
F3.152909205510066
tp4873
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p4874
(F14.726941956103373
F2.89762937105619
tp4875
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p4876
(F12.90200865502451
F3.0647007868840146
tp4877
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p4878
(F10.755661349826388
F2.71348630464994
tp4879
sS'print(psutil.cpu_percent())\nprint(psutil.virtual_memory())'
p4880
(F13.05392721424932
F2.6990013122558594
tp4881
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p4882
(F15.039545623349472
F2.828875321608323
tp4883
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4884
(F13.038847940226171
F3.0810552743765025
tp4885
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p4886
(F13.770928851628709
F2.9821695181039662
tp4887
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4888
(F11.857030080464073
F3.0890655517578125
tp4889
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4890
(F15.247764818596117
F2.8439266498272238
tp4891
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p4892
(F15.437862772337148
F3.212397942176232
tp4893
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p4894
(F13.563154055748457
F3.1502459599421573
tp4895
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p4896
(F10.044238074351165
F2.9186641986553488
tp4897
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p4898
(F12.97966857618122
F3.0652615473820615
tp4899
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p4900
(F13.099517039763622
F2.899265876183143
tp4901
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'"
p4902
(F11.83980204264323
F2.8109717735877404
tp4903
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p4904
(F14.972496712561881
F3.08957026554988
tp4905
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4906
(F13.381681896391369
F2.9213541471041164
tp4907
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4908
(F14.721644993832237
F2.935443878173828
tp4909
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p4910
(F11.658665865384615
F2.921620882474459
tp4911
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4912
(F12.99072055158944
F2.7389271075908956
tp4913
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p4914
(F12.046912241790254
F3.1315521827110877
tp4915
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p4916
(F12.294081431825447
F3.0705830500676083
tp4917
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p4918
(F11.092858009089053
F3.0990160428560696
tp4919
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p4920
(F12.789883623486158
F3.0990371704101562
tp4921
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p4922
(F13.152003725763201
F2.901202862079327
tp4923
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4924
(F13.177984300947868
F3.050299130953275
tp4925
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p4926
(F15.29653591579861
F3.147632305438702
tp4927
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4928
(F13.998532626295336
F2.999185708852915
tp4929
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name'
p4930
(F15.63555908203125
F3.0906703655536356
tp4931
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4932
(F12.690109740653538
F2.8693257845365086
tp4933
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p4934
(F12.737613897587954
F2.87056644146259
tp4935
sS'import win32com.client\nfrom ctypes import *'
p4936
(F16.05666004527699
F2.582376626821665
tp4937
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p4938
(F14.284560744826859
F3.3015814561110277
tp4939
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p4940
(F14.41466796875
F3.2610831627478967
tp4941
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))'
p4942
(F10.530560493469238
F2.6773241483248196
tp4943
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p4944
(F13.622237384450884
F3.0638944185697117
tp4945
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p4946
(F13.176860373858448
F3.0043006310096154
tp4947
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p4948
(F11.611227596507353
F2.8581293546236477
tp4949
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p4950
(F13.556629269622093
F3.0823050278883715
tp4951
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p4952
(F13.118764433470911
F3.0213570227989783
tp4953
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p4954
(F13.781097233644006
F3.019195556640625
tp4955
sS'class process_stats:\n    pass'
p4956
(F12.245857932350852
F2.7839214618389425
tp4957
sS'return x\n\n\nclass process_stats:\n    pass'
p4958
(F11.612223625183105
F2.8143797654371996
tp4959
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4960
(F13.252835485329582
F3.08175776554988
tp4961
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p4962
(F11.979567522321428
F3.01448733990009
tp4963
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p4964
(F17.03790980747768
F3.2271751990685096
tp4965
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p4966
(F13.410639177288925
F3.131360567533053
tp4967
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p4968
(F14.761897742587601
F2.865147223839393
tp4969
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4970
(F12.046984511638374
F2.951326223520132
tp4971
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p4972
(F14.88250547466856
F2.8199718181903544
tp4973
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p4974
(F13.273886161938048
F3.022594451904297
tp4975
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p4976
(F13.191044921875
F2.987537090594952
tp4977
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p4978
(F11.893372938368056
F2.731028043306791
tp4979
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p4980
(F13.176520432692307
F3.0732938326322117
tp4981
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p4982
(F13.916038525963149
F3.0367035498985877
tp4983
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p4984
(F12.094561155572492
F2.8768254793607273
tp4985
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p4986
(F14.512026888652912
F2.964238093449519
tp4987
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p4988
(F13.554174855444387
F3.0630264282226562
tp4989
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p4990
(F12.937634154040405
F2.902464353121244
tp4991
sS"for objItem in colItems:\n    if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n        pass"
p4992
(F13.172896926467484
F2.864575606126052
tp4993
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p4994
(F14.136073521205358
F2.864062089186448
tp4995
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p4996
(F11.619049627130682
F3.0882908747746396
tp4997
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak'
p4998
(F15.025204542206556
F3.03370607816256
tp4999
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5000
(F15.68259332413064
F3.0307088998647838
tp5001
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p5002
(F12.460040398363796
F3.1687933114858775
tp5003
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5004
(F12.993891018540111
F3.1280467693622294
tp5005
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p5006
(F12.500195821126303
F2.865415719839243
tp5007
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '"
p5008
(F15.081715119190704
F3.297236515925481
tp5009
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5010
(F14.16519319168245
F2.8519134521484375
tp5011
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5012
(F13.36046362704918
F3.0045926020695615
tp5013
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p5014
(F10.10064828996178
F3.1617132333608775
tp5015
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5016
(F12.35205340641801
F2.9569631723257213
tp5017
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5018
(F13.940520167731629
F3.0062179565429688
tp5019
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5020
(F12.374672801224227
F2.888393988976112
tp5021
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5022
(F13.783013283902802
F3.016313993013822
tp5023
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5024
(F13.711734297263682
F3.0212613619290867
tp5025
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5026
(F13.297473215917398
F3.0256869976337137
tp5027
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p5028
(F12.606675136236497
F3.0454013531024637
tp5029
sS'import psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5030
(F12.526709268259447
F2.7240066528320312
tp5031
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    pass'
p5032
(F14.857124730160361
F3.0271022503192606
tp5033
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5034
(F14.467596606673482
F2.909265371469351
tp5035
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5036
(F13.1815472249546
F3.048593961275541
tp5037
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5038
(F14.229478870738637
F3.1917134798490086
tp5039
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5040
(F8.635676686356707
F2.9723246647761417
tp5041
sS'if found_flag:\n    pass'
p5042
(F11.789905894886363
F2.8235379732572117
tp5043
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5044
(F14.003883726317957
F3.030423091008113
tp5045
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5046
(F11.619518352004716
F2.9191727271446815
tp5047
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5048
(F12.750439324290896
F2.9831842275766225
tp5049
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5050
(F7.647327656648597
F2.9857811560997596
tp5051
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5052
(F15.003237516983695
F3.0511770982008715
tp5053
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5054
(F13.297686212713069
F3.040691082294171
tp5055
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5056
(F13.443293092477376
F2.9432455209585338
tp5057
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5058
(F14.4854121387453
F2.7544080294095554
tp5059
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5060
(F14.970786100898692
F2.9406697199894833
tp5061
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5062
(F13.481004240763122
F2.9037642845740685
tp5063
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p5064
(F11.697554548816568
F2.8495944096491885
tp5065
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5066
(F12.585086059570312
F2.6206427354079027
tp5067
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5068
(F12.541331116582306
F2.9344227130596456
tp5069
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5070
(F14.682410916872938
F2.8905583895169773
tp5071
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5072
(F12.600542672072784
F3.1546930166391225
tp5073
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5074
(F13.132129726890756
F2.944416046142578
tp5075
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5076
(F12.876165053423714
F3.099218515249399
tp5077
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5078
(F13.70510440929089
F3.0330995412973256
tp5079
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5080
(F12.976273551404374
F3.0568838853102465
tp5081
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5082
(F12.080182364817416
F2.945068359375
tp5083
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5084
(F15.219708066998106
F2.983337695782001
tp5085
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5086
(F10.06154425569283
F3.2001430804912863
tp5087
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5088
(F12.962118638833992
F3.16393309373122
tp5089
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5090
(F15.342063413847477
F3.19475584763747
tp5091
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5092
(F14.834944100215518
F3.0648140540489783
tp5093
sS"for attribute in self.supported_types[counter_type]:\n    eval_str = ('objItem.%s' % attribute)"
p5094
(F15.578384399414062
F3.0632969782902646
tp5095
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5096
(F12.339368442406402
F3.081720205453726
tp5097
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5098
(F12.094949121633288
F3.145946209247296
tp5099
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5100
(F11.265402088994565
F3.0146378737229567
tp5101
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5102
(F13.068264121539983
F2.959171882042518
tp5103
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5104
(F13.053249606838474
F3.05715091411884
tp5105
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5106
(F11.752244215745192
F3.123107616717999
tp5107
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5108
(F11.692015969073834
F3.1107362600473256
tp5109
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p5110
(F16.36724853515625
F2.568998776949369
tp5111
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5112
(F14.665882038620284
F3.021556560809796
tp5113
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5114
(F12.410055534024151
F2.897766406719501
tp5115
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5116
(F12.671526590983072
F2.9204095693734975
tp5117
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5118
(F11.373140052930843
F3.1644442631648135
tp5119
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5120
(F14.835855180066398
F2.9178416912372294
tp5121
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5122
(F12.987837357954545
F2.890278155987079
tp5123
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5124
(F14.541932091346155
F2.88686282818134
tp5125
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5126
(F12.803579006354457
F2.995179396409255
tp5127
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5128
(F13.54914157673464
F3.0308177654559794
tp5129
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5130
(F13.38664889574392
F3.0383805495042067
tp5131
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5132
(F12.71984828304083
F2.987238957331731
tp5133
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5134
(F9.2822021484375
F3.088499509371244
tp5135
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5136
(F12.36173943580665
F2.7376588674692006
tp5137
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5138
(F13.772993607954545
F3.03862791794997
tp5139
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5140
(F13.626848269731571
F3.086810772235577
tp5141
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5142
(F10.924942016601562
F2.9001215421236477
tp5143
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5144
(F14.481164044498849
F2.8587247408353367
tp5145
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5146
(F12.424897065033784
F3.0845647958608775
tp5147
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5148
(F13.08700518540933
F3.1008280240572414
tp5149
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5150
(F12.49524538919806
F3.072130643404447
tp5151
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p5152
(F11.798048354640152
F2.890469477726863
tp5153
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5154
(F13.192740462662337
F3.0551364605243387
tp5155
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5156
(F14.416612850722446
F3.208355243389423
tp5157
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5158
(F14.508568715240996
F2.9714202880859375
tp5159
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5160
(F14.654515625
F2.8880072373610277
tp5161
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5162
(F12.865539870337042
F2.9893065232496996
tp5163
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5164
(F12.80527126198948
F3.049558786245493
tp5165
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5166
(F12.16690454727564
F3.1711754432091346
tp5167
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5168
(F13.576708882861226
F3.0304659329927883
tp5169
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5170
(F13.841602091324459
F3.0533805260291467
tp5171
sS'from __future__ import print_function\nimport os\nimport psutil\npid = os.getpid()'
p5172
(F16.110323588053387
F2.64470701951247
tp5173
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5174
(F14.429629165514381
F2.849942133976863
tp5175
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5176
(F14.419078223033301
F3.0299312884990988
tp5177
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5178
(F12.16093986265121
F3.095113314115084
tp5179
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5180
(F13.27267565046038
F2.875486520620493
tp5181
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5182
(F13.130833382842205
F2.9452215341421275
tp5183
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5184
(F14.341233473557692
F3.0482559204101562
tp5185
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5186
(F12.305092259457236
F3.1550689110389123
tp5187
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime'
p5188
(F16.475833468967014
F2.572503896859976
tp5189
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5190
(F14.035427268491972
F3.034246884859525
tp5191
sS"this_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5192
(F15.410325050354004
F2.7402132474459133
tp5193
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5194
(F13.216290780914699
F2.9759867741511417
tp5195
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5196
(F15.574406623840332
F2.569042205810547
tp5197
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5198
(F11.708959406072443
F2.803395784818209
tp5199
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5200
(F8.398885336266943
F3.05458743755634
tp5201
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5202
(F13.130965482271634
F2.9036988478440504
tp5203
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p5204
(F13.912272914174642
F3.002399151141827
tp5205
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5206
(F10.324619989809783
F2.7365003732534556
tp5207
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5208
(F16.170465959821428
F3.1646173917330227
tp5209
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5210
(F12.164452914533944
F2.953488276554988
tp5211
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5212
(F13.054723921911421
F3.0006954486553488
tp5213
sS'if (proc_name.lower() in obj_name.lower()):\n    pass'
p5214
(F12.68150634765625
F2.875763232891376
tp5215
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5216
(F12.666690526832461
F3.112285907451923
tp5217
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5218
(F14.19537109375
F2.8020260150615988
tp5219
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5220
(F14.428559366861979
F2.8545608520507812
tp5221
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict"
p5222
(F14.954894108558769
F3.3114266028771033
tp5223
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5224
(F12.922093672718075
F3.0803486750676083
tp5225
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5226
(F13.009040994847075
F2.9996167696439304
tp5227
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5228
(F13.823815738453584
F3.071698702298678
tp5229
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5230
(F13.43992058805717
F3.0306707528921275
tp5231
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5232
(F11.781675253848293
F2.9553970923790565
tp5233
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5234
(F12.6446151214392
F2.944758782019982
tp5235
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5236
(F15.291312477805398
F2.8549408545860877
tp5237
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5238
(F14.817915322124094
F2.9473812396709738
tp5239
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5240
(F13.24656718987462
F3.060061821570763
tp5241
sS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)'
p5242
(F13.434120178222656
F2.6448050278883715
tp5243
sS'def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5244
(F15.495580745648734
F2.9379962040827823
tp5245
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5246
(F13.12711433531746
F2.987041179950421
tp5247
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5248
(F13.422337704613096
F3.0171561607947717
tp5249
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5250
(F14.603643243963068
F2.859198056734525
tp5251
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5252
(F13.106313705444336
F2.906004685621995
tp5253
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5254
(F13.123091534870428
F3.005544222318209
tp5255
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5256
(F13.519679090711806
F3.046634087195763
tp5257
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5258
(F14.610571135514936
F2.8769296499399037
tp5259
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5260
(F14.354529825846354
F3.3523084200345554
tp5261
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'"
p5262
(F15.054099343039773
F2.9049676748422475
tp5263
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5264
(F13.267822265625
F2.98101073044997
tp5265
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p5266
(F15.056930541992188
F3.0447845458984375
tp5267
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass"
p5268
(F9.266574120336724
F3.06843009361854
tp5269
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict"
p5270
(F14.715620561079545
F3.1175865760216346
tp5271
sS'if (len(colItems) > 0):\n    pass'
p5272
(F9.302909402286305
F2.9486606304462137
tp5273
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5274
(F14.744621725643382
F3.135300562931941
tp5275
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5276
(F14.749440068783967
F2.949983156644381
tp5277
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5278
(F15.436625480651855
F3.0208206176757812
tp5279
sS"import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5280
(F8.652639469630282
F2.9861588111290565
tp5281
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5282
(F13.855755780194256
F3.0297816349909854
tp5283
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5284
(F13.90940449470534
F3.0587005615234375
tp5285
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5286
(F13.02412155439269
F3.0507656977726865
tp5287
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5288
(F13.267099854071754
F3.051513965313251
tp5289
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5290
(F13.225179437346059
F3.0484783466045675
tp5291
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5292
(F11.27617125298567
F2.9964024470402646
tp5293
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5294
(F13.352062031970046
F3.003541506253756
tp5295
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5296
(F10.768493268474844
F3.0990060659555287
tp5297
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5298
(F12.599286760602679
F3.071994194617638
tp5299
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5300
(F13.77635099667321
F3.0258084810697117
tp5301
sS'memoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5302
(F11.172012992527174
F2.8684492844801683
tp5303
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5304
(F12.401421226531621
F3.019732255202073
tp5305
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5306
(F12.16466376122008
F3.174656794621394
tp5307
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5308
(F13.110297220233225
F2.9472051767202525
tp5309
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5310
(F14.538665870246763
F2.9137071462777944
tp5311
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5312
(F14.207957732371796
F3.064882131723257
tp5313
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5314
(F12.57749138450214
F3.068173041710487
tp5315
sS'proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5316
(F15.559106659470944
F3.3643370408278246
tp5317
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5318
(F9.850675989369877
F3.1584085317758412
tp5319
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p5320
(F9.721980503627233
F2.9882818368765025
tp5321
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5322
(F13.999156605113637
F2.9762743436373196
tp5323
sS'print(psutil.virtual_memory())'
p5324
(F12.976516723632812
F2.728925264798678
tp5325
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5326
(F13.195847703171921
F3.063305194561298
tp5327
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5328
(F12.034477583858944
F3.0829576345590444
tp5329
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p5330
(F12.000605564491421
F3.1583216740534854
tp5331
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5332
(F13.15996686150046
F2.8819779616135817
tp5333
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5334
(F11.220842516100085
F3.070879716139573
tp5335
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5336
(F14.041715923108553
F2.849810086763822
tp5337
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()"
p5338
(F12.403772989908854
F2.882539602426382
tp5339
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5340
(F13.912401792019773
F3.0735508845402646
tp5341
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5342
(F11.997109263710826
F2.966138399564303
tp5343
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p5344
(F6.013486099243164
F3.125456296480619
tp5345
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5346
(F13.695008511673151
F3.0063934326171875
tp5347
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5348
(F14.620185742747134
F2.9378656240609975
tp5349
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5350
(F12.431048062578517
F2.9520122821514425
tp5351
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5352
(F15.259345160590279
F3.07352535541241
tp5353
sS"if found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5354
(F14.909873679832176
F3.246959979717548
tp5355
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5356
(F12.252689505912162
F2.8306922912597656
tp5357
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5358
(F14.788313356164384
F2.950543917142428
tp5359
sS'import os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)'
p5360
(F15.9988525390625
F2.6791373032789965
tp5361
sS'perf_object_list = self.supported_types.keys()'
p5362
(F14.375432631548714
F3.023959526648888
tp5363
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5364
(F9.935754309167395
F3.076623769906851
tp5365
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5366
(F13.004275299781977
F3.049883622389573
tp5367
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5368
(F14.511654076986755
F2.969554607684796
tp5369
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5370
(F14.868232194767442
F2.8173003563514123
tp5371
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5372
(F13.672730396412037
F3.097148895263672
tp5373
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5374
(F13.132190671741453
F2.899376208965595
tp5375
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5376
(F12.454143177379262
F2.94669430072491
tp5377
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5378
(F15.268498118330793
F3.134326641376202
tp5379
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5380
(F13.431034909018987
F3.041935553917518
tp5381
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5382
(F14.576739380691226
F2.9110794067382812
tp5383
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5384
(F14.5678577942607
F2.8621673583984375
tp5385
sS'print result_dict'
p5386
(F14.786305745442709
F2.890818375807542
tp5387
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p5388
(F9.481463623046874
F3.0120931772085338
tp5389
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5390
(F13.71157873682229
F3.065370119535006
tp5391
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5392
(F13.382730641084558
F2.9833106994628906
tp5393
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5394
(F13.638165367141454
F3.0597493098332333
tp5395
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5396
(F12.478270199424342
F2.9277106065016527
tp5397
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5398
(F13.240465469942748
F2.9098924490121694
tp5399
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5400
(F11.83641726471657
F3.0932256258451023
tp5401
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5402
(F11.371197159882565
F2.9934862576998196
tp5403
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5404
(F11.066381997620033
F3.0538529616135817
tp5405
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5406
(F14.096136833639706
F3.0068368178147535
tp5407
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5408
(F13.660735650671906
F3.018618657038762
tp5409
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5410
(F13.249170757192847
F3.070735051081731
tp5411
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5412
(F12.090362121411065
F3.113246330848107
tp5413
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5414
(F13.005313885880776
F3.0481802133413463
tp5415
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p5416
(F4.736115809849331
F3.0986058161808896
tp5417
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict"
p5418
(F14.727590849905303
F3.141296680157001
tp5419
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5420
(F13.905759999449824
F3.059458219088041
tp5421
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5422
(F8.044872465587797
F3.0537144587590146
tp5423
sS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5424
(F16.207840768914473
F2.772249075082632
tp5425
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5426
(F12.62746878650701
F3.05524415236253
tp5427
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p5428
(F12.5709228515625
F2.9711908193734975
tp5429
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5430
(F13.871697319878471
F3.3769815885103664
tp5431
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5432
(F10.69440666077629
F2.687191596397987
tp5433
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True'
p5434
(F15.14879273832514
F3.1246267465444713
tp5435
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5436
(F15.574931218073917
F2.946844247671274
tp5437
sS"'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5438
(F2.8216164906819663
F2.7552455021784854
tp5439
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5440
(F12.199831387523409
F2.9289556650015025
tp5441
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5442
(F13.095371761485042
F2.8946533203125
tp5443
sS'proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict'
p5444
(F15.3330659866333
F2.937440432035006
tp5445
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5446
(F14.023429323041269
F2.96238767183744
tp5447
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5448
(F13.426212345157658
F2.942914522611178
tp5449
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5450
(F12.782303934689507
F2.8768093402569113
tp5451
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5452
(F13.641321477652964
F3.007370875431941
tp5453
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5454
(F12.917885789593447
F3.089909480168269
tp5455
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5456
(F12.47735200948383
F2.748292482816256
tp5457
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5458
(F12.579662584278681
F2.9288236177884617
tp5459
sS'from ctypes import *\nfrom ctypes.wintypes import *'
p5460
(F15.002213698167067
F2.575663053072416
tp5461
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5462
(F13.93651862684729
F3.0910723759577823
tp5463
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5464
(F13.41267450438862
F3.007838322566106
tp5465
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p5466
(F15.415639042075163
F3.036092024583083
tp5467
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5468
(F15.037510463169642
F2.8376018817608175
tp5469
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]'
p5470
(F10.3199173127762
F2.6606539212740383
tp5471
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5472
(F13.911566063841681
F3.047292269193209
tp5473
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5474
(F15.01934629498106
F3.2559083791879506
tp5475
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p5476
(F14.480718759390024
F2.8308481069711537
tp5477
sS"for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5478
(F16.532785723286292
F2.767159388615535
tp5479
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5480
(F11.894137271995708
F2.9379642193134012
tp5481
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5482
(F13.46682500643004
F3.0347662705641527
tp5483
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5484
(F13.02793893306213
F2.92684085552509
tp5485
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5486
(F12.979015578311753
F2.940719017615685
tp5487
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5488
(F11.536622600790896
F3.120236029991737
tp5489
sS'from __future__ import print_function\nimport psutil\nprint(psutil.cpu_percent())\nprint(psutil.virtual_memory())'
p5490
(F15.395371791294643
F2.660021561842698
tp5491
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5492
(F13.78897707326197
F2.986217205341046
tp5493
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5494
(F13.359763340643275
F2.9620590209960938
tp5495
sS"proc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5496
(F16.04753134907156
F2.7669398968036356
tp5497
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\''
p5498
(F15.514988068611391
F3.064027052659255
tp5499
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p5500
(F13.548848119275323
F3.0087966918945312
tp5501
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    pass'
p5502
(F13.131183492726294
F2.9395845853365383
tp5503
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5504
(F13.177030302209705
F2.922912891094501
tp5505
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5506
(F13.125037977430555
F2.9912003737229567
tp5507
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5508
(F14.785910866477273
F2.917476067176232
tp5509
sS'from ctypes.wintypes import *\nimport pythoncom'
p5510
(F15.704681396484375
F2.5757296635554385
tp5511
sS'break\nif found_flag:\n    pass'
p5512
(F12.5709228515625
F2.7439583998460035
tp5513
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5514
(F13.451775761779595
F3.0724933330829325
tp5515
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5516
(F13.566082937584802
F2.9081817040076623
tp5517
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5518
(F13.243034471267773
F2.931078397310697
tp5519
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5520
(F14.735223915371193
F2.873019291804387
tp5521
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p5522
(F14.09468397983285
F3.0038540179912863
tp5523
sS'from __future__ import print_function\nimport os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5524
(F14.138731800426136
F2.692686227651743
tp5525
sS'pid = os.getpid()'
p5526
(F10.830335828993055
F2.626829294057993
tp5527
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5528
(F13.839606789981618
F2.9688353905311
tp5529
sS'continue'
p5530
(F10.417540232340494
F2.8228108332707333
tp5531
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass'
p5532
(F12.761585582386363
F3.06819094144381
tp5533
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5534
(F14.111656149839744
F2.9715640728290262
tp5535
sS'self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5536
(F17.235454690867456
F2.9341245797964244
tp5537
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        pass'
p5538
(F15.125116644965278
F3.0853740985576925
tp5539
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5540
(F13.624334255186449
F3.0575960599459133
tp5541
sS'import pythoncom'
p5542
(F14.695377349853516
F2.6413858853853664
tp5543
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5544
(F16.05482884457237
F3.173248584453876
tp5545
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5546
(F11.768050309065934
F2.7202347975510817
tp5547
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5548
(F13.404350180813319
F3.047588054950421
tp5549
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5550
(F13.558205740792411
F3.0625824561485877
tp5551
sS'self.filter_list = filter_list'
p5552
(F17.090329256924715
F3.3199342580942006
tp5553
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5554
(F14.610743108785377
F2.913484133206881
tp5555
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5556
(F12.87500708938294
F3.08354245699369
tp5557
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5558
(F15.037693093039772
F2.860287299522987
tp5559
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5560
(F14.375508925494026
F3.0110144981971154
tp5561
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5562
(F10.502264873798078
F2.7367283747746396
tp5563
sS"from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5564
(F9.794303063118813
F2.735646467942458
tp5565
sS'pythoncom.CoInitialize()'
p5566
(F9.05436897277832
F2.83680666410006
tp5567
sS"py = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint('memory use:', memoryUse)"
p5568
(F11.677400207519531
F2.7973260145920973
tp5569
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p5570
(F13.243873232886905
F2.9134005033052883
tp5571
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5572
(F12.984566142126335
F3.000829843374399
tp5573
sS'import pythoncom\nimport pywintypes\nimport datetime'
p5574
(F16.398410034179687
F2.569063039926382
tp5575
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5576
(F13.583522882247506
F3.0386962890625
tp5577
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5578
(F13.567025252214567
F3.009585747352013
tp5579
sS'x = MEMORYSTATUS()'
p5580
(F8.112097603934151
F2.9039864173302283
tp5581
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5582
(F12.536764888440148
F3.0664678720327525
tp5583
sS"'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '"
p5584
(F2.8216164906819663
F2.7552452087402344
tp5585
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5586
(F13.395423192330211
F3.002972822922927
tp5587
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5588
(F13.13155117656518
F2.8999261122483473
tp5589
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5590
(F14.349787490172956
F3.113954397348257
tp5591
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5592
(F10.079436700994318
F2.750025822566106
tp5593
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p5594
(F14.799552585767662
F3.2013526329627404
tp5595
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5596
(F12.506709231606013
F3.0342283982496996
tp5597
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5598
(F13.16233744367163
F3.086055168738732
tp5599
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5600
(F14.069299253157384
F2.9944416926457333
tp5601
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5602
(F14.552239897287437
F3.030872638408954
tp5603
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5604
(F13.95594721889952
F2.966074430025541
tp5605
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p5606
(F10.82061383440778
F3.0248360267052283
tp5607
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5608
(F14.437974717881945
F3.174775930551382
tp5609
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5610
(F12.556552688092417
F3.080349848820613
tp5611
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p5612
(F15.378485785590279
F2.580948462853065
tp5613
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p5614
(F13.333141765763274
F2.972957024207482
tp5615
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5616
(F13.176835054731638
F2.931292313795823
tp5617
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5618
(F15.126813798674739
F2.9848961463341346
tp5619
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5620
(F12.889989552145709
F2.8788939255934496
tp5621
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])"
p5622
(F14.164895762567935
F3.0778609055739183
tp5623
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5624
(F13.577507622808003
F3.037491431603065
tp5625
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5626
(F13.272372702909648
F2.914735060471755
tp5627
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p5628
(F14.612239422184405
F2.7762295649601865
tp5629
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5630
(F12.781964945431127
F2.9424881568321815
tp5631
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5632
(F12.067544205182072
F3.130033933199369
tp5633
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5634
(F8.048024770375845
F3.1229776235727162
tp5635
sS'if (not self.process_name_list):\n    pass'
p5636
(F14.140457153320312
F2.9367637634277344
tp5637
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5638
(F10.2959365234375
F2.7491331834059496
tp5639
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5640
(F13.808401007401315
F2.950170663686899
tp5641
sS"this_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5642
(F15.571533203125
F2.6925747211162863
tp5643
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5644
(F13.17324462890625
F2.923633282001202
tp5645
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5646
(F13.330060738130564
F3.060215876652644
tp5647
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }"
p5648
(F12.666275323606005
F2.865780463585487
tp5649
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5650
(F12.34892675295398
F3.0995348416841946
tp5651
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list"
p5652
(F16.205761058910472
F3.1331517146183896
tp5653
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5654
(F13.033987720483278
F3.0638371981107273
tp5655
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p5656
(F14.42630550986842
F2.865870549128606
tp5657
sS'from ctypes import *'
p5658
(F14.668388366699219
F2.5795587392953725
tp5659
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5660
(F12.782305348916832
F3.05885989849384
tp5661
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5662
(F12.907488204245071
F3.0840236957256613
tp5663
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5664
(F10.303707546657986
F2.668731982891376
tp5665
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5666
(F13.35568200536521
F2.987718728872446
tp5667
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5668
(F10.815607165613919
F2.689424074613131
tp5669
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p5670
(F14.638928865131579
F2.9295184795673075
tp5671
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5672
(F13.127668421186787
F2.9023372943584738
tp5673
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5674
(F12.974908964512712
F3.0551487849308896
tp5675
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p5676
(F11.895124064700704
F2.8638006357046275
tp5677
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p5678
(F13.631506717566287
F3.035760439359225
tp5679
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5680
(F13.75666698511096
F2.9897481478177586
tp5681
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5682
(F16.094644818987167
F2.5770821204552283
tp5683
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"'
p5684
(F2.8216164906819663
F2.7552452087402344
tp5685
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()"
p5686
(F12.67352294921875
F2.877229543832632
tp5687
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p5688
(F13.52661955758427
F2.994381537804237
tp5689
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5690
(F12.693145879641737
F3.037030733548678
tp5691
sS'__revision__ = 3\nimport win32com.client'
p5692
(F14.598443349202475
F2.648504697359525
tp5693
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5694
(F13.65150232068727
F3.0329495943509617
tp5695
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5696
(F13.12972891527434
F2.9011603135329027
tp5697
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5698
(F13.386536225818453
F3.018853994516226
tp5699
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5700
(F12.22739059860642
F3.040470710167518
tp5701
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict"
p5702
(F14.685521792059076
F3.1034475473257213
tp5703
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5704
(F11.692179619511471
F2.873437734750601
tp5705
sS'if (len(colItems) > 0):\n    for objItem in colItems:\n        found_flag = False'
p5706
(F12.925342190650202
F3.146370814396785
tp5707
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client'
p5708
(F12.800872802734375
F2.6515772892878604
tp5709
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p5710
(F14.054789733886718
F2.8436801616962137
tp5711
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p5712
(F13.723937195616884
F3.0403242844801683
tp5713
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5714
(F13.367587875850983
F2.9633733309232273
tp5715
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p5716
(F14.361344222184066
F2.868967496431791
tp5717
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    pass"
p5718
(F13.116214850010016
F2.9014217670147238
tp5719
sS'import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p5720
(F12.784004543138588
F2.6987674419696512
tp5721
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p5722
(F13.424060997596154
F3.047625321608323
tp5723
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p5724
(F13.117117630807977
F2.896134303166316
tp5725
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5726
(F14.712682088216146
F2.9104253328763523
tp5727
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5728
(F13.40333686440678
F3.052003126878005
tp5729
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5730
(F12.41621118984173
F2.941972879263071
tp5731
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p5732
(F9.029497892960258
F3.092733236459585
tp5733
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    pass'
p5734
(F14.992460363051471
F3.116510244516226
tp5735
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p5736
(F14.665739147868377
F3.103009737454928
tp5737
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p5738
(F15.112290402676196
F3.30980711716872
tp5739
sS'for result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()'
p5740
(F15.879654422883064
F2.8156949556790867
tp5741
sS"print 'this proc results:'\nprint this_proc_results"
p5742
(F12.761781172318893
F2.7283856318547177
tp5743
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak'
p5744
(F12.952545002236135
F3.0675345200758715
tp5745
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5746
(F12.559140249399038
F3.0401050861065206
tp5747
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5748
(F9.5360722362547
F3.0499807504507213
tp5749
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5750
(F14.791514650825183
F2.874135530911959
tp5751
sS'this_proc_dict[attribute] = eval(eval_str)'
p5752
(F15.146985222311582
F3.3273221529447117
tp5753
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5754
(F14.564730224609375
F3.0466927748460035
tp5755
sS'proc_results_list = []'
p5756
(F11.969261169433594
F3.0606149526742787
tp5757
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5758
(F13.253875827492212
F2.956734583928035
tp5759
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True'
p5760
(F14.905696745841734
F3.1574686490572414
tp5761
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p5762
(F12.601542154947916
F2.907954289362981
tp5763
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5764
(F15.37628658234127
F2.920355283297025
tp5765
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5766
(F12.830073888286334
F2.9021676870492787
tp5767
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5768
(F14.517974194862859
F2.862839625431941
tp5769
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5770
(F12.985537903047703
F3.0679793724646935
tp5771
sS'proc_results = stats_processor.get_stats()'
p5772
(F12.519230143229167
F2.884927896352915
tp5773
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5774
(F13.749592308859222
F3.0448981065016527
tp5775
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5776
(F13.332401926924543
F2.976762918325571
tp5777
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5778
(F13.207235394891212
F2.9239114614633412
tp5779
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5780
(F13.570084110383064
F3.0788958622859073
tp5781
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5782
(F14.75993224916543
F2.9253933246319113
tp5783
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p5784
(F12.562836518158784
F3.048138838547927
tp5785
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5786
(F14.374223066298342
F2.9659910935621996
tp5787
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5788
(F8.305489131382533
F3.051438258244441
tp5789
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5790
(F13.438709900442477
F2.936004932110126
tp5791
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p5792
(F12.467344702743903
F3.0681234506460338
tp5793
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5794
(F11.590495545187114
F2.832259251521184
tp5795
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5796
(F13.026305093930636
F3.0423431396484375
tp5797
sS'if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5798
(F14.84874153137207
F3.0680809020996094
tp5799
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5800
(F12.916303980068898
F3.0714771564190206
tp5801
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5802
(F13.08450107473545
F3.0409586979792667
tp5803
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5804
(F11.514218537703805
F2.6745684697077823
tp5805
sS"__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5806
(F10.258223397391182
F2.677844707782452
tp5807
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p5808
(F13.639212036132813
F2.8895621666541467
tp5809
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5810
(F13.804977612260055
F3.071440183199369
tp5811
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5812
(F9.76102878736413
F2.9502493051382213
tp5813
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5814
(F14.935803616431452
F2.928887880765475
tp5815
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    pass"
p5816
(F10.8629150390625
F2.7107276916503906
tp5817
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5818
(F12.770273915537587
F3.1007203322190504
tp5819
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p5820
(F13.365924775515648
F3.051714383638822
tp5821
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5822
(F12.873639568592766
F2.87895994919997
tp5823
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p5824
(F15.13248019748264
F2.800305880033053
tp5825
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5826
(F13.039163394850128
F3.0362176161545973
tp5827
sS"return this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5828
(F13.930886088937953
F3.0768153850848856
tp5829
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5830
(F13.970553694100216
F2.732167757474459
tp5831
sS"return proc_results_list\n\ndef get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()"
p5832
(F13.7691650390625
F2.912632868840144
tp5833
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()'
p5834
(F11.291862562347312
F3.1164210392878604
tp5835
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    pass'
p5836
(F10.121926047585227
F2.659314962533804
tp5837
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p5838
(F14.711033935546874
F3.241755852332482
tp5839
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5840
(F13.664639809974155
F3.101398761455829
tp5841
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p5842
(F15.315559582832533
F3.0230111342210035
tp5843
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5844
(F11.22659685511789
F3.176878709059495
tp5845
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5846
(F12.296088471283785
F2.9766100369966946
tp5847
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p5848
(F13.463987930961277
F2.6023345360389123
tp5849
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5850
(F13.176903985867835
F2.9518177325908956
tp5851
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p5852
(F13.439481268011527
F3.0599790719839244
tp5853
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5854
(F12.860505022321428
F2.923823429987981
tp5855
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5856
(F13.105186487749169
F2.945280515230619
tp5857
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p5858
(F15.293991088867188
F2.966400439922626
tp5859
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p5860
(F12.955134689097104
F3.0620968158428488
tp5861
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5862
(F13.109076286764706
F2.944715059720553
tp5863
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5864
(F12.894942294034092
F3.097375723031851
tp5865
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p5866
(F12.051162548279494
F2.9964130108173075
tp5867
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p5868
(F13.068256753177966
F2.959810110238882
tp5869
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5870
(F11.795791044263197
F3.1042776841383715
tp5871
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5872
(F8.333132575539981
F3.0692115196814904
tp5873
sS'proc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5874
(F13.688849555121529
F3.243421407846304
tp5875
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p5876
(F13.574606230764678
F3.029754345233624
tp5877
sS'for result_dict in proc_results:\n    print result_dict\nimport os'
p5878
(F16.758196149553573
F3.0435565068171573
tp5879
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }"
p5880
(F10.194106279793433
F3.1672733013446512
tp5881
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5882
(F13.511405332681017
F3.0277932974008412
tp5883
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5884
(F15.733314208984375
F3.1558597271259012
tp5885
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p5886
(F13.067548156415343
F2.959869384765625
tp5887
sS"_fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5888
(F7.148253829390915
F3.17954342181866
tp5889
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5890
(F12.474103918027637
F2.8848627530611477
tp5891
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p5892
(F12.972459224232455
F3.0631402822641225
tp5893
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5894
(F15.571039835611979
F2.5802430372971754
tp5895
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5896
(F12.537979125976562
F3.090378687931941
tp5897
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5898
(F12.148517327997276
F2.884931417611929
tp5899
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5900
(F13.176238004429134
F3.0863304138183594
tp5901
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p5902
(F12.929078177698145
F3.075291560246394
tp5903
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5904
(F9.496960847274117
F2.7342458871694713
tp5905
sS"return sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)"
p5906
(F15.812216421274039
F3.046387892503005
tp5907
sS"class MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()"
p5908
(F8.106176131810898
F3.1447369502140927
tp5909
sS'def get_sys_stats():\n    pass'
p5910
(F12.901064046223958
F2.7937892033503604
tp5911
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5912
(F13.077668606505101
F3.174758030818059
tp5913
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5914
(F14.540510110294118
F2.9403310922475963
tp5915
sS'self.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p5916
(F17.143780517578126
F3.2494882436899037
tp5917
sS'this_proc_dict = {}'
p5918
(F12.43555908203125
F3.0871766897348256
tp5919
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5920
(F13.236992038026148
F3.055500323955829
tp5921
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5922
(F15.36326114430147
F2.7846028254582333
tp5923
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p5924
(F7.306992701480263
F3.019391573392428
tp5925
sS'if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p5926
(F15.955239613850912
F3.1576573298527646
tp5927
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p5928
(F11.178556787276024
F3.0930557250976562
tp5929
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p5930
(F10.404712718921703
F2.6935580326960635
tp5931
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5932
(F13.099709404839409
F2.9607053903432994
tp5933
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5934
(F12.73984183517157
F2.831274179311899
tp5935
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5936
(F12.525153958067602
F2.9147042494553785
tp5937
sS"colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5938
(F13.17451523289536
F2.841886960543119
tp5939
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p5940
(F14.627160078642385
F2.9100652841421275
tp5941
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p5942
(F11.503848936499619
F2.8156879131610575
tp5943
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p5944
(F13.669410492271505
F3.0653742276705227
tp5945
sS"if (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p5946
(F15.04065410907452
F3.2057277972881613
tp5947
sS'return this_proc_dict'
p5948
(F14.661443710327148
F2.993620065542368
tp5949
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5950
(F13.394911024305555
F2.9152647165151744
tp5951
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p5952
(F17.546045420121175
F3.072691697340745
tp5953
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p5954
(F16.42443339029948
F2.5742563100961537
tp5955
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p5956
(F14.387507927813653
F3.0004774240347056
tp5957
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5958
(F14.191254679361979
F3.0165267357459435
tp5959
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p5960
(F15.001223915501646
F2.864758711594802
tp5961
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p5962
(F13.648604487959958
F3.0633025536170373
tp5963
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p5964
(F13.440706300030788
F3.0223623422475963
tp5965
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p5966
(F13.839932937903598
F3.06784174992488
tp5967
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5968
(F11.42481320403343
F3.1617642916165867
tp5969
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p5970
(F14.228505727407095
F3.1074180603027344
tp5971
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p5972
(F14.470696319686411
F2.87842765221229
tp5973
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p5974
(F12.847895051565606
F2.873120821439303
tp5975
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p5976
(F11.345453984908277
F2.914661407470703
tp5977
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p5978
(F13.880339626736111
F2.9705690237192006
tp5979
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5980
(F10.171137192670036
F3.193605276254507
tp5981
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p5982
(F11.00574951171875
F3.0974561251126804
tp5983
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p5984
(F13.693888530472286
F3.0702664301945615
tp5985
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p5986
(F11.58496307908443
F2.8186883192795973
tp5987
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p5988
(F12.422998046875
F2.877454610971304
tp5989
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p5990
(F14.503643120659722
F2.7760165287898135
tp5991
sS'pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p5992
(F13.963336944580078
F3.0812732989971456
tp5993
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    pass"
p5994
(F8.343451777590982
F3.0359356219951925
tp5995
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p5996
(F11.83559061686198
F2.848403050349309
tp5997
sS'pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list'
p5998
(F16.113525390625
F2.89623055091271
tp5999
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6000
(F14.950839050814636
F2.8912781935471754
tp6001
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6002
(F13.853947027609767
F2.9846085768479567
tp6003
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p6004
(F13.151088324652777
F2.7998733520507812
tp6005
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6006
(F12.35689554586039
F2.8899019681490383
tp6007
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p6008
(F13.554091469535615
F2.927435361422025
tp6009
sS'sys_dict = get_sys_stats()'
p6010
(F15.247822688176083
F2.845517085148738
tp6011
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x'
p6012
(F11.320916175842285
F2.9144991361177883
tp6013
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \''
p6014
(F11.176418552150974
F3.0176462026742787
tp6015
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p6016
(F12.828630027357852
F3.04351073044997
tp6017
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p6018
(F14.392462836371529
F3.2179192763108473
tp6019
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p6020
(F13.495007694128788
F3.034603705772987
tp6021
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p6022
(F11.645696233342719
F3.144923576941857
tp6023
sS'found_flag = False'
p6024
(F13.83616202218192
F2.819315396822416
tp6025
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()"
p6026
(F14.65468166185462
F3.2346476041353664
tp6027
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    pass'
p6028
(F11.107834907427225
F3.1004835275503306
tp6029
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p6030
(F11.522847038488418
F2.940821721003606
tp6031
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6032
(F12.129546155427631
F3.1148640559269833
tp6033
sS"def get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p6034
(F13.767783243148052
F3.050878671499399
tp6035
sS'self.perf_object_list = perf_object_list'
p6036
(F15.836997477213542
F3.0064122126652646
tp6037
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6038
(F12.502913254957933
F2.872515458327073
tp6039
sS"from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]"
p6040
(F9.63062729070216
F2.7295461801382213
tp6041
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p6042
(F14.381501296470905
F2.5826841501089244
tp6043
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6044
(F13.343311424026947
F2.9679779639610877
tp6045
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    pass'
p6046
(F11.271448447951505
F3.0580679086538463
tp6047
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6048
(F13.877186188464156
F2.9952063927283654
tp6049
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    pass"
p6050
(F6.830974232066762
F2.9546588017390323
tp6051
sS'return sys_dict'
p6052
(F17.907821655273438
F2.913594759427584
tp6053
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    pass'
p6054
(F11.434646845611285
F3.143614255464994
tp6055
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p6056
(F10.784985550050813
F2.713135059063251
tp6057
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}"
p6058
(F10.95863525390625
F3.0639560406024637
tp6059
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p6060
(F13.890467201791159
F2.7302909264197717
tp6061
sS'if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    pass'
p6062
(F14.87234762440557
F3.000020540677584
tp6063
sS"this_proc_dict = {}\nif (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])"
p6064
(F14.793110164788251
F3.230723160963792
tp6065
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p6066
(F14.516354209498354
F2.904146047738882
tp6067
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p6068
(F13.09499800832648
F2.8960492060734677
tp6069
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p6070
(F12.75010238155242
F2.9840316772460938
tp6071
sS'py = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))'
p6072
(F11.867131233215332
F2.8124410189115086
tp6073
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p6074
(F11.050752578681049
F3.097208756666917
tp6075
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os"
p6076
(F14.814897166002517
F3.0882139939528246
tp6077
sS"self.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6078
(F13.245482336956522
F2.9924697875976562
tp6079
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p6080
(F13.316208522507727
F2.9363106947678785
tp6081
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6082
(F12.789802797379032
F2.98200930081881
tp6083
sS'"process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p6084
(F2.8216164906819663
F2.7552452087402344
tp6085
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p6086
(F13.364853093653549
F3.160707033597506
tp6087
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p6088
(F13.965650634765625
F3.2698880709134617
tp6089
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6090
(F13.195183414152298
F3.0044940068171573
tp6091
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p6092
(F12.0573411491049
F3.1596189645620494
tp6093
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p6094
(F15.044013763142523
F2.862386263333834
tp6095
sS"import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p6096
(F9.263535332433957
F3.0150927030123196
tp6097
sS'for attribute in self.supported_types[counter_type]:\n    pass'
p6098
(F16.19329071044922
F3.1340965857872596
tp6099
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p6100
(F10.943604403409092
F3.1378200237567606
tp6101
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p6102
(F13.129212474495274
F3.001970731295072
tp6103
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6104
(F15.378341571003402
F2.848663330078125
tp6105
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p6106
(F14.356326268724173
F2.8438468346228967
tp6107
sS"print 'this proc results:'"
p6108
(F7.225813865661621
F2.6421775817871094
tp6109
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p6110
(F11.154639908030063
F3.04967528123122
tp6111
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6112
(F12.598910845588236
F3.0643988389235277
tp6113
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass"
p6114
(F14.878011613884228
F2.8105533306415262
tp6115
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6116
(F14.334157910496515
F2.971494821401743
tp6117
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p6118
(F13.716341270315487
F3.061966822697566
tp6119
sS'for objItem in colItems:\n    pass'
p6120
(F14.198957003079927
F3.068463545579177
tp6121
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict'
p6122
(F13.126527317445285
F2.8958505483774037
tp6123
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6124
(F13.452161101855188
F2.9314657358022838
tp6125
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()'
p6126
(F12.880085208873057
F3.077861492450421
tp6127
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6128
(F15.102691650390625
F2.8898784930889425
tp6129
sS"proc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6130
(F15.3689716796875
F2.93949948824369
tp6131
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p6132
(F13.575353110708841
F3.0584945678710938
tp6133
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p6134
(F10.993532029844873
F3.1123601473294773
tp6135
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6136
(F10.730569979039634
F3.008296379676232
tp6137
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p6138
(F14.456562015181738
F2.7512215834397535
tp6139
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *'
p6140
(F13.585751182154604
F2.613872528076172
tp6141
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6142
(F13.54020980477079
F3.060719710129958
tp6143
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p6144
(F14.467088438624101
F2.863954103910006
tp6145
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p6146
(F13.354765678364071
F3.0191879272460938
tp6147
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                pass"
p6148
(F14.485674758184524
F2.8582525986891527
tp6149
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p6150
(F14.790035991548741
F3.047168731689453
tp6151
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6152
(F11.535984205163043
F3.106701190655048
tp6153
sS"import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x"
p6154
(F9.845025980247641
F2.931803189791166
tp6155
sS"pythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6156
(F14.691261468931685
F2.8973192068246694
tp6157
sS'break\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        pass'
p6158
(F15.668950398763021
F3.144244854266827
tp6159
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p6160
(F13.132406374007937
F3.059173877422626
tp6161
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6162
(F13.266852505804954
F3.0643929701585035
tp6163
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '"
p6164
(F14.077273269584277
F2.849138993483323
tp6165
sS"if (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6166
(F14.796112927971576
F2.8932019747220554
tp6167
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p6168
(F13.150900021114865
F3.0261286222017727
tp6169
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6170
(F14.169136338561545
F3.087628584641677
tp6171
sS'from ctypes.wintypes import *'
p6172
(F14.774540901184082
F2.5851622361403246
tp6173
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass'
p6174
(F13.602332920415856
F3.063279078556941
tp6175
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p6176
(F11.344374712775736
F3.081059382512019
tp6177
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'"
p6178
(F16.904517764136905
F3.268415010892428
tp6179
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)"
p6180
(F13.138839628067485
F3.014735295222356
tp6181
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6182
(F12.197188802083334
F3.0846595764160156
tp6183
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom'
p6184
(F16.3216552734375
F2.571842780480018
tp6185
sS"sys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p6186
(F14.796062601023706
F3.248497302715595
tp6187
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6188
(F13.869827270507812
F3.0112342834472656
tp6189
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p6190
(F13.071722553114686
F2.9617811349722056
tp6191
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)'
p6192
(F13.66506965088457
F3.0102034348707933
tp6193
sS'class MEMORYSTATUS(Structure):\n    pass'
p6194
(F9.05905787150065
F2.9408064622145433
tp6195
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))'
p6196
(F12.789295285247093
F2.9031160794771633
tp6197
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6198
(F12.931701436584248
F3.130037161020132
tp6199
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p6200
(F15.10366436613708
F2.8685117868276744
tp6201
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p6202
(F12.66548528206929
F3.0436451251690206
tp6203
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p6204
(F11.500666880767618
F2.88002923818735
tp6205
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass'
p6206
(F12.53549395018424
F3.0568709740271935
tp6207
sS"if (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6208
(F14.272269192351597
F3.1083206763634315
tp6209
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass'
p6210
(F13.476304449594794
F3.030591231126052
tp6211
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()"
p6212
(F14.256300951086956
F3.1049437889686
tp6213
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list'
p6214
(F12.691454829001913
F3.0904629047100363
tp6215
sS"self.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p6216
(F12.869592737268519
F2.990007547231821
tp6217
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6218
(F12.113193915142276
F3.1131550715519833
tp6219
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            pass'
p6220
(F13.424334831957546
F3.0418736384465146
tp6221
sS'class MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}'
p6222
(F11.146045749470339
F3.1420091482309194
tp6223
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p6224
(F13.99905846189346
F2.8548052861140323
tp6225
sS"import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [('dwLength', DWORD), ('dwMemoryLoad', DWORD), ('dwTotalPhys', DWORD), ('dwAvailPhys', DWORD), ('dwTotalPageFile', DWORD), ('dwAvailPageFile', DWORD), ('dwTotalVirtual', DWORD), ('dwAvailVirtual', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))"
p6226
(F10.612363688151042
F2.712142357459435
tp6227
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')'
p6228
(F13.376951673941308
F2.9553249065692606
tp6229
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p6230
(F13.37306491494766
F3.0070909353402944
tp6231
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p6232
(F12.829660180715031
F2.872808603140024
tp6233
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6234
(F13.672067126019673
F2.994480719933143
tp6235
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []'
p6236
(F13.538191060425051
F3.062031965989333
tp6237
sS'class process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }'
p6238
(F11.679392847521552
F3.204691373384916
tp6239
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p6240
(F13.723883734809029
F2.8350548377403846
tp6241
sS'__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6242
(F13.409370814732142
F2.911389864408053
tp6243
sS'def get_stats(self):\n    pass'
p6244
(F12.017415727887835
F2.8894119262695312
tp6245
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6246
(F13.687402932040662
F3.0175062326284556
tp6247
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6248
(F12.808206789804084
F2.8708836482121396
tp6249
sS'this_pid = os.getpid()'
p6250
(F13.250724098899148
F2.6926234318659854
tp6251
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    pass"
p6252
(F14.663096346596415
F3.1282733036921573
tp6253
sS"for counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6254
(F14.780109405517578
F2.7893406794621396
tp6255
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)'
p6256
(F13.0416259765625
F2.875162271352915
tp6257
sS"break\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6258
(F14.698825880028735
F3.119459005502554
tp6259
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p6260
(F12.951436616359963
F3.068592364971454
tp6261
sS"this_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6262
(F14.514628507653061
F2.9624798114483175
tp6263
sS"def get_sys_stats():\n    ' Returns a dictionary of the system stats'\npythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict"
p6264
(F13.45318603515625
F2.875578073354868
tp6265
sS"objSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    pass"
p6266
(F13.634538922991071
F2.8286062387319713
tp6267
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6268
(F13.253435899982344
F3.0348167419433594
tp6269
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)"
p6270
(F14.593822337962964
F2.9617940462552586
tp6271
sS'for objItem in colItems:\n    found_flag = False'
p6272
(F15.144191966337317
F3.145337618314303
tp6273
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()"
p6274
(F15.089364624023437
F3.110799642709585
tp6275
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6276
(F14.35919806184669
F2.979548821082482
tp6277
sS'for result_dict in proc_results:\n    pass'
p6278
(F15.607474772135417
F3.1381454467773438
tp6279
sS"if (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)"
p6280
(F14.87947128758286
F3.0108619103064904
tp6281
sS'return x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6282
(F12.897604772286822
F3.164590982290415
tp6283
sS"x = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p6284
(F15.31138328269676
F3.0245279165414662
tp6285
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    pass"
p6286
(F13.699928595430107
F3.0634806706355167
tp6287
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p6288
(F12.94847412109375
F2.61262453519381
tp6289
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()"
p6290
(F11.016320878533042
F3.0632608853853664
tp6291
sS"stats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'\nprint this_proc_results"
p6292
(F15.718192435599661
F2.9475367619441104
tp6293
sS'windll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass'
p6294
(F13.791486405129929
F3.0388210003192606
tp6295
sS'import win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list'
p6296
(F12.505784254807692
F2.7827670757587137
tp6297
sS'colItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        pass'
p6298
(F13.332887195405506
F2.875494150015024
tp6299
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'"
p6300
(F14.991195450967817
F3.1691680321326623
tp6301
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)'
p6302
(F12.753888290229884
F2.944266392634465
tp6303
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6304
(F13.679871851084183
F3.018741020789513
tp6305
sS'from ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()'
p6306
(F13.217598668072998
F2.9703128521259012
tp6307
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            pass"
p6308
(F12.627397171711673
F2.998385502741887
tp6309
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    pass"
p6310
(F13.449861168598234
F3.021836207463191
tp6311
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()"
p6312
(F13.789286613464355
F3.0675248366135817
tp6313
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6314
(F12.86260392600924
F2.9948495718149037
tp6315
sS"self.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []"
p6316
(F13.035031786151961
F3.0361416156475363
tp6317
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes'
p6318
(F14.61508846282959
F2.581577887901893
tp6319
sS"pythoncom.CoInitialize()\nx = winmem()\nsys_dict = {'dwAvailPhys': x.dwAvailPhys, 'dwAvailVirtual': x.dwAvailVirtual, }\nreturn sys_dict\nif (__name__ == '__main__'):\n    sys_dict = get_sys_stats()\nstats_processor = process_stats(process_name_list=['process2watch'], perf_object_list=[], filter_list=[])\nproc_results = stats_processor.get_stats()\nfor result_dict in proc_results:\n    print result_dict\nimport os\nthis_pid = os.getpid()\nthis_proc_results = stats_processor.get_pid_stats(this_pid)\nprint 'this proc results:'"
p6320
(F15.189054410133137
F2.9672877971942606
tp6321
sS'self.process_name_list = process_name_list'
p6322
(F17.184336344401043
F2.894151834341196
tp6323
sS"pythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6324
(F12.310884363511029
F3.0839529771071215
tp6325
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *'
p6326
(F13.932354266826923
F2.59243158193735
tp6327
sS'from ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])'
p6328
(F13.110516314739948
F2.9441434420072117
tp6329
sS'def winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')'
p6330
(F12.902263653391167
F3.05474119919997
tp6331
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6332
(F14.528043571494807
F2.857593242938702
tp6333
sS"pythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')"
p6334
(F14.733406163469146
F3.0007693950946512
tp6335
sS"if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n    pass"
p6336
(F12.256772641782407
F2.759380047137921
tp6337
sS"if (not self.process_name_list):\n    found_flag = True\nelse:\n    for proc_name in self.process_name_list:\n        obj_name = objItem.Name\nif (proc_name.lower() in obj_name.lower()):\n    found_flag = True\nbreak\nif found_flag:\n    for attribute in self.supported_types[counter_type]:\n        eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nproc_results_list.append(this_proc_dict)"
p6338
(F15.004355778769842
F3.2095879774827223
tp6339
sS"self.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    pass"
p6340
(F11.838948567708334
F3.183162102332482
tp6341
sS"import os\nimport psutil\npid = os.getpid()\npy = psutil.Process(pid)\nmemoryUse = (py.memory_info()[0] / (2.0 ** 30))\nprint('memory use:', memoryUse)"
p6342
(F12.549895109953704
F2.7070597135103664
tp6343
sS"def __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        '\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))"
p6344
(F14.011642272213855
F3.0378024761493387
tp6345
sS'print(psutil.cpu_percent())'
p6346
(F11.281913757324219
F2.6904942439152646
tp6347
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \'\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\''
p6348
(F13.251485157453775
F3.064313741830679
tp6349
sS"this_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict"
p6350
(F13.768906322877799
F3.1905781672551083
tp6351
sS'"\\nMonitor window processes\\nderived from:\\n>for sys available mem\\nhttp://msdn2.microsoft.com/en-us/library/aa455130.aspx\\n> individual process information and python script examples\\nhttp://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\nNOTE: the WMI interface/process is also available for performing similar tasks\\n        I\'m not using it here because the current method covers my needs, but if someday it\'s needed\\n        to extend or improve this module, then may want to investigate the WMI tools available.\\n        WMI for python:\\n        http://tgolden.sc.sabren.com/python/wmi.html\\n"\n__revision__ = 3\nimport win32com.client\nfrom ctypes import *\nfrom ctypes.wintypes import *\nimport pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()'
p6352
(F11.756071221891535
F2.7256202697753906
tp6353
sS"objWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak"
p6354
(F14.165706787109375
F2.8501331622783956
tp6355
sS"def get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()\nproc_results_list = []\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')"
p6356
(F14.688788519965279
F2.925505124605619
tp6357
sS'import pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "\n\ndef __init__(self, process_name_list=[], perf_object_list=[], filter_list=[]):\n    \'process_names_list == the list of all processes to log (if empty log all)\\n        perf_object_list == list of process counters to log\\n        filter_list == list of text to filter\\n        print_results == boolean, output to stdout\\n        \'\npythoncom.CoInitialize()\nself.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = \'Win32_PerfFormattedData_\'\nself.supported_types = {\'NETFramework_NETCLRMemory\': [\'Name\', \'NumberTotalCommittedBytes\', \'NumberTotalReservedBytes\', \'NumberInducedGC\', \'NumberGen0Collections\', \'NumberGen1Collections\', \'NumberGen2Collections\', \'PromotedMemoryFromGen0\', \'PromotedMemoryFromGen1\', \'PercentTimeInGC\', \'LargeObjectHeapSize\'], \'PerfProc_Process\': [\'Name\', \'PrivateBytes\', \'ElapsedTime\', \'IDProcess\', \'Caption\', \'CreatingProcessID\', \'Description\', \'IODataBytesPersec\', \'IODataOperationsPersec\', \'IOOtherBytesPersec\', \'IOOtherOperationsPersec\', \'IOReadBytesPersec\', \'IOReadOperationsPersec\', \'IOWriteBytesPersec\', \'IOWriteOperationsPersec\'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = \'.\'\nobjWMIService = win32com.client.Dispatch(\'WbemScripting.SWbemLocator\')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, \'root\\\\cimv2\')\nquery_str = (\'Select * from %s%s\' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, \'IDProcess\') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = (\'objItem.%s\' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict[\'TimeStamp\'] = (datetime.datetime.now().strftime(\'%Y-%m-%d %H:%M:%S.\') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    \'\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        \''
p6358
(F12.956434368265086
F3.0639668978177586
tp6359
sS"self.process_name_list = process_name_list\nself.perf_object_list = perf_object_list\nself.filter_list = filter_list\nself.win32_perf_base = 'Win32_PerfFormattedData_'\nself.supported_types = {'NETFramework_NETCLRMemory': ['Name', 'NumberTotalCommittedBytes', 'NumberTotalReservedBytes', 'NumberInducedGC', 'NumberGen0Collections', 'NumberGen1Collections', 'NumberGen2Collections', 'PromotedMemoryFromGen0', 'PromotedMemoryFromGen1', 'PercentTimeInGC', 'LargeObjectHeapSize'], 'PerfProc_Process': ['Name', 'PrivateBytes', 'ElapsedTime', 'IDProcess', 'Caption', 'CreatingProcessID', 'Description', 'IODataBytesPersec', 'IODataOperationsPersec', 'IOOtherBytesPersec', 'IOOtherOperationsPersec', 'IOReadBytesPersec', 'IOReadOperationsPersec', 'IOWriteBytesPersec', 'IOWriteOperationsPersec'], }\n\ndef get_pid_stats(self, pid):\n    this_proc_dict = {}\npythoncom.CoInitialize()\nif (not self.perf_object_list):\n    perf_object_list = self.supported_types.keys()\nfor counter_type in perf_object_list:\n    strComputer = '.'\nobjWMIService = win32com.client.Dispatch('WbemScripting.SWbemLocator')\nobjSWbemServices = objWMIService.ConnectServer(strComputer, 'root\\\\cimv2')\nquery_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)\nthis_proc_dict['TimeStamp'] = (datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.') + str(datetime.datetime.now().microsecond)[:3])\nbreak\nreturn this_proc_dict\n\ndef get_stats(self):\n    '\\n        Show process stats for all processes in given list, if none given return all processes   \\n        If filter list is defined return only the items that match or contained in the list\\n        Returns a list of result dictionaries\\n        '\npythoncom.CoInitialize()"
p6360
(F13.377285888100117
F3.01734366783729
tp6361
sS'import datetime\n\n\nclass MEMORYSTATUS(Structure):\n    pass'
p6362
(F9.773042566636029
F2.7581226642315206
tp6363
sS'import pythoncom\nimport pywintypes\nimport datetime\n\n\nclass MEMORYSTATUS(Structure):\n    _fields_ = [(\'dwLength\', DWORD), (\'dwMemoryLoad\', DWORD), (\'dwTotalPhys\', DWORD), (\'dwAvailPhys\', DWORD), (\'dwTotalPageFile\', DWORD), (\'dwAvailPageFile\', DWORD), (\'dwTotalVirtual\', DWORD), (\'dwAvailVirtual\', DWORD)]\n\ndef winmem():\n    x = MEMORYSTATUS()\nwindll.kernel32.GlobalMemoryStatus(byref(x))\nreturn x\n\n\nclass process_stats:\n    "process_stats is able to provide counters of (all?) the items available in perfmon.\\n    Refer to the self.supported_types keys for the currently supported \'Performance Objects\'\\n    To add logging support for other data you can derive the necessary data from perfmon:\\n    ---------\\n    perfmon can be run from windows \'run\' menu by entering \'perfmon\' and enter.\\n    Clicking on the \'+\' will open the \'add counters\' menu,\\n    From the \'Add Counters\' dialog, the \'Performance object\' is the self.support_types key.\\n    --> Where spaces are removed and symbols are entered as text (Ex. \\n    For the items you wish to log add the proper attribute name in the list in the self.supported_types dictionary,\\n    keyed by the \'Performance Object\' name as mentioned above.\\n    ---------\\n    NOTE: The \'NETFramework_NETCLRMemory\' key does not seem to log dotnet 2.0 properly.\\n    Initially the python implementation was derived from:\\n    http://www.microsoft.com/technet/scriptcenter/scripts/default.mspx?mfr=true\\n    "'
p6364
(F9.921459133342161
F2.9234566321739783
tp6365
sS'proc_results_list.append(this_proc_dict)'
p6366
(F15.711790084838867
F3.193145751953125
tp6367
sS"query_str = ('Select * from %s%s' % (self.win32_perf_base, counter_type))\ncolItems = objSWbemServices.ExecQuery(query_str)\nif (len(colItems) > 0):\n    for objItem in colItems:\n        if (hasattr(objItem, 'IDProcess') and (pid == objItem.IDProcess)):\n            for attribute in self.supported_types[counter_type]:\n                eval_str = ('objItem.%s' % attribute)\nthis_proc_dict[attribute] = eval(eval_str)"
p6368
(F14.660207349200581
F2.889482938326322
tp6369
sS'this_proc_dict = {}\nif (not self.process_name_list):\n    pass'
p6370
(F14.43519761827257
F3.1349249619704027
tp6371
ssI5137497
(dp6372
S"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')"
p6373
(F11.945374382866753
F4.105695343017578
tp6374
sS"print((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))"
p6375
(F13.159631063771803
F4.00097427368164
tp6376
sS"print('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6377
(F11.876266479492188
F3.7515186309814452
tp6378
sS"full_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6379
(F14.224748883928571
F3.781381607055664
tp6380
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')"
p6381
(F9.730867607648982
F4.045467376708984
tp6382
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))"
p6383
(F9.719376303932883
F4.005419158935547
tp6384
sS"print('This file directory only')"
p6385
(F6.651454925537109
F4.3715980529785154
tp6386
sS"full_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))"
p6387
(F14.42042824074074
F3.927869415283203
tp6388
sS"import os\nprint('Path at terminal when executing this file')"
p6389
(F9.863804287380642
F3.965585708618164
tp6390
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)"
p6391
(F11.453412420099431
F4.170206451416016
tp6392
sS"print('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')"
p6393
(F12.812442264041385
F3.942236328125
tp6394
sS"print('This file directory only')\nprint(os.path.dirname(full_path))"
p6395
(F12.638429260253906
F3.9323524475097655
tp6396
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6397
(F13.02103271484375
F3.858221435546875
tp6398
sS"(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6399
(F11.743690490722656
F3.796935272216797
tp6400
sS"print((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6401
(F13.107084386488971
F3.8949020385742186
tp6402
sS"(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6403
(F12.345289829799107
F3.76314697265625
tp6404
sS"print('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6405
(F13.764209888599536
F3.777720642089844
tp6406
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')"
p6407
(F12.416346538497741
F3.9598522186279297
tp6408
sS'import os'
p6409
(F15.522573471069336
F3.8392333984375
tp6410
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6411
(F12.50950766509434
F3.8209888458251955
tp6412
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6413
(F12.204545734309349
F3.839875411987305
tp6414
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6415
(F12.069010858950408
F3.851849365234375
tp6416
sS"print((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6417
(F8.655089668605639
F4.241942977905273
tp6418
sS"print('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)"
p6419
(F13.889264787946429
F3.98414306640625
tp6420
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6421
(F12.030181884765625
F3.8630836486816404
tp6422
sS'dir_path = os.path.dirname(os.path.realpath(__file__))'
p6423
(F14.951561969259512
F3.838612747192383
tp6424
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6425
(F13.03077654157366
F3.883818435668945
tp6426
sS"full_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6427
(F12.671820842044454
F3.7852336883544924
tp6428
sS"print((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6429
(F11.567398071289062
F3.839516448974609
tp6430
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')"
p6431
(F11.530805433118665
F3.9213348388671876
tp6432
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))"
p6433
(F9.616808210100446
F4.3314674377441404
tp6434
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)"
p6435
(F11.794530029296874
F4.131002044677734
tp6436
sS"print('This file full path (following symlinks)')"
p6437
(F6.651454925537109
F4.3715980529785154
tp6438
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')"
p6439
(F15.328379313151041
F4.144279098510742
tp6440
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6441
(F12.521226671006945
F3.830486297607422
tp6442
sS'from __future__ import print_function'
p6443
(F18.818325805664063
F4.438111114501953
tp6444
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6445
(F12.605958826401654
F3.8147144317626953
tp6446
sS"print((full_path + '\\n'))"
p6447
(F11.729586283365885
F4.427524566650391
tp6448
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6449
(F12.254945234818893
F3.9476409912109376
tp6450
sS"print('This file directory and name')"
p6451
(F6.651454925537109
F4.3715980529785154
tp6452
sS"print((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')"
p6453
(F12.527418772379557
F4.001394653320313
tp6454
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)"
p6455
(F12.748434038304572
F3.990683746337891
tp6456
sS"print('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6457
(F13.202732252038043
F3.775605392456055
tp6458
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')"
p6459
(F11.441399207481972
F4.105089569091797
tp6460
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))"
p6461
(F12.781174097305689
F3.962136077880859
tp6462
sS"print((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6463
(F12.315209089006697
F3.79070930480957
tp6464
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))"
p6465
(F9.87352294921875
F4.315235137939453
tp6466
sS"print('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6467
(F12.410198813990542
F3.7756309509277344
tp6468
sS"print((os.getcwd() + '\\n'))"
p6469
(F8.994519914899554
F4.315177917480469
tp6470
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))"
p6471
(F11.718431877367424
F4.113017272949219
tp6472
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)"
p6473
(F11.654155862742456
F3.9395286560058596
tp6474
sS"print((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)"
p6475
(F13.21263313293457
F4.062181854248047
tp6476
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')"
p6477
(F11.623881946910512
F4.066854095458984
tp6478
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')"
p6479
(F9.328196772822627
F4.01594352722168
tp6480
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6481
(F11.704006498893806
F3.8119388580322267
tp6482
sS"print((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6483
(F12.631212187976372
F3.813370132446289
tp6484
sS'import os\ncwd = os.getcwd()'
p6485
(F11.782864888509115
F3.8132644653320313
tp6486
sS"print((((path + ' --> ') + filename) + '\\n'))"
p6487
(F9.079443189832899
F4.228369522094726
tp6488
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6489
(F11.614494185014205
F3.896818923950195
tp6490
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6491
(F11.850348772321428
F3.889363098144531
tp6492
sS'from __future__ import print_function\nimport os'
p6493
(F19.02752450796274
F4.157897186279297
tp6494
sS"print('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6495
(F12.805710483604754
F3.758815383911133
tp6496
sS"print((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6497
(F11.155644597233954
F4.0149883270263675
tp6498
sS"print('Path at terminal when executing this file')"
p6499
(F6.651454925537109
F4.3715980529785154
tp6500
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6501
(F12.044590119392641
F3.8627220153808595
tp6502
sS'import os\ndir_path = os.path.dirname(os.path.realpath(__file__))'
p6503
(F15.38042978140024
F3.7096939086914062
tp6504
sS"print((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6505
(F12.723678739944306
F3.7980674743652343
tp6506
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))"
p6507
(F12.01370689517162
F4.0739990234375
tp6508
sS"print((__file__ + '\\n'))"
p6509
(F10.590306599934896
F4.323029327392578
tp6510
sS"full_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6511
(F13.099208947383996
F3.767536163330078
tp6512
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')"
p6513
(F12.103988935362619
F4.0501361846923825
tp6514
sS"print('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6515
(F12.281600693524894
F3.7435844421386717
tp6516
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))"
p6517
(F12.647898356119791
F4.053670883178711
tp6518
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6519
(F12.357667357057005
F3.8248012542724608
tp6520
sS"print('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6521
(F12.876521809895833
F3.7528358459472657
tp6522
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))"
p6523
(F10.073230944181743
F4.033298492431641
tp6524
sS"print('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6525
(F11.338638644748263
F3.7807559967041016
tp6526
sS'print(os.path.dirname(full_path))'
p6527
(F13.942867024739583
F3.900131607055664
tp6528
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))"
p6529
(F11.87568996263587
F3.919768142700195
tp6530
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6531
(F12.278804591444672
F3.838850402832031
tp6532
sS"full_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6533
(F13.124852079503677
F3.760816955566406
tp6534
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6535
(F12.115580401082678
F3.7906143188476564
tp6536
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)"
p6537
(F12.546317435599661
F4.122974395751953
tp6538
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')"
p6539
(F9.308321380615235
F4.340393447875977
tp6540
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6541
(F11.776663643973214
F3.872221755981445
tp6542
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))"
p6543
(F12.716865785660282
F4.112212371826172
tp6544
sS'(path, filename) = os.path.split(full_path)'
p6545
(F14.165595160590279
F3.753199005126953
tp6546
sS"print((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6547
(F13.411061448317307
F3.844411849975586
tp6548
sS"print((full_path + '\\n'))\nprint('This file directory and name')"
p6549
(F10.597691255457262
F4.436796569824219
tp6550
sS"print('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))"
p6551
(F13.647005081176758
F3.930948257446289
tp6552
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))"
p6553
(F8.832544427168997
F4.322589111328125
tp6554
sS"(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')\nprint(os.path.dirname(full_path))"
p6555
(F12.6889727557147
F3.7537891387939455
tp6556
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')"
p6557
(F8.601399739583334
F4.333036422729492
tp6558
sS'cwd = os.getcwd()'
p6559
(F10.456675211588541
F4.093108749389648
tp6560
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')"
p6561
(F9.513238525390625
F4.323677825927734
tp6562
sS"full_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')"
p6563
(F13.418868064880371
F3.944091033935547
tp6564
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6565
(F12.378250999012213
F3.84051628112793
tp6566
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')"
p6567
(F9.426463040438565
F4.385992431640625
tp6568
sS"print((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6569
(F12.02127015356924
F3.819347381591797
tp6570
sS"print('This file path, relative to os.getcwd()')"
p6571
(F6.651454925537109
F4.3715980529785154
tp6572
sS"print((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))\nprint('This file directory only')"
p6573
(F12.291263974946121
F3.826617431640625
tp6574
sS'full_path = os.path.realpath(__file__)'
p6575
(F15.216987609863281
F3.9904815673828127
tp6576
sS"print('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')"
p6577
(F11.37035702987456
F4.105062866210938
tp6578
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)"
p6579
(F12.501536909356174
F3.912145233154297
tp6580
sS"print((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')"
p6581
(F8.772696244089227
F4.322862243652343
tp6582
sS"import os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))\nprint('This file full path (following symlinks)')\nfull_path = os.path.realpath(__file__)\nprint((full_path + '\\n'))\nprint('This file directory and name')\n(path, filename) = os.path.split(full_path)\nprint((((path + ' --> ') + filename) + '\\n'))"
p6583
(F11.937756573712385
F3.8016334533691407
tp6584
sS"from __future__ import print_function\nimport os\nprint('Path at terminal when executing this file')\nprint((os.getcwd() + '\\n'))\nprint('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))"
p6585
(F11.913889783494016
F4.100286865234375
tp6586
sS"print('This file path, relative to os.getcwd()')\nprint((__file__ + '\\n'))"
p6587
(F9.977145924287683
F4.3727775573730465
tp6588
sS"print((__file__ + '\\n'))\nprint('This file full path (following symlinks)')"
p6589
(F9.814153334673714
F4.342418670654297
tp6590
ssI930397
(dp6591
S"alist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6592
(F6.449952156313004
F1.6346926255659624
tp6593
sS"alist[(-1):]\nastr = ''"
p6594
(F7.1709780011858255
F1.598732514814897
tp6595
sS'some_list[(-2)] = 3'
p6596
(F10.750352125901442
F1.597578915682706
tp6597
sS'alist[(-1)]\nalist[(-1):]'
p6598
(F6.161574469672309
F1.6792245344682173
tp6599
sS'alist[(-1):]'
p6600
(F6.1342529296875
F1.626540097323331
tp6601
sS'astr[(-1)]\nastr[(-1):]'
p6602
(F6.161574469672309
F1.6792245344682173
tp6603
sS'some_list = [1, 2, 3]'
p6604
(F9.328161973219652
F1.50587289983576
tp6605
sS"alist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]"
p6606
(F6.49490000406901
F1.6690677296031604
tp6607
sS'alist.pop()'
p6608
(F9.073728288922991
F1.5259390744295986
tp6609
sS'some_list'
p6610
(F17.871754455566407
F1.7306421453302556
tp6611
sS'alist = []\nalist[(-1)]\nalist[(-1):]'
p6612
(F6.312274435292119
F1.571828842163086
tp6613
sS'alist = []\nalist[(-1)]'
p6614
(F6.361705235072544
F1.5284706462513318
tp6615
sS'some_list[(-2)] = 3\nsome_list'
p6616
(F12.946098776424632
F1.5849123868075283
tp6617
sS"astr = ''\nastr[(-1)]"
p6618
(F6.2819389930138225
F1.5627332167191939
tp6619
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5\nsome_list[(-2)] = 3\nsome_list'
p6620
(F11.457756972894437
F1.5150479403409092
tp6621
sS"astr = ''\nastr[(-1)]\nastr[(-1):]"
p6622
(F6.212731101296165
F1.584442138671875
tp6623
sS"astr = ''"
p6624
(F7.562953186035156
F1.809155204079368
tp6625
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]"
p6626
(F6.621859305245536
F1.5846120660955256
tp6627
sS"alist[(-1)]\nalist[(-1):]\nastr = ''"
p6628
(F6.800025246360085
F1.663587050004439
tp6629
sS'alist = []'
p6630
(F5.210867245992024
F1.5169296264648438
tp6631
sS'astr[(-1)]'
p6632
(F5.941989898681641
F1.6264109178022905
tp6633
sS"alist[(-1):]\nastr = ''\nastr[(-1)]"
p6634
(F6.626886541193182
F1.6091093583540483
tp6635
sS'alist[(-1)]'
p6636
(F5.941989474826389
F1.6264109178022905
tp6637
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5'
p6638
(F10.082767333984375
F1.503544200550426
tp6639
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''"
p6640
(F6.806932237413195
F1.5692551352761008
tp6641
sS"alist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6642
(F6.335670275565906
F1.685097954489968
tp6643
sS'some_list[(-1)] = 5\nsome_list[(-2)] = 3'
p6644
(F10.957633056640624
F1.5875157442959873
tp6645
sS"alist = []\nalist[(-1)]\nalist[(-1):]\nastr = ''\nastr[(-1)]\nastr[(-1):]"
p6646
(F6.459666859019887
F1.6052357066761365
tp6647
sS'some_list = [1, 2, 3]\nsome_list[(-1)] = 5\nsome_list[(-2)] = 3'
p6648
(F10.511740194784629
F1.513260234485973
tp6649
sS'some_list[(-1)] = 5'
p6650
(F10.548682579627403
F1.6162161393599077
tp6651
sS'astr[(-1):]'
p6652
(F6.1342529296875
F1.626540097323331
tp6653
sS'some_list[(-1)] = 5\nsome_list[(-2)] = 3\nsome_list'
p6654
(F12.212665426320044
F1.5807685852050781
tp6655
ssI961632
(dp6656
S"str(10)\nint('10')"
p6657
(F7.435790322043679
F2.0367327796088324
tp6658
sS'str(a)'
p6659
(F8.772350947062174
F2.1104147169325085
tp6660
sS'str(10)'
p6661
(F7.393227895100911
F2.1087591383192272
tp6662
sS'str(i)'
p6663
(F8.644381841023764
F2.1720962524414062
tp6664
sS"int('10')"
p6665
(F5.982837677001953
F2.0837171342637806
tp6666
sS'a.__str__()'
p6667
(F11.76059299045139
F2.2792046864827475
tp6668
ssI1712227
(dp6669
S"items.append('apple')\nitems.append('orange')"
p6670
(F10.520387776692708
F1.7372129440307618
tp6671
sS"items = []\nitems.append('apple')\nitems.append('orange')\nitems.append('banana')"
p6672
(F9.952990496600115
F1.6681253433227539
tp6673
sS'print l'
p6674
(F12.30093002319336
F1.5979134559631347
tp6675
sS'l.length'
p6676
(F14.868974304199218
F1.6463722229003905
tp6677
sS"items.append('banana')"
p6678
(F9.483587265014648
F1.6748226165771485
tp6679
sS'len(items)'
p6680
(F10.745286305745443
F1.4916484832763672
tp6681
sS"items.append('apple')"
p6682
(F9.483587265014648
F1.6748228073120117
tp6683
sS'l = slist(range(10))\nl.length\nprint l'
p6684
(F11.575863308376736
F1.5839092254638671
tp6685
sS"items = []\nitems.append('apple')\nitems.append('orange')"
p6686
(F9.544823455810548
F1.609097671508789
tp6687
sS'items.__len__()'
p6688
(F13.792283799913195
F1.6915748596191407
tp6689
sS"items.append('orange')\nitems.append('banana')"
p6690
(F10.520387776692708
F1.7372129440307618
tp6691
sS'True'
p6692
(F12.271570841471354
F1.7714784622192383
tp6693
sS'class slist(list):\n    pass'
p6694
(F9.519022623697916
F1.6067127227783202
tp6695
sS'def length(self):\n    pass'
p6696
(F10.558462778727213
F1.743316650390625
tp6697
sS'def length(self):\n    return len(self)'
p6698
(F11.715158462524414
F1.7013763427734374
tp6699
sS"items.append('orange')"
p6700
(F9.483587265014648
F1.6748228073120117
tp6701
sS'l.length\nprint l'
p6702
(F13.86845588684082
F1.597782802581787
tp6703
sS'l = slist(range(10))\nl.length'
p6704
(F11.901102701822916
F1.6068531036376954
tp6705
sS'items = []'
p6706
(F6.534525553385417
F1.4905889511108399
tp6707
sS'return len(self)'
p6708
(F13.859688895089286
F1.6960674285888673
tp6709
sS'len([1, 2, 3])'
p6710
(F7.199263254801433
F1.5054401397705077
tp6711
sS'l = slist(range(10))'
p6712
(F9.062254472212357
F1.6327533721923828
tp6713
sS"items = []\nitems.append('apple')"
p6714
(F8.80432363656851
F1.5415717124938966
tp6715
sS"items.append('apple')\nitems.append('orange')\nitems.append('banana')"
p6716
(F10.76080252907493
F1.7713598251342773
tp6717
ssI1720421
(dp6718
S'for item in itertools.chain(listone, listtwo):\n    pass'
p6719
(F13.041907416449654
F3.2955216627854567
tp6720
sS'import itertools'
p6721
(F15.972984313964844
F3.1567362271822414
tp6722
sS'pass'
p6723
(F10.744378407796225
F3.600114969106821
tp6724
sS'import itertools\nfor item in itertools.chain(listone, listtwo):\n    pass'
p6725
(F13.584368024553571
F3.145308567927434
tp6726
sS'mergedlist = (listone + listtwo)'
p6727
(F8.886769612630209
F3.4004607567420373
tp6728
sS'mergedlist = list(set((listone + listtwo)))'
p6729
(F9.985483805338541
F3.1913199791541467
tp6730
ssI209513
(dp6731
S"x = int('deadbeef', 16)"
p6732
(F7.970218658447266
F1.7953419155544705
tp6733
sS'int(s, 16)'
p6734
(F8.626317977905273
F1.7702213923136394
tp6735
sS"int('a', 16)\nint('0xa', 16)"
p6736
(F7.3574167887369795
F1.7863339318169489
tp6737
sS"int('0xa', 16)"
p6738
(F6.5820841789245605
F1.807050281100803
tp6739
sS"print int('10', 0)"
p6740
(F8.405644734700521
F1.7753396564059787
tp6741
sS"print int('0xdeadbeef', 0)"
p6742
(F8.405644734700521
F1.7753396564059787
tp6743
sS"print int('0xdeadbeef', 0)\nprint int('10', 0)"
p6744
(F9.19801689596737
F1.7587876849704318
tp6745
sS"int('a', 16)"
p6746
(F6.5820841789245605
F1.807050069173177
tp6747
ssI642154
(dp6748
S'[[int(y) for y in x] for x in T1]'
p6749
(F14.75132581922743
F1.9234685030850498
tp6750
sS'T2 = [[int(column) for column in row] for row in T1]'
p6751
(F15.021603393554688
F1.9005185907537288
tp6752
sS'T2 = [parse_a_row_of_T1(row) for row in T1]'
p6753
(F16.06387745250355
F1.924301494251598
tp6754
sS'T2 = [map(int, x) for x in T1]'
p6755
(F12.938636779785156
F1.9458292180841619
tp6756
sS"print((int('1') + 1))"
p6757
(F7.939980140099158
F1.913941816850142
tp6758
ssI7961363
(dp6759
S"list(OrderedDict.fromkeys('abracadabra'))"
p6760
(F9.503714243570963
F3.7403748830159507
tp6761
sS's = [1, 2, 3]\nlist((set(t) - set(s)))'
p6762
(F9.051864624023438
F2.627716382344564
tp6763
sS"list(dict.fromkeys('abracadabra'))"
p6764
(F9.377132068980824
F3.315903663635254
tp6765
sS'list(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p6766
(F9.93519951315487
F2.6288623809814453
tp6767
sS't\nlist(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p6768
(F10.11802503797743
F2.6148438453674316
tp6769
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt'
p6770
(F7.153634033203125
F3.078802744547526
tp6771
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]\nlist((set(t) - set(s)))'
p6772
(F8.662629226158405
F2.572643597920736
tp6773
sS'from collections import OrderedDict'
p6774
(F18.717010498046875
F2.7784601847330728
tp6775
sS'list(set(t))'
p6776
(F9.865956624348959
F2.9102261861165366
tp6777
sS'list((set(t) - set(s)))'
p6778
(F10.07381820678711
F3.055072466532389
tp6779
sS's = [1, 2, 3]'
p6780
(F6.6722939231178975
F2.939375877380371
tp6781
sS't\nlist(set(t))'
p6782
(F10.998850042169744
F2.948831558227539
tp6783
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))'
p6784
(F7.877109411991004
F2.715127944946289
tp6785
sS't'
p6786
(F15.102676391601562
F4.099415461222331
tp6787
sS'list(set(t))\ns = [1, 2, 3]'
p6788
(F9.122557790655838
F2.812622388203939
tp6789
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]\nt\nlist(set(t))\ns = [1, 2, 3]'
p6790
(F7.836153252180233
F2.6788711547851562
tp6791
sS't\nlist(set(t))\ns = [1, 2, 3]'
p6792
(F9.606128510974703
F2.8147506713867188
tp6793
sS't = [1, 2, 3, 1, 2, 5, 6, 7, 8]'
p6794
(F6.186969259510869
F3.028191884358724
tp6795
sS"from collections import OrderedDict\nlist(OrderedDict.fromkeys('abracadabra'))"
p6796
(F13.338136461046007
F2.8343334197998047
tp6797
ssI6996603
(dp6798
S'shutil.rmtree(path, ignore_errors=False, onerror=None)'
p6799
(F12.725762261284721
F3.2236913045247397
tp6800
sS'os.removedirs(name)'
p6801
(F11.365958213806152
F2.776886410183377
tp6802
sS'os.rmdir'
p6803
(F13.278297424316406
F2.6964054107666016
tp6804
sS'os.remove'
p6805
(F15.068106079101563
F2.6528572506374783
tp6806
ssI2269827
(dp6807
S"(chr(101) == 'e')\nhex(65)"
p6808
(F6.312764485677083
F1.9652544657389324
tp6809
sS"hex(65)\n(chr(65) == 'A')"
p6810
(F6.052999369303385
F1.910037358601888
tp6811
sS"('0x%x' % 255)"
p6812
(F5.431058611188616
F1.8264228502909343
tp6813
sS"(chr(101) == 'e')\nhex(65)\n(chr(65) == 'A')"
p6814
(F6.243040084838867
F1.9801114400227864
tp6815
sS"(chr(101) == 'e')"
p6816
(F5.409170913696289
F2.0074119567871094
tp6817
sS"strHex = ('0x%0.2X' % 255)"
p6818
(F8.626919555664063
F1.8282861709594727
tp6819
sS"('0x%X' % 255)"
p6820
(F5.431058611188616
F1.8264226913452148
tp6821
sS'hex(65)'
p6822
(F6.385583241780599
F1.8965191841125488
tp6823
sS"(chr(65) == 'A')"
p6824
(F5.409170913696289
F2.0074119567871094
tp6825
ssI9257094
(dp6826
S"lower = raw_input('type in the same thing caps lock.')"
p6827
(F11.141635131835937
F3.1738003624810114
tp6828
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p6829
(F12.397409292367788
F3.2396428849962025
tp6830
sS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()"
p6831
(F11.662592270795036
F3.2108207278781467
tp6832
sS'print upper.upper()\nprint lower.lower()'
p6833
(F11.253324381510417
F3.17252434624566
tp6834
sS'print s.upper()'
p6835
(F10.049613952636719
F3.1193936665852866
tp6836
sS'string.ascii_uppercase'
p6837
(F16.24993351527623
F3.0068240695529513
tp6838
sS"upper = raw_input('type in something lowercase.')"
p6839
(F11.153434753417969
F3.1701958974202475
tp6840
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')"
p6841
(F12.26155572188528
F3.2171779208713107
tp6842
sS's.upper()'
p6843
(F9.850021362304688
F3.138545142279731
tp6844
sS"s = 'sdsd'\ns.upper()"
p6845
(F9.181743275035512
F3.048445383707682
tp6846
sS"upper = raw_input('type in something lowercase.')\nlower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p6847
(F12.310600511955492
F3.2337688869900174
tp6848
sS"lower = raw_input('type in the same thing caps lock.')\nprint upper.upper()\nprint lower.lower()"
p6849
(F11.711996714274088
F3.207118140326606
tp6850
sS'print upper.upper()'
p6851
(F10.756690979003906
F3.1966400146484375
tp6852
sS"s = 'sdsd'"
p6853
(F7.781169128417969
F3.064849429660373
tp6854
sS'print lower.lower()'
p6855
(F10.431706428527832
F3.1609149509006076
tp6856
sS'import string'
p6857
(F15.843301773071289
F3.0409923129611545
tp6858
sS'import string\nstring.ascii_uppercase'
p6859
(F16.297238159179688
F2.9986835055881076
tp6860
sS"s = 'sdsd'\nprint s.upper()"
p6861
(F9.223102569580078
F3.047052171495226
tp6862
ssI730764
(dp6863
S'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass\nelse:\n    raise'
p6864
(F10.341838747956032
F3.4531041463216146
tp6865
sS'try:\n    doSomething()\nexcept Exception:\n    pass'
p6866
(F8.394936009457236
F3.427781168619792
tp6867
sS'try:\n    sys.exit(1)\nexcept Exception:\n    pass'
p6868
(F8.78324962797619
F3.4148793538411457
tp6869
sS'try:\n    doSomething()\nexcept:\n    pass'
p6870
(F7.749825371636285
F3.4295621236165363
tp6871
sS'pass'
p6872
(F9.61197280883789
F3.3716779073079426
tp6873
sS"shutil.rmtree('/fake/dir')"
p6874
(F8.16574764251709
F3.562933858235677
tp6875
sS'try:\n    do_something()\nexcept:\n    pass'
p6876
(F8.364316438373766
F3.4014818827311197
tp6877
sS'raise'
p6878
(F15.565544128417969
F3.41737798055013
tp6879
sS'shutil.rmtree(2)'
p6880
(F9.032915115356445
F3.532410176595052
tp6881
sS'shutil.rmtree(path)'
p6882
(F9.937618255615234
F3.514234924316406
tp6883
sS'if (e.errno == 2):\n    pass'
p6884
(F10.365993245442708
F3.4173375447591146
tp6885
sS'handle_exception()'
p6886
(F12.415921892438616
F3.4612391153971354
tp6887
sS'try:\n    do_something()\nexcept:\n    handle_exception()'
p6888
(F9.478558747664742
F3.409706624348958
tp6889
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass\nelse:\n    pass'
p6890
(F10.253224217614463
F3.4444455464680988
tp6891
sS'sys.exit(1)'
p6892
(F9.287506103515625
F3.378614807128906
tp6893
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    pass'
p6894
(F10.601226806640625
F3.491760762532552
tp6895
sS'try:\n    shutil.rmtree(path)\nexcept OSError:\n    pass'
p6896
(F9.129463195800781
F3.494063313802083
tp6897
sS'try:\n    sys.exit(1)\nexcept:\n    pass'
p6898
(F8.13299331665039
F3.4162684122721356
tp6899
sS'do_something()'
p6900
(F11.32506343296596
F3.3443761189778645
tp6901
sS'doSomething()'
p6902
(F9.4449462890625
F3.387434387207031
tp6903
sS'try:\n    shutil.rmtree(path)\nexcept OSError as e:\n    if (e.errno == 2):\n        pass'
p6904
(F10.68359375
F3.449223836263021
tp6905
sS'try:\n    do_something()\nexcept:\n    handle_exception()\nraise'
p6906
(F10.455009765625
F3.411011250813802
tp6907
ssI70797
(dp6908
S"var = raw_input('Please enter something: ')"
p6909
(F11.099702453613281
F4.254337734646267
tp6910
sS'import sys'
p6911
(F15.459249496459961
F4.294022030300564
tp6912
sS'from __future__ import print_function\nimport sys\nprint(sys.argv)'
p6913
(F16.312432861328126
F4.314638773600261
tp6914
sS'print(sys.argv)'
p6915
(F10.985960006713867
F4.289965311686198
tp6916
sS'from __future__ import print_function'
p6917
(F18.94512481689453
F4.312578837076823
tp6918
sS'import sys\nprint sys.argv'
p6919
(F14.37277560763889
F4.377512613932292
tp6920
sS"input_var = input('Enter something: ')\nprint(('you entered ' + input_var))"
p6921
(F11.566017514183407
F4.203559027777778
tp6922
sS'import sys\nprint(sys.argv)'
p6923
(F12.334279840642756
F4.327320098876953
tp6924
sS"print 'you entered', var"
p6925
(F8.585014343261719
F4.276465945773655
tp6926
sS'from __future__ import print_function\nimport sys'
p6927
(F19.157704279972958
F4.2982593112521705
tp6928
sS"input_var = input('Enter something: ')"
p6929
(F10.782095336914063
F4.234522077772352
tp6930
sS'print sys.argv'
p6931
(F13.25723139444987
F4.341436598036024
tp6932
sS"var = raw_input('Please enter something: ')\nprint 'you entered', var"
p6933
(F11.173868815104166
F4.238706800672743
tp6934
sS"print(('you entered ' + input_var))"
p6935
(F10.85693359375
F4.205470614963108
tp6936
ssI4706499
(dp6937
S'f.seek(0)\nf.read()'
p6938
(F9.908960614885602
F1.4916507403055828
tp6939
sS'f.seek(0)'
p6940
(F9.391084671020508
F1.6731346448262532
tp6941
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6942
(F10.000074114118304
F1.495211919148763
tp6943
sS"f.write('hi')"
p6944
(F8.719005584716797
F1.4965332349141438
tp6945
sS"f.write('hi')\nf.seek(0)"
p6946
(F9.667231241861979
F1.533434549967448
tp6947
sS"open('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p6948
(F7.763487497965495
F1.308581272761027
tp6949
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p6950
(F9.802324567522321
F1.465795675913493
tp6951
sS"open('test', 'rb').read()"
p6952
(F7.372202555338542
F1.3349415461222331
tp6953
sS"f.seek(0)\nf.write('bye')"
p6954
(F9.611031087239583
F1.5033338864644368
tp6955
sS"with open('foo', 'a') as f:\n    pass"
p6956
(F10.18387222290039
F1.2987616856892903
tp6957
sS'f.read()'
p6958
(F8.899320874895368
F1.4611992835998535
tp6959
sS"myfile.write('appended text')"
p6960
(F8.719005584716797
F1.4965332349141438
tp6961
sS"f = open('test', 'a+')"
p6962
(F7.113858032226562
F1.3580602010091145
tp6963
sS"with open('test.txt', 'a') as myfile:\n    myfile.write('appended text')"
p6964
(F9.830899193173362
F1.2852436701456706
tp6965
sS"f.write('hi')\nf.seek(0)\nf.read()"
p6966
(F9.731474376860119
F1.4726556142171223
tp6967
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p6968
(F9.396372708407315
F1.3959740002950032
tp6969
sS"f.read()\nf.seek(0)\nf.write('bye')"
p6970
(F9.665647960844494
F1.4411719640096028
tp6971
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6972
(F9.976285608803353
F1.4703790346781414
tp6973
sS"f.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6974
(F9.887392316545759
F1.4889017740885417
tp6975
sS"f.seek(0)\nf.write('bye')\nf.seek(0)"
p6976
(F9.885862870649857
F1.536580244700114
tp6977
sS'f.seek(0)\nf.read()\nf.seek(0)'
p6978
(F9.985410417829241
F1.5168442726135254
tp6979
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p6980
(F9.602061489172149
F1.40204652150472
tp6981
sS"open('test', 'a+b').write('koko')"
p6982
(F7.566947350135217
F1.33206574122111
tp6983
sS"f.write('cool beans...')"
p6984
(F8.719005584716797
F1.4965332349141438
tp6985
sS"with open('foo', 'a') as f:\n    f.write('cool beans...')"
p6986
(F9.830899193173362
F1.2852436701456706
tp6987
sS'f.read()\nf.seek(0)'
p6988
(F9.65150887625558
F1.491520086924235
tp6989
sS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p6990
(F9.860787527901786
F1.4719799359639485
tp6991
sS"'testkoko'"
p6992
(F3.310255686442057
F1.5184949239095051
tp6993
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p6994
(F9.821277073451451
F1.492070198059082
tp6995
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()"
p6996
(F9.002578735351562
F1.3886477152506511
tp6997
sS"f.write('bye')"
p6998
(F8.719005584716797
F1.4965330759684246
tp6999
sS"f.write('bye')\nf.seek(0)"
p7000
(F9.667231241861979
F1.533434549967448
tp7001
sS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')\nopen('test', 'rb').read()"
p7002
(F7.979120042588976
F1.2956016858418782
tp7003
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p7004
(F9.902635846819196
F1.483210563659668
tp7005
sS"f = open('test', 'a+')\nf.write('hi')"
p7006
(F8.028116562787224
F1.3569234212239583
tp7007
sS"open('test', 'wb').write('test')\nopen('test', 'a+b').write('koko')"
p7008
(F7.909317626953125
F1.3064330418904622
tp7009
sS"f.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p7010
(F9.852234784294577
F1.447297732035319
tp7011
sS"f.write('koko')"
p7012
(F8.719005584716797
F1.4965330759684246
tp7013
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)"
p7014
(F9.571573294845281
F1.4120985666910808
tp7015
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)"
p7016
(F8.82594108581543
F1.4041086832682292
tp7017
sS"f.write('bye')\nf.seek(0)\nf.read()"
p7018
(F9.731474376860119
F1.4726556142171223
tp7019
sS"open('test', 'wb').write('test')"
p7020
(F7.566947350135217
F1.33206574122111
tp7021
sS"f = open('test', 'a+')\nf.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)"
p7022
(F9.32882360509924
F1.4088672002156575
tp7023
sS"f.write('test')"
p7024
(F8.719005584716797
F1.4965330759684246
tp7025
sS'fseek(stream, 0, SEEK_END)'
p7026
(F11.627071380615234
F1.7015339533487956
tp7027
sS"f.write('hi')\nf.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')\nf.seek(0)\nf.read()"
p7028
(F9.891841888427734
F1.465225378672282
tp7029
sS"f.seek(0)\nf.read()\nf.seek(0)\nf.write('bye')"
p7030
(F9.918590000697545
F1.47235902150472
tp7031
sS"with open('test.txt', 'a') as myfile:\n    pass"
p7032
(F10.18387222290039
F1.2987616856892903
tp7033
ssI22676
(dp7034
S"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7035
(F13.113781628307995
F1.9530899341289814
tp7036
sS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p7037
(F11.974631899879093
F1.7843137887807994
tp7038
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7039
(F11.945771484375
F1.8862703763521635
tp7040
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7041
(F13.07981325545401
F1.7794322967529297
tp7042
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192"
p7043
(F13.088036867651608
F1.891729501577524
tp7044
sS"file_name = url.split('/')[(-1)]"
p7045
(F10.411488850911459
F2.01486323429988
tp7046
sS"import urllib2\nresponse = urllib2.urlopen('http://www.example.com/')"
p7047
(F12.563246506911058
F1.807986332820012
tp7048
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7049
(F13.088737487792969
F2.0088700514573317
tp7050
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7051
(F13.342125202047415
F2.0259945209209738
tp7052
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192"
p7053
(F12.967851911272321
F1.9376047574556792
tp7054
sS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7055
(F12.74803485292377
F1.967354260958158
tp7056
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7057
(F11.710564815636838
F1.8385209303635817
tp7058
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7059
(F13.057918607271635
F2.1443101442777195
tp7060
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0"
p7061
(F13.36323866733285
F2.1510356022761417
tp7062
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7063
(F13.348528945655154
F2.0885471930870643
tp7064
sS'import urllib'
p7065
(F15.841285705566406
F1.9164937826303334
tp7066
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7067
(F11.77681687298943
F1.8279125507061298
tp7068
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7069
(F11.852682179418103
F2.2024066631610575
tp7070
sS"url = 'http://download.thinkbroadband.com/10MB.zip'"
p7071
(F8.01016616821289
F2.088317577655499
tp7072
sS'if (not buffer):\n    break\nfile_size_dl += len(buffer)'
p7073
(F12.992434294327445
F2.266143798828125
tp7074
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7075
(F12.940263591828893
F1.9599423041710486
tp7076
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7077
(F13.124733302904213
F1.8240968264066255
tp7078
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7079
(F12.02747224506579
F1.8481665391188402
tp7080
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))"
p7081
(F12.705049896240235
F1.941933851975661
tp7082
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))"
p7083
(F12.950606734664351
F2.1328788170447717
tp7084
sS"f = open(file_name, 'wb')"
p7085
(F11.639166514078775
F1.9471632150503306
tp7086
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7087
(F13.166065401243932
F2.176679024329552
tp7088
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))"
p7089
(F12.883042446402616
F2.1918802994948168
tp7090
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7091
(F12.499119349888392
F2.1462312845083384
tp7092
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7093
(F13.270594741358902
F2.1315493950477014
tp7094
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7095
(F13.39087625151699
F2.0852376497708836
tp7096
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7097
(F13.168951955782314
F2.163228548490084
tp7098
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192"
p7099
(F13.406093052455358
F2.1281460982102613
tp7100
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7101
(F12.805443548387096
F2.2344803443321815
tp7102
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7103
(F13.343431816726435
F2.0896296867957482
tp7104
sS'for data in tqdm(response.iter_content()):\n    pass'
p7105
(F13.58311767578125
F2.0009564619797926
tp7106
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7107
(F13.403396749050819
F2.120182624230018
tp7108
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7109
(F13.033783883759469
F2.182134041419396
tp7110
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7111
(F13.297578699448529
F1.980383506188026
tp7112
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0"
p7113
(F13.122920643199574
F1.9428837115948017
tp7114
sS'break'
p7115
(F10.777142842610678
F2.128733414870042
tp7116
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7117
(F13.060748459002294
F2.1923285264235277
tp7118
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p7119
(F12.697060902913412
F2.1982847360464244
tp7120
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]"
p7121
(F10.042352849786932
F1.9932237771841197
tp7122
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7123
(F12.709369451349431
F1.81623048048753
tp7124
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7125
(F12.941377233286373
F1.9568377274733324
tp7126
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0"
p7127
(F13.597127278645834
F2.16020760169396
tp7128
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7129
(F13.451466878255209
F2.1233306297889123
tp7130
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7131
(F13.439946193321079
F2.035728014432467
tp7132
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7133
(F12.938792782738096
F2.1976036658653846
tp7134
sS'f.close()'
p7135
(F8.620965685163226
F2.04093390244704
tp7136
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7137
(F13.002919164197198
F1.7755844409649189
tp7138
sS'import requests'
p7139
(F16.690610885620117
F1.8365604694073017
tp7140
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0"
p7141
(F12.931243896484375
F1.9375294905442457
tp7142
sS"urllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p7143
(F8.896945190429687
F1.952520517202524
tp7144
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p7145
(F12.940450978833576
F2.159694084754357
tp7146
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7147
(F12.96125996907552
F2.1437059549184947
tp7148
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7149
(F12.552433558872767
F1.8551907172569861
tp7150
sS"response = urllib2.urlopen('http://www.example.com/')"
p7151
(F10.995624542236328
F1.9131229107196515
tp7152
sS'from tqdm import tqdm\nimport requests'
p7153
(F18.80035400390625
F1.851873984703651
tp7154
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7155
(F11.972830636160714
F2.2503795623779297
tp7156
sS"with open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7157
(F12.688532779091283
F1.9522099128136268
tp7158
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7159
(F12.699242933741155
F1.9343220637394831
tp7160
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7161
(F12.24812057783019
F1.834844442514273
tp7162
sS'handle.write(data)'
p7163
(F11.218528747558594
F1.95066892183744
tp7164
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7165
(F12.691680908203125
F2.215545947735126
tp7166
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7167
(F13.193796037946429
F2.0734323354867787
tp7168
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7169
(F13.240775402681328
F2.1395191779503455
tp7170
sS'file_size_dl = 0\nblock_sz = 8192'
p7171
(F14.363999430338541
F2.0600594740647535
tp7172
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p7173
(F12.953209918478262
F2.1735179607684794
tp7174
sS"f = open(file_name, 'wb')\nmeta = u.info()"
p7175
(F12.602256774902344
F2.0899567237267127
tp7176
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7177
(F12.948726210483285
F2.1697411170372596
tp7178
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7179
(F12.962492879231771
F2.149947533240685
tp7180
sS'print status,'
p7181
(F12.347994232177735
F2.135741894061749
tp7182
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7183
(F12.96390035878057
F2.148851981529823
tp7184
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7185
(F12.912107482437015
F1.9122423025277944
tp7186
sS'status = (status + (chr(8) * (len(status) + 1)))'
p7187
(F10.334729401961617
F2.829274691068209
tp7188
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7189
(F13.01100002989477
F2.0004536555363583
tp7190
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7191
(F12.359961794133772
F2.386659622192383
tp7192
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192"
p7193
(F13.565793991088867
F2.1026138892540565
tp7194
sS'u = urllib2.urlopen(url)'
p7195
(F12.494991302490234
F1.9785631619966948
tp7196
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7197
(F11.556472778320312
F1.812709955068735
tp7198
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7199
(F13.328608815262957
F1.7813981863168569
tp7200
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7201
(F13.3702429946588
F2.116503348717323
tp7202
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)'
p7203
(F13.591211318969727
F2.1322590754582333
tp7204
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0"
p7205
(F13.543834071005545
F2.1233001122107873
tp7206
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7207
(F13.116401890345982
F1.9573866037222056
tp7208
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7209
(F13.273080254678673
F1.9370836111215444
tp7210
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7211
(F11.722448278356481
F1.886479744544396
tp7212
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7213
(F11.650772094726562
F1.8285409487210786
tp7214
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7215
(F12.173270609841419
F1.9368365361140325
tp7216
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7217
(F13.309341785519623
F2.1859717735877404
tp7218
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7219
(F13.574599646087876
F2.1033395620492787
tp7220
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7221
(F13.202851394127155
F1.9727946061354418
tp7222
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7223
(F12.720522673233695
F2.034894356360802
tp7224
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7225
(F12.800627335258152
F2.163383043729342
tp7226
sS'if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7227
(F12.934315999348959
F2.054270524245042
tp7228
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p7229
(F12.022678150850183
F1.7906023172231822
tp7230
sS'response = requests.get(url, stream=True)'
p7231
(F13.052987234933036
F1.9270515441894531
tp7232
sS'if (not buffer):\n    break'
p7233
(F10.629117329915365
F2.4745724017803488
tp7234
sS'status = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()'
p7235
(F10.677157315340908
F2.362786806546725
tp7236
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7237
(F13.299252241085737
F2.0883008516751804
tp7238
sS"import urllib\nurllib.urlretrieve('http://www.example.com/songs/mp3.mp3', 'mp3.mp3')"
p7239
(F10.68646709735577
F1.8513438885028546
tp7240
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7241
(F13.350080774185505
F2.014408698448768
tp7242
sS'meta = u.info()'
p7243
(F11.849305894639757
F2.5142027047964244
tp7244
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7245
(F12.961919611150568
F2.1499834794264574
tp7246
sS'from tqdm import tqdm'
p7247
(F18.537474314371746
F2.117336860069862
tp7248
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7249
(F12.883464288274082
F2.1491435124323917
tp7250
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7251
(F12.812224857390873
F1.949587161724384
tp7252
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))"
p7253
(F12.626715087890625
F2.1926967914287863
tp7254
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192"
p7255
(F13.591224001165022
F2.14664180462177
tp7256
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0"
p7257
(F13.46519276793574
F2.009540264423077
tp7258
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7259
(F14.363828075175382
F2.0941863426795373
tp7260
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7261
(F12.382414899553572
F1.8817033034104567
tp7262
sS'if (not buffer):\n    pass'
p7263
(F10.50288200378418
F2.44760982806866
tp7264
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7265
(F13.266813359708868
F2.1780022841233473
tp7266
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7267
(F13.083547579187925
F1.9131519611065204
tp7268
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]"
p7269
(F10.8480322265625
F1.8569539877084584
tp7270
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7271
(F13.416737606650905
F2.1039035503680887
tp7272
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7273
(F13.069592492055085
F1.904553193312425
tp7274
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7275
(F12.233925197435463
F1.8871055016150842
tp7276
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7277
(F12.817735944475446
F1.8015031080979567
tp7278
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p7279
(F13.465676766854745
F2.1488446455735426
tp7280
sS"with open('10MB', 'wb') as handle:\n    pass"
p7281
(F10.530915260314941
F2.068376981295072
tp7282
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7283
(F13.286714033647018
F2.1384928776667667
tp7284
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p7285
(F12.185912214006697
F2.206094448383038
tp7286
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)"
p7287
(F11.314783896169354
F1.8959538386418269
tp7288
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'"
p7289
(F15.20737046461839
F1.823510976938101
tp7290
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7291
(F13.456513275971284
F2.12778326181265
tp7292
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7293
(F13.119969540550596
F2.018321844247671
tp7294
sS"block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7295
(F13.331745929028614
F2.1304864149827223
tp7296
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7297
(F13.736730115167026
F1.782937269944411
tp7298
sS'file_size_dl = 0'
p7299
(F15.309371948242188
F2.080486150888296
tp7300
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,\nf.close()"
p7301
(F13.013577593051322
F2.15400637113131
tp7302
sS'import urllib2'
p7303
(F16.24258041381836
F1.8776064652663012
tp7304
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))"
p7305
(F12.960181826636905
F2.0118193993201623
tp7306
sS'while True:\n    buffer = u.read(block_sz)'
p7307
(F12.29568142361111
F2.192317082331731
tp7308
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7309
(F13.706264241536458
F2.10675782423753
tp7310
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7311
(F11.694551740373884
F1.8539164616511419
tp7312
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')"
p7313
(F12.051361762152778
F1.8071016164926381
tp7314
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7315
(F12.811770484561013
F1.9526789738581731
tp7316
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7317
(F13.295600705030488
F2.0109613858736477
tp7318
sS"while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7319
(F13.44603223924513
F2.1152797112098107
tp7320
sS'f.write(buffer)'
p7321
(F11.203389167785645
F1.9737108670748198
tp7322
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7323
(F13.16127498851103
F2.1343118227445164
tp7324
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0"
p7325
(F13.56392610990084
F2.127171149620643
tp7326
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7327
(F13.157928736863939
F2.182188767653245
tp7328
sS'html = response.read()'
p7329
(F10.056331210666233
F1.8902979630690355
tp7330
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7331
(F12.689926147460938
F2.2153924795297475
tp7332
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7333
(F13.623981778583829
F1.7792877784142127
tp7334
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192"
p7335
(F13.52986234777114
F2.115735274094802
tp7336
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7337
(F13.112302943638392
F1.9180911137507513
tp7338
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7339
(F13.22762515419408
F2.093870309682993
tp7340
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p7341
(F12.248965176669033
F1.8673045818622296
tp7342
sS"f.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7343
(F12.931445121765137
F2.2049691126896787
tp7344
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7345
(F13.377382090393926
F2.1372362283559947
tp7346
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))\nprint status,"
p7347
(F13.66419921875
F2.1770351116473856
tp7348
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7349
(F13.45514453125
F2.114649405846229
tp7350
sS'status = (status + (chr(8) * (len(status) + 1)))\nprint status,'
p7351
(F11.208358199508101
F2.7568277212289662
tp7352
sS"if (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7353
(F13.150241758765244
F2.1927595872145433
tp7354
sS"status = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7355
(F12.073647553066039
F2.407675963181716
tp7356
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7357
(F12.591760583826014
F2.1950582357553334
tp7358
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7359
(F12.894725871535966
F2.0927592057448168
tp7360
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7361
(F13.029452804231296
F1.957839085505559
tp7362
sS'buffer = u.read(block_sz)'
p7363
(F13.53018569946289
F2.111514458289513
tp7364
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))"
p7365
(F12.674971657237787
F1.8889518150916467
tp7366
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)'
p7367
(F12.870195007324218
F2.152009523831881
tp7368
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)"
p7369
(F13.004287719726562
F1.9503150353064904
tp7370
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7371
(F13.09591273257607
F2.1210162823016825
tp7372
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)"
p7373
(F10.846328735351562
F1.8902143331674428
tp7374
sS"response = urllib2.urlopen('http://www.example.com/')\nhtml = response.read()"
p7375
(F11.137339274088541
F1.8243606273944561
tp7376
sS'file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass'
p7377
(F12.546242091966713
F2.244205034696139
tp7378
sS'r = requests.get(url)'
p7379
(F11.788276672363281
F1.903589395376352
tp7380
sS'print status,\nf.close()'
p7381
(F10.127314480868252
F1.985467323890099
tp7382
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7383
(F11.88951195610894
F1.9390678405761719
tp7384
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nr = requests.get(url)\nprint len(r.content)"
p7385
(F12.8374658203125
F1.8078617682823768
tp7386
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)"
p7387
(F13.148831245594454
F1.9651879530686598
tp7388
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7389
(F12.91231566436531
F1.9102255014272838
tp7390
sS"file_size = int(meta.getheaders('Content-Length')[0])"
p7391
(F11.511401706271702
F2.3286898686335635
tp7392
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192"
p7393
(F13.14681682180851
F1.942940932053786
tp7394
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7395
(F12.388108995225695
F1.9415902357835035
tp7396
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7397
(F13.079162904365578
F1.9641600388746996
tp7398
sS"file_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7399
(F13.485863054302376
F2.1847606072059045
tp7400
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7401
(F12.16851280475485
F1.8393504802997296
tp7402
sS"response = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        handle.write(data)"
p7403
(F13.03064084520527
F1.8190423525296724
tp7404
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))"
p7405
(F12.359354654947916
F2.1901143880990834
tp7406
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7407
(F12.96365913722826
F1.9464987241304839
tp7408
sS'block_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break'
p7409
(F12.192142159598214
F2.2202829214242787
tp7410
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    for data in tqdm(response.iter_content()):\n        pass"
p7411
(F12.7557763671875
F1.8223988459660456
tp7412
sS'file_size_dl += len(buffer)'
p7413
(F15.242727915445963
F2.0932549696702223
tp7414
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7415
(F13.16079076131185
F2.118021158071665
tp7416
sS'while True:\n    pass'
p7417
(F8.474890814887154
F2.632701873779297
tp7418
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7419
(F12.962457037591316
F2.143787090594952
tp7420
sS"url = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))"
p7421
(F12.513269333612351
F1.9366570986234224
tp7422
sS'for data in tqdm(response.iter_content()):\n    handle.write(data)'
p7423
(F13.41197265625
F1.9414179875300481
tp7424
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7425
(F13.120318312872024
F2.022815704345703
tp7426
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7427
(F13.284797127016128
F2.1492112966684194
tp7428
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass"
p7429
(F13.161086856617647
F2.126233907846304
tp7430
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7431
(F13.25208401967244
F2.151972844050481
tp7432
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))\nstatus = (status + (chr(8) * (len(status) + 1)))"
p7433
(F13.196058067908654
F2.163587423471304
tp7434
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()"
p7435
(F12.705636912378772
F1.9424909444955678
tp7436
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7437
(F13.51166025797526
F2.110399686373197
tp7438
sS"from tqdm import tqdm\nimport requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)"
p7439
(F14.483565110426683
F1.7986390040471003
tp7440
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break"
p7441
(F13.160628000895182
F2.123353811410757
tp7442
sS'r = requests.get(url)\nprint len(r.content)'
p7443
(F12.957377115885416
F1.8822031754713793
tp7444
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)'
p7445
(F12.832502649185505
F2.0712388845590444
tp7446
sS'block_sz = 8192'
p7447
(F12.354474748883929
F2.194310555091271
tp7448
sS"file_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7449
(F12.792748166803728
F2.1697393564077525
tp7450
sS"file_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7451
(F13.564820677369505
F2.12249755859375
tp7452
sS'print len(r.content)'
p7453
(F13.472061157226562
F2.0709351759690504
tp7454
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192"
p7455
(F13.453396091213474
F2.0069728264441857
tp7456
sS"meta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])"
p7457
(F12.321051964393028
F2.3507106487567606
tp7458
sS"import requests\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nresponse = requests.get(url, stream=True)\nwith open('10MB', 'wb') as handle:\n    pass"
p7459
(F12.257737901475695
F1.7787946554330678
tp7460
sS"f = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)"
p7461
(F13.41856761259191
F2.11388059762808
tp7462
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7463
(F12.816683987958715
F1.893308346088116
tp7464
sS"import urllib2\nurl = 'http://download.thinkbroadband.com/10MB.zip'\nfile_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0"
p7465
(F13.063088507401316
F1.8909441140981822
tp7466
sS'block_sz = 8192\nwhile True:\n    pass'
p7467
(F10.582257080078126
F2.4917640686035156
tp7468
sS"file_name = url.split('/')[(-1)]\nu = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7469
(F12.852405024509803
F1.9405765533447266
tp7470
sS'file_size_dl += len(buffer)\nf.write(buffer)'
p7471
(F14.402374267578125
F1.9862032670241137
tp7472
sS'while True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    pass'
p7473
(F11.852400154903018
F2.184048579289363
tp7474
sS"print(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    buffer = u.read(block_sz)\nif (not buffer):\n    break\nfile_size_dl += len(buffer)\nf.write(buffer)\nstatus = ('%10d  [%3.2f%%]' % (file_size_dl, ((file_size_dl * 100.0) / file_size)))"
p7475
(F13.532190393518519
F2.111424079308143
tp7476
sS"u = urllib2.urlopen(url)\nf = open(file_name, 'wb')\nmeta = u.info()\nfile_size = int(meta.getheaders('Content-Length')[0])\nprint(('Downloading: %s Bytes: %s' % (file_name, file_size)))\nfile_size_dl = 0\nblock_sz = 8192\nwhile True:\n    pass"
p7477
(F13.071505916819852
F2.0027162111722507
tp7478
ssI739993
(dp7479
S"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])"
p7480
(F15.54422607421875
F3.068730218069894
tp7481
sS'import pip\ninstalled_packages = pip.get_installed_distributions()'
p7482
(F18.100953843858505
F3.0774533408028737
tp7483
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os\nos.getcwd()"
p7484
(F15.425731312144887
F3.020321709769113
tp7485
sS"['behave==1.2.4', 'enum34==1.0', 'flask==0.10.1', 'itsdangerous==0.24', 'jinja2==2.7.2', 'jsonschema==2.3.0', 'markupsafe==0.23', 'nose==1.3.3', 'parse-type==0.3.4', 'parse==1.6.4', 'prettytable==0.7.2', 'requests==2.3.0', 'six==1.6.1', 'vioozer-metadata==0.1', 'vioozer-users-server==0.1', 'werkzeug==0.9.4']"
p7486
(F3.569268362862723
F3.2799429212297713
tp7487
sS"import pip\nsorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os"
p7488
(F15.911372134560033
F3.0371006556919644
tp7489
sS'from __future__ import print_function'
p7490
(F18.10297546386719
F3.0703370230538503
tp7491
sS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7492
(F15.49320125579834
F3.1502203260149275
tp7493
sS"from __future__ import print_function\nimport pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7494
(F17.66668911637931
F3.024683271135603
tp7495
sS'(iterpipes == 0.4)'
p7496
(F6.597383226667132
F3.067031042916434
tp7497
sS'from __future__ import print_function\nimport pip'
p7498
(F19.119769756610577
F3.079683576311384
tp7499
sS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7500
(F17.108739736128825
F3.036962236676897
tp7501
sS"installed_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint(installed_packages_list)"
p7502
(F15.796836294778963
F3.1345421927315846
tp7503
sS'from __future__ import print_function\nimport pip\ninstalled_packages = pip.get_installed_distributions()'
p7504
(F18.953325059678818
F3.0857911791120256
tp7505
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os\nos.getcwd()"
p7506
(F15.013621260480184
F3.040820530482701
tp7507
sS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint(installed_packages_list)"
p7508
(F16.717369495738637
F3.065054484776088
tp7509
sS"import pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint(installed_packages_list)"
p7510
(F17.039753880994073
F3.042646953037807
tp7511
sS'print(installed_packages_list)'
p7512
(F14.278369140625
F3.0160767691476003
tp7513
sS"installed_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])"
p7514
(F16.715793775475543
F3.0664920806884766
tp7515
sS'import os'
p7516
(F15.396838188171387
F3.0503251211983815
tp7517
sS"from __future__ import print_function\nimport pip\ninstalled_packages = pip.get_installed_distributions()\ninstalled_packages_list = sorted([('%s==%s' % (i.key, i.version)) for i in installed_packages])\nprint(installed_packages_list)"
p7518
(F17.531652649836754
F3.0335775102887834
tp7519
sS'os.getcwd()'
p7520
(F9.554735456194196
F3.0454504830496654
tp7521
sS'(docutils == 0.7)'
p7522
(F6.597383226667132
F3.067031042916434
tp7523
sS"help('modules')"
p7524
(F6.746859868367513
F3.040497371128627
tp7525
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])"
p7526
(F14.97610092163086
F3.1221506936209544
tp7527
sS'import pip'
p7528
(F16.311870574951172
F3.0798279898507253
tp7529
sS'import os\nos.getcwd()'
p7530
(F12.249612426757812
F3.0502703530447826
tp7531
sS'installed_packages = pip.get_installed_distributions()'
p7532
(F17.169962565104168
F3.085424150739397
tp7533
sS"sorted([('%s==%s' % (i.key, i.version)) for i in pip.get_installed_distributions()])\nimport os"
p7534
(F15.445120675223214
F3.0700882502964566
tp7535
ssI6797984
(dp7536
S"raw_input('Type Something').lower()"
p7537
(F10.791854858398438
F1.4997848163951526
tp7538
sS"s = 'Kilometer'"
p7539
(F7.8356163024902346
F1.4084420637650923
tp7540
sS"from __future__ import print_function\ns = 'Kilometer'\nprint(s.lower())"
p7541
(F13.59041164232337
F1.4142608642578125
tp7542
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'"
p7543
(F7.8356163024902346
F1.4084420637650923
tp7544
sS"s = 'Kilometer'\nprint(s.lower())"
p7545
(F8.797926766531807
F1.3157523762096057
tp7546
sS'from __future__ import print_function'
p7547
(F18.533763122558593
F1.6065630479292436
tp7548
sS"print s.lower()\nprint s.decode('utf-8').lower()"
p7549
(F10.264688110351562
F1.3287053541703657
tp7550
sS"from __future__ import print_function\ns = 'Kilometer'"
p7551
(F16.270010811941965
F1.514389384876598
tp7552
sS'print(s.lower())'
p7553
(F9.227225494384765
F1.3948995416814631
tp7554
sS"print s.decode('utf-8').lower()"
p7555
(F9.379173865685097
F1.3356015465476296
tp7556
sS'print s.lower()'
p7557
(F9.95806884765625
F1.36003962430087
tp7558
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()\nprint s.decode('utf-8').lower()"
p7559
(F9.702543258666992
F1.3125036413019353
tp7560
sS"s = '\\xd0\\x9a\\xd0\\xb8\\xd0\\xbb\\xd0\\xbe\\xd0\\xbc\\xd0\\xb5\\xd1\\x82\\xd1\\x80'\nprint s.lower()"
p7561
(F9.250189463297525
F1.3020000457763672
tp7562
ssI1207457
(dp7563
S'import codecs'
p7564
(F14.072975158691406
F2.9425673484802246
tp7565
sS"type(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7566
(F9.133438110351562
F2.7723190784454346
tp7567
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')"
p7568
(F8.764401084498354
F2.7963008880615234
tp7569
sS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7570
(F10.551302337646485
F2.920902729034424
tp7571
sS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7572
(F8.757332249691611
F2.894892454147339
tp7573
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata"
p7574
(F11.574716567993164
F2.9059293270111084
tp7575
sS'f.write(my_unicode_string)'
p7576
(F14.202164967854818
F2.8117802143096924
tp7577
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)"
p7578
(F8.283384704589844
F2.9117536544799805
tp7579
sS"s = u'\\xa310'\ns.encode('utf8')\ns.encode('utf16')"
p7580
(F9.020294992547287
F2.763232469558716
tp7581
sS"f = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p7582
(F10.823138427734374
F2.8976964950561523
tp7583
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7584
(F10.212514241536459
F2.936753749847412
tp7585
sS"s = u'\\xa310'"
p7586
(F7.232583618164062
F2.75056529045105
tp7587
sS"import unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7588
(F10.154966874556107
F2.9078731536865234
tp7589
sS"s.encode('utf16')"
p7590
(F8.469173431396484
F2.7675650119781494
tp7591
sS"a.encode('ascii', 'ignore')"
p7592
(F7.797702789306641
F2.8133111000061035
tp7593
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'"
p7594
(F7.619671630859375
F2.9640750885009766
tp7595
sS"s.encode('utf8')"
p7596
(F8.469173431396484
F2.7675650119781494
tp7597
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'"
p7598
(F7.463677978515625
F2.8390684127807617
tp7599
sS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')"
p7600
(F8.645167631261488
F2.8912887573242188
tp7601
sS'type(a)'
p7602
(F8.765937169392904
F3.0058231353759766
tp7603
sS"import codecs\nf = codecs.open('path/to/file.txt', 'w', 'utf8')\nf.write(my_unicode_string)"
p7604
(F11.20901380266462
F2.8721566200256348
tp7605
sS"a = u'aaa\\xe0\\xe7\\xe7\\xe7\\xf1\\xf1\\xf1'\ntype(a)\na.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7606
(F8.90295137677874
F2.7592177391052246
tp7607
sS"a.encode('ascii', 'ignore')\na.encode('ascii', 'replace')"
p7608
(F8.41241455078125
F2.7873589992523193
tp7609
sS"s.encode('utf8')\ns.encode('utf16')"
p7610
(F9.24600830078125
F2.768332004547119
tp7611
sS'import unicodedata'
p7612
(F14.072975158691406
F2.9425673484802246
tp7613
sS"unicodedata.normalize('NFKD', title).encode('ascii', 'ignore')"
p7614
(F9.091970107134651
F2.909886121749878
tp7615
sS"f = codecs.open('path/to/file.txt', 'w', 'utf8')"
p7616
(F7.115990230015346
F2.9378128051757812
tp7617
sS"a.encode('ascii', 'replace')"
p7618
(F7.797702789306641
F2.8133111000061035
tp7619
sS"type(a)\na.encode('ascii', 'ignore')"
p7620
(F9.060662841796875
F2.815375804901123
tp7621
sS"'Kluft skrams infor pa federal electoral groe'"
p7622
(F2.4451276461283364
F2.822789192199707
tp7623
sS"title = u'Kl\\xfcft skr\\xe4ms inf\\xf6r p\\xe5 f\\xe9d\\xe9ral \\xe9lectoral gro\\xdfe'\nimport unicodedata\nunicodedata.normalize('NFKD', title).encode('ascii', 'ignore')\n'Kluft skrams infor pa federal electoral groe'"
p7624
(F9.894582895132212
F2.923945903778076
tp7625
sS"s = u'\\xa310'\ns.encode('utf8')"
p7626
(F8.312569936116537
F2.741689920425415
tp7627
ssI3294889
(dp7628
S"d = {'x': 1, 'y': 2, 'z': 3, }\nlist(d)"
p7629
(F6.579205720320992
F2.4299156188964846
tp7630
sS'for (key, value) in d.iteritems():\n    pass'
p7631
(F11.394432469418174
F2.478997230529785
tp7632
sS"print '{0} corresponds to {1}'.format(letter, number)"
p7633
(F10.220088611949574
F2.76849365234375
tp7634
sS'd.keys()'
p7635
(F10.225288391113281
F2.6386014938354494
tp7636
sS'for key in d:\n    pass'
p7637
(F12.148401433771307
F2.432742118835449
tp7638
sS"for (letter, number) in d.items():\n    print letter, 'corresponds to', number"
p7639
(F11.583656311035156
F2.5583648681640625
tp7640
sS'for (key, value) in d.items():\n    pass'
p7641
(F11.66642841539885
F2.4212684631347656
tp7642
sS'd.items()'
p7643
(F10.324937002999443
F2.547085189819336
tp7644
sS"print letter, 'corresponds to', number"
p7645
(F10.081497192382812
F2.900985908508301
tp7646
sS'list(d)'
p7647
(F9.058220545450846
F2.476386070251465
tp7648
sS"for (letter, number) in d.items():\n    print '{0} corresponds to {1}'.format(letter, number)"
p7649
(F11.64882179542824
F2.5898969650268553
tp7650
sS'for (letter, number) in d.items():\n    pass'
p7651
(F12.049608732524671
F2.4979631423950197
tp7652
sS'for (k, v) in d.items():\n    pass'
p7653
(F11.912775943153783
F2.4160602569580076
tp7654
sS"d = {'x': 1, 'y': 2, 'z': 3, }"
p7655
(F5.758494059244792
F2.551227569580078
tp7656
sS"print k, 'corresponds to', v"
p7657
(F9.568599700927734
F2.6679391860961914
tp7658
sS'pass'
p7659
(F10.753851572672525
F3.0351869583129885
tp7660
sS"for (k, v) in d.items():\n    print k, 'corresponds to', v"
p7661
(F11.171740214029947
F2.407428741455078
tp7662
sS'list(d)\nd.keys()'
p7663
(F10.756692250569662
F2.4855653762817385
tp7664
sS"d = {'x': 1, 'y': 2, 'z': 3, }\nlist(d)\nd.keys()"
p7665
(F7.796701891668912
F2.4325979232788084
tp7666
ssI7571635
(dp7667
S"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7668
(F11.154265822025767
F1.815031491793119
tp7669
sS"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7670
(F11.839798907844388
F1.8242786114032452
tp7671
sS"print 'Not found'"
p7672
(F10.16242790222168
F2.1738783029409556
tp7673
sS"print 'found'"
p7674
(F10.16242790222168
F2.1738783029409556
tp7675
sS'(7 in a)'
p7676
(F10.72952379499163
F1.8343190413254957
tp7677
sS"index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7678
(F11.36819349016462
F1.8155501439021184
tp7679
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7680
(F9.553604125976562
F1.9132009652944713
tp7681
sS"a = [1, 2, 3, 4, 'a', 'b', 'c']"
p7682
(F5.711103740491365
F1.8023782876821666
tp7683
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7684
(F10.526505220853366
F1.8440140944260817
tp7685
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'"
p7686
(F10.026187133789062
F1.8930110931396484
tp7687
sS'a_index = index[7]'
p7688
(F12.390657043457031
F1.8172686650202825
tp7689
sS'a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7690
(F10.679611206054688
F1.84545164841872
tp7691
sS'a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))'
p7692
(F10.35439989043445
F1.865454306969276
tp7693
sS"try:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7694
(F9.239229144472064
F1.9122726733867939
tp7695
sS'a = [4, 2, 3, 1, 5, 6]'
p7696
(F6.10198974609375
F1.8284859290489783
tp7697
sS'try:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7698
(F10.387458801269531
F1.8932330791766827
tp7699
sS"return ('a' in a)"
p7700
(F10.104999542236328
F1.8293763674222505
tp7701
sS'index = dict(((y, x) for (x, y) in enumerate(a)))'
p7702
(F12.697083740234374
F1.8526455805851862
tp7703
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    pass"
p7704
(F10.28541734483507
F1.8355645399827223
tp7705
sS'index = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    pass'
p7706
(F12.050669352213541
F1.8249033414400542
tp7707
sS"a = [4, 2, 3, 1, 5, 6]\nindex = dict(((y, x) for (x, y) in enumerate(a)))\ntry:\n    a_index = index[7]\nexcept KeyError:\n    print 'Not found'\nelse:\n    print 'found'"
p7708
(F10.132457994434931
F1.8343934279221754
tp7709
sS"a = [1, 2, 3, 4, 'a', 'b', 'c']\nreturn ('a' in a)"
p7710
(F7.308012155386118
F1.8141787602351263
tp7711
ssI1093322
(dp7712
S"('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7713
(F9.96696023380055
F2.5624491373697915
tp7714
sS'import sys'
p7715
(F14.494152069091797
F2.3386942545572915
tp7716
sS"import sys\nsys.hexversion\n('%x' % sys.hexversion)"
p7717
(F11.534280776977539
F2.3763860066731772
tp7718
sS"import sys\nsys.hexversion\n('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7719
(F11.727217356363932
F2.427259572347005
tp7720
sS'sys.hexversion'
p7721
(F11.924571228027343
F2.4084698994954428
tp7722
sS'sys.version_info'
p7723
(F14.110787527901786
F2.4202794392903644
tp7724
sS'print sys.version'
p7725
(F13.337165832519531
F2.3777506510416666
tp7726
sS"('%x' % sys.hexversion)"
p7727
(F8.399425930447048
F2.4794489542643228
tp7728
sS'sys.version_info\nsys.hexversion'
p7729
(F14.390974564985795
F2.421520741780599
tp7730
sS'import sys\nsys.hexversion'
p7731
(F14.7505521774292
F2.366815185546875
tp7732
sS'(sys.hexversion < 33947648)'
p7733
(F10.002909342447916
F2.66580810546875
tp7734
sS"sys.hexversion\n('%x' % sys.hexversion)"
p7735
(F10.563434307391827
F2.403492736816406
tp7736
sS"sys.hexversion\n('%x' % sys.hexversion)\n(sys.hexversion < 33947648)"
p7737
(F11.027631487165179
F2.472539265950521
tp7738
sS'(python - V)'
p7739
(F8.907611301967076
F2.477095540364583
tp7740
sS'assert (sys.version_info >= (2, 5))'
p7741
(F12.293526649475098
F2.470904795328776
tp7742
ssI5618878
(dp7743
S"list1 = ['1', '2', '3']"
p7744
(F5.041284040971235
F1.8649375438690186
tp7745
sS"str1 = ''.join(list1)"
p7746
(F8.839968872070312
F1.7319238185882568
tp7747
sS"L = ['L', 'O', 'L']\nmakeitastring = ''.join(map(str, L))"
p7748
(F8.25427001953125
F1.7821459770202637
tp7749
sS"makeitastring = ''.join(map(str, L))"
p7750
(F9.703968302408855
F1.7785992622375488
tp7751
sS"L = [1, 2, 3]\n' '.join((str(x) for x in L))\n'1 2 3'"
p7752
(F10.286691599878772
F1.8015475273132324
tp7753
sS'L = [1, 2, 3]'
p7754
(F6.029973810369318
F1.9051905870437622
tp7755
sS"list1 = ['1', '2', '3']\nstr1 = ''.join(list1)"
p7756
(F7.606318664550781
F1.8329287767410278
tp7757
sS"' '.join((str(x) for x in L))"
p7758
(F12.093218635110293
F1.7522656917572021
tp7759
sS"str1 = ''.join((str(e) for e in list1))"
p7760
(F12.595036556846217
F1.7541007995605469
tp7761
sS"list1 = [1, 2, 3]\nstr1 = ''.join((str(e) for e in list1))"
p7762
(F11.206103094692889
F1.8227190971374512
tp7763
sS'list1 = [1, 2, 3]'
p7764
(F6.660032792524858
F1.8628968000411987
tp7765
sS"L = ['L', 'O', 'L']"
p7766
(F4.524831251664595
F1.894580602645874
tp7767
sS"L = [1, 2, 3]\n' '.join((str(x) for x in L))"
p7768
(F10.59377712673611
F1.8080472946166992
tp7769
sS"' '.join((str(x) for x in L))\n'1 2 3'"
p7770
(F11.46340621145148
F1.7574213743209839
tp7771
sS"'1 2 3'"
p7772
(F3.864029884338379
F2.0026042461395264
tp7773
ssI3277503
(dp7774
S'array.append(line)'
p7775
(F11.23121452331543
F2.8425753275553385
tp7776
sS"with open('file.txt', 'r') as ins:\n    pass"
p7777
(F10.207831382751465
F2.5976298014322916
tp7778
sS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    pass"
p7779
(F10.923532420191272
F2.4011680603027346
tp7780
sS'with open(fname) as f:\n    pass'
p7781
(F11.649592808314733
F2.6670799255371094
tp7782
sS"with open('filename') as f:\n    lines = f.readlines()"
p7783
(F11.04160385131836
F2.4870012919108073
tp7784
sS"with open('file.txt', 'r') as ins:\n    array = []"
p7785
(F9.27168193616365
F2.475085957845052
tp7786
sS"with open('filename') as f:\n    pass"
p7787
(F10.790890284946986
F2.6362899780273437
tp7788
sS'array = []'
p7789
(F6.915200551350911
F2.9614458719889325
tp7790
sS'lines = f.readlines()'
p7791
(F11.066218058268229
F2.636177571614583
tp7792
sS"with open('file.txt', 'r') as ins:\n    array = []\nfor line in ins:\n    array.append(line)"
p7793
(F11.273695104262409
F2.3800928751627604
tp7794
sS'content = f.readlines()'
p7795
(F10.88667212592231
F3.0790257771809895
tp7796
sS'with open(fname) as f:\n    content = f.readlines()'
p7797
(F11.60835952758789
F2.5494122823079426
tp7798
sS"lines = [line.rstrip('\\n') for line in open('filename')]"
p7799
(F11.151519775390625
F2.441253407796224
tp7800
sS'for line in ins:\n    pass'
p7801
(F12.2190898548473
F2.559766642252604
tp7802
sS'for line in ins:\n    array.append(line)'
p7803
(F12.549616813659668
F2.5637863159179686
tp7804
ssI5844672
(dp7805
S'def removekey(d, key):\n    r = dict(d)\ndel r[key]\nreturn r'
p7806
(F12.272265842982701
F2.217928409576416
tp7807
sS'a'
p7808
(F14.19760258992513
F2.4122328758239746
tp7809
sS'def removekey(d, key):\n    r = dict(d)'
p7810
(F10.877977873149671
F2.229886770248413
tp7811
sS'del r[key]\nreturn r'
p7812
(F13.097193908691406
F2.19614839553833
tp7813
sS'{i: a[i] for i in a if (i != 0)}'
p7814
(F13.311166381835937
F2.2347283363342285
tp7815
sS'def removekey(d, key):\n    pass'
p7816
(F10.765345982142858
F2.276803731918335
tp7817
sS'return r'
p7818
(F14.183065414428711
F2.550029754638672
tp7819
sS'a\n{i: a[i] for i in a if (i != 0)}'
p7820
(F13.597448175603693
F2.24556827545166
tp7821
sS'del d[key]'
p7822
(F10.939949035644531
F2.1725974082946777
tp7823
sS'{}'
p7824
(F5.272654056549072
F2.4200034141540527
tp7825
sS'def removekey(d, key):\n    r = dict(d)\ndel r[key]'
p7826
(F11.72730712890625
F2.2180275917053223
tp7827
sS'del r[key]'
p7828
(F11.133372715541295
F2.1945409774780273
tp7829
sS'r = dict(d)'
p7830
(F9.893465995788574
F2.2037649154663086
tp7831
sS"'gdbye'"
p7832
(F4.784525553385417
F2.65854811668396
tp7833
ssI16296643
(dp7834
S'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)\ny = ((mousex + cameraX) // 60)\na[x][y] = 1'
p7835
(F9.364126841227213
F3.467817544937134
tp7836
sS"l = ['my', 'name', 'is', 'mr', 'list']\nl\ntuple(l)"
p7837
(F6.96685097434304
F3.5119919776916504
tp7838
sS"t = ('my', 'name', 'is', 'mr', 'tuple')"
p7839
(F5.184596252441406
F3.7488322257995605
tp7840
sS'y = ((mousex + cameraX) // 60)\na[x][y] = 1'
p7841
(F9.116303817085598
F3.466672420501709
tp7842
sS'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)\ny = ((mousex + cameraX) // 60)'
p7843
(F9.19613968698602
F3.4979610443115234
tp7844
sS'tuple((tuple(i) for i in edited))'
p7845
(F13.149027506510416
F3.4454798698425293
tp7846
sS'if (clicked[0] == 1):\n    pass'
p7847
(F8.769824981689453
F3.496964454650879
tp7848
sS'tuple(itertools.imap(tuple, edited))'
p7849
(F11.17476830115685
F3.4386415481567383
tp7850
sS'map(list, level)'
p7851
(F10.298440933227539
F3.451719284057617
tp7852
sS'l\ntuple(l)'
p7853
(F10.613107681274414
F3.480292797088623
tp7854
sS"l = ['my', 'name', 'is', 'mr', 'list']"
p7855
(F4.5682932535807295
F3.511363983154297
tp7856
sS't'
p7857
(F14.267717997233072
F3.7435858249664307
tp7858
sS'level1 = [list(row) for row in level1]'
p7859
(F12.670357840401786
F3.4556946754455566
tp7860
sS'a = numpy.array(level1)'
p7861
(F11.90318603515625
F3.519475221633911
tp7862
sS'list(t)'
p7863
(F8.549208323160807
F3.5213418006896973
tp7864
sS'level1 = map(list, level1)'
p7865
(F9.528561401367188
F3.434598445892334
tp7866
sS"t = ('my', 'name', 'is', 'mr', 'tuple')\nt"
p7867
(F7.098441628848805
F3.760026454925537
tp7868
sS'if (clicked[0] == 1):\n    x = ((mousey + cameraY) // 60)'
p7869
(F8.852878863994892
F3.464247703552246
tp7870
sS't\nlist(t)'
p7871
(F10.372696876525879
F3.5843758583068848
tp7872
sS'tuple(l)'
p7873
(F9.001278559366861
F3.4547903537750244
tp7874
sS"t = ('my', 'name', 'is', 'mr', 'tuple')\nt\nlist(t)"
p7875
(F7.35469540682706
F3.675319194793701
tp7876
sS"l = ['my', 'name', 'is', 'mr', 'list']\nl"
p7877
(F6.340725169462316
F3.5089645385742188
tp7878
sS'a'
p7879
(F13.723026275634766
F3.5368432998657227
tp7880
sS'a = numpy.array(level1)\na'
p7881
(F13.196520487467447
F3.509960889816284
tp7882
sS'[list(i) for i in level]'
p7883
(F13.118666330973307
F3.538020610809326
tp7884
sS'x = ((mousey + cameraY) // 60)'
p7885
(F8.308900099534254
F3.4909892082214355
tp7886
sS'l'
p7887
(F14.266793568929037
F3.523468017578125
tp7888
sS'y = ((mousex + cameraX) // 60)'
p7889
(F8.439183161808895
F3.540778398513794
tp7890
sS'a[x][y] = 1'
p7891
(F9.383139870383523
F3.422908306121826
tp7892
ssI4004550
(dp7893
S"s = '5.2 5.6 5.3'\nfloats = [float(x) for x in s.split()]"
p7894
(F11.78364424272017
F2.738065719604492
tp7895
sS"s = '5.2 5.6 5.3'"
p7896
(F8.549676513671875
F2.940229034423828
tp7897
sS'floats = [float(x) for x in s.split()]'
p7898
(F12.583330790201822
F2.7431386947631835
tp7899
sS'floats = map(float, s.split())'
p7900
(F11.231794084821429
F2.6875631332397463
tp7901
ssI10543303
(dp7902
S'j = [4, 5, 6, 7, 1, 3, 7, 5]'
p7903
(F5.937021891276042
F2.5577606788048377
tp7904
sS'j = np.array(j)'
p7905
(F11.483370208740235
F2.8661563579852762
tp7906
sS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nsum(((i > 5) for i in j))'
p7907
(F8.799446953667534
F2.4691913311298075
tp7908
sS'sum((j > i))'
p7909
(F9.956452178955079
F2.543405972994291
tp7910
sS'len([1 for i in j if (i > 5)])'
p7911
(F13.604334513346354
F2.4887219942533054
tp7912
sS'j = [4, 5, 6, 7, 1, 3, 7, 5]\nlen([1 for i in j if (i > 5)])'
p7913
(F9.938935932360197
F2.4653836763822117
tp7914
sS'import numpy as np\nj = np.array(j)'
p7915
(F13.486900838216146
F2.899605677678035
tp7916
sS'sum(((i > 5) for i in j))'
p7917
(F11.761837005615234
F2.476885575514573
tp7918
sS'import numpy as np'
p7919
(F17.76667658487956
F2.986129173865685
tp7920
sS'issubclass(bool, int)'
p7921
(F10.50191879272461
F2.7062078622671275
tp7922
sS'import numpy as np\nj = np.array(j)\nsum((j > i))'
p7923
(F12.800587972005209
F2.8211446908804088
tp7924
sS'j = np.array(j)\nsum((j > i))'
p7925
(F11.4945068359375
F2.78994134756235
tp7926
ssI432842
(dp7927
S'return (bool(str1) ^ bool(str2))'
p7928
(F10.245318821498326
F2.1036070505777995
tp7929
sS'from operator import xor\nxor(bool(a), bool(b))'
p7930
(F14.727108604029604
F2.1221549987792967
tp7931
sS'(bool(a) ^ bool(b))'
p7932
(F10.041949932391827
F2.147813924153646
tp7933
sS'xor(bool(a), bool(b))'
p7934
(F10.698480878557477
F2.1535741170247396
tp7935
sS'(bool(a) != bool(b))'
p7936
(F9.566352257361778
F2.1417444864908854
tp7937
sS'((a and (not b)) or ((not a) and b))'
p7938
(F12.46125720796131
F2.1693155924479166
tp7939
sS'def logical_xor(str1, str2):\n    pass'
p7940
(F13.022919654846191
F2.3446136474609376
tp7941
sS'def logical_xor(str1, str2):\n    return (bool(str1) ^ bool(str2))'
p7942
(F12.001537181712964
F2.189875284830729
tp7943
sS'from operator import xor'
p7944
(F21.718465169270832
F2.1383588155110678
tp7945
ssI1303243
(dp7946
S'isinstance(o, str)'
p7947
(F9.80264949798584
F2.1698196956089566
tp7948
sS'(type(o) is str)'
p7949
(F11.549920654296875
F2.1299029758998325
tp7950
sS'isinstance(o, basestring)'
p7951
(F9.306614875793457
F2.2014151981898715
tp7952
sS'isinstance(obj_to_test, str)'
p7953
(F14.332040150960287
F2.2204963139125278
tp7954
ssI163542
(dp7955
S'p.stdin.close()'
p7956
(F11.169806586371529
F3.273543221609933
tp7957
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]\np.stdin.close()"
p7958
(F11.177773934823495
F3.235327947707403
tp7959
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7960
(F13.056927116549744
F3.241604759579613
tp7961
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p7962
(F13.21636777935606
F3.2546630132765997
tp7963
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)"
p7964
(F11.980811485877403
F3.2570528302873885
tp7965
sS"from subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint(grep_stdout.decode())"
p7966
(F13.357693481445313
F3.2465693155924478
tp7967
sS"pipe = os.popen(cmd, 'w', bufsize)\npipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin"
p7968
(F13.77096208844866
F3.244563874744234
tp7969
sS"from __future__ import print_function\nfrom subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7970
(F14.155259757206357
F3.2425973074776784
tp7971
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]"
p7972
(F11.576510342684658
F3.2363001505533853
tp7973
sS'from subprocess import Popen, PIPE, STDOUT'
p7974
(F16.4371826171875
F3.282741001674107
tp7975
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')"
p7976
(F10.753614044189453
F3.267217363630022
tp7977
sS"from __future__ import print_function\nfrom subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p7978
(F14.707202729724703
F3.2581594557989213
tp7979
sS'p.communicate()[0]'
p7980
(F8.856593322753906
F3.25131588890439
tp7981
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)"
p7982
(F11.063603719075521
F3.287752423967634
tp7983
sS'print(grep_stdout.decode())'
p7984
(F12.669728597005209
F3.3533503214518228
tp7985
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint(grep_stdout.decode())"
p7986
(F12.271728515625
F3.2569016956147694
tp7987
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')"
p7988
(F12.1009521484375
F3.244008018856957
tp7989
sS"pipe = os.popen(cmd, 'w', bufsize)"
p7990
(F11.859032767159599
F3.3297925676618303
tp7991
sS'from __future__ import print_function\nfrom subprocess import Popen, PIPE, STDOUT'
p7992
(F18.46558259662829
F3.287043980189732
tp7993
sS"grep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint(grep_stdout.decode())"
p7994
(F13.089346749441964
F3.2636409941173734
tp7995
sS"p.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]"
p7996
(F10.348894621196546
F3.2318580264136907
tp7997
sS"p = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p7998
(F11.579735565185548
F3.250946044921875
tp7999
sS"from __future__ import print_function\nfrom subprocess import Popen, PIPE, STDOUT\np = Popen(['grep', 'f'], stdout=PIPE, stdin=PIPE, stderr=STDOUT)\ngrep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]\nprint(grep_stdout.decode())"
p8000
(F14.224134362262228
F3.2454419817243303
tp8001
sS"grep_stdout = p.communicate(input='one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')[0]"
p8002
(F12.090507956112132
F3.244194757370722
tp8003
sS'from __future__ import print_function'
p8004
(F18.96556854248047
F3.365586417061942
tp8005
sS'p.communicate()[0]\np.stdin.close()'
p8006
(F10.734063890245226
F3.2357381184895835
tp8007
sS'pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin'
p8008
(F13.724186290394176
F3.2657652355375744
tp8009
sS"p = subprocess.Popen(['grep', 'f'], stdout=subprocess.PIPE, stdin=subprocess.PIPE)\np.stdin.write('one\\ntwo\\nthree\\nfour\\nfive\\nsix\\n')\np.communicate()[0]\np.stdin.close()"
p8010
(F11.823987520658052
F3.2349693661644343
tp8011
ssI306400
(dp8012
S'second_random_item = list_of_random_items[1]'
p8013
(F15.947679307725695
F1.8792792002360026
tp8014
sS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p8015
(F17.284755972928778
F1.8429428100585938
tp8016
sS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']"
p8017
(F6.0946400960286455
F1.847162628173828
tp8018
sS'random_index = randrange(0, len(foo))\nprint foo[random_index]'
p8019
(F12.66411822775136
F1.8579766591389975
tp8020
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p8021
(F16.375756107159514
F1.8586329142252604
tp8022
sS'first_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8023
(F16.410459681919644
F1.8593756357828777
tp8024
sS'from random import randrange'
p8025
(F19.203556060791016
F1.916983413696289
tp8026
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8027
(F16.52385748000372
F1.854759979248047
tp8028
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8029
(F16.63146551724138
F1.8416642506917318
tp8030
sS'print foo[random_index]'
p8031
(F13.655817667643229
F1.863400904337565
tp8032
sS'first_random_item = list_of_random_items[0]'
p8033
(F15.941748725043404
F1.8700087229410807
tp8034
sS'import random'
p8035
(F15.929794311523438
F1.9545408884684246
tp8036
sS"from __future__ import print_function\nimport random\nfoo = ['a', 'b', 'c', 'd', 'e']\nprint(random.choice(foo))"
p8037
(F11.54955394847973
F1.8829205830891926
tp8038
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p8039
(F15.96525717681309
F1.8412054697672526
tp8040
sS'from __future__ import print_function\nimport random'
p8041
(F19.42230694110577
F2.148541005452474
tp8042
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))"
p8043
(F10.444697660558363
F1.8231305440266927
tp8044
sS"foo = ['a', 'b', 'c', 'd', 'e']"
p8045
(F4.252386983235677
F1.9710800170898437
tp8046
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p8047
(F12.77955078125
F1.9671653747558593
tp8048
sS"import random\nfoo = ['a', 'b', 'c', 'd', 'e']\nprint(random.choice(foo))"
p8049
(F8.14820316859654
F1.834561284383138
tp8050
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p8051
(F16.487779017857143
F1.8413555145263671
tp8052
sS'group_of_items = {1, 2, 3, 4}'
p8053
(F11.190286075367647
F1.9805945078531901
tp8054
sS"from __future__ import print_function\nimport random\nfoo = ['a', 'b', 'c', 'd', 'e']"
p8055
(F11.577822084780093
F1.9638256072998046
tp8056
sS'print(random.choice(foo))'
p8057
(F10.279274680397727
F1.9587577819824218
tp8058
sS'num_to_select = 2'
p8059
(F14.727515326605904
F2.2980979919433593
tp8060
sS'import random\ngroup_of_items = {1, 2, 3, 4}\nnum_to_select = 2'
p8061
(F13.314989362444196
F1.8678436279296875
tp8062
sS'from random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]'
p8063
(F14.365081787109375
F1.854956563313802
tp8064
sS'import random\ngroup_of_items = {1, 2, 3, 4}'
p8065
(F12.12877197265625
F1.8534430185953776
tp8066
sS'group_of_items = {1, 2, 3, 4}\nnum_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p8067
(F15.826417236328124
F1.8651594797770181
tp8068
sS'from random import randrange\nrandom_index = randrange(0, len(foo))'
p8069
(F14.169477844238282
F1.8720602671305338
tp8070
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange"
p8071
(F8.965328979492188
F1.841904067993164
tp8072
sS"foo = ['a', 'b', 'c', 'd', 'e']\nfrom random import randrange\nrandom_index = randrange(0, len(foo))\nprint foo[random_index]"
p8073
(F11.257933843703498
F1.8236717224121093
tp8074
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8075
(F17.768545711741726
F1.857208251953125
tp8076
sS'from __future__ import print_function'
p8077
(F19.4171875
F2.295037333170573
tp8078
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]'
p8079
(F17.901715446920957
F1.8695688883463542
tp8080
sS'list_of_random_items = random.sample(group_of_items, num_to_select)\nfirst_random_item = list_of_random_items[0]\nsecond_random_item = list_of_random_items[1]'
p8081
(F17.124448649088542
F1.8393749237060546
tp8082
sS"foo = ['a', 'b', 'c', 'd', 'e']\nprint(random.choice(foo))"
p8083
(F7.467841796875
F1.8486372629801433
tp8084
sS'list_of_random_items = random.sample(group_of_items, num_to_select)'
p8085
(F17.169534536508415
F1.8502784729003907
tp8086
sS'random_index = randrange(0, len(foo))'
p8087
(F11.865840657552083
F1.8923353830973306
tp8088
sS'num_to_select = 2\nlist_of_random_items = random.sample(group_of_items, num_to_select)'
p8089
(F17.761447682100183
F1.893047841389974
tp8090
ssI3996904
(dp8091
S'frand = uniform(0, 10)'
p8092
(F8.012445068359375
F4.87612787882487
tp8093
sS'random.randint(a, b)'
p8094
(F10.717692565917968
F4.393945905897352
tp8095
sS'from __future__ import print_function\nimport random\nprint(random.randint(0, 9))'
p8096
(F14.58300537109375
F4.624793158637153
tp8097
sS'import random'
p8098
(F15.596696853637695
F4.508534325493707
tp8099
sS'import random\nprint(random.randint(0, 9))'
p8100
(F10.89084529876709
F4.482423570421007
tp8101
sS'from random import randrange, uniform'
p8102
(F18.299592971801758
F4.397378709581163
tp8103
sS'from __future__ import print_function\nfrom random import randint'
p8104
(F20.0087890625
F4.605294969346788
tp8105
sS'irand = randrange(0, 10)'
p8106
(F7.3171028137207035
F4.833827124701606
tp8107
sS'from __future__ import print_function'
p8108
(F18.858526611328124
F5.053434583875868
tp8109
sS'print(randint(0, 9))'
p8110
(F8.4211557561701
F4.7145669725206165
tp8111
sS'from random import randint\nprint(randint(0, 9))'
p8112
(F12.043879508972168
F4.451789008246528
tp8113
sS'from random import randrange, uniform\nirand = randrange(0, 10)'
p8114
(F12.519519581514245
F4.455845303005642
tp8115
sS'from random import randint'
p8116
(F18.76575469970703
F4.446465386284722
tp8117
sS'from __future__ import print_function\nimport random'
p8118
(F19.083172137920673
F4.768716600206163
tp8119
sS'print(random.randint(0, 9))'
p8120
(F9.740705049954927
F4.505335066053602
tp8121
sS'irand = randrange(0, 10)\nfrand = uniform(0, 10)'
p8122
(F7.970447741056743
F4.812783559163411
tp8123
sS'from random import randrange, uniform\nirand = randrange(0, 10)\nfrand = uniform(0, 10)'
p8124
(F11.151067880483774
F4.507174173990886
tp8125
sS'from __future__ import print_function\nfrom random import randint\nprint(randint(0, 9))'
p8126
(F15.196790771484375
F4.525892469618055
tp8127
ssI627435
(dp8128
S'a = [1, 2, 3, 4, 5, 6]\nindex = 3'
p8129
(F6.797684442429316
F1.7464104970296224
tp8130
sS'def __init__(self, items):\n    pass'
p8131
(F13.554905891418457
F2.1044026692708333
tp8132
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p8133
(F13.244283326914612
F1.906305694580078
tp8134
sS'def del_method():\n    global a'
p8135
(F11.897162301199776
F2.194549560546875
tp8136
sS'self.items = items'
p8137
(F13.86343274797712
F1.8999114990234376
tp8138
sS'def slice_method():\n    global a'
p8139
(F12.455671037946429
F1.9599589029947917
tp8140
sS'del a[index]'
p8141
(F11.657152448381696
F1.7535497029622396
tp8142
sS'global index'
p8143
(F16.45306396484375
F2.136902109781901
tp8144
sS'global index\na = (a[:index] + a[(index + 1):])'
p8145
(F10.642035802205404
F1.7907262166341147
tp8146
sS'def del_method():\n    global a\nglobal index'
p8147
(F14.221765854779411
F2.183507029215495
tp8148
sS'index = 3\na = (a[:index] + a[(index + 1):])'
p8149
(F9.509400634765624
F1.7742682139078776
tp8150
sS'def slice_method():\n    global a\nglobal index\na = (a[:index] + a[(index + 1):])'
p8151
(F11.93494394663218
F1.8388561248779296
tp8152
sS'a\ndel a[(-1)]\na'
p8153
(F10.085105895996094
F1.820256805419922
tp8154
sS'return foo((self.items + right.items))'
p8155
(F12.990806070963542
F1.8748756408691407
tp8156
sS'a.pop()'
p8157
(F10.052742004394531
F1.7346410115559896
tp8158
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])'
p8159
(F13.167869984019886
F1.8879165649414062
tp8160
sS'a = range(10)\na\ndel a[(-1)]'
p8161
(F9.02339011744449
F1.8677832285563152
tp8162
sS'global index\na.pop(index)'
p8163
(F13.709439364346592
F1.7630035400390625
tp8164
sS'return foo(self.items[index])'
p8165
(F11.761953989664713
F1.7766738891601563
tp8166
sS'a = [1, 2, 3, 4, 5, 6]\nindex = 3\na = (a[:index] + a[(index + 1):])'
p8167
(F8.086161543683309
F1.7389020284016927
tp8168
sS'class foo(object):\n\n    def __init__(self, items):\n        pass'
p8169
(F12.70693852351262
F2.0051307678222656
tp8170
sS'class foo(object):\n    pass'
p8171
(F9.448239008585611
F2.0172725677490235
tp8172
sS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo((self.items + right.items))'
p8173
(F13.13239216354658
F1.8941509246826171
tp8174
sS'a = (a[:index] + a[(index + 1):])'
p8175
(F9.362799508231026
F1.756389363606771
tp8176
sS'def slice_method():\n    global a\nglobal index'
p8177
(F14.651123046875
F1.9777722676595053
tp8178
sS'index = 3'
p8179
(F9.851219177246094
F1.8996641794840494
tp8180
sS'a\ndel a[(-1)]'
p8181
(F8.732501983642578
F1.822718048095703
tp8182
sS'def del_method():\n    pass'
p8183
(F10.995697021484375
F2.2201751708984374
tp8184
sS'def pop_method():\n    global a\nglobal index'
p8185
(F14.636243034811582
F1.9336873372395833
tp8186
sS'a'
p8187
(F14.068305969238281
F1.8962809244791667
tp8188
sS'a.pop(1)'
p8189
(F10.162280082702637
F1.7493269602457682
tp8190
sS'a = range(10)\nindex = 3'
p8191
(F9.885075887044271
F1.8693578084309896
tp8192
sS'a = range(10)\na\ndel a[(-1)]\na'
p8193
(F9.855069115048362
F1.8640597025553385
tp8194
sS'def pop_method():\n    global a'
p8195
(F12.433658054896764
F1.9130279541015625
tp8196
sS'def del_method():\n    global a\nglobal index\ndel a[index]'
p8197
(F13.795784328294838
F2.0416375478108724
tp8198
sS'a = range(10)'
p8199
(F8.729643821716309
F1.8676111857096354
tp8200
sS'del a[(-1)]\na'
p8201
(F9.970523198445639
F1.8164429982503256
tp8202
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    pass'
p8203
(F13.278435748556387
F1.957440185546875
tp8204
sS'global index\ndel a[index]'
p8205
(F13.639985656738281
F1.8561225891113282
tp8206
sS'def __init__(self, items):\n    self.items = items'
p8207
(F14.185514831542969
F2.0198782602945964
tp8208
sS'def pop_method():\n    pass'
p8209
(F11.572176419771635
F1.9212753295898437
tp8210
sS'a.pop(index)'
p8211
(F11.678071975708008
F1.7150433858235676
tp8212
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items'
p8213
(F13.266344197591145
F1.9533387502034505
tp8214
sS'class foo(object):\n\n    def __init__(self, items):\n        self.items = items\n\ndef __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    return foo((self.items + right.items))'
p8215
(F13.368156708866717
F1.8796305338541666
tp8216
sS"a = ['a', 'b', 'c', 'd']\na.pop(1)"
p8217
(F7.313263702392578
F1.7085678100585937
tp8218
sS'del a[(-1)]'
p8219
(F8.128157043457032
F1.819530995686849
tp8220
sS'def pop_method():\n    global a\nglobal index\na.pop(index)'
p8221
(F13.959125518798828
F1.8395128885904948
tp8222
sS'def __getitem__(self, index):\n    return foo(self.items[index])'
p8223
(F12.628585205078124
F1.904517364501953
tp8224
sS'def __add__(self, right):\n    pass'
p8225
(F12.771882057189941
F2.0860135396321615
tp8226
sS"a = ['a', 'b', 'c', 'd']\na.pop()"
p8227
(F7.0499717310855265
F1.7107701619466147
tp8228
sS'def slice_method():\n    pass'
p8229
(F11.585726224459135
F1.9763445536295572
tp8230
sS'def __getitem__(self, index):\n    return foo(self.items[index])\n\ndef __add__(self, right):\n    pass'
p8231
(F12.953369140625
F1.9480608622233073
tp8232
sS"a = ['a', 'b', 'c', 'd']"
p8233
(F4.877813779390776
F1.788884989420573
tp8234
sS'def __add__(self, right):\n    return foo((self.items + right.items))'
p8235
(F13.014013017926898
F1.9416976928710938
tp8236
sS'a = range(10)\na'
p8237
(F11.006201171875
F1.8859940846761067
tp8238
sS'global a'
p8239
(F15.461219787597656
F2.100333658854167
tp8240
sS'a = [1, 2, 3, 4, 5, 6]'
p8241
(F5.915073619169347
F1.7446651458740234
tp8242
sS'def __getitem__(self, index):\n    pass'
p8243
(F12.639245986938477
F2.092743174235026
tp8244
ssI1773805
(dp8245
S"with open('example.yaml') as stream:\n    pass"
p8246
(F11.483016967773438
F1.8450695384632458
tp8247
sS'from __future__ import print_function\nimport ruamel.yaml as yaml'
p8248
(F20.522818172679226
F1.9112098000266335
tp8249
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8250
(F7.69364595413208
F1.8769916187633167
tp8251
sS"from __future__ import print_function\nimport yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint((data == data_loaded))"
p8252
(F12.177365451388889
F1.8552929271351208
tp8253
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8254
(F10.759720828555047
F1.8585581345991655
tp8255
sS"from __future__ import print_function\nimport yaml\nwith open('example.yaml', 'r') as stream:\n    pass"
p8256
(F15.014683314732142
F1.8695370067249646
tp8257
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8258
(F11.216279933763587
F1.8595033125443892
tp8259
sS"with open('example.yaml', 'r') as stream:\n    pass"
p8260
(F10.665384292602539
F1.8250727220015093
tp8261
sS'data_loaded = yaml.load(stream)'
p8262
(F14.211522420247396
F1.938867915760387
tp8263
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8264
(F12.736523858432111
F1.846902153708718
tp8265
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8266
(F10.08277060768821
F1.8896713256835938
tp8267
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8268
(F8.63078351702009
F1.8701360875909978
tp8269
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8270
(F10.903116498674665
F1.855181260542436
tp8271
sS"from __future__ import print_function\nimport yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8272
(F11.984361217867944
F1.8582070090553977
tp8273
sS"from __future__ import print_function\nimport yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8274
(F11.503775687839674
F1.8617203452370383
tp8275
sS'yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)'
p8276
(F15.069753011067709
F2.0254147269509057
tp8277
sS'from __future__ import print_function\nimport yaml\nimport io'
p8278
(F19.97178077697754
F2.0017963756214487
tp8279
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8280
(F10.720273798162287
F1.8779307278719815
tp8281
sS"from __future__ import print_function\nimport yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8282
(F10.161527609523338
F1.8726010756059126
tp8283
sS'import yaml'
p8284
(F16.747116088867188
F1.901926040649414
tp8285
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint((data == data_loaded))"
p8286
(F13.54446802383814
F1.8424562974409624
tp8287
sS"with open('data.yaml', 'r') as stream:\n    pass"
p8288
(F10.665384292602539
F1.8250727220015093
tp8289
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    pass"
p8290
(F7.991126217059235
F1.8773543617942117
tp8291
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8292
(F13.400893481809701
F1.843315297907049
tp8293
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint((data == data_loaded))"
p8294
(F11.504250178261408
F1.856169960715554
tp8295
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8296
(F10.63631223282724
F1.8632174405184658
tp8297
sS'import ruamel.yaml as yaml'
p8298
(F19.621551513671875
F1.9072206670587712
tp8299
sS"from __future__ import print_function\nimport yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8300
(F11.505950927734375
F1.8876670490611682
tp8301
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8302
(F10.287866684996967
F1.8594110662286931
tp8303
sS"from __future__ import print_function\nimport yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8304
(F9.586713067416486
F1.9707270535555752
tp8305
sS"with io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8306
(F13.18404796511628
F1.89413781599565
tp8307
sS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint((data == data_loaded))"
p8308
(F13.481631808810764
F1.806412089954723
tp8309
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint((data == data_loaded))"
p8310
(F11.22610002223069
F1.8519285375421697
tp8311
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8312
(F10.49563498025412
F1.893131602894176
tp8313
sS"with open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)"
p8314
(F13.0891650390625
F1.778223904696378
tp8315
sS"import yaml\nwith open('example.yaml', 'r') as stream:\n    pass"
p8316
(F11.947025499845806
F1.8291372819380327
tp8317
sS'print(exc)'
p8318
(F8.186946233113607
F2.135446721857244
tp8319
sS'import io'
p8320
(F16.700803756713867
F1.9928569793701172
tp8321
sS"import io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8322
(F6.19181956415591
F2.0125675201416016
tp8323
sS"from __future__ import print_function\nimport ruamel.yaml as yaml\nwith open('example.yaml') as stream:\n    pass"
p8324
(F16.69267374674479
F1.8606586456298828
tp8325
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    data_loaded = yaml.load(stream)\nprint((data == data_loaded))"
p8326
(F11.093606567382812
F1.8539182489568538
tp8327
sS'from __future__ import print_function'
p8328
(F19.786512756347655
F2.108281048861417
tp8329
sS'from __future__ import print_function\nimport yaml'
p8330
(F20.14231755183293
F2.0104508833451704
tp8331
sS'import yaml\nimport io'
p8332
(F18.059927804129465
F1.9138832092285156
tp8333
sS"import yaml\nimport io\ndata = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8334
(F7.214333047672194
F1.9870491027832031
tp8335
sS"import ruamel.yaml as yaml\nwith open('example.yaml') as stream:\n    pass"
p8336
(F14.770826067243304
F1.8266036293723367
tp8337
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)\nwith open('data.yaml', 'r') as stream:\n    pass"
p8338
(F10.114215087890624
F1.8626707250421697
tp8339
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }"
p8340
(F5.595924909724745
F2.0549456856467505
tp8341
sS"data = {'a list': [1, 42, 3.141, 1337, 'help', u'\\u20ac'], 'a string': 'bla', 'another dict': {'foo': 'bar', 'key': 'value', 'the answer': 42, }, }\nwith io.open('data.yaml', 'w', encoding='utf8') as outfile:\n    yaml.dump(data, outfile, default_flow_style=False, allow_unicode=True)"
p8342
(F9.865318388097426
F1.8962227214466443
tp8343
sS'print(yaml.load(stream))'
p8344
(F12.092701305042613
F1.9642654765735974
tp8345
sS'print((data == data_loaded))'
p8346
(F12.601348876953125
F2.0486777912486684
tp8347
ssI663171
(dp8348
S"x = 'Hello World!'"
p8349
(F8.016168975830078
F2.148919912484976
tp8350
sS'x[:2]\nx[:(-2)]\nx[(-2):]'
p8351
(F7.359859008789062
F2.0245933532714844
tp8352
sS'x[:(-2)]\nx[(-2):]'
p8353
(F6.9662828947368425
F2.041882588313176
tp8354
sS'x[:2]'
p8355
(F7.561195373535156
F1.9499579209547777
tp8356
sS'x[(-2):]\nx[2:(-2)]'
p8357
(F7.179588317871094
F2.0316773928128757
tp8358
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]"
p8359
(F7.6186907087053575
F1.9880200899564302
tp8360
sS'x[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8361
(F7.13720334809402
F2.0426582923302283
tp8362
sS'x[:(-2)]'
p8363
(F6.501590728759766
F2.021871420053335
tp8364
sS'x[2:]\nx[:2]'
p8365
(F7.97115971491887
F1.9501234201284556
tp8366
sS'x[:2]\nx[:(-2)]'
p8367
(F7.315479755401611
F1.9970086904672475
tp8368
sS"x = 'Hello World!'\nx[2:]\nx[:2]"
p8369
(F8.019885792451745
F1.9106022761418269
tp8370
sS'x[2:]'
p8371
(F7.697628021240234
F1.9515457153320312
tp8372
sS"'H-e-l-l-o- -W-o-r-l-d'[::2]"
p8373
(F4.601670265197754
F1.8730173844557543
tp8374
sS'x[(-2):]'
p8375
(F6.7802375793457035
F2.0408656780536356
tp8376
sS's = Substr(s, beginning, LENGTH)'
p8377
(F11.094645182291666
F1.9677521632267878
tp8378
sS'x[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8379
(F7.391633823939732
F2.032865964449369
tp8380
sS'x[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]'
p8381
(F7.542963539681783
F2.03030879680927
tp8382
sS'some_string[::(-1)]'
p8383
(F8.116861196664663
F1.8715038299560547
tp8384
sS"x = 'Hello World!'\nx[2:]"
p8385
(F8.213260303844105
F1.9102087754469652
tp8386
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]\nx[2:(-2)]"
p8387
(F7.526006401909722
F2.0032499753511868
tp8388
sS"x = 'Hello World!'\nx[2:]\nx[:2]\nx[:(-2)]"
p8389
(F7.70297358586238
F1.9620707585261419
tp8390
sS'x[2:]\nx[:2]\nx[:(-2)]\nx[(-2):]'
p8391
(F7.6124538298576105
F2.0200664813701925
tp8392
sS'x[2:]\nx[:2]\nx[:(-2)]'
p8393
(F7.6770241477272725
F1.9935786907489483
tp8394
sS'x[2:(-2)]'
p8395
(F6.637413718483665
F1.9976190420297475
tp8396
sS's = s[beginning:(beginning + LENGTH)]'
p8397
(F10.441096714564733
F1.790887685922476
tp8398
ssI1185524
(dp8399
S'str.lstrip()'
p8400
(F9.175982883998326
F4.568726973100142
tp8401
sS'str.strip()\nstr.lstrip()'
p8402
(F10.181342491736778
F4.402075680819425
tp8403
sS"s = '   foo    \\t   '"
p8404
(F7.929989624023437
F4.467545942826704
tp8405
sS"s = s.strip(' \\t\\n\\r')"
p8406
(F9.837492370605469
F4.347456498579546
tp8407
sS"print pat.sub('', s)"
p8408
(F9.587072199041193
F4.428439053622159
tp8409
sS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p8410
(F10.791530833524817
F4.323975996537642
tp8411
sS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8412
(F9.869937896728516
F4.3351287841796875
tp8413
sS"import re\nprint re.sub('[\\\\s+]', '', s)"
p8414
(F10.906625747680664
F4.310770208185369
tp8415
sS"print re.sub('[\\\\s+]', '', s)"
p8416
(F9.6435300386869
F4.317713650790128
tp8417
sS's = s.lstrip()'
p8418
(F9.689899020724827
F4.4317144914106885
tp8419
sS'str.strip()'
p8420
(F8.710750034877233
F4.376681241122159
tp8421
sS"pat = re.compile('\\\\s+')"
p8422
(F9.033594512939453
F4.357256802645597
tp8423
sS"s = '  \\t a string example\\t  '"
p8424
(F7.929989624023437
F4.467545942826704
tp8425
sS'str.rstrip()'
p8426
(F9.175982883998326
F4.568726973100142
tp8427
sS'print s.strip()'
p8428
(F9.801273345947266
F4.35753042047674
tp8429
sS'import re'
p8430
(F15.757369041442871
F4.320146734064275
tp8431
sS'str.lstrip()\nstr.rstrip()'
p8432
(F10.133618868314302
F4.53227441961115
tp8433
sS's = s.strip()'
p8434
(F10.424492730034721
F4.349953738125888
tp8435
sS"s = '   foo    \\t   '\nprint s.strip()"
p8436
(F9.11520258585612
F4.3402838273481885
tp8437
sS"s = '  \\t a string example\\t  '\ns = s.strip()"
p8438
(F9.788952167217548
F4.330771359530362
tp8439
sS's = s.rstrip()'
p8440
(F9.689899020724827
F4.4317144914106885
tp8441
sS'str.strip()\nstr.lstrip()\nstr.rstrip()'
p8442
(F10.6060646458676
F4.412343805486506
tp8443
sS'astringexample'
p8444
(F11.401206970214844
F4.6161582253196025
tp8445
sS"import re\npat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8446
(F10.394849989149305
F4.325253573330966
tp8447
sS"s = '  \\t  foo   \\t   bar \\t  '\nprint pat.sub('', s)"
p8448
(F9.345217895507812
F4.365220503373579
tp8449
sS"import re\npat = re.compile('\\\\s+')"
p8450
(F10.647571270282452
F4.330825112082741
tp8451
sS"pat = re.compile('\\\\s+')\ns = '  \\t  foo   \\t   bar \\t  '"
p8452
(F9.827813284737724
F4.34799541126598
tp8453
sS"s = '  \\t  foo   \\t   bar \\t  '"
p8454
(F7.929989624023437
F4.467545942826704
tp8455
ssI354038
(dp8456
S"b = '963spam'\nb.isdigit()"
p8457
(F9.08412031693892
F1.8396862877739801
tp8458
sS"a = '03523'\na.isdigit()\nb = '963spam'\nb.isdigit()"
p8459
(F9.038487025669642
F1.8254500495062933
tp8460
sS'a.isdigit()'
p8461
(F9.353111267089844
F1.8088493347167969
tp8462
sS"a = '03523'"
p8463
(F8.504407501220703
F1.7688121795654297
tp8464
sS"a = '03523'\na.isdigit()\nb = '963spam'"
p8465
(F8.877357991536458
F1.7815988328721788
tp8466
sS"a.isdigit()\nb = '963spam'"
p8467
(F9.311831387606533
F1.7791375054253473
tp8468
sS'b.isdigit()'
p8469
(F9.572865077427455
F1.8651930491129558
tp8470
sS"b = '963spam'"
p8471
(F8.670465850830078
F1.7930463155110676
tp8472
sS"a.isdigit()\nb = '963spam'\nb.isdigit()"
p8473
(F9.280327292049632
F1.8282216389973958
tp8474
sS"float('NaN')"
p8475
(F6.487306594848633
F1.7059876124064128
tp8476
sS"a = '03523'\na.isdigit()"
p8477
(F9.15260800448331
F1.7993267907036676
tp8478
ssI2600191
(dp8479
S'[1, 2, 3, 4, 1, 4, 1].count(1)'
p8480
(F6.25191913951527
F2.1743545532226562
tp8481
sS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]"
p8482
(F10.439457062752016
F2.1042760213216147
tp8483
sS"l = ['a', 'b', 'b']"
p8484
(F5.351925243030895
F2.1982297261555988
tp8485
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8486
(F10.478017356178977
F2.3579493204752606
tp8487
sS"l = ['a', 'b', 'b']\n[[x, l.count(x)] for x in set(l)]\ndict(((x, l.count(x)) for x in set(l)))"
p8488
(F11.90606802481192
F2.093405532836914
tp8489
sS'import timeit'
p8490
(F18.58953285217285
F2.461968739827474
tp8491
sS"l.count('a')\nl.count('b')"
p8492
(F10.539278157552083
F2.2530982971191404
tp8493
sS'from collections import Counter\nCounter(l)'
p8494
(F14.206519386985086
F2.1122272491455076
tp8495
sS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8496
(F10.196283513849432
F2.280303192138672
tp8497
sS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p8498
(F8.465056242766204
F2.137708791097005
tp8499
sS'from collections import Counter'
p8500
(F19.459393819173176
F2.13818842569987
tp8501
sS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p8502
(F4.31816639619715
F2.223408508300781
tp8503
sS"l = ['a', 'b', 'b']\nfrom collections import Counter"
p8504
(F10.897052764892578
F2.1402570088704427
tp8505
sS'Counter(l)'
p8506
(F8.758525848388672
F2.2636177062988283
tp8507
sS"z = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']\nCounter(z)"
p8508
(F5.620914112437855
F2.168634287516276
tp8509
sS"print 'count():   ', t2.repeat(repeat=3, number=10000)"
p8510
(F9.835736443014707
F2.2761085510253904
tp8511
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8512
(F9.115781784057617
F2.455180867513021
tp8513
sS'dict(((x, l.count(x)) for x in set(l)))'
p8514
(F12.634437561035156
F2.072398885091146
tp8515
sS"l.count('b')"
p8516
(F9.779914855957031
F2.257898203531901
tp8517
sS"l = ['a', 'b', 'b']\nl.count('a')"
p8518
(F7.72786627875434
F2.1966532389322917
tp8519
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8520
(F10.391670227050781
F2.3371307373046877
tp8521
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8522
(F11.080938485952524
F2.4707715352376303
tp8523
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8524
(F10.222705296107701
F2.369243367513021
tp8525
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8526
(F10.998145693824405
F2.375732421875
tp8527
sS"l = ['a', 'b', 'b']\nl.count('a')\nl.count('b')"
p8528
(F8.879297485351563
F2.196069081624349
tp8529
sS"t2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8530
(F9.115781784057617
F2.455180867513021
tp8531
sS"l.count('a')"
p8532
(F9.779914855957031
F2.257898203531901
tp8533
sS'[[x, l.count(x)] for x in set(l)]'
p8534
(F12.671051025390625
F2.068149948120117
tp8535
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)\nprint 'count():   ', t2.repeat(repeat=3, number=10000)"
p8536
(F10.804709598935883
F2.3446022033691407
tp8537
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8538
(F9.82641070822011
F2.4730458577473957
tp8539
sS"l = ['a', 'b', 'b']\nfrom collections import Counter\nCounter(l)"
p8540
(F10.154626755487351
F2.123698933919271
tp8541
sS'[[x, l.count(x)] for x in set(l)]\ndict(((x, l.count(x)) for x in set(l)))'
p8542
(F13.354923595081676
F2.0628753662109376
tp8543
sS'Counter(z)'
p8544
(F8.915600458780924
F2.411498514811198
tp8545
sS"from collections import Counter\nz = ['blue', 'red', 'blue', 'yellow', 'blue', 'red']"
p8546
(F8.229578191583807
F2.168476867675781
tp8547
sS"import timeit\nt1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')"
p8548
(F11.28236592610677
F2.4491783142089845
tp8549
sS"t1 = timeit.Timer('Counter(l)', 'import random;import string;from collections import Counter;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nt2 = timeit.Timer('[[x,l.count(x)] for x in set(l)]', 'import random;import string;n=1000;l=[random.choice(string.ascii_letters) for x in xrange(n)]')\nprint 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8550
(F10.395561805138222
F2.3926600138346354
tp8551
sS"print 'Counter(): ', t1.repeat(repeat=3, number=10000)"
p8552
(F9.835736443014707
F2.2761085510253904
tp8553
ssI845058
(dp8554
S'def mapcount(filename):\n    pass'
p8555
(F10.093806584676107
F2.610322605479847
tp8556
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8557
(F12.729788028492647
F2.57000056180087
tp8558
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8559
(F12.984539711312072
F2.456058155406605
tp8560
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8561
(F11.433458116319445
F2.4366656216708096
tp8562
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8563
(F13.124077396116395
F2.524689934470437
tp8564
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8565
(F11.651886428611865
F2.43938532742587
tp8566
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8567
(F12.417501343227231
F2.4768621271306817
tp8568
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8569
(F12.30116562015754
F2.451631546020508
tp8570
sS'lines = 0'
p8571
(F10.715398406982422
F2.459313826127486
tp8572
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8573
(F12.779498089800825
F2.516977310180664
tp8574
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p8575
(F11.723276966022995
F2.4353431354869497
tp8576
sS'from __future__ import with_statement'
p8577
(F19.692037963867186
F2.585340153087269
tp8578
sS'return lines\n\ndef bufcount(filename):\n    pass'
p8579
(F11.276978492736816
F2.5130809437144888
tp8580
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p8581
(F13.166848009965552
F2.454104336825284
tp8582
sS'def simplecount(filename):\n    pass'
p8583
(F10.093806584676107
F2.610322605479847
tp8584
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8585
(F12.682698810634328
F2.515382419932972
tp8586
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8587
(F11.931306659050708
F2.443489594893022
tp8588
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8589
(F12.525569242589613
F2.471364454789595
tp8590
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8591
(F13.44708305027174
F2.4536944302645596
tp8592
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8593
(F13.066773646086165
F2.4539789720015093
tp8594
sS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8595
(F12.217078653971354
F2.6527997797185723
tp8596
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8597
(F12.948576274671053
F2.504228938709606
tp8598
sS"def mapcount(filename):\n    f = open(filename, 'r+')"
p8599
(F9.803327058490954
F2.4783165671608667
tp8600
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8601
(F12.411027763944222
F2.478215304287997
tp8602
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8603
(F11.450197492327009
F2.452048561789773
tp8604
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8605
(F12.476786768713662
F2.5001988844438032
tp8606
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8607
(F13.077819568841527
F2.468713240189986
tp8608
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8609
(F12.100369540127842
F2.4656883586536753
tp8610
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p8611
(F12.571893964494977
F2.527939189564098
tp8612
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8613
(F12.435140273150276
F2.6701854359019888
tp8614
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8615
(F12.750916299940664
F2.5127910267223013
tp8616
sS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8617
(F12.02212481431558
F2.6739574779163706
tp8618
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8619
(F12.400586387528802
F2.472295414317738
tp8620
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass'
p8621
(F12.199117024739584
F2.503053144975142
tp8622
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8623
(F12.527466961156541
F2.4765418659556997
tp8624
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8625
(F12.378419363839285
F2.4642899253151636
tp8626
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8627
(F12.357760712594697
F2.453949148004705
tp8628
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8629
(F12.609627501605308
F2.5026092529296875
tp8630
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8631
(F12.204381528108016
F2.453025991266424
tp8632
sS'readline = buf.readline'
p8633
(F14.631435939243861
F2.591614983298562
tp8634
sS'for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8635
(F12.614381489000822
F2.6453252272172407
tp8636
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8637
(F12.73855206144958
F2.589315241033381
tp8638
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8639
(F12.470103357568641
F2.4548253146084873
tp8640
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p8641
(F12.693732125418526
F2.5526438626376065
tp8642
sS"print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8643
(F11.162540283203125
F2.6028770099986684
tp8644
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8645
(F11.80438923385908
F2.436888954856179
tp8646
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8647
(F12.459332540760869
F2.6636390686035156
tp8648
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8649
(F12.21841903471611
F2.43477387861772
tp8650
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8651
(F11.44941914876302
F2.4389171600341797
tp8652
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8653
(F12.91659620331555
F2.457574324174361
tp8654
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8655
(F11.999736544452135
F2.463421041315252
tp8656
sS'pass'
p8657
(F10.276464462280273
F2.67528620633212
tp8658
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8659
(F12.319462345336294
F2.4607852589000356
tp8660
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8661
(F12.585231278582317
F2.4541702270507812
tp8662
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8663
(F13.006627478966346
F2.525535236705433
tp8664
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p8665
(F12.701810670130461
F2.4520062533291904
tp8666
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8667
(F12.410615976790936
F2.464584697376598
tp8668
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8669
(F13.111512155243844
F2.453384746204723
tp8670
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p8671
(F12.751881816599628
F2.4517704356800425
tp8672
sS'lines += 1'
p8673
(F9.883961486816407
F2.4600296020507812
tp8674
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8675
(F12.225521955818966
F2.4466689716685903
tp8676
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8677
(F12.498450319739382
F2.4781421314586294
tp8678
sS"f = open(filename, 'r+')"
p8679
(F8.5740478515625
F2.477343125776811
tp8680
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8681
(F12.688692889636076
F2.4808776161887427
tp8682
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8683
(F11.577623711257685
F2.454194502397017
tp8684
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8685
(F12.959711162860577
F2.531174052845348
tp8686
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8687
(F12.812037150065104
F2.4546083970503374
tp8688
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8689
(F13.117671342329546
F2.4899744553999468
tp8690
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8691
(F12.549504084385179
F2.4861127679998223
tp8692
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8693
(F12.81251220703125
F2.528799230402166
tp8694
sS'buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8695
(F12.666501871744792
F2.549619501287287
tp8696
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p8697
(F10.916079313858695
F2.489150133999911
tp8698
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8699
(F12.586174011230469
F2.5084422718394888
tp8700
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p8701
(F13.245878258529974
F2.500020807439631
tp8702
sS'for func in [mapcount, simplecount, bufcount, opcount]:\n    pass'
p8703
(F11.995484201531662
F2.639322454279119
tp8704
sS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8705
(F12.101298429528061
F2.691120147705078
tp8706
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8707
(F12.16486580141129
F2.474452105435458
tp8708
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p8709
(F16.257887098524307
F2.6021934856068003
tp8710
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8711
(F13.403097347337372
F2.467444333163175
tp8712
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8713
(F12.65022499655837
F2.4692927273837
tp8714
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8715
(F12.826939957865168
F2.5959354747425425
tp8716
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8717
(F12.710217552463504
F2.517741983587092
tp8718
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8719
(F12.61987018585205
F2.4910319935191763
tp8720
sS'buf = mmap.mmap(f.fileno(), 0)'
p8721
(F10.258076667785645
F2.6389037045565518
tp8722
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8723
(F12.69529296875
F2.5075614235617896
tp8724
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8725
(F12.369957419002757
F2.4552352211692114
tp8726
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8727
(F12.701341132155987
F2.524653348055753
tp8728
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8729
(F13.168973781194788
F2.4896812438964844
tp8730
sS'return lines\n\ndef simplecount(filename):\n    lines = 0'
p8731
(F10.991951836480034
F2.462565855546431
tp8732
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8733
(F12.686967957694575
F2.580445896495472
tp8734
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p8735
(F12.593567648051698
F2.597138838334517
tp8736
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8737
(F12.762109827112269
F2.5226674513383345
tp8738
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8739
(F12.716097213208865
F2.5115399794145064
tp8740
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8741
(F12.123806521189298
F2.4426571239124644
tp8742
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8743
(F12.38454256924716
F2.442156358198686
tp8744
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8745
(F12.765160683473926
F2.56979699568315
tp8746
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p8747
(F12.329670597956731
F2.4776698025790127
tp8748
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8749
(F12.547076138583096
F2.4541986638849433
tp8750
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8751
(F12.40091193704044
F2.466706536032937
tp8752
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8753
(F12.490812821821732
F2.4939951463179155
tp8754
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8755
(F12.819317072088069
F2.5219064192338423
tp8756
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8757
(F11.783601822391633
F2.4313947504216973
tp8758
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p8759
(F12.160462914443597
F2.465418208729137
tp8760
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8761
(F12.283748183139535
F2.46405011957342
tp8762
sS'read_f = f.read'
p8763
(F16.508005777994793
F2.5536705363880503
tp8764
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8765
(F12.80676513671875
F2.542152231389826
tp8766
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8767
(F12.510548909505209
F2.493061239069158
tp8768
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8769
(F12.800184652838908
F2.4723446585915307
tp8770
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8771
(F12.476978302001953
F2.459952787919478
tp8772
sS'buf = read_f(buf_size)\nreturn lines'
p8773
(F13.756640625
F2.5019229542125356
tp8774
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8775
(F12.270383920242537
F2.455983595414595
tp8776
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline'
p8777
(F12.227124727689302
F2.576066797429865
tp8778
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8779
(F12.639896422859252
F2.4504078951748935
tp8780
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p8781
(F12.576174978482522
F2.4513017481023613
tp8782
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8783
(F13.12573639164126
F2.4760006991299717
tp8784
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8785
(F12.386883448040674
F2.4840001192959873
tp8786
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8787
(F12.185386411605343
F2.4415033513849433
tp8788
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p8789
(F13.223213195800781
F2.4830154072154653
tp8790
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p8791
(F13.364040919712611
F2.455169677734375
tp8792
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8793
(F12.147517952376496
F2.454686078158292
tp8794
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8795
(F12.127711142263104
F2.6704483032226562
tp8796
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p8797
(F11.36760525173611
F2.437698017467152
tp8798
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8799
(F12.513039136840398
F2.4783200350674717
tp8800
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8801
(F12.860344704617276
F2.514993667602539
tp8802
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8803
(F12.514082067153034
F2.481332952325994
tp8804
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8805
(F12.561259424963662
F2.4818898981267754
tp8806
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8807
(F12.505425453186035
F2.4734278592196377
tp8808
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8809
(F12.615276613862457
F2.4901149056174536
tp8810
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8811
(F12.818006013569079
F2.5567713650790127
tp8812
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8813
(F11.53964918486926
F2.436190518465909
tp8814
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8815
(F12.519912978350106
F2.490325927734375
tp8816
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8817
(F12.518691261215965
F2.4792123274369673
tp8818
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8819
(F12.524989536830358
F2.478496724909002
tp8820
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8821
(F12.870658712184175
F2.479279258034446
tp8822
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8823
(F10.73399894468246
F2.5006519664417612
tp8824
sS"assert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8825
(F11.616020940965221
F2.7192975824529473
tp8826
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p8827
(F11.541448256548714
F2.4934980219060723
tp8828
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8829
(F12.943523448000672
F2.570288051258434
tp8830
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8831
(F12.669726860232469
F2.453714544122869
tp8832
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8833
(F12.180274777296113
F2.4552608836780894
tp8834
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8835
(F12.559376307896205
F2.506053751165217
tp8836
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8837
(F12.686455928918088
F2.483675870028409
tp8838
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8839
(F12.587908626152073
F2.4697494506835938
tp8840
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8841
(F11.56400324789326
F2.4383068084716797
tp8842
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8843
(F12.3246069555884
F2.4646682739257812
tp8844
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8845
(F12.812233664772727
F2.4974417252974077
tp8846
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8847
(F12.692070470647772
F2.480680812488903
tp8848
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p8849
(F12.516997343264752
F2.4549265774813565
tp8850
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8851
(F12.677858323317308
F2.4920323111794214
tp8852
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8853
(F12.755819021177686
F2.524367419156161
tp8854
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8855
(F12.72608865717406
F2.500268589366566
tp8856
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8857
(F12.599177631578947
F2.51333271373402
tp8858
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8859
(F12.431939019097221
F2.4788882515647193
tp8860
sS"while buf:\n    lines += buf.count('\\n')"
p8861
(F9.616485595703125
F2.5226620760830967
tp8862
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8863
(F11.834528605143229
F2.43507905439897
tp8864
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p8865
(F12.199896587588922
F2.4601469906893643
tp8866
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p8867
(F11.668343680245536
F2.4363143227317114
tp8868
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p8869
(F12.290430626502404
F2.4676359350031074
tp8870
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8871
(F12.673406541961985
F2.48030593178489
tp8872
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p8873
(F12.490211411277846
F2.4534275748512964
tp8874
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p8875
(F12.142525269813145
F2.4370495189319956
tp8876
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p8877
(F11.599525734230324
F2.4647527174516157
tp8878
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8879
(F12.437281494140626
F2.4515744989568535
tp8880
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p8881
(F11.347204420301649
F2.570930827747692
tp8882
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p8883
(F12.461704233530405
F2.4750185879794033
tp8884
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8885
(F12.672265625
F2.517263239080256
tp8886
sS'read_f = f.read\nbuf = read_f(buf_size)'
p8887
(F14.201068115234374
F2.5389246507124468
tp8888
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8889
(F12.611469107614436
F2.4548605138605293
tp8890
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8891
(F12.334233655427632
F2.4542361172762783
tp8892
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8893
(F12.799001169728708
F2.453017321499911
tp8894
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p8895
(F13.246623560325387
F2.4531790993430396
tp8896
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p8897
(F12.838746536609738
F2.4980798201127485
tp8898
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8899
(F12.266893826998198
F2.458316109397195
tp8900
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8901
(F12.047046802662036
F2.4944367842240767
tp8902
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8903
(F12.717607365098111
F2.469491958618164
tp8904
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8905
(F12.885278818558673
F2.5264902981844815
tp8906
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p8907
(F12.170768229166667
F2.4779611067338423
tp8908
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8909
(F11.433484825721154
F2.4393333088267934
tp8910
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p8911
(F12.59771493765024
F2.676195491443981
tp8912
sS'import time\nimport mmap\nimport random\nfrom collections import defaultdict'
p8913
(F18.71828409830729
F2.6309627186168325
tp8914
sS'buf_size = (1024 * 1024)\nread_f = f.read'
p8915
(F12.66309959010074
F2.572821010242809
tp8916
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random'
p8917
(F19.179848118832236
F2.591955705122514
tp8918
sS"lines += buf.count('\\n')"
p8919
(F10.141616821289062
F2.4960954839533027
tp8920
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p8921
(F12.564443588256836
F2.4995805566961113
tp8922
sS'from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict'
p8923
(F19.463134765625
F2.602559869939631
tp8924
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p8925
(F12.400098751752804
F2.475293419577859
tp8926
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8927
(F12.51865876850329
F2.440957849675959
tp8928
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8929
(F12.170481178977273
F2.6706716364080254
tp8930
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p8931
(F12.697051227395304
F2.452493494207209
tp8932
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p8933
(F11.985867500305176
F2.4557633833451704
tp8934
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8935
(F12.550019697709518
F2.4533708745783027
tp8936
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8937
(F12.009656270345053
F2.6500412334095347
tp8938
sS'for func in [mapcount, simplecount, bufcount, opcount]:\n    start_time = time.time()'
p8939
(F12.542171902126736
F2.629971590909091
tp8940
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p8941
(F12.06151487116228
F2.4551734924316406
tp8942
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p8943
(F12.838081173780488
F2.569377899169922
tp8944
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8945
(F12.03412391399515
F2.445383071899414
tp8946
sS'read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8947
(F12.795467921665736
F2.508723345669833
tp8948
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8949
(F12.270644199701003
F2.455609928477894
tp8950
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p8951
(F11.924640299479167
F2.4347475225275215
tp8952
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p8953
(F12.314589436848959
F2.4932797171852807
tp8954
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8955
(F12.036856002166491
F2.4467731822620737
tp8956
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8957
(F12.24683885450487
F2.4428587826815518
tp8958
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p8959
(F12.814200979764344
F2.53141958063299
tp8960
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1'
p8961
(F11.335033215974507
F2.5517246939919214
tp8962
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p8963
(F12.354441481370193
F2.562144712968306
tp8964
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8965
(F12.757001273239716
F2.499012686989524
tp8966
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p8967
(F12.721223892704133
F2.515697479248047
tp8968
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p8969
(F11.668425147213153
F2.4359156868674536
tp8970
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p8971
(F11.702800835503472
F2.449685877019709
tp8972
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p8973
(F12.577366239302386
F2.482135772705078
tp8974
sS"num_lines = sum((1 for line in open('myfile.txt')))"
p8975
(F13.186015881990132
F2.447904586791992
tp8976
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p8977
(F11.752882737379808
F2.4511273124001245
tp8978
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p8979
(F12.497736551675452
F2.4692474712025034
tp8980
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p8981
(F12.352956671463815
F2.460948423905806
tp8982
sS'buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p8983
(F12.021840145713405
F2.537989529696378
tp8984
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p8985
(F11.183731842041016
F2.4528860612349077
tp8986
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p8987
(F13.073677141104948
F2.48812519420277
tp8988
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p8989
(F12.770432044719827
F2.453113382512873
tp8990
sS'for (key, vals) in counts.items():\n    pass'
p8991
(F11.982647544459292
F2.6314818642356177
tp8992
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p8993
(F12.447675017272534
F2.4546722065318716
tp8994
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p8995
(F12.458810129473287
F2.452890569513494
tp8996
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p8997
(F11.87451171875
F2.472763928500089
tp8998
sS'with open(fname) as f:\n    pass'
p8999
(F11.558355058942523
F2.469739220359109
tp9000
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9001
(F12.622284833122702
F2.4783144864169033
tp9002
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9003
(F13.085244668496621
F2.4800668196244673
tp9004
sS'readline = buf.readline\nwhile readline():\n    pass'
p9005
(F11.10164328182445
F2.583254033868963
tp9006
sS'for i in range(5):\n    pass'
p9007
(F11.058093479701451
F2.5856234810569068
tp9008
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9009
(F11.233194623674665
F2.5107688903808594
tp9010
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9011
(F12.569489655671296
F2.474720001220703
tp9012
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9013
(F12.61714861034292
F2.49233003096147
tp9014
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9015
(F12.40092176072141
F2.4551573666659268
tp9016
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9017
(F12.18272705078125
F2.476793982765891
tp9018
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9019
(F11.556551332826968
F2.478816119107333
tp9020
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9021
(F12.536638957698171
F2.4510350660844282
tp9022
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9023
(F12.240898318407012
F2.445028305053711
tp9024
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9025
(F12.709541907677284
F2.452547073364258
tp9026
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9027
(F13.281072443181818
F2.4547795382413
tp9028
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9029
(F11.642063802083333
F2.434031746604226
tp9030
sS'counts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass'
p9031
(F12.959572034004408
F2.68408185785467
tp9032
sS'lines = 0\nbuf_size = (1024 * 1024)'
p9033
(F9.143245442708333
F2.648300517689098
tp9034
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9035
(F12.511426202182111
F2.4296002821488814
tp9036
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9037
(F12.935755632925725
F2.485079678622159
tp9038
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9039
(F11.774309562914299
F2.4378783486106177
tp9040
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9041
(F13.113759007947198
F2.4689348394220527
tp9042
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9043
(F12.523124346979483
F2.489119616421786
tp9044
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass'
p9045
(F12.365902549342104
F2.4586625532670454
tp9046
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9047
(F12.875198364257812
F2.5567252419211646
tp9048
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9049
(F11.784537179129464
F2.52247446233576
tp9050
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9051
(F12.014698621961806
F2.5114466927268286
tp9052
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9053
(F12.271847455929487
F2.4456084858287466
tp9054
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9055
(F12.468321981309336
F2.4617231542413887
tp9056
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9057
(F12.62488029998483
F2.4530995108864526
tp9058
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9059
(F12.747987464353612
F2.490680867975408
tp9060
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p9061
(F12.00043475811298
F2.453603744506836
tp9062
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p9063
(F11.34879896375868
F2.4656925201416016
tp9064
sS'lines = 0\nreadline = buf.readline'
p9065
(F12.973388671875
F2.51034875349565
tp9066
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9067
(F12.636765843115482
F2.505422592163086
tp9068
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9069
(F14.45819091796875
F2.4884461489590732
tp9070
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p9071
(F11.997861056857639
F2.5247242667458276
tp9072
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9073
(F11.54774960604581
F2.4361421411687676
tp9074
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9075
(F10.777386256626674
F2.4872140017422764
tp9076
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9077
(F12.241141300073407
F2.458532680164684
tp9078
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9079
(F12.140452963082902
F2.4494684392755683
tp9080
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9081
(F11.31063968188142
F2.4860076904296875
tp9082
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9083
(F11.779660311612217
F2.48413103277033
tp9084
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9085
(F12.350778398722628
F2.4417715939608486
tp9086
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9087
(F12.300470452559622
F2.4721620733087715
tp9088
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9089
(F12.333168312355324
F2.443998683582653
tp9090
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9091
(F12.525313282740935
F2.4850311279296875
tp9092
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9093
(F14.460873307852909
F2.504378232088956
tp9094
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9095
(F12.101523303110666
F2.4550954645330254
tp9096
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9097
(F12.689622782044491
F2.5009850588711826
tp9098
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9099
(F12.596681337098818
F2.494660117409446
tp9100
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9101
(F12.455529189691312
F2.472854267467152
tp9102
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9103
(F11.99039939597801
F2.433015823364258
tp9104
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9105
(F12.799693309477647
F2.592125979336825
tp9106
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9107
(F12.57193603515625
F2.467946486039595
tp9108
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9109
(F11.860886594082446
F2.4472583423961294
tp9110
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9111
(F12.301216683736662
F2.4390314275568183
tp9112
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9113
(F12.962362060546875
F2.4872542294588955
tp9114
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9115
(F12.184205144898504
F2.4520315690474077
tp9116
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9117
(F12.391735148879716
F2.448609612204812
tp9118
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9119
(F11.792025696997548
F2.434209476817738
tp9120
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9121
(F12.734728921979865
F2.4908533963290127
tp9122
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9123
(F12.587728297456781
F2.4854325381192295
tp9124
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9125
(F12.315602428508255
F2.4612915732643823
tp9126
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9127
(F11.594663266782407
F2.4490443142977627
tp9128
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9129
(F12.124767848423549
F2.456718098033558
tp9130
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9131
(F13.279241746471774
F2.5404108220880683
tp9132
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9133
(F11.742716761997768
F2.4584754597056997
tp9134
sS"def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9135
(F12.549942787247474
F2.5918039842085405
tp9136
sS'from collections import defaultdict'
p9137
(F19.788102467854817
F2.691634785045277
tp9138
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9139
(F12.69860148879717
F2.502203507856889
tp9140
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9141
(F12.569952342135847
F2.4731584028764204
tp9142
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9143
(F12.582771779866237
F2.4823840748180044
tp9144
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9145
(F12.533050537109375
F2.4756346615878018
tp9146
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9147
(F12.999228902382425
F2.496424588290128
tp9148
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9149
(F13.043766276041667
F2.45507136258212
tp9150
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9151
(F12.430024704130568
F2.4807891845703125
tp9152
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9153
(F12.154552641369047
F2.441686283458363
tp9154
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9155
(F12.829231006187081
F2.541460384022106
tp9156
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9157
(F12.732461547851562
F2.526009299538352
tp9158
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9159
(F11.888978503999256
F2.46927885575728
tp9160
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9161
(F12.534328294836957
F2.5384606448086826
tp9162
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9163
(F12.901185620732669
F2.5394731001420454
tp9164
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9165
(F12.711008747264104
F2.518015081232244
tp9166
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9167
(F12.223148716517857
F2.451639175415039
tp9168
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9169
(F12.487115016496514
F2.4808001084761186
tp9170
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p9171
(F12.455372162979014
F2.4541173414750532
tp9172
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9173
(F12.113523087411556
F2.4479807073419746
tp9174
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9175
(F12.041072466901241
F2.462165659124201
tp9176
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9177
(F12.25537338256836
F2.4684857455166904
tp9178
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9179
(F12.237740325927735
F2.443945798006925
tp9180
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9181
(F12.72274292714497
F2.502153223211115
tp9182
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p9183
(F11.407078968394886
F2.504751205444336
tp9184
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9185
(F12.176287117650954
F2.454941836270419
tp9186
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9187
(F12.498270026159503
F2.476275010542436
tp9188
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9189
(F12.300254128196023
F2.479821812022816
tp9190
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9191
(F12.462734029750631
F2.4807666431773794
tp9192
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9193
(F12.806197045554578
F2.4872075861150567
tp9194
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9195
(F12.477334158761161
F2.454981717196378
tp9196
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9197
(F13.4183837890625
F2.455626054243608
tp9198
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9199
(F12.683246319110577
F2.5091479908336294
tp9200
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9201
(F12.328920063219572
F2.454936461015181
tp9202
sS'for line in open(filename):\n    lines += 1\nreturn lines'
p9203
(F12.550602963096217
F2.4385826804421167
tp9204
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9205
(F12.090477476728724
F2.456059542569247
tp9206
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9207
(F12.381498095015404
F2.4879934137517754
tp9208
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9209
(F12.86946025647615
F2.487932031804865
tp9210
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9211
(F12.675049937855114
F2.4696310216730293
tp9212
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9213
(F13.04827798379434
F2.472372055053711
tp9214
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p9215
(F13.09952046829841
F2.4556827545166016
tp9216
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9217
(F12.611537976211377
F2.5086375149813565
tp9218
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9219
(F10.794866225298714
F2.5420313748446377
tp9220
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9221
(F12.14120876198948
F2.4435882568359375
tp9222
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9223
(F11.656880326704545
F2.4326031424782495
tp9224
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9225
(F12.520703545932111
F2.4903656352650034
tp9226
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9227
(F12.389066538416353
F2.4444840171120386
tp9228
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9229
(F12.637354013871173
F2.5090560913085938
tp9230
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9231
(F12.449175860430744
F2.441918459805575
tp9232
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9233
(F12.51333837571487
F2.4768754785711113
tp9234
sS'for line in open(filename):\n    lines += 1'
p9235
(F11.954541206359863
F2.435762578790838
tp9236
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9237
(F12.786994280133928
F2.5157331986860796
tp9238
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9239
(F12.918624465529984
F2.51522480357777
tp9240
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9241
(F12.69701457473467
F2.508928819136186
tp9242
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9243
(F12.911165677584135
F2.5413436889648438
tp9244
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9245
(F12.576753566576087
F2.4927846735174004
tp9246
sS'while readline():\n    lines += 1\nreturn lines'
p9247
(F10.588383674621582
F2.4977874755859375
tp9248
sS'def simplecount(filename):\n    lines = 0'
p9249
(F9.926042829241071
F2.5190115841952236
tp9250
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9251
(F12.618448397008384
F2.5040076862681997
tp9252
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9253
(F12.11194076538086
F2.43337700583718
tp9254
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9255
(F12.348350123355264
F2.451226667924361
tp9256
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9257
(F12.213189019097221
F2.439885226162997
tp9258
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0'
p9259
(F11.497966948009672
F2.446552796797319
tp9260
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9261
(F12.12708740234375
F2.5207380814985796
tp9262
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9263
(F12.592525882320805
F2.5109743638472124
tp9264
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9265
(F12.517992492115825
F2.4928529912775215
tp9266
sS'counts[func].append((time.time() - start_time))'
p9267
(F12.856773739769345
F2.7032718658447266
tp9268
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9269
(F12.485117900013412
F2.4820917302911933
tp9270
sS"for (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9271
(F11.87122549661776
F2.613842183893377
tp9272
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9273
(F12.550157222510373
F2.4903737848455254
tp9274
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9275
(F12.6237659973857
F2.5025000138716265
tp9276
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9277
(F12.898205833713504
F2.4888194691051138
tp9278
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9279
(F12.856992070546408
F2.551489743319425
tp9280
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9281
(F12.044835140830592
F2.436716079711914
tp9282
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9283
(F12.818513690300708
F2.4507342251864346
tp9284
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9285
(F11.299159458705358
F2.467405319213867
tp9286
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9287
(F12.875115966796875
F2.5324457341974433
tp9288
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9289
(F12.239056987147178
F2.4395869861949575
tp9290
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p9291
(F12.477308094930306
F2.4536252455277876
tp9292
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9293
(F12.103549194335937
F2.490081960504705
tp9294
sS'return lines'
p9295
(F13.702268600463867
F2.479277350685813
tp9296
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p9297
(F11.955273109794463
F2.4577430378306997
tp9298
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9299
(F11.91607455549569
F2.4952397779984907
tp9300
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9301
(F12.558149371230812
F2.4857085834849966
tp9302
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p9303
(F12.286096689652423
F2.4995311390269888
tp9304
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9305
(F12.3088427734375
F2.4947086681019175
tp9306
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9307
(F12.64788863570602
F2.4996382973410864
tp9308
sS'import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9309
(F13.661676316034226
F2.633747794411399
tp9310
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    pass'
p9311
(F10.96790786016555
F2.552137028087269
tp9312
sS'import mmap\nimport random\nfrom collections import defaultdict'
p9313
(F18.86846923828125
F2.6542294242165307
tp9314
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9315
(F12.583408900669642
F2.5049353512850674
tp9316
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9317
(F12.305307919217139
F2.4525143016468394
tp9318
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9319
(F12.292287342583956
F2.4463646628639917
tp9320
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9321
(F12.430292038690476
F2.474937092174183
tp9322
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9323
(F11.552213134765625
F2.431771018288352
tp9324
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p9325
(F12.393580955795095
F2.453825690529563
tp9326
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9327
(F12.26409912109375
F2.4526079351251777
tp9328
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9329
(F12.426398349167714
F2.4562197598544033
tp9330
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9331
(F12.76974275150401
F2.5085033069957388
tp9332
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9333
(F12.34232674064217
F2.464447021484375
tp9334
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9335
(F11.641236770984738
F2.460249814120206
tp9336
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9337
(F13.49357267680921
F2.4739423231645064
tp9338
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9339
(F12.613903973553631
F2.502103632146662
tp9340
sS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9341
(F12.707195366753472
F2.679371573708274
tp9342
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9343
(F12.293134073572835
F2.4398184689608486
tp9344
sS'return (i + 1)'
p9345
(F8.47815227508545
F2.596258683638139
tp9346
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9347
(F12.331630267518939
F2.471305326981978
tp9348
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9349
(F12.672993578941993
F2.454721450805664
tp9350
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9351
(F13.119480705870608
F2.488813573663885
tp9352
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9353
(F12.166952835886102
F2.521069960160689
tp9354
sS'return (i + 1)\ncounts = defaultdict(list)'
p9355
(F10.991845703125
F2.640701640735973
tp9356
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9357
(F12.72326529832073
F2.4888073314319956
tp9358
sS'while readline():\n    pass'
p9359
(F9.029008345170455
F2.5565189014781606
tp9360
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)"
p9361
(F12.35020751953125
F2.453419945456765
tp9362
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9363
(F11.63173828125
F2.4402422471479936
tp9364
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9365
(F11.69926591352983
F2.5211306485262783
tp9366
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9367
(F12.690120796535327
F2.505589571866122
tp9368
sS'def opcount(fname):\n    pass'
p9369
(F9.373051961263021
F2.65922043540261
tp9370
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()'
p9371
(F13.057686438927284
F2.5570350993763316
tp9372
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9373
(F12.69882276581555
F2.512211712923917
tp9374
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9375
(F11.864833437163254
F2.4318329204212534
tp9376
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9377
(F13.896425545933734
F2.4765054529363457
tp9378
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9379
(F15.25208371184593
F2.539412411776456
tp9380
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9381
(F12.74850782707556
F2.491737192327326
tp9382
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p9383
(F12.79667822994403
F2.5135872580788354
tp9384
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9385
(F12.761361030910326
F2.467636455189098
tp9386
sS'import random\nfrom collections import defaultdict'
p9387
(F18.902018229166668
F2.6923592307350854
tp9388
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0'
p9389
(F11.278952026367188
F2.5976727225563745
tp9390
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9391
(F13.061138898725213
F2.4993199435147373
tp9392
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9393
(F12.87968455646055
F2.5768777673894707
tp9394
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9395
(F12.548942444816468
F2.4816754081032495
tp9396
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9397
(F11.376383721073971
F2.440985246138139
tp9398
sS'import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9399
(F14.317293802897135
F2.61536303433505
tp9400
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9401
(F13.188270120059743
F2.4525701349431817
tp9402
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9403
(F12.621726606145252
F2.452250914140181
tp9404
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9405
(F11.661009253525153
F2.5313573317094282
tp9406
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9407
(F12.792100963025991
F2.5106253190474077
tp9408
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9409
(F11.7913818359375
F2.497747768055309
tp9410
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9411
(F12.48976553857854
F2.4999909834428267
tp9412
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9413
(F11.6548220316569
F2.4382844404740767
tp9414
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9415
(F11.935075808794071
F2.454644636674361
tp9416
sS"return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9417
(F12.678655235512743
F2.5686697526411577
tp9418
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9419
(F12.771001851783609
F2.4875044389204546
tp9420
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9421
(F12.292368334393169
F2.471660440618342
tp9422
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9423
(F12.728604403409092
F2.510927373712713
tp9424
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass"
p9425
(F12.301642042590727
F2.454581520774148
tp9426
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9427
(F11.6075439453125
F2.4548499367453833
tp9428
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9429
(F12.469170547113187
F2.6762955405495386
tp9430
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9431
(F11.890677315848214
F2.439035589044744
tp9432
sS'start_time = time.time()'
p9433
(F12.13197187943892
F2.7244123979048296
tp9434
sS'return lines\n\ndef opcount(fname):\n    pass'
p9435
(F10.751699447631836
F2.5299559506503018
tp9436
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9437
(F12.793143136160714
F2.4895896911621094
tp9438
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9439
(F12.567326181942654
F2.453921578147195
tp9440
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9441
(F12.118587370841734
F2.472664399580522
tp9442
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9443
(F12.545182291666666
F2.4534261876886543
tp9444
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9445
(F11.891829490661621
F2.433134078979492
tp9446
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9447
(F12.559611246257486
F2.489286422729492
tp9448
sS'while buf:\n    pass'
p9449
(F8.142559475368923
F2.5596386302601206
tp9450
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9451
(F11.910091870451627
F2.45330134305087
tp9452
sS'from __future__ import with_statement\nimport time\nimport mmap'
p9453
(F19.5751953125
F2.5828292153098364
tp9454
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9455
(F12.043745471585181
F2.4277704412286933
tp9456
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9457
(F12.5029931640625
F2.454134854403409
tp9458
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9459
(F12.6968748107437
F2.5383838306773794
tp9460
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9461
(F12.679532943233367
F2.497755917635831
tp9462
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9463
(F12.659227110499101
F2.49012582952326
tp9464
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9465
(F12.750219435918899
F2.510515039617365
tp9466
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9467
(F12.633481034608645
F2.505216425115412
tp9468
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9469
(F12.629688345508658
F2.4772607629949395
tp9470
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass'
p9471
(F11.725969381893382
F2.4535789489746094
tp9472
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9473
(F12.589132803457755
F2.5023493333296343
tp9474
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass'
p9475
(F11.570868355887276
F2.654551766135476
tp9476
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9477
(F12.273897611177885
F2.443450927734375
tp9478
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9479
(F12.22316414969308
F2.452211553400213
tp9480
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9481
(F12.734284229767628
F2.5054411454634233
tp9482
sS'import time'
p9483
(F16.61302947998047
F2.633099989457564
tp9484
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9485
(F12.465071273723822
F2.4531014182350854
tp9486
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9487
(F12.76247959036045
F2.54802790555087
tp9488
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9489
(F11.164091411389803
F2.5228120630437676
tp9490
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9491
(F12.565738133021764
F2.469462654807351
tp9492
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9493
(F12.659729344884777
F2.4544024033979936
tp9494
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9495
(F11.906052310909844
F2.442903171886097
tp9496
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9497
(F12.366434733072916
F2.4461692463267934
tp9498
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9499
(F12.72862562242445
F2.4532609419389204
tp9500
sS"assert (func('big_file.txt') == 1209138)"
p9501
(F8.237448952414773
F2.7295650135387075
tp9502
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0"
p9503
(F11.738980974469866
F2.446859533136541
tp9504
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9505
(F12.416149139404297
F2.447755986993963
tp9506
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9507
(F12.46383285522461
F2.476913798939098
tp9508
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9509
(F12.811072398040254
F2.4943559820001777
tp9510
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9511
(F12.845736799568966
F2.5620956420898438
tp9512
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9513
(F11.819508678508255
F2.4357745430686255
tp9514
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9515
(F12.581308248342042
F2.4932403564453125
tp9516
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9517
(F13.190414348821989
F2.4545074809681284
tp9518
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass"
p9519
(F11.386598398987676
F2.494468862360174
tp9520
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9521
(F12.899559449613765
F2.543939243663441
tp9522
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines'
p9523
(F11.499370868389423
F2.463188344782049
tp9524
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9525
(F12.868201027453786
F2.4787571646950464
tp9526
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9527
(F12.224816176470588
F2.451653914018111
tp9528
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9529
(F12.253775980935169
F2.4438532049005683
tp9530
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9531
(F12.895497448039505
F2.481322548606179
tp9532
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9533
(F12.424149946732955
F2.4442438645796343
tp9534
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9535
(F12.866378536739864
F2.451724312522195
tp9536
sS'return lines\n\ndef simplecount(filename):\n    pass'
p9537
(F11.276978492736816
F2.513080770319158
tp9538
sS'import mmap'
p9539
(F17.901580810546875
F2.585633711381392
tp9540
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9541
(F11.789792229147519
F2.4648798162286933
tp9542
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9543
(F12.19069840604027
F2.444201035933061
tp9544
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9545
(F12.24511832303779
F2.4581548517400567
tp9546
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass"
p9547
(F12.551414022640307
F2.45303015275435
tp9548
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9549
(F12.401517980238971
F2.467878515070135
tp9550
sS'for (i, l) in enumerate(f):\n    pass'
p9551
(F12.249679565429688
F2.651567285711115
tp9552
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9553
(F12.821412552234738
F2.511602921919389
tp9554
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9555
(F12.805668542144495
F2.529743888161399
tp9556
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9557
(F12.5378076171875
F2.6767460216175425
tp9558
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9559
(F12.516006576431382
F2.476274837147106
tp9560
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9561
(F12.922127388619089
F2.5219539295543325
tp9562
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9563
(F13.144304358440897
F2.478817332874645
tp9564
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9565
(F13.470382431806144
F2.4836852333762427
tp9566
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9567
(F12.652744710880475
F2.4995417161421343
tp9568
sS'from collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9569
(F13.111529032389322
F2.6202885020862925
tp9570
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9571
(F12.386711930429469
F2.4834860021417793
tp9572
sS"counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9573
(F12.612525201612904
F2.678625626997514
tp9574
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1"
p9575
(F12.167094778507314
F2.4549401023171167
tp9576
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9577
(F12.881455320749224
F2.4953668767755683
tp9578
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9579
(F12.790765625
F2.4789983575994317
tp9580
sS"buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9581
(F12.013686912647191
F2.4585626775568183
tp9582
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9583
(F12.626581415399775
F2.4924054579301314
tp9584
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9585
(F12.022049422116623
F2.444856817072088
tp9586
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)"
p9587
(F12.893529477326766
F2.5004614049738105
tp9588
sS'import mmap\nimport random'
p9589
(F17.680245535714285
F2.6013837294145064
tp9590
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9591
(F12.571942497702207
F2.476326682350852
tp9592
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9593
(F12.814623392815959
F2.4904474778608843
tp9594
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9595
(F12.942897511951958
F2.5590362548828125
tp9596
sS"lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9597
(F12.00094678925305
F2.4440481012517754
tp9598
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9599
(F13.001817975725446
F2.523874109441584
tp9600
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9601
(F11.606382016782407
F2.433808586814187
tp9602
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9603
(F11.492225383890085
F2.4304991635409268
tp9604
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9605
(F12.665288658781424
F2.509591882879084
tp9606
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9607
(F12.4041650390625
F2.483628359707919
tp9608
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9609
(F12.623543548583985
F2.510953903198242
tp9610
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9611
(F12.743700214460784
F2.5081253051757812
tp9612
sS'import time\nimport mmap'
p9613
(F18.133019583565847
F2.60386137528853
tp9614
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines'
p9615
(F12.267915513780382
F2.4344560449773613
tp9616
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9617
(F13.385949832876934
F2.469978852705522
tp9618
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9619
(F12.327127659574469
F2.468935012817383
tp9620
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9621
(F13.276932626400354
F2.487238797274503
tp9622
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9623
(F12.372574869791666
F2.434784629128196
tp9624
sS"buf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9625
(F12.76080322265625
F2.5296485207297583
tp9626
sS'buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)'
p9627
(F12.576318359375
F2.4904984560879795
tp9628
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9629
(F12.48441373384916
F2.5030912919477983
tp9630
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9631
(F12.433031658793604
F2.437864303588867
tp9632
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9633
(F12.395424171730324
F2.6580644087357954
tp9634
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9635
(F12.386876424153646
F2.489412481134588
tp9636
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9637
(F12.46742913661859
F2.470586429942738
tp9638
sS'def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9639
(F12.23046875
F2.4861744967373935
tp9640
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9641
(F12.623460149190512
F2.45263012972745
tp9642
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9643
(F12.789005570347534
F2.4679040041836826
tp9644
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9645
(F12.376012223490168
F2.4646710482510654
tp9646
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9647
(F12.499411366468559
F2.487679221413352
tp9648
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9649
(F12.42379210425205
F2.663118535822088
tp9650
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9651
(F12.624757287097953
F2.4534860090775923
tp9652
sS'with open(fname) as f:\n    for (i, l) in enumerate(f):\n        pass'
p9653
(F12.77753316945043
F2.514229340986772
tp9654
sS'def opcount(fname):\n    with open(fname) as f:\n        pass'
p9655
(F11.027999214504076
F2.506393779407848
tp9656
sS'return lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass'
p9657
(F12.4471435546875
F2.4954369284889917
tp9658
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9659
(F12.163781207540762
F2.543132608587092
tp9660
sS'buf_size = (1024 * 1024)'
p9661
(F8.554618835449219
F2.732535622336648
tp9662
sS'counts = defaultdict(list)'
p9663
(F10.962333679199219
F2.675356778231534
tp9664
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9665
(F12.596118958015753
F2.5007260062477807
tp9666
sS'from __future__ import with_statement\nimport time'
p9667
(F19.504727877103367
F2.588399713689631
tp9668
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9669
(F12.774583027859238
F2.500639481977983
tp9670
sS'while readline():\n    lines += 1'
p9671
(F9.33293210543119
F2.53469536521218
tp9672
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9673
(F12.178116861979166
F2.4442596435546875
tp9674
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0"
p9675
(F12.61933621493253
F2.4664438421075996
tp9676
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read"
p9677
(F13.256484787185471
F2.454904729669744
tp9678
sS'counts = defaultdict(list)\nfor i in range(5):\n    pass'
p9679
(F11.640489124116444
F2.6622340462424536
tp9680
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9681
(F12.607744140625
F2.5003589283336294
tp9682
sS'buf = read_f(buf_size)'
p9683
(F12.707417805989584
F2.5645640980113638
tp9684
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9685
(F12.54306782155797
F2.434607072310014
tp9686
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9687
(F12.710429395365919
F2.476695320822976
tp9688
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9689
(F12.596576339628067
F2.494885878129439
tp9690
sS"counts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9691
(F12.571641265368852
F2.6647959622469815
tp9692
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9693
(F11.51884028596698
F2.515077764337713
tp9694
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9695
(F11.26492648654514
F2.52520751953125
tp9696
sS'def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9697
(F12.06514892578125
F2.4467674602161753
tp9698
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9699
(F12.532341535701308
F2.4623416553844106
tp9700
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9701
(F12.191786745761304
F2.4431549419056284
tp9702
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    print key.__name__, ':', (sum(vals) / float(len(vals)))"
p9703
(F12.74047191722973
F2.5314820029518823
tp9704
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    pass'
p9705
(F11.349482486122533
F2.47800688310103
tp9706
sS'def bufcount(filename):\n    pass'
p9707
(F10.093806584676107
F2.610322605479847
tp9708
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)"
p9709
(F12.84174053485577
F2.4532061490145596
tp9710
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9711
(F12.64280856385523
F2.438723824240945
tp9712
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')"
p9713
(F13.749332203584558
F2.5383576479825107
tp9714
sS'lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9715
(F12.341817519244026
F2.5350161465731533
tp9716
sS"while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9717
(F12.630698464133523
F2.509717594493519
tp9718
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9719
(F11.73771903884243
F2.435201818292791
tp9720
sS'for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)'
p9721
(F11.744267781575521
F2.4334761879660864
tp9722
sS'f = open(filename)'
p9723
(F10.467263221740723
F2.4698090986772017
tp9724
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines"
p9725
(F12.290395205782861
F2.4545683427290483
tp9726
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9727
(F12.294585712139423
F2.446923689408736
tp9728
sS"buf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9729
(F12.958622179533306
F2.5682220458984375
tp9730
sS'readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    pass'
p9731
(F12.086325509207589
F2.4486604170365767
tp9732
sS'buf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)'
p9733
(F11.636473435621996
F2.457552823153409
tp9734
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9735
(F12.546431477864584
F2.494850678877397
tp9736
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)"
p9737
(F12.65942985628858
F2.5150879946621982
tp9738
sS"for i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9739
(F12.54708507449128
F2.6694882132790307
tp9740
sS'for line in open(filename):\n    pass'
p9741
(F12.214084080287389
F2.4230129935524682
tp9742
sS'return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9743
(F12.111944580078125
F2.434234792535955
tp9744
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9745
(F12.735723961333525
F2.505785681984641
tp9746
sS'def bufcount(filename):\n    f = open(filename)'
p9747
(F10.56016450769761
F2.4840002926913174
tp9748
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9749
(F13.01149167296707
F2.5380032279274682
tp9750
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        pass"
p9751
(F13.061785579277073
F2.4539527893066406
tp9752
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9753
(F12.764844788896276
F2.5161861072887075
tp9754
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9755
(F12.677780151367188
F2.5180832255970347
tp9756
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9757
(F13.11858301076284
F2.4966224323619497
tp9758
sS'def opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)'
p9759
(F12.337376521183895
F2.555983456698331
tp9760
sS'counts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9761
(F12.321508459142736
F2.689334175803445
tp9762
sS'readline = buf.readline\nwhile readline():\n    lines += 1'
p9763
(F11.133976986533717
F2.5182037353515625
tp9764
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    pass'
p9765
(F11.429544138353924
F2.432288950139826
tp9766
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)"
p9767
(F12.42425537109375
F2.4424686431884766
tp9768
sS'import time\nimport mmap\nimport random'
p9769
(F17.755433654785158
F2.610285152088512
tp9770
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9771
(F12.708786423141891
F2.4917123967950996
tp9772
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9773
(F12.094490470467033
F2.4522139809348364
tp9774
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9775
(F12.78965284003586
F2.465208400379528
tp9776
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)"
p9777
(F12.11929530951813
F2.4547306407581675
tp9778
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9779
(F12.816058066323839
F2.4749461087313565
tp9780
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0"
p9781
(F14.387115478515625
F2.491455078125
tp9782
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9783
(F11.611863812196601
F2.451637788252397
tp9784
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9785
(F12.530888352438668
F2.4928450150923296
tp9786
sS'import random'
p9787
(F16.438518524169922
F2.651936270973899
tp9788
sS"def simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9789
(F12.44999049653943
F2.475138924338601
tp9790
sS"def mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines"
p9791
(F11.47559110997087
F2.4993128343061968
tp9792
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0'
p9793
(F10.591404215494792
F2.4672638286243784
tp9794
sS"from collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline"
p9795
(F12.695885009765625
F2.4778629649769175
tp9796
sS"buf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9797
(F12.569429837740385
F2.4795414317737925
tp9798
sS'lines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0'
p9799
(F11.826355753065664
F2.433855750344016
tp9800
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines"
p9801
(F12.531367824388587
F2.44115552035245
tp9802
sS'import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    pass'
p9803
(F14.76989633065683
F2.611080516468395
tp9804
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)"
p9805
(F12.400984241116431
F2.471040378917347
tp9806
sS"read_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass"
p9807
(F12.99834994612069
F2.4794377413663
tp9808
sS"lines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()"
p9809
(F12.813736765008224
F2.517578125
tp9810
sS'return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1'
p9811
(F11.903547807173295
F2.431497747247869
tp9812
sS"def bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9813
(F12.189874334649724
F2.462026422674006
tp9814
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1"
p9815
(F13.779002380371093
F2.483070200139826
tp9816
sS"from __future__ import with_statement\nimport time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    pass"
p9817
(F13.86242206280048
F2.4906314503062856
tp9818
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9819
(F12.761097741505456
F2.515575408935547
tp9820
sS"return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))\nfor (key, vals) in counts.items():\n    pass"
p9821
(F12.55431396484375
F2.678354089910334
tp9822
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')"
p9823
(F12.095899498980978
F2.459789102727717
tp9824
sS"readline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        start_time = time.time()\nassert (func('big_file.txt') == 1209138)\ncounts[func].append((time.time() - start_time))"
p9825
(F12.613880944630456
F2.491225155917081
tp9826
sS"for line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9827
(F12.61284912109375
F2.4889210787686435
tp9828
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)'
p9829
(F12.121506048708547
F2.435861760919744
tp9830
sS"import mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    pass"
p9831
(F12.395263671875
F2.453521034934304
tp9832
sS"return lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    pass"
p9833
(F12.322109913262794
F2.4440156763250176
tp9834
sS'while readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read'
p9835
(F12.033914500269397
F2.4363798661665483
tp9836
sS'buf = read_f(buf_size)\nwhile buf:\n    pass'
p9837
(F11.543861389160156
F2.5379565845836294
tp9838
sS"import time\nimport mmap\nimport random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9839
(F12.841981357201599
F2.489030664617365
tp9840
sS"return lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)"
p9841
(F12.621650752314816
F2.4876826893199575
tp9842
sS'return (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass'
p9843
(F12.225064364346592
F2.682273344560103
tp9844
sS"while buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    for func in [mapcount, simplecount, bufcount, opcount]:\n        pass"
p9845
(F12.737720386402026
F2.53908989646218
tp9846
sS"import random\nfrom collections import defaultdict\n\ndef mapcount(filename):\n    f = open(filename, 'r+')\nbuf = mmap.mmap(f.fileno(), 0)\nlines = 0\nreadline = buf.readline\nwhile readline():\n    lines += 1\nreturn lines\n\ndef simplecount(filename):\n    lines = 0\nfor line in open(filename):\n    lines += 1\nreturn lines\n\ndef bufcount(filename):\n    f = open(filename)\nlines = 0\nbuf_size = (1024 * 1024)\nread_f = f.read\nbuf = read_f(buf_size)\nwhile buf:\n    lines += buf.count('\\n')\nbuf = read_f(buf_size)\nreturn lines\n\ndef opcount(fname):\n    with open(fname) as f:\n        for (i, l) in enumerate(f):\n            pass\nreturn (i + 1)\ncounts = defaultdict(list)\nfor i in range(5):\n    pass"
p9847
(F12.615897757108094
F2.481496290727095
tp9848
ssI6416131
(dp9849
S'copy = self.copy()'
p9850
(F11.088929918077257
F3.07924747467041
tp9851
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()'
p9852
(F12.06583309173584
F3.0050339698791504
tp9853
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9854
(F9.45758176317402
F3.123206615447998
tp9855
sS'class Dict(dict):\n\n    def __add__(self, other):\n        pass'
p9856
(F12.04952416053185
F3.039348602294922
tp9857
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9858
(F12.454148589587602
F3.1107006072998047
tp9859
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9860
(F12.439143968665082
F3.031733512878418
tp9861
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9862
(F13.527039421929253
F3.1984639167785645
tp9863
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9864
(F12.153958565848214
F3.046736717224121
tp9865
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9866
(F13.74329464934593
F3.088557720184326
tp9867
sS'copy.update(self)'
p9868
(F12.147656440734863
F3.120197296142578
tp9869
sS"(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9870
(F9.000410970052084
F3.1298487186431885
tp9871
sS'def __add__(self, other):\n    copy = self.copy()'
p9872
(F12.396100130948154
F3.3831706047058105
tp9873
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9874
(F11.767596344449627
F3.2047271728515625
tp9875
sS"default_data = Dict({'item1': 1, 'item2': 2, })"
p9876
(F8.331021760639391
F3.3136518001556396
tp9877
sS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9878
(F13.436654090881348
F3.2541651725769043
tp9879
sS'copy = other.copy()'
p9880
(F11.213889227973091
F3.049306631088257
tp9881
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9882
(F12.133791323061343
F3.196415424346924
tp9883
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9884
(F10.75830078125
F3.175395965576172
tp9885
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9886
(F9.655941356312145
F3.2326879501342773
tp9887
sS'return copy\n\ndef __radd__(self, other):\n    pass'
p9888
(F12.926756286621094
F3.3497815132141113
tp9889
sS"({'test1': 1, } + Dict(test2=2))"
p9890
(F7.462417153751149
F3.0458829402923584
tp9891
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9892
(F10.973231874663254
F3.1862268447875977
tp9893
sS"return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9894
(F11.135643648814005
F3.191004991531372
tp9895
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9896
(F13.256013812440814
F3.2058842182159424
tp9897
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p9898
(F12.937107480805496
F3.0479300022125244
tp9899
sS'class Dict(dict):\n    pass'
p9900
(F9.77820905049642
F2.8964271545410156
tp9901
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9902
(F11.040463990803007
F3.246302843093872
tp9903
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy'
p9904
(F12.993913922991071
F2.974191188812256
tp9905
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy'
p9906
(F13.244091961834881
F3.0234384536743164
tp9907
sS'copy.update(other)'
p9908
(F11.915681838989258
F2.97092866897583
tp9909
sS"default_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9910
(F9.119987487792969
F3.249896287918091
tp9911
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9912
(F11.438799370659723
F3.13106632232666
tp9913
sS'copy.update(self)\nreturn copy'
p9914
(F13.66227860884233
F3.1108686923980713
tp9915
sS'def __radd__(self, other):\n    copy = other.copy()'
p9916
(F12.394550670276988
F3.330524444580078
tp9917
sS'def __radd__(self, other):\n    pass'
p9918
(F12.462311744689941
F3.478196859359741
tp9919
sS"default_data['item3'] = 3"
p9920
(F10.405582427978516
F3.343649387359619
tp9921
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9922
(F13.124059542803698
F3.0226454734802246
tp9923
sS'return copy'
p9924
(F14.362205505371094
F3.234304904937744
tp9925
sS"class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9926
(F11.63808472688533
F3.047496795654297
tp9927
sS"copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9928
(F12.06903818491343
F3.132481336593628
tp9929
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9930
(F11.660445924789187
F3.2629051208496094
tp9931
sS'copy.update(other)\nreturn copy'
p9932
(F13.751708984375
F2.9730098247528076
tp9933
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)'
p9934
(F12.698286007612179
F2.9703891277313232
tp9935
sS'def __add__(self, other):\n    pass'
p9936
(F12.559438705444336
F3.4749884605407715
tp9937
sS"copy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9938
(F10.113461198477909
F3.1433234214782715
tp9939
sS"(default_data + {'item3': 3, })"
p9940
(F9.482654026576451
F3.2288668155670166
tp9941
sS'class Dict(dict):\n\n    def __add__(self, other):\n        copy = self.copy()\ncopy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9942
(F12.8838472366333
F3.026434898376465
tp9943
sS"default_data.update({'item3': 3, })"
p9944
(F10.042092895507812
F3.3246631622314453
tp9945
sS"default_data.update({'item4': 4, 'item5': 5, })"
p9946
(F9.0902099609375
F3.298844575881958
tp9947
sS'return copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9948
(F12.772687471829927
F3.239854335784912
tp9949
sS"default_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })\n({'test1': 1, } + Dict(test2=2))"
p9950
(F8.899303436279297
F3.183745861053467
tp9951
sS'def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9952
(F13.021530677532327
F3.2678184509277344
tp9953
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()'
p9954
(F13.234304717092803
F3.0937552452087402
tp9955
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)'
p9956
(F13.525703430175781
F3.0878520011901855
tp9957
sS"return copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })\n(default_data + {'item3': 3, })"
p9958
(F9.885689871651786
F3.185238838195801
tp9959
sS"def __radd__(self, other):\n    copy = other.copy()\ncopy.update(self)\nreturn copy\ndefault_data = Dict({'item1': 1, 'item2': 2, })"
p9960
(F11.991729736328125
F3.2564587593078613
tp9961
sS'copy.update(other)\nreturn copy\n\ndef __radd__(self, other):\n    pass'
p9962
(F13.50396615487558
F3.135946273803711
tp9963
ssI53513
(dp9964
S"print('List is empty')"
p9965
(F6.090480804443359
F2.007320750843395
tp9966
sS"from __future__ import print_function\nif (not a):\n    print('List is empty')"
p9967
(F13.137662251790365
F2.0029818794944068
tp9968
sS"print 'the list is empty'"
p9969
(F10.002903938293457
F2.03235522183505
tp9970
sS'from __future__ import print_function'
p9971
(F19.05328826904297
F2.0738147388805044
tp9972
sS'if (not a):\n    pass'
p9973
(F9.339587529500326
F1.9220799532803623
tp9974
sS"if (len(li) == 0):\n    print 'the list is empty'"
p9975
(F7.926249784581802
F1.9647279219193892
tp9976
sS'if (len(li) == 0):\n    pass'
p9977
(F8.489847183227539
F1.9669877832586116
tp9978
sS'from __future__ import print_function\nif (not a):\n    pass'
p9979
(F14.641434442429315
F2.0237180536443535
tp9980
sS"if (not a):\n    print('List is empty')"
p9981
(F7.99758046468099
F1.9248171719637783
tp9982
ssI849674
(dp9983
S"import thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9984
(F11.433825324563418
F3.2081502278645835
tp9985
sS'print errtxt'
p9986
(F12.148051261901855
F3.4581621805826823
tp9987
sS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    pass'
p9988
(F12.243002755301339
F3.200475056966146
tp9989
sS'import thread, time'
p9990
(F16.104220072428387
F3.276544443766276
tp9991
sS'while 1:\n    pass'
p9992
(F7.21125962999132
F3.227198028564453
tp9993
sS'pass'
p9994
(F9.889446894327799
F3.3230494181315104
tp9995
sS'import thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p9996
(F11.430860900878907
F3.2370226542154947
tp9997
sS"import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p9998
(F11.73038821750217
F3.2126698811848957
tp9999
sS'import thread'
p10000
(F15.903739929199219
F3.277979024251302
tp10001
sS'import thread\n\ndef myfunction(mystring, *args):\n    pass'
p10002
(F11.081438566509046
F3.217748006184896
tp10003
sS"Thread(target=myfunction, args=('MyStringHere', 1)).start()"
p10004
(F10.814683532714843
F3.2073582967122394
tp10005
sS'def myfunction(mystring, *args):\n    pass'
p10006
(F10.013889567057292
F3.2869949340820312
tp10007
sS'def myfunction(mystring, *args):\n    print mystring'
p10008
(F10.5226411819458
F3.318956502278646
tp10009
sS"from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p10010
(F12.147497389051649
F3.197423299153646
tp10011
sS't.start()\nt.join()'
p10012
(F10.684185321514423
F3.5082850138346355
tp10013
sS't.start()'
p10014
(F9.920427594866071
F3.3138689676920574
tp10015
sS'time.sleep(5)'
p10016
(F9.408279418945312
F3.160430399576823
tp10017
sS'print mystring'
p10018
(F12.148051261901855
F3.4581621805826823
tp10019
sS't.join()'
p10020
(F10.184094020298549
F3.714544423421224
tp10021
sS'from threading import Thread\n\ndef myfunction(mystring, *args):\n    print mystring'
p10022
(F12.555770874023438
F3.215912119547526
tp10023
sS'from threading import Thread'
p10024
(F18.733740488688152
F3.3168851216634114
tp10025
sS"def myfunction(mystring, *args):\n    print mystring\nif (__name__ == '__main__'):\n    pass"
p10026
(F11.00699971516927
F3.24647699991862
tp10027
sS'import thread, time\n\ndef myfunction(mystring, *args):\n    print mystring'
p10028
(F11.892223011363637
F3.238902282714844
tp10029
sS"if (__name__ == '__main__'):\n    pass"
p10030
(F10.304526774088542
F3.4452860514322916
tp10031
sS'import thread, time\n\ndef myfunction(mystring, *args):\n    pass'
p10032
(F11.638861519949776
F3.2193628946940103
tp10033
sS"thread.start_new_thread(myfunction, ('MyStringHere', 1))"
p10034
(F12.513072543674046
F3.329523722330729
tp10035
sS"t = Thread(None, myfunction, None, ('MyStringHere', 1))"
p10036
(F9.955001831054688
F3.3721031188964843
tp10037
ssI8270092
(dp10038
S"pattern = re.compile('\\\\s+')"
p10039
(F9.300408935546875
F2.0373929341634116
tp10040
sS'sentence = sentence.strip()'
p10041
(F10.584025065104166
F2.451970206366645
tp10042
sS"import re\npattern = re.compile('\\\\s+')"
p10043
(F11.376192533052885
F2.0255391862657337
tp10044
sS"pattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p10045
(F10.671539306640625
F2.0708675384521484
tp10046
sS"import re\npattern = re.compile('\\\\s+')\nsentence = re.sub(pattern, '', sentence)"
p10047
(F11.281813401442308
F2.0715599060058594
tp10048
sS"'helloapple'"
p10049
(F3.3916403452555337
F2.559118906656901
tp10050
sS"sentence = re.sub('\\\\s+', '', sentence, flags=re.UNICODE)"
p10051
(F11.385559844970704
F2.1052237616644964
tp10052
sS"sentence = sentence.replace(' ', '')"
p10053
(F9.08032480875651
F2.3117362128363714
tp10054
sS'import re'
p10055
(F15.36067008972168
F2.0725184546576605
tp10056
sS"sentence = re.sub(pattern, '', sentence)"
p10057
(F10.943493434361049
F2.0756437513563366
tp10058
sS"'hello  apple'"
p10059
(F3.3916403452555337
F2.559118906656901
tp10060
sS"'hello apple'"
p10061
(F3.3916403452555337
F2.559118906656901
tp10062
sS"sentence = ''.join(sentence.split())"
p10063
(F9.71500723702567
F2.0738417307535806
tp10064
ssI227459
(dp10065
S'chr(97)'
p10066
(F6.448462804158528
F3.2712347242567272
tp10067
sS'ord()'
p10068
(F6.356193542480469
F3.30794440375434
tp10069
sS"chr(97)\nchr((ord('a') + 3))"
p10070
(F7.071335686577691
F3.128573523627387
tp10071
sS'unichr(1234)'
p10072
(F6.448462804158528
F3.2712347242567272
tp10073
sS"ord('a')\nchr(97)\nchr((ord('a') + 3))"
p10074
(F6.929893161939538
F3.094549391004774
tp10075
sS'unichr(97)'
p10076
(F6.448462804158528
F3.271235148111979
tp10077
sS"chr((ord('a') + 3))"
p10078
(F7.6089641864483175
F3.0597652859157987
tp10079
sS"ord('a')"
p10080
(F5.944657643636067
F3.2026104397243924
tp10081
sS'unichr(97)\nunichr(1234)'
p10082
(F6.0565643310546875
F3.270687950981988
tp10083
sS"ord(u'\\u3042')"
p10084
(F5.944657643636067
F3.2026104397243924
tp10085
sS"ord('a')\nchr(97)"
p10086
(F5.942400845614347
F3.1859122382269964
tp10087
ssI931092
(dp10088
S'def reverse_a_string_slowly(a_string):\n    pass'
p10089
(F16.539186096191408
F2.233466012137277
tp10090
sS'def reversed_string(a_string):\n    return a_string[::(-1)]'
p10091
(F11.430921766493055
F2.0940476826259067
tp10092
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)'
p10093
(F16.479739718967014
F2.105732100350516
tp10094
sS"return ''.join(reversed(string))"
p10095
(F9.5379269917806
F2.2461024693080356
tp10096
sS'string[slice_obj]'
p10097
(F13.909147262573242
F2.1149905068533763
tp10098
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p10099
(F16.873747238005052
F2.167780876159668
tp10100
sS'step = (-1)'
p10101
(F6.6500444412231445
F2.6963702610560825
tp10102
sS"new_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p10103
(F14.731539306640625
F2.119403566632952
tp10104
sS"'foo'[::(-1)]"
p10105
(F4.479397860440341
F2.1816838128226146
tp10106
sS"index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p10107
(F13.771832552823154
F2.088388442993164
tp10108
sS'new_string += a_string[index]'
p10109
(F14.983570098876953
F2.13200010572161
tp10110
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1"
p10111
(F14.481917980105377
F2.1075665610177174
tp10112
sS'return a_string[::(-1)]'
p10113
(F8.295545850481306
F2.081523895263672
tp10114
sS'index = len(a_string)'
p10115
(F13.113482666015624
F2.17534909929548
tp10116
sS"start = stop = None\nstep = (-1)\nreverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p10117
(F12.34480375402114
F2.1640447889055525
tp10118
sS'def reverse_a_string_more_slowly(a_string):\n    pass'
p10119
(F17.560578779740766
F2.3397118704659596
tp10120
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''"
p10121
(F16.086692810058594
F2.1962146759033203
tp10122
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p10123
(F13.786898295084635
F2.0982044764927457
tp10124
sS'start = stop = None\nstep = (-1)'
p10125
(F9.40520259312221
F2.462444850376674
tp10126
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))"
p10127
(F16.320946369696102
F2.149905204772949
tp10128
sS"'foo'[reverse_slice]"
p10129
(F11.511053085327148
F2.1324849809919084
tp10130
sS'return new_string'
p10131
(F14.005415598551432
F2.308789389474051
tp10132
sS'slice_obj = slice(start, stop, step)'
p10133
(F14.284919738769531
F2.1365459987095425
tp10134
sS'new_strings = []'
p10135
(F10.864967346191406
F2.172903060913086
tp10136
sS'while index:\n    index -= 1\nnew_string += a_string[index]'
p10137
(F12.765350341796875
F2.098952157156808
tp10138
sS'reverse_slice = slice(start, stop, step)'
p10139
(F13.901388985770089
F2.164438383919852
tp10140
sS"reverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p10141
(F14.265026274181547
F2.111060551234654
tp10142
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    pass"
p10143
(F14.7754218869093
F2.1146411895751953
tp10144
sS"new_string = ''"
p10145
(F12.342825753348214
F2.3746931893484935
tp10146
sS'new_strings.append(a_string[index])'
p10147
(F14.553440348307292
F2.1239727565220425
tp10148
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p10149
(F13.340651568244486
F2.0856740134102956
tp10150
sS'step = (-1)\nreverse_slice = slice(start, stop, step)'
p10151
(F11.45777093796503
F2.269934926714216
tp10152
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []'
p10153
(F16.469795509620948
F2.206280299595424
tp10154
sS'min(timeit.repeat((lambda : reversed_string(a_string))))'
p10155
(F14.705877130681818
F2.1432803017752513
tp10156
sS'index = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]'
p10157
(F13.235766995337702
F2.104956899370466
tp10158
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))"
p10159
(F15.688847859700521
F2.085711751665388
tp10160
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))'
p10161
(F16.52070260555186
F2.123523712158203
tp10162
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])'
p10163
(F15.151804606119791
F2.062765666416713
tp10164
sS"'hello world'[::(-1)]"
p10165
(F4.479397860440341
F2.1816839490618025
tp10166
sS'string[start:stop:step]'
p10167
(F11.135407257080079
F2.0828274318150113
tp10168
sS'slice_obj = slice(start, stop, step)\nstring[slice_obj]'
p10169
(F15.6260986328125
F2.0870626994541714
tp10170
sS"step = (-1)\nreverse_slice = slice(start, stop, step)\n'foo'[reverse_slice]"
p10171
(F12.240005493164062
F2.17057010105678
tp10172
sS'index -= 1'
p10173
(F10.036537170410156
F2.529564448765346
tp10174
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    pass'
p10175
(F15.218292236328125
F2.0915613174438477
tp10176
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p10177
(F16.636043972439236
F2.1444023677280972
tp10178
sS'def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1'
p10179
(F14.914832073709238
F2.0863429478236606
tp10180
sS'min(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p10181
(F16.99032880675118
F2.154379435947963
tp10182
sS'new_string += a_string[index]\nreturn new_string'
p10183
(F15.557742848115808
F2.1165289197649275
tp10184
sS"return ''.join(new_strings)"
p10185
(F12.66642899946733
F2.1816212790352956
tp10186
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]"
p10187
(F14.854042335792824
F2.0993573325020924
tp10188
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)"
p10189
(F16.007135564630683
F2.113755907331194
tp10190
sS"a_string = ('amanaplanacanalpanama' * 10)"
p10191
(F9.621009826660156
F2.1374947684151784
tp10192
sS'index = len(a_string)\nwhile index:\n    pass'
p10193
(F11.966283162434896
F2.137849807739258
tp10194
sS'start = stop = None'
p10195
(F11.375746590750557
F2.507106236049107
tp10196
sS'def reversed_string(a_string):\n    pass'
p10197
(F13.953526496887207
F2.158919198172433
tp10198
sS'min(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p10199
(F15.898015448387634
F2.139411245073591
tp10200
sS'min(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))'
p10201
(F17.265301044170673
F2.1245972769601003
tp10202
sS"def reverse_string_readable_answer(string):\n    return ''.join(reversed(string))"
p10203
(F14.374874538845486
F2.163572311401367
tp10204
sS"while index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p10205
(F13.545984758649553
F2.0869507108415877
tp10206
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))"
p10207
(F15.964279546970275
F2.1252219336373463
tp10208
sS'start = stop = None\nstep = (-1)\nreverse_slice = slice(start, stop, step)'
p10209
(F11.80679773401331
F2.2427725110735213
tp10210
sS"def reverse_a_string_more_slowly(a_string):\n    new_strings = []\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_strings.append(a_string[index])\nreturn ''.join(new_strings)"
p10211
(F15.141819545200892
F2.066697801862444
tp10212
sS'while index:\n    index -= 1'
p10213
(F8.95800850608132
F2.1872081756591797
tp10214
sS'min(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))'
p10215
(F16.198865450345554
F2.1326400211879184
tp10216
sS'while index:\n    pass'
p10217
(F8.727183871799046
F2.2836388179234097
tp10218
sS'min(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p10219
(F16.854132516043528
F2.171419416155134
tp10220
sS'string[subscript]'
p10221
(F9.74389902750651
F2.1661254337855746
tp10222
sS"def reverse_a_string_slowly(a_string):\n    new_string = ''\nindex = len(a_string)\nwhile index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string"
p10223
(F15.08330781581038
F2.0953944069998607
tp10224
sS"reversed_string('foo')"
p10225
(F9.704601287841797
F2.3531107221330916
tp10226
sS'index = len(a_string)\nwhile index:\n    index -= 1'
p10227
(F11.546296691894531
F2.1257450921194896
tp10228
sS'min(timeit.repeat((lambda : reversed_string(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_slowly(a_string))))\nmin(timeit.repeat((lambda : reverse_a_string_more_slowly(a_string))))'
p10229
(F16.52300365551098
F2.16744259425572
tp10230
sS'def reverse_string_readable_answer(string):\n    pass'
p10231
(F16.790856255425346
F2.2027383531842912
tp10232
sS'while index:\n    index -= 1\nnew_string += a_string[index]\nreturn new_string'
p10233
(F13.57258888527199
F2.0893987928118025
tp10234
sS'while index:\n    index -= 1\nnew_strings.append(a_string[index])'
p10235
(F12.9111083984375
F2.090960366385324
tp10236
sS"a_string = ('amanaplanacanalpanama' * 10)\nmin(timeit.repeat((lambda : reverse_string_readable_answer(a_string))))\nmin(timeit.repeat((lambda : reversed_string(a_string))))"
p10237
(F15.617658648574562
F2.1013330732073103
tp10238
ssI415511
(dp10239
S'import datetime'
p10240
(F14.966394424438477
F1.582368638780382
tp10241
sS'from time import gmtime, strftime'
p10242
(F17.846776962280273
F1.833904054429796
tp10243
sS'datetime.datetime.now()'
p10244
(F11.666214836968315
F1.6471911536322699
tp10245
sS'str(datetime.now())'
p10246
(F9.365123748779297
F1.7211049397786458
tp10247
sS'datetime.datetime.time(datetime.datetime.now())'
p10248
(F12.978400230407715
F1.595430268181695
tp10249
sS'from datetime import datetime'
p10250
(F18.814857482910156
F1.6108955807156033
tp10251
sS'datetime.datetime.now().time()'
p10252
(F11.297621506911058
F1.6397646798027887
tp10253
sS'import datetime\ndatetime.datetime.now()'
p10254
(F12.933344523111979
F1.543145285712348
tp10255
sS"from time import gmtime, strftime\nstrftime('%Y-%m-%d %H:%M:%S', gmtime())"
p10256
(F12.40409761316636
F1.8759994506835938
tp10257
sS"strftime('%Y-%m-%d %H:%M:%S', gmtime())"
p10258
(F7.048252105712891
F1.9294505649142795
tp10259
sS'from datetime import datetime\nstr(datetime.now())'
p10260
(F13.592927042643229
F1.5680493248833551
tp10261
ssI14043934
(dp10262
S'import datetime'
p10263
(F15.620627403259277
F4.2920692443847654
tp10264
sS'dt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p10265
(F11.38785400390625
F4.158329772949219
tp10266
sS'import datetime\nt = datetime.datetime.now()\n(t - datetime.timedelta(hours=1, minutes=10))'
p10267
(F12.357540007560484
F4.030767822265625
tp10268
sS't = datetime.datetime.now()\n(t - datetime.timedelta(hours=1, minutes=10))'
p10269
(F11.882120404924665
F4.042117309570313
tp10270
sS'import datetime\nt = datetime.datetime.now()'
p10271
(F13.452410016741071
F4.0606128692626955
tp10272
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p10273
(F13.265432184392756
F4.111737060546875
tp10274
sS'dt\ndt -= datetime.timedelta(hours=5)'
p10275
(F11.667060852050781
F4.132957077026367
tp10276
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)'
p10277
(F12.326816681892641
F4.057621765136719
tp10278
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt'
p10279
(F12.626797762784092
F4.056843566894531
tp10280
sS'dt.time()'
p10281
(F9.267605372837611
F4.388857650756836
tp10282
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p10283
(F12.299130526455967
F4.066854858398438
tp10284
sS'dt -= datetime.timedelta(hours=5)'
p10285
(F11.487079620361328
F4.198396682739258
tp10286
sS'(t - datetime.timedelta(hours=1, minutes=10))'
p10287
(F11.411514282226562
F4.133982849121094
tp10288
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p10289
(F12.356050931490385
F4.118669509887695
tp10290
sS't = datetime.time(1, 2)'
p10291
(F10.268061319986979
F4.091876220703125
tp10292
sS't = datetime.datetime.now()'
p10293
(F12.225602583451705
F4.101095962524414
tp10294
sS'dt'
p10295
(F12.730684916178385
F4.535016632080078
tp10296
sS'dt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)'
p10297
(F12.608788692589963
F4.107774353027343
tp10298
sS'dt = datetime.datetime.combine(datetime.date.today(), t)'
p10299
(F12.805697631835937
F4.114003753662109
tp10300
sS't = datetime.time(1, 2)\ndt = datetime.datetime.combine(datetime.date.today(), t)\ndt\ndt -= datetime.timedelta(hours=5)\ndt.time()'
p10301
(F12.164326171875
F4.0804290771484375
tp10302
sS'dt -= datetime.timedelta(hours=5)\ndt.time()'
p10303
(F11.380963643391928
F4.190458679199219
tp10304
ssI3940128
(dp10305
S'L = [0, 10, 20, 40]\nL.reverse()\nL'
p10306
(F8.383477347237724
F1.8922516215931287
tp10307
sS'array = [0, 10, 20, 40]'
p10308
(F6.5777435302734375
F1.7249129902232776
tp10309
sS'array = [0, 10, 20, 40]\nfor i in reversed(array):\n    pass'
p10310
(F9.826778118426983
F1.6558530980890447
tp10311
sS'array = [0, 10, 20, 40]\nfor i in reversed(array):\n    print i'
p10312
(F9.995426884403935
F1.6558931524103337
tp10313
sS'L = [0, 10, 20, 40]\nL.reverse()'
p10314
(F7.8494423314144735
F1.8737803372469815
tp10315
sS'for i in reversed(array):\n    pass'
p10316
(F11.784731183733259
F1.7188160636208274
tp10317
sS'print i'
p10318
(F11.854872703552246
F1.8923279155384412
tp10319
sS'L'
p10320
(F12.362958272298178
F2.014741897583008
tp10321
sS'L = [0, 10, 20, 40]'
p10322
(F6.510378910945012
F1.656306353482333
tp10323
sS'L[::(-1)]'
p10324
(F5.603323156183416
F1.671849337491122
tp10325
sS'for i in reversed(array):\n    print i'
p10326
(F11.932208251953124
F1.7226187966086648
tp10327
sS'L.reverse()\nL'
p10328
(F10.421871609157986
F2.192098444158381
tp10329
sS'L = [0, 10, 20, 40]\nL[::(-1)]'
p10330
(F6.3444346552309785
F1.6424928144975142
tp10331
sS'L.reverse()'
p10332
(F8.970756530761719
F2.213999488136985
tp10333
ssI1949318
(dp10334
S'import httplib'
p10335
(F16.657936096191406
F3.0513126373291017
tp10336
sS'200'
p10337
(F7.59817377726237
F3.2816871643066405
tp10338
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10339
(F12.543174743652344
F3.0281093597412108
tp10340
sS"conn = httplib.HTTPConnection('www.python.org')"
p10341
(F10.943064602938565
F3.147116851806641
tp10342
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p10343
(F11.223481551460598
F3.017837142944336
tp10344
sS"conn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10345
(F9.52365451388889
F3.234653854370117
tp10346
sS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)'
p10347
(F13.6874169921875
F2.968479537963867
tp10348
sS'r1 = conn.getresponse()'
p10349
(F8.852112664116753
F3.3403587341308594
tp10350
sS'import requests\n\ndef url_ok(url):\n    r = requests.head(url)\nreturn (r.status_code == 200)'
p10351
(F13.862860785590279
F3.004123306274414
tp10352
sS"print urllib.urlopen('http://www.stackoverflow.com').getcode()"
p10353
(F10.593541071965145
F2.981126403808594
tp10354
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')"
p10355
(F12.514381408691406
F3.0693099975585936
tp10356
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')"
p10357
(F10.566771697998046
F3.0907983779907227
tp10358
sS"conn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10359
(F12.02766587999132
F3.1851322174072267
tp10360
sS"conn.request('HEAD', '/')"
p10361
(F8.866815948486328
F3.2314151763916015
tp10362
sS"import httplib\nconn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10363
(F11.216804750504032
F3.0267917633056642
tp10364
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()\nprint r1.status, r1.reason"
p10365
(F12.176125191353464
F3.0838722229003905
tp10366
sS'r = requests.head(url)'
p10367
(F12.348490905761718
F2.956614875793457
tp10368
sS'print r1.status, r1.reason'
p10369
(F16.16802062988281
F3.0985103607177735
tp10370
sS'def url_ok(url):\n    pass'
p10371
(F12.94242422921317
F3.356554412841797
tp10372
sS'r1 = conn.getresponse()\nprint r1.status, r1.reason'
p10373
(F13.132164849175346
F3.2323631286621093
tp10374
sS'def url_ok(url):\n    r = requests.head(url)\nreturn (r.status_code == 200)'
p10375
(F13.969072341918945
F3.2607383728027344
tp10376
sS'import requests\n\ndef url_ok(url):\n    pass'
p10377
(F13.356745402018229
F3.0014352798461914
tp10378
sS'import requests'
p10379
(F16.678165435791016
F2.901738739013672
tp10380
sS'def url_ok(url):\n    r = requests.head(url)'
p10381
(F13.491083054315476
F3.234109878540039
tp10382
sS'return (r.status_code == 200)'
p10383
(F12.868938446044922
F3.353759002685547
tp10384
sS"conn = httplib.HTTPConnection('www.python.org')\nconn.request('HEAD', '/')\nr1 = conn.getresponse()"
p10385
(F10.642594473702568
F3.093145751953125
tp10386
sS"print urllib.urlopen('http://www.stackoverflow.com').getcode()\n200"
p10387
(F10.734763590494792
F2.9869308471679688
tp10388
ssI2052390
(dp10389
S'raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10390
(F11.102105034722221
F3.832225105979226
tp10391
sS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    pass'
p10392
(F13.688593401227678
F3.8226124156605112
tp10393
sS'raise AppError, error, sys.exc_info()[2]\nraise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p10394
(F11.60915316068209
F3.780074032870206
tp10395
sS'raise AppError, error, sys.exc_info()[2]'
p10396
(F12.142712063259548
F3.832513289018111
tp10397
sS"('message', 'foo', 'bar', 'baz')"
p10398
(F3.5750822587446733
F3.8912228670987217
tp10399
sS'print(err.args)'
p10400
(F10.761738777160645
F3.7918624877929688
tp10401
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)\nraise'
p10402
(F14.831610107421875
F3.8201831470836294
tp10403
sS'do_something_in_app_that_breaks_easily()'
p10404
(F18.174652099609375
F3.9029326005415483
tp10405
sS'if ((important_key not in resource_dict) and (not ok_to_be_missing)):\n    pass'
p10406
(F16.618644468245968
F3.8475154529918325
tp10407
sS'class MyAppLookupError(LookupError):\n    "raise this when there\'s a lookup error for my app"'
p10408
(F11.440095901489258
F4.036872516978871
tp10409
sS'raise'
p10410
(F15.045875549316406
F3.8763913241299717
tp10411
sS"if ((important_key not in resource_dict) and (not ok_to_be_missing)):\n    raise MyAppLookupError('resource is missing, and that is not ok.')"
p10412
(F15.485603734066611
F3.8388200239701704
tp10413
sS"raise MyAppLookupError('resource is missing, and that is not ok.')"
p10414
(F10.262861633300782
F3.991691242564808
tp10415
sS'if (foo not in _ALLOWED_ARGS):\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10416
(F11.762866604712702
F3.8059952475807886
tp10417
sS'logger.error(error)'
p10418
(F11.86292552947998
F3.811569560657848
tp10419
sS'"raise this when there\'s a lookup error for my app"'
p10420
(F2.9261048634847007
F3.8399887084960938
tp10421
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."'
p10422
(F11.161082676478795
F3.882010719992898
tp10423
sS'from __future__ import print_function\ntry:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print(err.args)'
p10424
(F15.010846819196429
F3.7993323586203833
tp10425
sS'demo_bad_catch()'
p10426
(F12.924711439344618
F3.848202445290305
tp10427
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."\nif (foo not in _ALLOWED_ARGS):\n    raise ValueError(\'{foo} wrong, use "baz" or "bar"\'.format(foo=repr(foo)))'
p10428
(F12.154041637073863
F3.8318314985795454
tp10429
sS"raise Exception('I know python!')"
p10430
(F8.006335667201451
F3.858448722145774
tp10431
sS'raise error.with_traceback(sys.exc_info()[2])'
p10432
(F13.741183471679687
F3.8285851912064985
tp10433
sS'try:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    print(err.args)'
p10434
(F13.640597534179687
F3.8329703591086646
tp10435
sS'"foo should be either \'baz\' or \'bar\'. returns something very useful."'
p10436
(F2.9261048634847007
F3.8399887084960938
tp10437
sS'def api_func(foo):\n    pass'
p10438
(F12.215911865234375
F3.897186972878196
tp10439
sS"raise 'message'"
p10440
(F8.960918426513672
F3.8779227516867896
tp10441
sS'def api_func(foo):\n    "foo should be either \'baz\' or \'bar\'. returns something very useful."\nif (foo not in _ALLOWED_ARGS):\n    pass'
p10442
(F12.485244224811423
F3.877566250887784
tp10443
sS'demo_no_catch()'
p10444
(F12.459281073676216
F3.8852251226251777
tp10445
sS'class MyAppLookupError(LookupError):\n    pass'
p10446
(F12.27558708190918
F3.991628126664595
tp10447
sS'from __future__ import print_function\ntry:\n    some_code_that_may_raise_our_value_error()\nexcept ValueError as err:\n    pass'
p10448
(F15.179554332386363
F3.7957999489524146
tp10449
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    logger.error(error)'
p10450
(F14.483600817228618
F3.8208982294256035
tp10451
sS"raise ValueError('A very specific bad thing happened', 'foo', 'bar', 'baz')"
p10452
(F7.0117340087890625
F4.000631505792791
tp10453
sS"raise Exception('I know Python!')"
p10454
(F8.006335667201451
F3.858448722145774
tp10455
sS"raise ValueError('A very specific bad thing happened')"
p10456
(F8.971878051757812
F3.905771428888494
tp10457
sS'if (foo not in _ALLOWED_ARGS):\n    pass'
p10458
(F12.000467300415039
F3.775610490278764
tp10459
sS'from __future__ import print_function'
p10460
(F17.80315704345703
F3.776160153475675
tp10461
sS'some_code_that_may_raise_our_value_error()'
p10462
(F17.32035265470806
F3.9054582769220527
tp10463
sS'try:\n    do_something_in_app_that_breaks_easily()\nexcept AppError as error:\n    pass'
p10464
(F14.495430686257102
F3.8141937255859375
tp10465
sS"raise ValueError, 'message'"
p10466
(F10.612798418317523
F3.9825612848455254
tp10467
sS'raise sys.exc_info()[0], sys.exc_info()[1], sys.exc_info()[2]'
p10468
(F11.149341692243304
F3.788991754705256
tp10469
sS'if (0 < distance <= RADIUS):\n    pass'
p10470
(F9.070360310872395
F3.8503331271084873
tp10471
sS'raise AssertionError("Unexpected value of \'distance\'!", distance)'
p10472
(F9.803843688964843
F3.871388868852095
tp10473
ssI2331943
(dp10474
S"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10475
(F13.174684651692708
F2.03216552734375
tp10476
sS'try:\n    import json\nexcept ImportError:\n    pass'
p10477
(F10.120461357964409
F2.1559488773345947
tp10478
sS'u.close()'
p10479
(F9.961148943219866
F2.3453965187072754
tp10480
sS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10481
(F12.23610814412435
F2.0377309322357178
tp10482
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10483
(F13.005411783854166
F2.0013580322265625
tp10484
sS'import simplejson as json'
p10485
(F18.321929931640625
F2.114983081817627
tp10486
sS'print json.load(u)'
p10487
(F12.571831597222221
F1.9919147491455078
tp10488
sS'import json'
p10489
(F15.270858764648438
F2.0595200061798096
tp10490
sS'import urllib2\nimport json'
p10491
(F16.620043073381698
F2.161053419113159
tp10492
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)\nu.close()"
p10493
(F12.701657895688657
F2.008549690246582
tp10494
sS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p10495
(F13.802871704101562
F2.1419215202331543
tp10496
sS'import urllib2'
p10497
(F16.238174438476562
F2.2565550804138184
tp10498
sS"import urllib2\nimport json\nu = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10499
(F13.62405014038086
F2.0499796867370605
tp10500
sS'print json.load(u)\nu.close()'
p10501
(F12.242889404296875
F2.0253381729125977
tp10502
sS"u = urllib2.urlopen('http://www.reddit.com/.json')"
p10503
(F11.500758361816406
F2.262572765350342
tp10504
sS"import json\nu = urllib2.urlopen('http://www.reddit.com/.json')"
p10505
(F12.48630582369291
F2.0897512435913086
tp10506
sS"u = urllib2.urlopen('http://www.reddit.com/.json')\nprint json.load(u)"
p10507
(F12.534735785590279
F2.0275182723999023
tp10508
sS'try:\n    import json\nexcept ImportError:\n    import simplejson as json'
p10509
(F12.222741989862351
F2.066096305847168
tp10510
ssI273192
(dp10511
S'os.makedirs(path, exist_ok=True)'
p10512
(F14.782396589006696
F2.7236658732096353
tp10513
sS'if (not os.path.isdir(path)):\n    raise'
p10514
(F12.300537109375
F2.6190951029459635
tp10515
sS'if (exception.errno != errno.EEXIST):\n    raise'
p10516
(F12.833034739774817
F2.828991190592448
tp10517
sS'os.makedirs(directory)'
p10518
(F11.249593734741211
F2.6557080586751303
tp10519
sS'distutils.dir_util.mkpath(path)'
p10520
(F13.770779927571615
F2.681280517578125
tp10521
sS'import distutils.dir_util'
p10522
(F17.85308074951172
F2.6694002787272137
tp10523
sS'raise'
p10524
(F15.839892069498697
F2.9197067260742187
tp10525
sS'import distutils.dir_util\ndistutils.dir_util.mkpath(path)'
p10526
(F16.196507504111842
F2.6210914611816407
tp10527
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    if (not os.path.isdir(path)):\n        raise'
p10528
(F11.165702418277139
F2.609857940673828
tp10529
sS'if (exception.errno != errno.EEXIST):\n    pass'
p10530
(F12.574483534869026
F2.8254132588704426
tp10531
sS'import errno'
p10532
(F17.429101943969727
F2.798724873860677
tp10533
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    pass'
p10534
(F9.526634216308594
F2.706177266438802
tp10535
sS'if (not os.path.exists(directory)):\n    os.makedirs(directory)'
p10536
(F12.537653605143229
F2.579089864095052
tp10537
sS'if (not os.path.exists(directory)):\n    pass'
p10538
(F12.399939286081414
F2.615946960449219
tp10539
sS'import errno\n\ndef make_sure_path_exists(path):\n    pass'
p10540
(F16.403488159179688
F2.839172871907552
tp10541
sS'import os'
p10542
(F15.655660629272461
F2.6592503865559896
tp10543
sS'os.makedirs(path)'
p10544
(F10.935794830322266
F2.653113301595052
tp10545
sS'def make_sure_path_exists(path):\n    pass'
p10546
(F16.579908582899307
F2.893939971923828
tp10547
sS'if (not os.path.isdir(path)):\n    pass'
p10548
(F12.108958997224507
F2.6160919189453127
tp10549
sS'import os\nimport errno\n\ndef make_sure_path_exists(path):\n    pass'
p10550
(F16.308990478515625
F2.679998779296875
tp10551
sS'try:\n    os.makedirs(path)\nexcept OSError:\n    if (not os.path.isdir(path)):\n        pass'
p10552
(F11.120723523591694
F2.608399200439453
tp10553
sS'import os\nimport errno'
p10554
(F17.182521275111608
F2.6471181233723957
tp10555
ssI4020539
(dp10556
S"from __future__ import print_function\nmyString = 'spam\\\\neggs'"
p10557
(F17.05397745768229
F3.1837539672851562
tp10558
sS'import codecs'
p10559
(F14.3267822265625
F3.165265655517578
tp10560
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10561
(F13.13355183151533
F2.9427253723144533
tp10562
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint(decoded_string)"
p10563
(F12.75092872413429
F2.994815635681152
tp10564
sS"return codecs.decode(match.group(0), 'unicode-escape')"
p10565
(F10.32000732421875
F3.2500640869140627
tp10566
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p10567
(F12.357516043526786
F2.9771484375
tp10568
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10569
(F11.958274623325893
F3.1014944076538087
tp10570
sS"from __future__ import print_function\ns = 'na\\xc3\\xafve \\\\t test'\nprint(s.encode('utf-8').decode('unicode_escape'))"
p10571
(F12.888390902815194
F3.0017175674438477
tp10572
sS"print(s.encode('latin-1').decode('unicode_escape'))"
p10573
(F9.470662117004395
F2.9982269287109373
tp10574
sS"print(decode_escapes('Ern\\xc5\\x91 \\\\t Rubik'))"
p10575
(F9.776747963645242
F3.093316078186035
tp10576
sS"print(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10577
(F11.232336636247306
F3.106419563293457
tp10578
sS"myString = 'na\\xc3\\xafve \\\\t test'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10579
(F11.389016151428223
F3.1172760009765623
tp10580
sS'import re'
p10581
(F15.182929039001465
F2.8699575424194337
tp10582
sS"print(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10583
(F11.380282402038574
F3.1269901275634764
tp10584
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10585
(F12.94879150390625
F2.947142219543457
tp10586
sS"s = 'na\\xc3\\xafve \\\\t test'"
p10587
(F7.514759826660156
F3.0608943939208983
tp10588
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10589
(F12.311979594983553
F2.956986999511719
tp10590
sS"myString = 'na\\xc3\\xafve \\\\t test'"
p10591
(F11.764055887858072
F3.219054412841797
tp10592
sS"print(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10593
(F11.023709897641782
F3.1258026123046876
tp10594
sS"myString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10595
(F11.389016151428223
F3.1172760009765623
tp10596
sS"from __future__ import print_function\nmyString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p10597
(F14.080180168151855
F3.0049453735351563
tp10598
sS"print('Ern\\xc5\\x91 \\\\t Rubik'.encode('latin-1').decode('unicode_escape'))"
p10599
(F8.642322540283203
F3.0248897552490233
tp10600
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p10601
(F11.280241593070652
F2.9684062957763673
tp10602
sS"from __future__ import print_function\nprint('Ern\\xc5\\x91 \\\\t Rubik'.encode('latin-1').decode('unicode_escape'))"
p10603
(F13.02846435546875
F3.0156391143798826
tp10604
sS"from __future__ import print_function\nprint(s.encode('latin-1').decode('unicode_escape'))"
p10605
(F13.64248291015625
F3.0062299728393556
tp10606
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10607
(F12.631977428089488
F2.9732524871826174
tp10608
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10609
(F13.411012776692708
F2.912555694580078
tp10610
sS"from __future__ import print_function\nmyString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p10611
(F14.195560802112926
F2.995779037475586
tp10612
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10613
(F12.26803249782986
F2.986777496337891
tp10614
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10615
(F11.855235706676137
F3.0860713958740233
tp10616
sS"myString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint(decoded_string)"
p10617
(F12.527477446056547
F2.9775501251220704
tp10618
sS'from __future__ import print_function\nimport codecs'
p10619
(F18.320108266977165
F3.195566177368164
tp10620
sS"import codecs\nprint(codecs.decode(s, 'unicode_escape'))"
p10621
(F10.665989875793457
F3.0573474884033205
tp10622
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10623
(F12.8101806640625
F2.952374267578125
tp10624
sS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')"
p10625
(F12.414988982371796
F3.0377182006835937
tp10626
sS"decoded_string = myString.decode('string_escape')\nprint(decoded_string)"
p10627
(F13.037680053710938
F3.0364505767822267
tp10628
sS"decoded_string = myString.decode('string_escape')"
p10629
(F12.488821176382212
F3.053521728515625
tp10630
sS"from __future__ import print_function\nimport codecs\nmyString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10631
(F13.71344367825255
F3.0777719497680662
tp10632
sS'import re\nimport codecs'
p10633
(F15.89493887765067
F2.909817123413086
tp10634
sS'def decode_escapes(s):\n    pass'
p10635
(F12.083020891462054
F3.0782875061035155
tp10636
sS"print(codecs.decode(s, 'unicode_escape'))"
p10637
(F9.364609938401442
F3.0580112457275392
tp10638
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')"
p10639
(F12.603945922851562
F2.996173858642578
tp10640
sS"def decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), 'unicode-escape')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)"
p10641
(F13.368295010653409
F3.0623394012451173
tp10642
sS'print(decoded_string)'
p10643
(F11.487628936767578
F3.0305047988891602
tp10644
sS'def decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10645
(F13.370567908653847
F3.0038082122802736
tp10646
sS"from __future__ import print_function\nimport codecs\nmyString = 'spam\\\\neggs'"
p10647
(F16.867350260416668
F3.1771400451660154
tp10648
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10649
(F13.151654499333079
F2.9926891326904297
tp10650
sS'import codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10651
(F12.760886587747713
F2.943525695800781
tp10652
sS"myString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10653
(F11.610186602618244
F3.1182716369628904
tp10654
sS"from __future__ import print_function\nimport codecs\nprint(codecs.decode(s, 'unicode_escape'))"
p10655
(F14.1562109375
F3.064009094238281
tp10656
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n    pass'
p10657
(F13.080942327325994
F2.917397308349609
tp10658
sS"from __future__ import print_function\nimport codecs\nmyString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10659
(F13.707111705433238
F3.0767969131469726
tp10660
sS"s = 'na\\xc3\\xafve \\\\t test'\nprint(s.encode('utf-8').decode('unicode_escape'))"
p10661
(F9.11382827758789
F2.977003479003906
tp10662
sS"from __future__ import print_function\nimport codecs\nmyString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10663
(F12.917996419270834
F3.064189147949219
tp10664
sS"from __future__ import print_function\nprint(decode_escapes('Ern\\xc5\\x91 \\\\t Rubik'))"
p10665
(F14.67264404296875
F3.1557315826416015
tp10666
sS"decoded_string = bytes(myString, 'utf-8').decode('unicode_escape')"
p10667
(F11.419347974989149
F2.984239196777344
tp10668
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')'
p10669
(F12.849006099977355
F2.9528268814086913
tp10670
sS"import codecs\nmyString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))\nmyString = 'na\\xc3\\xafve \\\\t test'"
p10671
(F12.169636535644532
F3.102859878540039
tp10672
sS"myString = 'spam\\\\neggs'"
p10673
(F11.764055887858072
F3.219054412841797
tp10674
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))'
p10675
(F12.224675496419271
F2.952642250061035
tp10676
sS"print(s.encode('utf-8').decode('unicode_escape'))"
p10677
(F9.470662117004395
F2.9982269287109373
tp10678
sS'def decode_match(match):\n    pass'
p10679
(F12.376685006277901
F2.9760726928710937
tp10680
sS'from __future__ import print_function'
p10681
(F18.440765380859375
F3.2078903198242186
tp10682
sS"def decode_match(match):\n    return codecs.decode(match.group(0), 'unicode-escape')"
p10683
(F11.434582745587385
F3.0532241821289063
tp10684
sS'ESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10685
(F12.852617867385284
F3.0110475540161135
tp10686
sS'return ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10687
(F13.793606028837317
F3.267678070068359
tp10688
sS"from __future__ import print_function\ns = 'na\\xc3\\xafve \\\\t test'"
p10689
(F16.120309012276785
F3.1492965698242186
tp10690
sS"from __future__ import print_function\nmyString = 'spam\\\\neggs'\ndecoded_string = bytes(myString, 'utf-8').decode('unicode_escape')\ndecoded_string = myString.decode('string_escape')\nprint(decoded_string)"
p10691
(F14.143023322610293
F2.992724800109863
tp10692
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        pass'
p10693
(F13.379063197544642
F2.9221223831176757
tp10694
sS'import re\nimport codecs\nESCAPE_SEQUENCE_RE = re.compile(\'\\n    ( \\\\\\\\U........      \\n    | \\\\\\\\u....          \\n    | \\\\\\\\x..            \\n    | \\\\\\\\[0-7]{1,3}     \\n    | \\\\\\\\N\\\\{[^}]+\\\\}     \\n    | \\\\\\\\[\\\\\\\\\\\'"abfnrtv]  \\n    )\', (re.UNICODE | re.VERBOSE))\n\ndef decode_escapes(s):\n\n    def decode_match(match):\n        return codecs.decode(match.group(0), \'unicode-escape\')\nreturn ESCAPE_SEQUENCE_RE.sub(decode_match, s)'
p10695
(F13.241029986213235
F2.9731771469116213
tp10696
sS"import codecs\nmyString = 'spam\\\\neggs'"
p10697
(F13.364210340711805
F3.151826095581055
tp10698
sS"myString = 'spam\\\\neggs'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))\nmyString = 'na\\xc3\\xafve \\\\t test'\nprint(codecs.escape_decode(bytes(myString, 'utf-8'))[0].decode('utf-8'))"
p10699
(F11.398758176773313
F3.0994075775146483
tp10700
ssI21129020
(dp10701
S"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    pass"
p10702
(F11.728677113850912
F4.1114248978464225
tp10703
sS'import sys'
p10704
(F15.011777877807617
F4.284649497584293
tp10705
sS'use_unicode = True'
p10706
(F13.952720642089844
F4.280796251798931
tp10707
sS"sys.setdefaultencoding('utf8')"
p10708
(F8.69676399230957
F4.253473382247122
tp10709
sS'sys.getdefaultencoding()'
p10710
(F9.288896833147321
F4.337192334626851
tp10711
sS"(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10712
(F4.810140169583834
F4.075207358912418
tp10713
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)\npsycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p10714
(F16.810113722278224
F4.45705132735403
tp10715
sS"u'Z\\xfcrich'"
p10716
(F2.6973915100097656
F4.106537668328536
tp10717
sS'import sys\nreload(sys)'
p10718
(F11.58711412217882
F4.271638569078948
tp10719
sS'type(my_u)'
p10720
(F13.769010543823242
F4.290324964021382
tp10721
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10722
(F6.998241577148438
F4.0380104466488485
tp10723
sS"reload(sys)\nsys.setdefaultencoding('utf8')"
p10724
(F9.701458270733173
F4.281947487278988
tp10725
sS"(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10726
(F4.320463997977121
F4.048574748792146
tp10727
sS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'\ntype(my_u)"
p10728
(F14.352589198521205
F4.2402183131167765
tp10729
sS'my_unicode_string = my_file.read()'
p10730
(F15.659495035807291
F4.1147521169562085
tp10731
sS'import sys\nreload(sys)\nsys.getdefaultencoding()'
p10732
(F10.868586222330729
F4.317201714766653
tp10733
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODEARRAY)'
p10734
(F16.09256935119629
F4.4232739900287825
tp10735
sS"source = unicode(source, 'utf-8')"
p10736
(F9.469189453125
F4.152930811831825
tp10737
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')\n(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10738
(F6.361017227172852
F4.04036471718236
tp10739
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')"
p10740
(F6.969693183898926
F4.063832333213405
tp10741
sS"with io.open('my_utf8_file.txt', 'r', encoding='utf-8') as my_file:\n    my_unicode_string = my_file.read()"
p10742
(F13.53581322564019
F4.103635286030016
tp10743
sS"(u'The currency is: ' + '\\xe2\\x82\\xac')"
p10744
(F4.532532283238003
F4.1300803736636515
tp10745
sS'reload(sys)'
p10746
(F9.423727035522461
F4.297025981702302
tp10747
sS'reload(sys)\nsys.getdefaultencoding()'
p10748
(F10.26678721110026
F4.336152327688117
tp10749
sS"my_u = u'my \\xfcnic\\xf4d\\xe9 str\\u012fng'"
p10750
(F13.0792236328125
F4.179289968390214
tp10751
sS"charset = ('utf8',)"
p10752
(F6.600038528442383
F4.2172690943667765
tp10753
sS"charset = ('utf8',)\nuse_unicode = True"
p10754
(F10.958290100097656
F4.183063306306538
tp10755
sS"u'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10756
(F6.49005126953125
F4.031066091437089
tp10757
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')\n(u'The currency is: %s' % '\\xe2\\x82\\xac')"
p10758
(F7.301025390625
F4.034116243061266
tp10759
sS"unicode('\\xe2\\x82\\xac')"
p10760
(F6.849484125773112
F4.090144910310444
tp10761
sS"unicode('\\xe2\\x82\\xac')\nu'The currency is: {}'.format('\\xe2\\x82\\xac')"
p10762
(F7.933744577261118
F4.059012563605058
tp10763
sS"import sys\nreload(sys)\nsys.setdefaultencoding('utf8')"
p10764
(F10.36084270477295
F4.273142764442845
tp10765
sS'psycopg2.extensions.register_type(psycopg2.extensions.UNICODE)'
p10766
(F16.09256935119629
F4.4232739900287825
tp10767
ssI1854
(dp10768
S'platform.system()\nplatform.release()'
p10769
(F10.856688279371996
F5.728768435391513
tp10770
sS'import os\nprint os.name\nimport platform\nplatform.system()'
p10771
(F14.42545912000868
F5.586729569868608
tp10772
sS'import platform\nplatform.system()'
p10773
(F12.503766632080078
F5.630513971502131
tp10774
sS'import os\nos.name\nimport platform\nplatform.system()'
p10775
(F14.227919634650736
F5.588977120139382
tp10776
sS'os.name'
p10777
(F12.841754150390624
F5.594210537997159
tp10778
sS'os.name\nimport platform\nplatform.system()'
p10779
(F12.883010864257812
F5.611750862815163
tp10780
sS'os.name\nimport platform'
p10781
(F14.435222625732422
F5.592667319557884
tp10782
sS'os.name\nimport platform\nplatform.system()\nplatform.release()'
p10783
(F12.594711303710938
F5.642077706076882
tp10784
sS'import os\nprint os.name\nimport platform'
p10785
(F15.57767105102539
F5.559613314541903
tp10786
sS'import os\nos.name\nimport platform\nplatform.system()\nplatform.release()'
p10787
(F13.673369034476902
F5.618173425847834
tp10788
sS'platform.system()'
p10789
(F9.618597848074776
F5.653982682661577
tp10790
sS'import os\nos.name\nimport platform'
p10791
(F15.861758145419033
F5.55851260098544
tp10792
sS'import platform\nplatform.system()\nplatform.release()'
p10793
(F12.652053833007812
F5.688175201416016
tp10794
sS'import os\nos.name'
p10795
(F15.796607971191406
F5.545863064852628
tp10796
sS'platform.release()'
p10797
(F9.688061305454799
F5.746976679021662
tp10798
sS'import os'
p10799
(F15.406675338745117
F5.610065460205078
tp10800
sS'import platform'
p10801
(F16.29530143737793
F5.638927459716797
tp10802
sS'print os.name\nimport platform\nplatform.system()\nplatform.release()'
p10803
(F13.440570649646578
F5.61472563310103
tp10804
sS'print os.name\nimport platform\nplatform.system()'
p10805
(F13.80779317220052
F5.592551838267934
tp10806
sS'print os.name\nimport platform'
p10807
(F15.190460205078125
F5.57777231389826
tp10808
sS'print os.name'
p10809
(F14.319000244140625
F5.582063501531428
tp10810
sS'import os\nprint os.name\nimport platform\nplatform.system()\nplatform.release()'
p10811
(F13.927057902018229
F5.613344365900213
tp10812
sS'import os\nprint os.name'
p10813
(F15.218432956271702
F5.551510550759056
tp10814
ssI613183
(dp10815
S'd = defaultdict(int)\nfor w in text.split():\n    pass'
p10816
(F12.659953724254262
F2.416261672973633
tp10817
sS'd[w] += 1'
p10818
(F9.712141990661621
F2.4837112426757812
tp10819
sS'd = defaultdict(int)\nfor w in text.split():\n    d[w] += 1'
p10820
(F12.056577329282407
F2.3715219497680664
tp10821
sS'for w in text.split():\n    d[w] += 1'
p10822
(F11.928447723388672
F2.5623862743377686
tp10823
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10824
(F9.67129097732843
F2.0895564556121826
tp10825
sS'for w in sorted(d, key=d.get, reverse=True):\n    pass'
p10826
(F14.129037221272787
F2.057105541229248
tp10827
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10828
(F9.353188196818033
F2.071500301361084
tp10829
sS'd = defaultdict(int)'
p10830
(F11.359354972839355
F2.2970128059387207
tp10831
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10832
(F9.674778956992954
F2.086378335952759
tp10833
sS'sorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10834
(F12.263797925866168
F2.0165884494781494
tp10835
sS'import operator\nx = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }'
p10836
(F7.376914188779634
F2.392857074737549
tp10837
sS'import operator'
p10838
(F16.992977142333984
F2.8813486099243164
tp10839
sS'for w in sorted(d, key=d.get, reverse=True):\n    print w, d[w]'
p10840
(F13.692560831705729
F2.0845255851745605
tp10841
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }'
p10842
(F6.436684241661658
F2.36856746673584
tp10843
sS'for w in text.split():\n    pass'
p10844
(F12.682456461588542
F2.751502275466919
tp10845
sS'print w, d[w]'
p10846
(F11.565392388237846
F2.632199287414551
tp10847
sS'x = {1: 2, 3: 4, 4: 3, 2: 1, 0: 0, }\nsorted_x = sorted(x.items(), key=operator.itemgetter(1))'
p10848
(F9.355780283610025
F2.068469762802124
tp10849
sS'sorted_x = sorted(x.items(), key=operator.itemgetter(0))'
p10850
(F12.224052097486412
F2.021242141723633
tp10851
ssI3501382
(dp10852
S'x = Spam(0)'
p10853
(F7.840304374694824
F3.085556377064098
tp10854
sS'(type(x) == int)'
p10855
(F9.052940368652344
F2.8760431463068183
tp10856
sS'try:\n    x += 1\nexcept TypeError:\n    pass'
p10857
(F8.528570074784128
F2.8502063751220703
tp10858
sS'for index in range(y):\n    pass'
p10859
(F12.170425415039062
F2.920031114058061
tp10860
sS'pass'
p10861
(F9.449679692586264
F3.11683481389826
tp10862
sS'import numbers\nisinstance(3, numbers.Integral)'
p10863
(F12.2131594144381
F2.8984638560901987
tp10864
sS'float(5).is_integer()\nfloat(5.1).is_integer()'
p10865
(F11.468919836956522
F3.0745717828924004
tp10866
sS'(type(x) == int)\nisinstance(x, int)'
p10867
(F10.012943043428308
F2.8547182950106533
tp10868
sS'class Spam(int):\n    pass\nx = Spam(0)\n(type(x) == int)\nisinstance(x, int)'
p10869
(F10.33054722377232
F2.8263107646595347
tp10870
sS'def is_int(val):\n    pass'
p10871
(F12.303732735770089
F2.8559764515269888
tp10872
sS'return True'
p10873
(F11.67563247680664
F3.160001581365412
tp10874
sS'class Spam(int):\n    pass'
p10875
(F9.567798614501953
F2.8627166748046875
tp10876
sS'if (type(val) == int):\n    return True'
p10877
(F9.362090166877298
F2.817755265669389
tp10878
sS'x = Spam(0)\n(type(x) == int)\nisinstance(x, int)'
p10879
(F9.766361236572266
F2.906545639038086
tp10880
sS'if (type(val) == int):\n    pass'
p10881
(F9.072153091430664
F2.8119661157781426
tp10882
sS'return False'
p10883
(F11.67563247680664
F3.160001581365412
tp10884
sS'float(5).is_integer()\nfloat(5.1).is_integer()\nfloat(5.0).is_integer()'
p10885
(F11.672226849724264
F3.080261924050071
tp10886
sS'def is_int(val):\n    if (type(val) == int):\n        return True'
p10887
(F10.952342442103795
F2.8000009710138496
tp10888
sS'x += 1'
p10889
(F9.046559906005859
F3.012877724387429
tp10890
sS'float(5.1).is_integer()\nfloat(5.0).is_integer()'
p10891
(F11.185163414996603
F3.0770131891424004
tp10892
sS'class Spam(int):\n    pass\nx = Spam(0)'
p10893
(F9.912310951634458
F2.8475915735418145
tp10894
sS'import numbers'
p10895
(F16.690162658691406
F2.851759997281161
tp10896
sS'class Spam(int):\n    pass\nx = Spam(0)\n(type(x) == int)'
p10897
(F9.934409005301339
F2.8354082974520596
tp10898
sS'float(5).is_integer()'
p10899
(F11.02880605061849
F3.06863750110973
tp10900
sS'def is_int(val):\n    if (type(val) == int):\n        pass'
p10901
(F10.963185628255209
F2.8025762384588067
tp10902
sS'float(5.1).is_integer()'
p10903
(F10.456031799316406
F3.077909989790483
tp10904
sS'isinstance(3, numbers.Integral)'
p10905
(F10.29331283569336
F3.010459206321023
tp10906
sS'float(5.0).is_integer()'
p10907
(F10.456031799316406
F3.077909989790483
tp10908
sS'x = Spam(0)\n(type(x) == int)'
p10909
(F9.065580480238971
F2.95315898548473
tp10910
sS'isinstance(x, int)'
p10911
(F9.921547889709473
F2.930866241455078
tp10912
ssI89228
(dp10913
S"return_code = subprocess.call('echo Hello World', shell=True)"
p10914
(F12.070711135864258
F1.9357656240463257
tp10915
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,"
p10916
(F13.921394510472075
F1.9095426797866821
tp10917
sS'from subprocess import call'
p10918
(F18.8724848429362
F1.8580052852630615
tp10919
sS'for line in p.stdout.readlines():\n    print line,'
p10920
(F13.07111238178454
F2.044015884399414
tp10921
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p10922
(F13.289719801682692
F1.9229283332824707
tp10923
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,"
p10924
(F13.694650823419744
F1.9204740524291992
tp10925
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)"
p10926
(F13.575696505033052
F1.8794336318969727
tp10927
sS'import subprocess'
p10928
(F15.156196594238281
F1.8790555000305176
tp10929
sS'for line in p.stdout.readlines():\n    pass'
p10930
(F13.31205300723805
F1.9863084554672241
tp10931
sS"print subprocess.Popen(('echo %s ' % user_input), stdout=PIPE).stdout.read()"
p10932
(F12.15852294921875
F1.969789743423462
tp10933
sS"os.system('some_command < input_file | another_command > output_file')"
p10934
(F8.646077156066895
F1.9725080728530884
tp10935
sS"print subprocess.Popen('echo Hello World', shell=True, stdout=subprocess.PIPE).stdout.read()"
p10936
(F12.560997314453125
F1.9051172733306885
tp10937
sS"call(['ls', '-l'])"
p10938
(F6.193693542480469
F2.351977825164795
tp10939
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)"
p10940
(F13.92009866648707
F1.8692840337753296
tp10941
sS'for line in p.stdout.readlines():\n    print line,\nretval = p.wait()'
p10942
(F12.487694634331596
F2.0053458213806152
tp10943
sS"print os.popen('echo Hello World').read()"
p10944
(F10.217235858623798
F2.188737630844116
tp10945
sS'retval = p.wait()'
p10946
(F9.360587226019966
F2.1212892532348633
tp10947
sS'print line,'
p10948
(F11.130001068115234
F2.3737809658050537
tp10949
sS"p = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p10950
(F13.75971185593378
F1.9086564779281616
tp10951
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    pass"
p10952
(F13.993386501736111
F1.8988386392593384
tp10953
sS"import subprocess\np = subprocess.Popen('ls', shell=True, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)\nfor line in p.stdout.readlines():\n    print line,\nretval = p.wait()"
p10954
(F13.49339599609375
F1.9133306741714478
tp10955
sS"from subprocess import call\ncall(['ls', '-l'])"
p10956
(F11.110211181640626
F1.900795817375183
tp10957
ssI493386
(dp10958
S'import sys'
p10959
(F15.528148651123047
F2.920985539754232
tp10960
sS'sys.stdout.flush()'
p10961
(F11.490273369683159
F2.928617477416992
tp10962
sS"strings = ['one', 'two', 'three']\nfor i in xrange(3):\n    print(('Item %d: %s' % (i, strings[i])))"
p10963
(F8.6951759739926
F2.865388870239258
tp10964
sS'for i in range(10):\n    pass'
p10965
(F10.938179016113281
F2.8329858779907227
tp10966
sS'for i in range(10):\n    print i,'
p10967
(F10.909906387329102
F2.8727267583211265
tp10968
sS"sys.stdout.write('.')"
p10969
(F10.376795959472656
F2.897693316141764
tp10970
sS'print i,'
p10971
(F11.152359771728516
F2.9722363154093423
tp10972
sS"import sys\nsys.stdout.write('.')"
p10973
(F12.138738778921274
F2.8814096450805664
tp10974
sS"print('.', end='')"
p10975
(F7.339915466308594
F2.9304796854654946
tp10976
sS'for i in range(10):\n    print i,\nelse:\n    print '
p10977
(F10.19967385996943
F2.8081703186035156
tp10978
sS"print(('.' * 10))"
p10979
(F7.101634216308594
F2.783698081970215
tp10980
sS"for i in xrange(3):\n    print(('Item %d: %s' % (i, strings[i])))"
p10981
(F9.741074698311943
F2.846653620402018
tp10982
sS"strings = ['one', 'two', 'three']\nfor i in xrange(3):\n    pass"
p10983
(F8.803850173950195
F2.8425426483154297
tp10984
sS'print '
p10985
(F12.78030776977539
F2.879550298055013
tp10986
sS'for i in xrange(3):\n    pass'
p10987
(F10.829061235700335
F2.8638013203938804
tp10988
sS"print(('Item %d: %s' % (i, strings[i])))"
p10989
(F8.764287612017464
F2.7708495457967124
tp10990
sS'from __future__ import print_function'
p10991
(F18.703738403320312
F3.0718167622884116
tp10992
sS"from __future__ import print_function\nprint('.', end='')"
p10993
(F13.558775249280428
F2.9106337229410806
tp10994
sS"strings = ['one', 'two', 'three']"
p10995
(F5.03259970925071
F3.12538210550944
tp10996
sS'for i in range(10):\n    print i,\nelse:\n    pass'
p10997
(F10.012368907099185
F2.8103650410970054
tp10998
sS"print('.', end='', flush=True)"
p10999
(F8.735108511788505
F3.036287307739258
tp11000
sS"from __future__ import print_function\nprint('.', end='', flush=True)"
p11001
(F13.431120499320652
F2.9377921422322593
tp11002
ssI311627
(dp11003
S"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11004
(F11.144666466346154
F2.2340434147761417
tp11005
sS'import datetime\nmylist = []\ntoday = datetime.date.today()'
p11006
(F11.916392276161595
F2.2357814495380106
tp11007
sS"print ('This is a new day : ' + mylist[0])"
p11008
(F7.614133661443537
F2.4894400376539965
tp11009
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11010
(F11.05588079958546
F2.2227403200589695
tp11011
sS'today = datetime.date.today()\nmylist.append(today)'
p11012
(F12.395823160807291
F2.3224672170785756
tp11013
sS'print mylist[0]'
p11014
(F8.164353506905693
F2.5558145963228664
tp11015
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p11016
(F11.213825572620738
F2.1701290424053488
tp11017
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11018
(F10.863579027580492
F2.230650681715745
tp11019
sS"print 'Day of year: ', datetime.date.today().strftime('%j')"
p11020
(F10.247470631318933
F2.251725123478816
tp11021
sS'for date in mylist:\n    print str(date)'
p11022
(F12.207177734375
F2.4091465289776144
tp11023
sS"print 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11024
(F10.863579027580492
F2.230650681715745
tp11025
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11026
(F11.341712297712053
F2.403077639066256
tp11027
sS"import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p11028
(F10.31805419921875
F2.3341839130108175
tp11029
sS"print mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p11030
(F7.686406860351562
F2.677526620718149
tp11031
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p11032
(F11.261038944639008
F2.3586144080528846
tp11033
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11034
(F11.239617541827986
F2.3448314666748047
tp11035
sS'import time\nimport datetime'
p11036
(F16.245762416294642
F2.4927042447603664
tp11037
sS'import datetime\nmylist = []'
p11038
(F9.378819783528646
F2.4124827751746545
tp11039
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11040
(F11.191675256799769
F2.2546854752760668
tp11041
sS'import datetime'
p11042
(F14.665254592895508
F2.3465262192946215
tp11043
sS"import time\nprint time.strftime('%Y-%m-%d %H:%M')"
p11044
(F11.689552307128906
F2.382593008188101
tp11045
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11046
(F11.336664999684979
F2.355497066791241
tp11047
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p11048
(F10.863579027580492
F2.230650681715745
tp11049
sS"print 'This is a new day : ', mylist[0]"
p11050
(F7.543554517957899
F2.5499132596529446
tp11051
sS"'We are the 22, Nov 2008'"
p11052
(F2.638153553009033
F2.5027718177208533
tp11053
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p11054
(F11.661374299422555
F2.3517607175386868
tp11055
sS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p11056
(F10.763875624712776
F2.3834844735952525
tp11057
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11058
(F11.32998996310764
F2.307357201209435
tp11059
sS"today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p11060
(F10.230941772460938
F2.3995590209960938
tp11061
sS"print 'Day of week: ', datetime.date.today().strftime('%A')"
p11062
(F10.247470631318933
F2.251725123478816
tp11063
sS"print ('This is a new day : ' + str(mylist[0]))"
p11064
(F8.367259434291295
F2.4760621877817006
tp11065
sS"print 'We are the {:%d, %b %Y}'.format(today)"
p11066
(F9.027481926812065
F2.4039657299335184
tp11067
sS'print str(date)'
p11068
(F10.39395250592913
F2.3793921837439904
tp11069
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p11070
(F10.349180333754596
F2.2038734142596903
tp11071
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11072
(F11.191675256799769
F2.2546854752760668
tp11073
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11074
(F11.25832022607854
F2.322451664851262
tp11075
sS'mylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p11076
(F9.467288970947266
F2.749536367563101
tp11077
sS'mylist = []\ntoday = datetime.date.today()'
p11078
(F11.524324417114258
F2.294770020705003
tp11079
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11080
(F11.191675256799769
F2.2546854752760668
tp11081
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)'
p11082
(F11.98199932391827
F2.2770745204045224
tp11083
sS'today = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p11084
(F11.820733388264975
F2.338316697340745
tp11085
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11086
(F11.320542045261549
F2.252422039325421
tp11087
sS"import datetime\nprint(('Time in seconds since the epoch: %s' % time.time()))"
p11088
(F10.352358649758731
F2.314024411714994
tp11089
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p11090
(F10.760263352167039
F2.3223037719726562
tp11091
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')"
p11092
(F11.042955671037946
F2.1691053830660305
tp11093
sS"print 'Current date and time: ', datetime.datetime.now()"
p11094
(F11.181439717610678
F2.2058118673471303
tp11095
sS"mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p11096
(F10.05133056640625
F2.404408674973708
tp11097
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11098
(F11.05588079958546
F2.2227403200589695
tp11099
sS'mylist.append(today)\nprint mylist[0]'
p11100
(F10.524017333984375
F2.6223980830265927
tp11101
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11102
(F11.144666466346154
F2.2340434147761417
tp11103
sS"print(('Time in seconds since the epoch: %s' % time.time()))"
p11104
(F8.712972368512835
F2.438723930945763
tp11105
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11106
(F11.144666466346154
F2.2340434147761417
tp11107
sS"print 'We are the {:%d, %b %Y}'.format(today)\n'We are the 22, Nov 2008'"
p11108
(F8.488635670055043
F2.4096305553729715
tp11109
sS'import datetime\nmylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]'
p11110
(F11.539321899414062
F2.2903326474703274
tp11111
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11112
(F11.05588079958546
F2.2227403200589695
tp11113
sS"((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p11114
(F7.236636513157895
F2.749172797569862
tp11115
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11116
(F10.863579027580492
F2.230650681715745
tp11117
sS"print today.strftime('We are the %d, %b %Y')"
p11118
(F9.967830234103733
F2.4219065446120043
tp11119
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11120
(F11.242644319829253
F2.274708087627704
tp11121
sS'for date in mylist:\n    pass'
p11122
(F12.320782748135654
F2.5224761962890625
tp11123
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11124
(F11.144666466346154
F2.2340434147761417
tp11125
sS'print mylist[0]\n((2008 - 11) - 22)'
p11126
(F7.724993537454044
F2.731413327730619
tp11127
sS"mylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)\nprint 'This is a new day : ', mylist[0]"
p11128
(F9.014717102050781
F2.701311258169321
tp11129
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11130
(F11.180695049579327
F2.205994385939378
tp11131
sS"import datetime\nprint datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p11132
(F12.093699137369791
F2.1825423607459435
tp11133
sS"print 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11134
(F10.247470631318933
F2.251725123478816
tp11135
sS'((2008 - 11) - 22)'
p11136
(F6.545171564275568
F2.8551356975848856
tp11137
sS"print 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11138
(F11.220315520296392
F2.2967813931978664
tp11139
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11140
(F10.247470631318933
F2.251725123478816
tp11141
sS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11142
(F11.05588079958546
F2.2227403200589695
tp11143
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11144
(F11.220315520296392
F2.2967813931978664
tp11145
sS'import time'
p11146
(F15.342947006225586
F2.6324501037597656
tp11147
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')"
p11148
(F11.305706626490542
F2.207014670738807
tp11149
sS"print 'Current year: ', datetime.date.today().strftime('%Y')"
p11150
(F10.247470631318933
F2.251725123478816
tp11151
sS"print time.strftime('%Y-%m-%d %H:%M')"
p11152
(F10.16085476345486
F2.389648144061749
tp11153
sS"print 'Current date and time: ', datetime.datetime.now()\nprint 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p11154
(F11.277968343098959
F2.1876225104698768
tp11155
sS"print 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')"
p11156
(F10.863579027580492
F2.2306505349966197
tp11157
sS"print datetime.datetime.now().strftime('%Y-%m-%d %H:%M')"
p11158
(F11.245352172851563
F2.1999632028432994
tp11159
sS'mylist = []'
p11160
(F5.645266850789388
F2.636409172644982
tp11161
sS"print 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11162
(F11.05588079958546
F2.2227403200589695
tp11163
sS'today = datetime.date.today()'
p11164
(F12.454051624644887
F2.2714661818284254
tp11165
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')"
p11166
(F11.10465162627551
F2.191305013803335
tp11167
sS'mylist = []\ntoday = datetime.date.today()\nmylist.append(today)\nprint mylist[0]\n((2008 - 11) - 22)'
p11168
(F10.479744935647036
F2.3955566699688253
tp11169
sS"print 'Day of the month : ', datetime.date.today().strftime('%d')"
p11170
(F10.247470631318933
F2.251725123478816
tp11171
sS"print 'Month of year: ', datetime.date.today().strftime('%B')"
p11172
(F10.247470631318933
F2.251725123478816
tp11173
sS"print 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')"
p11174
(F10.863579027580492
F2.230650681715745
tp11175
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')"
p11176
(F10.936526211825283
F2.19129386314979
tp11177
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')\nprint 'Day of year: ', datetime.date.today().strftime('%j')\nprint 'Day of the month : ', datetime.date.today().strftime('%d')\nprint 'Day of week: ', datetime.date.today().strftime('%A')"
p11178
(F11.269827436107073
F2.3642795269305887
tp11179
sS'mylist.append(today)'
p11180
(F10.781946182250977
F2.693099095271184
tp11181
sS"print today.strftime('We are the %d, %b %Y')\n'We are the 22, Nov 2008'"
p11182
(F9.23206814852628
F2.4321010296161356
tp11183
sS"print 'Or like this: ', datetime.datetime.now().strftime('%y-%m-%d-%H-%M')\nprint 'Current year: ', datetime.date.today().strftime('%Y')\nprint 'Month of year: ', datetime.date.today().strftime('%B')\nprint 'Week number of the year: ', datetime.date.today().strftime('%W')\nprint 'Weekday of the week: ', datetime.date.today().strftime('%w')"
p11184
(F11.2193603515625
F2.229907696063702
tp11185
sS"import time\nimport datetime\nprint(('Time in seconds since the epoch: %s' % time.time()))"
p11186
(F11.372759246826172
F2.3963885674109826
tp11187
ssI1024847
(dp11188
S'print x\nx.update({3: 4, })\nprint x'
p11189
(F10.59948087993421
F2.029736137390137
tp11190
sS'data.pop(key)\ndata.clear()'
p11191
(F11.745112827845983
F1.8955066680908204
tp11192
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11193
(F10.261172703334264
F1.92547550201416
tp11194
sS'x.update({3: 4, })'
p11195
(F8.767081627478966
F2.009578514099121
tp11196
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p11197
(F8.39344165943287
F2.015213203430176
tp11198
sS'data.update(a=1)\ndata.update(data2)'
p11199
(F11.975783404181986
F2.2000171661376955
tp11200
sS'data = {}\ndata = dict()'
p11201
(F8.13479487101237
F1.9629735946655273
tp11202
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }"
p11203
(F6.662230173746745
F1.9030935287475585
tp11204
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p11205
(F11.404766145299693
F1.9685422897338867
tp11206
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p11207
(F10.224326620296557
F2.023478698730469
tp11208
sS'data.update(dict(a=1))'
p11209
(F11.118770892803486
F1.9913028717041015
tp11210
sS"d['mynewkey'] = 'mynewvalue'"
p11211
(F6.0086894035339355
F2.0255304336547852
tp11212
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11213
(F11.580014492603059
F2.050151062011719
tp11214
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]'
p11215
(F12.321630063264266
F2.1087974548339843
tp11216
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11217
(F10.562680128144056
F2.0663784027099608
tp11218
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p11219
(F9.126866658528646
F1.936874771118164
tp11220
sS'data.pop(key)'
p11221
(F11.056648254394531
F1.835474395751953
tp11222
sS'x = {1: 2, }'
p11223
(F7.469882965087891
F1.9822240829467774
tp11224
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11225
(F8.273989119619694
F1.9148460388183595
tp11226
sS'data = dict()'
p11227
(F8.639531816755023
F1.9117866516113282
tp11228
sS'data.update(dict(a=1))\ndata.update(a=1)'
p11229
(F11.901884599165482
F2.034617805480957
tp11230
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p11231
(F10.365736790707237
F2.0184452056884767
tp11232
sS'data.update(a=1)'
p11233
(F10.963825225830078
F2.1949047088623046
tp11234
sS"data['a'] = 1"
p11235
(F6.775528430938721
F2.180783271789551
tp11236
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11237
(F10.367162401431075
F1.9688945770263673
tp11238
sS"d = {'key': 'value', }\nprint d"
p11239
(F7.8313739483173075
F1.8800861358642578
tp11240
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p11241
(F8.376263874333079
F1.8771795272827148
tp11242
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p11243
(F8.364774263822115
F1.9192729949951173
tp11244
sS'del data[key]\ndata.pop(key)\ndata.clear()'
p11245
(F12.22017593383789
F1.8329296112060547
tp11246
sS'data.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p11247
(F12.23822021484375
F1.8846202850341798
tp11248
sS'data.update(data2)\ndel data[key]\ndata.pop(key)'
p11249
(F12.13140142531622
F1.8485898971557617
tp11250
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11251
(F9.928810813210227
F1.9523263931274415
tp11252
sS'print d'
p11253
(F12.379297256469727
F2.1044376373291014
tp11254
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11255
(F10.95523879107307
F2.0547510147094727
tp11256
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11257
(F10.157455444335938
F2.0891374588012694
tp11258
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p11259
(F11.408958621141387
F2.0795902252197265
tp11260
sS'print x\nx.update({3: 4, })'
p11261
(F9.97751235961914
F2.021670341491699
tp11262
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p11263
(F10.129559211011204
F1.913253402709961
tp11264
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p11265
(F9.877572493119674
F1.9954404830932617
tp11266
sS'data.update(data2)\ndel data[key]'
p11267
(F11.708360944475446
F2.0650829315185546
tp11268
sS"print d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p11269
(F10.029782976422991
F1.9168224334716797
tp11270
sS"data = {'a': 1, 'b': 2, 'c': 3, }"
p11271
(F5.882005903455946
F2.0881080627441406
tp11272
sS'del data[key]'
p11273
(F10.945041111537389
F1.933379554748535
tp11274
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p11275
(F9.848386764526367
F2.0486518859863283
tp11276
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11277
(F9.661653645833333
F2.045064926147461
tp11278
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p11279
(F9.423390156513936
F2.0347944259643556
tp11280
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }"
p11281
(F6.878532672750539
F1.943873405456543
tp11282
sS'del data[key]\ndata.pop(key)'
p11283
(F12.020818437848773
F1.8009916305541993
tp11284
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p11285
(F9.771919496597782
F1.9458162307739257
tp11286
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p11287
(F11.014060974121094
F2.0916160583496093
tp11288
sS'x.update({3: 4, })\nprint x'
p11289
(F9.973291397094727
F1.9990781784057616
tp11290
sS"d = {'key': 'value', }"
p11291
(F6.0557304382324215
F1.955040168762207
tp11292
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11293
(F11.120210029709508
F2.0964073181152343
tp11294
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11295
(F11.827544148763021
F1.9587285995483399
tp11296
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p11297
(F9.193402839429451
F2.0188589096069336
tp11298
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p11299
(F10.236813989016088
F1.9531639099121094
tp11300
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p11301
(F11.292659661708734
F2.010630989074707
tp11302
sS'data.clear()'
p11303
(F10.21112060546875
F2.2947511672973633
tp11304
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p11305
(F12.49257320827908
F1.9270099639892577
tp11306
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })"
p11307
(F8.405596415201822
F1.9277711868286134
tp11308
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p11309
(F9.993242961604421
F2.0802183151245117
tp11310
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11311
(F11.395802815755209
F2.028889274597168
tp11312
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()'
p11313
(F12.541189829508463
F1.9324195861816407
tp11314
sS'data.update(data2)'
p11315
(F10.566855430603027
F2.252177429199219
tp11316
sS'data = dict(a=1, b=2, c=3)'
p11317
(F10.173827277289497
F1.9895299911499023
tp11318
sS'x = {1: 2, }\nprint x\nx.update({3: 4, })\nprint x'
p11319
(F9.45400891985212
F1.9475549697875976
tp11320
sS"d = {'key': 'value', }\nprint d\nd['mynewkey'] = 'mynewvalue'\nprint d"
p11321
(F8.398779827615488
F1.8429346084594727
tp11322
sS"print d\nd['mynewkey'] = 'mynewvalue'"
p11323
(F8.902116255326705
F1.92510929107666
tp11324
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)"
p11325
(F10.999973707932693
F2.0875274658203127
tp11326
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)'
p11327
(F12.321135422279095
F2.074200248718262
tp11328
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p11329
(F8.325902524201766
F1.911534881591797
tp11330
sS"data.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)"
p11331
(F11.749513979311343
F1.935711669921875
tp11332
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11333
(F9.565483940972221
F1.9629886627197266
tp11334
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11335
(F11.515617712220148
F1.9890987396240234
tp11336
sS"data['a'] = 1\ndata.update({'a': 1, })"
p11337
(F7.984930419921875
F2.1083089828491213
tp11338
sS"data.update({'a': 1, })"
p11339
(F7.575194138746995
F2.11352481842041
tp11340
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11341
(F9.469083564226018
F1.9288331985473632
tp11342
sS'x = {1: 2, }\nprint x'
p11343
(F8.918533325195312
F2.0491777420043946
tp11344
sS'print x'
p11345
(F12.129889488220215
F2.4547536849975584
tp11346
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11347
(F10.034850424908576
F2.0085039138793945
tp11348
sS"d = {'key': 'value', }\nprint d\nd['mynewkey'] = 'mynewvalue'"
p11349
(F7.562411499023438
F1.8368049621582032
tp11350
sS"data = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11351
(F8.302413940429688
F1.8845760345458984
tp11352
sS'data.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p11353
(F12.468280029296874
F1.8946157455444337
tp11354
sS"data['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]"
p11355
(F11.197599057798032
F2.0753032684326174
tp11356
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)\ndata.clear()"
p11357
(F10.494150293935643
F2.0341304779052733
tp11358
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11359
(F8.256670270647321
F1.9991628646850585
tp11360
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))\ndata.update(a=1)"
p11361
(F10.685411124393857
F2.051340103149414
tp11362
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]\ndata.pop(key)'
p11363
(F12.52691650390625
F1.9060443878173827
tp11364
sS'data = {}'
p11365
(F6.702248255411784
F2.202032470703125
tp11366
sS"data.update({'a': 1, })\ndata.update(dict(a=1))"
p11367
(F10.20998779296875
F2.0370204925537108
tp11368
sS"data = dict(a=1, b=2, c=3)\ndata['a'] = 1"
p11369
(F9.520653686523438
F2.0103893280029297
tp11370
sS"data = {}\ndata = dict()\ndata = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)\ndata['a'] = 1\ndata.update({'a': 1, })\ndata.update(dict(a=1))"
p11371
(F9.045395095627029
F1.9124664306640624
tp11372
sS"d['mynewkey'] = 'mynewvalue'\nprint d"
p11373
(F8.6259502064098
F1.9871944427490233
tp11374
sS'data.update(dict(a=1))\ndata.update(a=1)\ndata.update(data2)\ndel data[key]'
p11375
(F12.418663678850447
F2.042337417602539
tp11376
sS"data = {'a': 1, 'b': 2, 'c': 3, }\ndata = dict(a=1, b=2, c=3)"
p11377
(F8.281678118024553
F1.9979843139648437
tp11378
sS'x = {1: 2, }\nprint x\nx.update({3: 4, })'
p11379
(F8.91912841796875
F1.9326370239257813
tp11380
ssI120656
(dp11381
S"from __future__ import print_function\nimport os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))"
p11382
(F14.392375745271382
F3.438746452331543
tp11383
sS"from __future__ import print_function\nimport os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p11384
(F15.04878162202381
F3.40272585550944
tp11385
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))\nif ('.git' in dirnames):\n    pass"
p11386
(F12.76289287366365
F3.397989273071289
tp11387
sS'print(os.path.join(dirname, subdirname))'
p11388
(F12.14468994140625
F3.463525136311849
tp11389
sS'print(os.path.join(dirname, filename))'
p11390
(F12.365672810872395
F3.40830930074056
tp11391
sS"dirnames.remove('.git')"
p11392
(F8.660053253173828
F3.6802829106648765
tp11393
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p11394
(F12.730923739346592
F3.3958861033121743
tp11395
sS'for filename in filenames:\n    pass'
p11396
(F12.535436456853693
F3.4327379862467446
tp11397
sS"import os\nfor filename in os.listdir('C:\\\\temp'):\n    pass"
p11398
(F12.496103387129935
F3.4504054387410483
tp11399
sS"import os\nfor filename in os.listdir('C:\\\\temp'):\n    print filename"
p11400
(F12.668679809570312
F3.4418630599975586
tp11401
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))"
p11402
(F13.054736909412203
F3.3963394165039062
tp11403
sS"if ('.git' in dirnames):\n    pass"
p11404
(F8.854884221003605
F3.635883649190267
tp11405
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))"
p11406
(F13.28976058959961
F3.397409756978353
tp11407
sS'for filename in filenames:\n    print(os.path.join(dirname, filename))'
p11408
(F13.017192011294158
F3.404209772745768
tp11409
sS'for subdirname in dirnames:\n    print(os.path.join(dirname, subdirname))'
p11410
(F12.544521165930707
F3.433511734008789
tp11411
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p11412
(F12.975957234700521
F3.421834945678711
tp11413
sS"for filename in filenames:\n    print(os.path.join(dirname, filename))\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11414
(F11.739546203613282
F3.417438507080078
tp11415
sS"from __future__ import print_function\nimport os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))\nif ('.git' in dirnames):\n    pass"
p11416
(F13.7988017689098
F3.438805262247721
tp11417
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))\nif ('.git' in dirnames):\n    pass"
p11418
(F12.972353392009493
F3.4641119639078775
tp11419
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p11420
(F13.29491455078125
F3.4177878697713218
tp11421
sS"for filename in os.listdir('C:\\\\temp'):\n    print filename"
p11422
(F12.159658992991728
F3.409434954325358
tp11423
sS"from __future__ import print_function\nimport os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))"
p11424
(F14.631036829065394
F3.4084993998209634
tp11425
sS'import os'
p11426
(F15.482961654663086
F3.412543614705404
tp11427
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11428
(F12.793366931733631
F3.4729506174723306
tp11429
sS'for subdirname in dirnames:\n    pass'
p11430
(F11.932754516601562
F3.68415896097819
tp11431
sS'print filename'
p11432
(F11.142632484436035
F3.4279982248942056
tp11433
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        pass"
p11434
(F13.442419803503787
F3.4369633992513022
tp11435
sS'os.listdir(path)'
p11436
(F12.03645133972168
F3.391576131184896
tp11437
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))"
p11438
(F13.516469471490206
F3.468881607055664
tp11439
sS"for filename in os.listdir('C:\\\\temp'):\n    pass"
p11440
(F11.897294998168945
F3.413459142049154
tp11441
sS"from __future__ import print_function\nimport os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    pass"
p11442
(F15.30769796932445
F3.391838709513346
tp11443
sS"from __future__ import print_function\nimport os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    pass"
p11444
(F14.600688934326172
F3.4272289276123047
tp11445
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    pass"
p11446
(F13.301403339092548
F3.384958267211914
tp11447
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))"
p11448
(F13.398234049479166
F3.4373178482055664
tp11449
sS'from __future__ import print_function\nimport os'
p11450
(F19.21574988731971
F3.5120264689127603
tp11451
sS"import os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    pass"
p11452
(F13.569774280894887
F3.459444999694824
tp11453
sS'from __future__ import print_function'
p11454
(F19.01140441894531
F3.6117372512817383
tp11455
sS"for (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11456
(F12.587932068624614
F3.407281239827474
tp11457
sS"from __future__ import print_function\nimport os\nfor (dirname, dirnames, filenames) in os.walk('.'):\n    for subdirname in dirnames:\n        print(os.path.join(dirname, subdirname))\nfor filename in filenames:\n    print(os.path.join(dirname, filename))\nif ('.git' in dirnames):\n    dirnames.remove('.git')"
p11458
(F13.592865318380376
F3.4468161265055337
tp11459
sS"for filename in filenames:\n    print(os.path.join(dirname, filename))\nif ('.git' in dirnames):\n    pass"
p11460
(F11.9880126953125
F3.3948402404785156
tp11461
sS"if ('.git' in dirnames):\n    dirnames.remove('.git')"
p11462
(F9.168830023871529
F3.6418940226236978
tp11463
ssI2150739
(dp11464
S'import datetime'
p11465
(F14.993412017822266
F4.17891450361772
tp11466
sS"from datetime import datetime\ndatetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p11467
(F12.91600850423177
F3.8636932373046875
tp11468
sS'def utcoffset(self, dt):\n    pass'
p11469
(F10.515487670898438
F4.764395627108487
tp11470
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p11471
(F12.788031005859375
F4.183629816228693
tp11472
sS'def utcoffset(self, dt):\n    return timedelta(minutes=(-399))'
p11473
(F9.839361439580502
F4.558341979980469
tp11474
sS"strftime('%Y-%m-%d %H:%M:%S')"
p11475
(F7.3299814860026045
F4.313319813121449
tp11476
sS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11477
(F16.092808476200812
F4.367966391823509
tp11478
sS'from datetime import tzinfo, timedelta, datetime'
p11479
(F19.210914611816406
F3.9379289800470527
tp11480
sS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        pass'
p11481
(F10.767855326334635
F4.87553613836115
tp11482
sS'datetime.fromtimestamp(x)'
p11483
(F11.478351593017578
F4.1542299444025215
tp11484
sS"from time import strftime\nstrftime('%Y-%m-%d %H:%M:%S')"
p11485
(F13.885797674005682
F4.195954062721946
tp11486
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))'
p11487
(F11.97892899946733
F4.132707422429865
tp11488
sS'from mx.DateTime.ISO import ParseDateTimeUTC'
p11489
(F16.652916541466347
F4.886201338334517
tp11490
sS'import datetime\ndatetime.datetime.now().isoformat()'
p11491
(F12.225008010864258
F3.961199326948686
tp11492
sS"x = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11493
(F10.253768920898438
F4.789903120561079
tp11494
sS'import datetime\ndatetime.datetime.utcnow().isoformat()'
p11495
(F12.290267944335938
F3.9664667302911933
tp11496
sS'datetime.datetime.now().isoformat()'
p11497
(F11.358302189753605
F4.00457763671875
tp11498
sS'from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n    pass'
p11499
(F12.939442510190217
F4.055033943869851
tp11500
sS"from datetime import tzinfo, timedelta, datetime\n\n\nclass TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11501
(F11.306602478027344
F4.122990001331676
tp11502
sS"class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))\ndatetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11503
(F10.132424408534789
F4.683923201127485
tp11504
sS'datetime.datetime.utcnow().isoformat()'
p11505
(F11.237311730018028
F4.009424729780718
tp11506
sS'from datetime import datetime'
p11507
(F18.811899820963543
F3.914314616810192
tp11508
sS"datetime(2002, 12, 25, tzinfo=TZ()).isoformat(' ')"
p11509
(F8.895811535063244
F4.33850062977184
tp11510
sS"datetime.strptime('2010-06-04 21:08:12', '%Y-%m-%d %H:%M:%S')"
p11511
(F9.049615478515625
F3.9900630604137075
tp11512
sS'class TZ(tzinfo):\n    pass'
p11513
(F9.059350967407227
F4.847287958318537
tp11514
sS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11515
(F13.90226884321733
F3.962249755859375
tp11516
sS"from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11517
(F15.510228774126839
F4.2562009638006035
tp11518
sS'from mx.DateTime.ISO import ParseDateTimeUTC\nfrom datetime import datetime'
p11519
(F17.925638834635418
F4.3980230851606885
tp11520
sS"x = ParseDateTimeUTC('2010-06-04 21:08:12')\ndatetime.fromtimestamp(x)"
p11521
(F11.420203713809743
F4.453018882057884
tp11522
sS'return timedelta(minutes=(-399))'
p11523
(F8.945353190104166
F4.278873443603516
tp11524
sS"from datetime import datetime\nx = ParseDateTimeUTC('2010-06-04 21:08:12')"
p11525
(F14.312531534830729
F3.9934206875887783
tp11526
sS'class TZ(tzinfo):\n\n    def utcoffset(self, dt):\n        return timedelta(minutes=(-399))'
p11527
(F10.196068966027463
F4.778017911044034
tp11528
sS'from time import strftime'
p11529
(F18.91455332438151
F4.2565789656205615
tp11530
ssI4641765
(dp11531
S'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p11532
(F13.218250363372093
F2.7132608890533447
tp11533
sS'things_to_add = [0, 1, 1, 0]'
p11534
(F10.174851361443014
F3.2456023693084717
tp11535
sS'fooList.append(3)\nfooList.append(2734)\nprint(fooList)'
p11536
(F11.260109279466713
F3.3520638942718506
tp11537
sS'fooList = [1, 3, 348, 2]'
p11538
(F7.564806801932199
F2.8619384765625
tp11539
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    L[idx] += amount\nL'
p11540
(F13.254062818444293
F2.6967039108276367
tp11541
sS'for (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p11542
(F14.670379638671875
F2.730278253555298
tp11543
sS'print(x)'
p11544
(F8.400585810343424
F3.3063697814941406
tp11545
sS'x = [2, 5, 10]'
p11546
(F6.443349664861506
F2.735177516937256
tp11547
sS'print(fooList)'
p11548
(F9.665459769112724
F3.3995447158813477
tp11549
sS'print(foo)'
p11550
(F8.258138020833334
F3.396606683731079
tp11551
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p11552
(F9.872309067670036
F2.7586851119995117
tp11553
sS'foo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)\nprint(foo)'
p11554
(F7.144618314855239
F2.7344179153442383
tp11555
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])\nprint(foo)'
p11556
(F8.536454853258634
F2.8112616539001465
tp11557
sS'foo.append(4)\nfoo.append([8, 7])\nprint(foo)'
p11558
(F9.626150131225586
F3.164173126220703
tp11559
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p11560
(F11.574927867542614
F2.708845853805542
tp11561
sS'L'
p11562
(F12.516657511393229
F3.682011604309082
tp11563
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])'
p11564
(F8.478202126242898
F2.787107467651367
tp11565
sS'from __future__ import print_function\nx = [2, 5, 10]\nx.insert(2, 77)'
p11566
(F12.35449429216056
F3.0695908069610596
tp11567
sS'from __future__ import print_function\nx = [2, 5, 10]\nx.insert(2, 77)\nprint(x)'
p11568
(F11.945573694565716
F3.1115458011627197
tp11569
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p11570
(F11.69519899602522
F2.71152925491333
tp11571
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)'
p11572
(F9.262252114035867
F2.8769214153289795
tp11573
sS'from __future__ import print_function\nfooList = [1, 3, 348, 2]'
p11574
(F13.068445620329484
F3.165663242340088
tp11575
sS'foo[3] = (foo[3] + 4)\nprint(foo)'
p11576
(F8.004165649414062
F2.963966131210327
tp11577
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)'
p11578
(F9.79664306640625
F2.9606518745422363
tp11579
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']"
p11580
(F10.618626185825892
F2.813796281814575
tp11581
sS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    pass'
p11582
(F13.41843052914268
F2.7453858852386475
tp11583
sS'from __future__ import print_function\nx = [2, 5, 10]'
p11584
(F13.351922607421875
F3.1192009449005127
tp11585
sS'for (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount'
p11586
(F14.58714011863426
F2.723642349243164
tp11587
sS'things_to_add = [(1, 1), (2, 1)]'
p11588
(F10.261069161551339
F2.818612575531006
tp11589
sS'foo = [1, 2, 3, 4, 5]'
p11590
(F5.692564900716146
F2.7288804054260254
tp11591
sS'L[:] = [sum(i) for i in zip(L, things_to_add)]'
p11592
(F13.886671799879808
F2.658031463623047
tp11593
sS"L[item['idx']] += item['amount']"
p11594
(F7.739912850516183
F2.7416131496429443
tp11595
sS'foo.append([8, 7])'
p11596
(F8.952958424886068
F3.229586124420166
tp11597
sS'x.insert(2, 77)'
p11598
(F9.160665130615234
F3.393690347671509
tp11599
sS'fooList.append(3)'
p11600
(F10.983751932779947
F3.4915947914123535
tp11601
sS'foo = [1, 2, 3, 4, 5]\nfoo.append(4)'
p11602
(F7.586777426979759
F2.744859218597412
tp11603
sS'fooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)\nprint(fooList)'
p11604
(F10.099160088433159
F2.9596610069274902
tp11605
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p11606
(F10.016393171037947
F2.7568869590759277
tp11607
sS'L[idx] += amount'
p11608
(F10.67878246307373
F2.9500415325164795
tp11609
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]'
p11610
(F8.256727547481143
F3.0618739128112793
tp11611
sS'from __future__ import print_function\nfoo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)'
p11612
(F10.146781519839639
F2.7886695861816406
tp11613
sS'from __future__ import print_function\nfooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)\nprint(fooList)'
p11614
(F12.449305555555556
F3.028520345687866
tp11615
sS'from __future__ import print_function\nfooList = [1, 3, 348, 2]\nfooList.append(3)'
p11616
(F12.86275162235383
F3.031630039215088
tp11617
sS'foo.append([8, 7])\nprint(foo)'
p11618
(F9.105011883903952
F3.2278029918670654
tp11619
sS'x = [2, 5, 10]\nx.insert(2, 77)\nprint(x)'
p11620
(F8.638623657226562
F2.972430467605591
tp11621
sS'fooList.append(3)\nfooList.append(2734)'
p11622
(F11.093717687270221
F3.4279284477233887
tp11623
sS'from __future__ import print_function\nfooList = [1, 3, 348, 2]\nfooList.append(3)\nfooList.append(2734)'
p11624
(F12.550030830578926
F3.0309319496154785
tp11625
sS'x = [2, 5, 10]\nx.insert(2, 77)'
p11626
(F8.370561218261718
F2.8751914501190186
tp11627
sS'from __future__ import print_function\nfoo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)\nprint(foo)'
p11628
(F10.119085977243822
F2.8444483280181885
tp11629
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    L[idx] += amount'
p11630
(F13.131921941583807
F2.6938118934631348
tp11631
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    pass"
p11632
(F10.289845249109101
F2.8676557540893555
tp11633
sS"L = [0, 0, 0, 0]\nthings_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })"
p11634
(F7.7926280886627906
F2.960287570953369
tp11635
sS'foo.append(4)\nfoo.append([8, 7])'
p11636
(F9.89839011744449
F3.1658198833465576
tp11637
sS"for item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p11638
(F12.891002110072545
F2.731713056564331
tp11639
sS'foo.append(4)'
p11640
(F9.4346342086792
F3.3041000366210938
tp11641
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    pass"
p11642
(F11.343794759114584
F2.9778406620025635
tp11643
sS'for (idx, amount) in things_to_add:\n    L[idx] += amount\nL'
p11644
(F14.769877507136417
F2.78460955619812
tp11645
sS'for (idx, amount) in things_to_add:\n    L[idx] += amount'
p11646
(F14.680898030598959
F2.7764840126037598
tp11647
sS"for item in things_to_add:\n    L[item['idx']] += item['amount']"
p11648
(F12.58081524188702
F2.7421982288360596
tp11649
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })\nfor item in things_to_add:\n    L[item['idx']] += item['amount']\nL"
p11650
(F10.783920814251077
F2.810614824295044
tp11651
sS'for item in things_to_add:\n    pass'
p11652
(F16.095419311523436
F2.9509174823760986
tp11653
sS'from __future__ import print_function\nfoo = [1, 2, 3, 4, 5]\nfoo.append(4)'
p11654
(F11.634243872857862
F2.8822410106658936
tp11655
sS'L = [0, 0, 0, 0]\nthings_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    pass'
p11656
(F11.5720654296875
F2.7300686836242676
tp11657
sS'from __future__ import print_function'
p11658
(F19.485391235351564
F3.6538472175598145
tp11659
sS'foo = [1, 2, 3, 4, 5]\nfoo[3] = (foo[3] + 4)'
p11660
(F6.642359240301724
F2.6796367168426514
tp11661
sS'from __future__ import print_function\nfoo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])'
p11662
(F11.280475434802828
F2.819138288497925
tp11663
sS'x.insert(2, 77)\nprint(x)'
p11664
(F9.522347005208333
F3.346344470977783
tp11665
sS'foo[3] = (foo[3] + 4)'
p11666
(F7.250672403971354
F2.8252570629119873
tp11667
sS'things_to_add = [0, 1, 1, 0]\nfor (idx, amount) in enumerate(things_to_add):\n    L[idx] += amount\nL'
p11668
(F13.308844672309029
F2.717062473297119
tp11669
sS'things_to_add = [(1, 1), (2, 1)]\nfor (idx, amount) in things_to_add:\n    pass'
p11670
(F13.305061535957533
F2.7103114128112793
tp11671
sS'L = [0, 0, 0, 0]'
p11672
(F4.761346083420974
F3.1722187995910645
tp11673
sS"things_to_add = ({'idx': 1, 'amount': 1, }, {'idx': 2, 'amount': 1, })"
p11674
(F8.435087142452117
F3.1529812812805176
tp11675
sS'fooList.append(2734)\nprint(fooList)'
p11676
(F11.022609456380208
F3.3931732177734375
tp11677
sS'from __future__ import print_function\nfoo = [1, 2, 3, 4, 5]\nfoo.append(4)\nfoo.append([8, 7])\nprint(foo)'
p11678
(F10.999910395196144
F2.856126070022583
tp11679
sS'fooList.append(2734)'
p11680
(F10.241344875759548
F3.5106406211853027
tp11681
sS'for (idx, amount) in enumerate(things_to_add):\n    pass'
p11682
(F15.27884327281605
F2.7870121002197266
tp11683
sS'for (idx, amount) in things_to_add:\n    pass'
p11684
(F15.545527407997533
F2.911620616912842
tp11685
sS'from __future__ import print_function\nfoo = [1, 2, 3, 4, 5]'
p11686
(F11.617198944091797
F3.024639368057251
tp11687
ssI1747817
(dp11688
S'dict(gen)'
p11689
(F8.55345344543457
F2.051336669921875
tp11690
sS'def key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11691
(F12.011177438204406
F2.1161142349243165
tp11692
sS'd = {k: v for (k, v) in iterable}'
p11693
(F13.051709343405332
F1.9476551055908202
tp11694
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))'
p11695
(F12.022887214781745
F1.9967939376831054
tp11696
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11697
(F9.24285176595052
F2.1388376235961912
tp11698
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11699
(F9.03384053932046
F2.1487268447875976
tp11700
sS'd = dict(map(key_value_gen, range(26)))'
p11701
(F13.492176818847657
F1.946954345703125
tp11702
sS'ts = [(1, 2), (3, 4), (5, 6)]'
p11703
(F6.855100548785666
F2.1173173904418947
tp11704
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11705
(F10.326773903586648
F2.294074058532715
tp11706
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11707
(F10.137953538161058
F2.330734062194824
tp11708
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))'
p11709
(F13.200899251302083
F1.973175048828125
tp11710
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)'
p11711
(F7.579838344029018
F2.0713827133178713
tp11712
sS'def key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))'
p11713
(F10.941034952799479
F2.265077590942383
tp11714
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11715
(F10.622841574928977
F2.1876911163330077
tp11716
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))'
p11717
(F10.370262884324596
F2.1814767837524416
tp11718
sS'dict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen\ndict(gen)'
p11719
(F10.442733764648438
F2.1734437942504883
tp11720
sS'def key_value_gen(k):\n    pass'
p11721
(F14.03487777709961
F2.256428337097168
tp11722
sS'yield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11723
(F11.416310360557155
F2.073099136352539
tp11724
sS'yield chr((k + 65))'
p11725
(F9.02019015225497
F2.356976318359375
tp11726
sS'd = {key: value for (key, value) in iterable}'
p11727
(F13.116537655101103
F2.040305519104004
tp11728
sS'dict(ts)'
p11729
(F8.55345344543457
F2.051336669921875
tp11730
sS'gen\ndict(gen)'
p11731
(F9.457969665527344
F2.1703828811645507
tp11732
sS'yield chr((((k + 13) % 26) + 65))'
p11733
(F8.379927785773026
F2.3205522537231444
tp11734
sS'def key_value_gen(k):\n    yield chr((k + 65))'
p11735
(F12.219951629638672
F2.1979822158813476
tp11736
sS'gen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11737
(F10.501486642020089
F2.331867980957031
tp11738
sS'gen'
p11739
(F12.347089131673178
F2.459847640991211
tp11740
sS'd = dict(((key, value) for (key, value) in iterable))'
p11741
(F12.083964954723012
F1.8614309310913086
tp11742
sS'd = {value: foo(value) for value in sequence if bar(value)}'
p11743
(F13.83110119047619
F1.9708303451538085
tp11744
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    yield chr((k + 65))\nyield chr((((k + 13) % 26) + 65))\nd = dict(map(key_value_gen, range(26)))'
p11745
(F12.51910995855564
F1.9837520599365235
tp11746
sS'ts = [(1, 2), (3, 4), (5, 6)]\ndict(ts)\ngen = ((i, (i + 1)) for i in range(1, 6, 2))\ngen'
p11747
(F9.257816384055397
F2.152070999145508
tp11748
sS'd = {value: foo(value) for value in sequence if bar(value)}\n\ndef key_value_gen(k):\n    pass'
p11749
(F14.056221626900339
F1.9761075973510742
tp11750
ssI2793324
(dp11751
S'a = [1, 2, 3, 4]'
p11752
(F5.8066852276141825
F2.1078594432157627
tp11753
sS'a.remove(c)'
p11754
(F10.659835815429688
F2.1796462115119484
tp11755
sS'pass'
p11756
(F9.728211720784506
F2.4428912892061123
tp11757
sS'if (c in a):\n    pass'
p11758
(F10.312238253079927
F2.2202675763298485
tp11759
sS'print a'
p11760
(F12.019757270812988
F2.3175517811494717
tp11761
sS"a.remove('b')"
p11762
(F9.160255432128906
F2.1700715457691864
tp11763
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if (x != 2)]'
p11764
(F9.104989400724085
F2.1136299582088696
tp11765
sS'if (6 in a):\n    pass'
p11766
(F9.669398381159855
F2.1956069048713234
tp11767
sS'a.remove(6)'
p11768
(F10.015928268432617
F2.164975783404182
tp11769
sS'if (6 in a):\n    a.remove(6)'
p11770
(F10.34191640218099
F2.1626557742848114
tp11771
sS'a = [x for x in a if (x != 2)]'
p11772
(F13.817454618566176
F2.0998562083524814
tp11773
sS'a = [x for x in a if (x != 2)]\nprint a'
p11774
(F13.894461059570313
F2.1096189162310433
tp11775
sS'a = [1, 2, 3, 4]\nif (6 in a):\n    a.remove(6)'
p11776
(F8.719779459635417
F2.1191650839412914
tp11777
sS'if (c in a):\n    a.remove(c)'
p11778
(F11.127265930175781
F2.1654941334443936
tp11779
sS"a.remove('b')\nprint a"
p11780
(F10.604082974520596
F2.1858199624454273
tp11781
sS'a = [1, 2, 3, 4]\nif (6 in a):\n    pass'
p11782
(F8.0483984375
F2.1231447107651653
tp11783
sS"a = ['a', 'b', 'c', 'd']\na.remove('b')"
p11784
(F6.9280036926269535
F2.0992346370921418
tp11785
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]'
p11786
(F5.530590209960938
F2.1336432064280793
tp11787
sS'try:\n    a.remove(6)\nexcept:\n    pass'
p11788
(F8.275782775878906
F2.2190082774442783
tp11789
sS'try:\n    a.remove(c)\nexcept ValueError:\n    pass'
p11790
(F9.635520935058594
F2.24744146010455
tp11791
sS'a = [1, 2, 3, 4, 2, 3, 4, 2, 7, 2]\na = [x for x in a if (x != 2)]\nprint a'
p11792
(F9.3997670953924
F2.1169359543744255
tp11793
sS"a = ['a', 'b', 'c', 'd']"
p11794
(F4.752101604755108
F2.1541763754451977
tp11795
sS"a = ['a', 'b', 'c', 'd']\na.remove('b')\nprint a"
p11796
(F7.897945238196331
F2.0921004800235523
tp11797
ssI123198
(dp11798
S'from shutil import copyfile\ncopyfile(src, dst)'
p11799
(F14.177442110501802
F1.5824508666992188
tp11800
sS'from shutil import copyfile'
p11801
(F18.79474639892578
F1.528375972401012
tp11802
sS"shutil.copy2('/dir/file.ext', '/new/dir')"
p11803
(F7.744451904296875
F1.6472814733331853
tp11804
sS"import shutil\nshutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p11805
(F9.855076716496395
F1.5240277377041904
tp11806
sS"shutil.copy2('/dir/file.ext', '/new/dir/newname.ext')"
p11807
(F7.744451904296875
F1.6472814733331853
tp11808
sS'copyfile(src, dst)'
p11809
(F10.074283599853516
F1.735944227738814
tp11810
sS'import shutil'
p11811
(F15.294964790344238
F1.511933066628196
tp11812
ssI1602934
(dp11813
S'from collections import defaultdict\nd = defaultdict((lambda : 0))'
p11814
(F13.425978716681986
F3.0510549545288086
tp11815
sS'key = (i % 10)'
p11816
(F8.997962103949654
F3.029712677001953
tp11817
sS"('a' in d)\n('c' in d)"
p11818
(F9.501007080078125
F3.0263007481892905
tp11819
sS'for i in xrange(100):\n    d[(i % 10)] += 1'
p11820
(F10.106692770253057
F3.0928338368733725
tp11821
sS'd = defaultdict((lambda : 0))'
p11822
(F9.837627410888672
F3.0574474334716797
tp11823
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    pass'
p11824
(F11.090530395507812
F3.0418291091918945
tp11825
sS'from collections import defaultdict\nd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    d[(i % 10)] += 1'
p11826
(F11.873789469401041
F3.091441790262858
tp11827
sS'd = dict()\nfor i in xrange(100):\n    pass'
p11828
(F10.703644561767579
F3.026901880900065
tp11829
sS"d = {'a': 1, 'b': 2, }"
p11830
(F5.927799769810268
F3.0037705103556314
tp11831
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11832
(F10.003945090553977
F3.098271369934082
tp11833
sS'if (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11834
(F9.348807779947917
F3.061395009358724
tp11835
sS"if ('key1' in dict):\n    print 'blah'\nelse:\n    print 'boo'"
p11836
(F7.525172840465199
F2.992786407470703
tp11837
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    pass'
p11838
(F10.180651245117188
F3.0916315714518228
tp11839
sS'for i in xrange(100):\n    key = (i % 10)'
p11840
(F10.303848266601562
F3.053747812906901
tp11841
sS'if (key in d):\n    d[key] += 1'
p11842
(F10.184237162272135
F3.0588804880777993
tp11843
sS'd[key] += 1'
p11844
(F8.709603309631348
F3.022440274556478
tp11845
sS"('a' in d)"
p11846
(F8.535752432686943
F3.0207732518514
tp11847
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)'
p11848
(F10.246265117938702
F3.0786186854044595
tp11849
sS'd = dict()'
p11850
(F8.645160130092076
F3.016691525777181
tp11851
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1'
p11852
(F10.569612724836482
F3.1004908879597983
tp11853
sS"if ('key1' in dict):\n    pass"
p11854
(F8.877264756422777
F2.999209403991699
tp11855
sS"d = {'a': 1, 'b': 2, }\n('a' in d)"
p11856
(F6.893009185791016
F3.00339412689209
tp11857
sS"if ('key1' in dict):\n    print 'blah'"
p11858
(F8.154871259416852
F3.0129836400349936
tp11859
sS"if ('key1' in dict):\n    print 'blah'\nelse:\n    pass"
p11860
(F8.029092697870164
F2.979039510091146
tp11861
sS'for i in xrange(100):\n    key = (i % 10)\nd[key] = (d.get(key, 0) + 1)'
p11862
(F10.608655427631579
F3.039523124694824
tp11863
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1'
p11864
(F10.74171983873522
F3.066229502360026
tp11865
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nd[key] = (d.get(key, 0) + 1)'
p11866
(F10.456488175825639
F3.0735603968302407
tp11867
sS'from collections import defaultdict'
p11868
(F20.049299875895183
F3.0381507873535156
tp11869
sS'from collections import defaultdict\nd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    pass'
p11870
(F12.807450358072916
F3.0587946573893228
tp11871
sS'd[key] = 1'
p11872
(F8.963125228881836
F3.0223220189412436
tp11873
sS'for i in xrange(100):\n    pass'
p11874
(F10.90780530657087
F3.073655446370443
tp11875
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    pass'
p11876
(F10.262324940074574
F3.0594847997029624
tp11877
sS'd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    pass'
p11878
(F11.113587646484374
F3.0624621709187827
tp11879
sS"d = {'a': 1, 'b': 2, }\n('a' in d)\n('c' in d)"
p11880
(F7.812064537635217
F3.0355250040690103
tp11881
sS'd[key] = (d.get(key, 0) + 1)'
p11882
(F9.567822908100329
F3.00490665435791
tp11883
sS"print 'blah'"
p11884
(F10.201433181762695
F3.2932554880777993
tp11885
sS"('c' in d)"
p11886
(F8.535752432686943
F3.0207732518514
tp11887
sS'd = dict()\nfor i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    pass'
p11888
(F10.909970735248766
F3.083927790323893
tp11889
sS'd[(i % 10)] += 1'
p11890
(F9.147438049316406
F3.098534266153971
tp11891
sS'for i in xrange(100):\n    key = (i % 10)\nif (key in d):\n    d[key] += 1\nelse:\n    d[key] = 1'
p11892
(F10.075230812539859
F3.0708465576171875
tp11893
sS'if (key in d):\n    pass'
p11894
(F10.94797105055589
F3.004422187805176
tp11895
sS'if (key in d):\n    d[key] += 1\nelse:\n    pass'
p11896
(F9.519642944335937
F3.0399033228556314
tp11897
sS'd = defaultdict((lambda : 0))\nfor i in xrange(100):\n    d[(i % 10)] += 1'
p11898
(F10.46931816549862
F3.109543800354004
tp11899
sS"print 'boo'"
p11900
(F10.201433181762695
F3.2932554880777993
tp11901
ssI9573244
(dp11902
S'if (not my_string):\n    pass'
p11903
(F11.392523629324776
F2.035446548461914
tp11904
sS"bool('   '.strip())"
p11905
(F7.969686126708984
F2.115492757161458
tp11906
sS"bool('')\nbool('   ')"
p11907
(F7.518834200772372
F2.0563265482584634
tp11908
sS"bool('   ')"
p11909
(F6.818502426147461
F2.093945058186849
tp11910
sS'if (not myString):\n    pass'
p11911
(F10.331062903771034
F2.011108144124349
tp11912
sS'if (not some_string):\n    pass'
p11913
(F11.698376246861049
F2.040607198079427
tp11914
sS"bool('   ')\nbool('   '.strip())"
p11915
(F8.346276346842448
F2.080222574869792
tp11916
sS'pass'
p11917
(F9.460311889648438
F2.1462720235188804
tp11918
sS"bool('')\nbool('   ')\nbool('   '.strip())"
p11919
(F8.468389129638672
F2.0549138387044272
tp11920
sS'if some_string:\n    pass'
p11921
(F11.154301036487926
F2.05098025004069
tp11922
sS"bool('')"
p11923
(F6.818502426147461
F2.093945058186849
tp11924
ssI743806
(dp11925
S"words = text.split(',')"
p11926
(F10.175944519042968
F1.5864100986056857
tp11927
sS"line = 'a sentence with a few words'\nline.split()"
p11928
(F9.512924887917258
F1.6421689987182617
tp11929
sS'words = text.split()'
p11930
(F10.518639458550346
F1.5779160393608942
tp11931
sS'line.split()'
p11932
(F9.799837384905134
F1.6149847242567275
tp11933
sS'word.append(words)'
p11934
(F11.298026084899902
F1.5351776546902127
tp11935
sS"line = 'a sentence with a few words'"
p11936
(F8.40405731201172
F1.8839056226942275
tp11937
sS'words.append(word)'
p11938
(F10.966958045959473
F1.5164290534125433
tp11939
sS'text.split()'
p11940
(F9.779313223702568
F1.6791572570800781
tp11941
ssI518021
(dp11942
S'len(l)\nlen(s)'
p11943
(F11.393583817915482
F1.7987003326416016
tp11944
sS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)\nlen(s)"
p11945
(F8.544314914279514
F1.8618047714233399
tp11946
sS"my_string = 'hello world'"
p11947
(F12.696884155273438
F1.9276784896850585
tp11948
sS'my_tuple = (1, 2, 3, 4, 5)\nlen(my_tuple)'
p11949
(F10.66900889078776
F1.8422489166259766
tp11950
sS'len(l)'
p11951
(F10.678691864013672
F1.832113265991211
tp11952
sS"l = [1, 2, 3, 4]\ns = 'abcde'\nlen(l)"
p11953
(F7.925507978959517
F1.8642328262329102
tp11954
sS"l = [1, 2, 3, 4]\ns = 'abcde'"
p11955
(F7.0317858527688415
F1.8405271530151368
tp11956
sS'my_list = [1, 2, 3, 4, 5]'
p11957
(F7.867519603056066
F1.851123046875
tp11958
sS"s = 'abcde'\nlen(l)"
p11959
(F9.86706314086914
F1.8196823120117187
tp11960
sS'len(s)'
p11961
(F10.738535563151041
F1.754171371459961
tp11962
sS"s = 'abcde'"
p11963
(F8.912238311767577
F2.0373233795166015
tp11964
sS"my_string = 'hello world'\nlen(my_string)"
p11965
(F13.88036128452846
F1.8780433654785156
tp11966
sS'my_tuple = (1, 2, 3, 4, 5)'
p11967
(F8.389517391429228
F1.8032054901123047
tp11968
sS"s = 'abcde'\nlen(l)\nlen(s)"
p11969
(F9.970945231119792
F1.8141490936279296
tp11970
sS'len(my_list)'
p11971
(F13.50546646118164
F1.8500476837158204
tp11972
sS'l = [1, 2, 3, 4]'
p11973
(F5.9761810302734375
F1.8628707885742188
tp11974
sS'len(my_string)'
p11975
(F13.508834838867188
F1.7945810317993165
tp11976
sS'len(my_tuple)'
p11977
(F13.85274600982666
F1.8022882461547851
tp11978
sS'my_list = [1, 2, 3, 4, 5]\nlen(my_list)'
p11979
(F10.146595001220703
F1.9022403717041017
tp11980
ssI510348
(dp11981
S"import time\nwhile True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p11982
(F10.097280883789063
F1.9142783482869465
tp11983
sS'time.sleep(60)'
p11984
(F9.304677963256836
F1.949824333190918
tp11985
sS'from time import sleep'
p11986
(F18.13165283203125
F1.9693388938903809
tp11987
sS"while True:\n    print 'This prints once a minute.'"
p11988
(F7.444245910644531
F1.9440706570943196
tp11989
sS'sleep(0.1)'
p11990
(F6.48643175760905
F1.964822769165039
tp11991
sS'import time'
p11992
(F14.72878360748291
F1.962310791015625
tp11993
sS'time.sleep(5)'
p11994
(F9.302050590515137
F1.9424289067586262
tp11995
sS'import time\ntime.sleep(60)'
p11996
(F11.04207957874645
F1.9295066197713215
tp11997
sS'import time\nwhile True:\n    pass'
p11998
(F10.386428833007812
F1.9052648544311523
tp11999
sS'import time\ntime.sleep(5)'
p12000
(F10.935564214533025
F1.9238848686218262
tp12001
sS"print 'This prints once a minute.'"
p12002
(F7.75352668762207
F2.094874540964762
tp12003
sS'from time import sleep\nsleep(0.1)'
p12004
(F13.142332597212357
F1.931780497233073
tp12005
sS'while True:\n    pass'
p12006
(F8.143955654568142
F1.9083882967631023
tp12007
sS'time.sleep(0.1)'
p12008
(F8.91959285736084
F1.9586437543233235
tp12009
sS"while True:\n    print 'This prints once a minute.'\ntime.sleep(60)"
p12010
(F8.957096773035387
F1.9113059043884277
tp12011
sS'import time\ntime.sleep(0.1)'
p12012
(F10.87252391468395
F1.934920310974121
tp12013
sS"import time\nwhile True:\n    print 'This prints once a minute.'"
p12014
(F9.593245286207933
F1.9289827346801758
tp12015
sS'time.sleep(time.localtime(time.time())[5])'
p12016
(F11.111222076416016
F1.9411319096883137
tp12017
ssI82831
(dp12018
S"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p12019
(F12.45903945550686
F1.529535146859976
tp12020
sS"print os.path.isfile('/etc')"
p12021
(F11.654391202059658
F1.5554310725285456
tp12022
sS"my_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p12023
(F12.459507868840145
F1.610823998084435
tp12024
sS"print os.path.exists('/etc/password.txt')"
p12025
(F12.538859974254262
F1.5423475412222056
tp12026
sS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p12027
(F12.915506998697916
F1.524717771089994
tp12028
sS'import os.path'
p12029
(F16.80129114786784
F1.511062768789438
tp12030
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p12031
(F12.04597400483631
F1.5406966576209435
tp12032
sS'import os.path\nos.path.exists(file_path)'
p12033
(F16.030156752642462
F1.5108978564922626
tp12034
sS'pass'
p12035
(F10.049075444539389
F1.6480061457707331
tp12036
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p12037
(F12.462635655556955
F1.531355931208684
tp12038
sS"from pathlib import Path\nmy_file = Path('/path/to/file')\nif my_file.is_file():\n    pass"
p12039
(F13.827694800592237
F1.6145365788386419
tp12040
sS"print os.path.isfile('/does/not/exist')"
p12041
(F11.654391202059658
F1.5554310725285456
tp12042
sS"from pathlib import Path\nmy_file = Path('/path/to/file')"
p12043
(F14.235904947916667
F1.6906130864070013
tp12044
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p12045
(F12.672287359470275
F1.526770518376277
tp12046
sS'from pathlib import Path'
p12047
(F18.961130777994793
F1.7183936192439153
tp12048
sS'os.path.isfile(fname)'
p12049
(F11.649248504638672
F1.6123960935152495
tp12050
sS"print os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12051
(F12.78894162645527
F1.5232825646033654
tp12052
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')"
p12053
(F12.04597400483631
F1.5406966576209435
tp12054
sS"print os.path.exists('/etc')"
p12055
(F12.538859974254262
F1.5423475412222056
tp12056
sS"my_file = Path('/path/to/file')"
p12057
(F10.967141723632812
F1.7375566042386568
tp12058
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')"
p12059
(F12.445472353980655
F1.5342769622802734
tp12060
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p12061
(F12.746818296370968
F1.5271467062143178
tp12062
sS'if my_file.is_file():\n    pass'
p12063
(F12.605733534869026
F1.6031304872952974
tp12064
sS"print os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12065
(F13.064964048324093
F1.5190150921161358
tp12066
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12067
(F12.71922827548668
F1.5229838444636419
tp12068
sS"print os.path.exists('/does/not/exist')"
p12069
(F12.538859974254262
F1.5423475412222056
tp12070
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')"
p12071
(F12.198060066469255
F1.5355958205003004
tp12072
sS"print os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12073
(F12.88457656488186
F1.522863974938026
tp12074
sS'import os.path\nos.path.isfile(fname)'
p12075
(F14.385415649414062
F1.5339848445012019
tp12076
sS"print os.path.isfile('/etc/password.txt')"
p12077
(F11.654391202059658
F1.5554310725285456
tp12078
sS"print os.path.isfile('/etc/password.txt')\nprint os.path.isfile('/etc')\nprint os.path.isfile('/does/not/exist')\nprint os.path.exists('/etc/password.txt')\nprint os.path.exists('/etc')"
p12079
(F12.618524289598652
F1.5260091928335338
tp12080
sS'os.path.exists(file_path)'
p12081
(F14.33307139078776
F1.5563973646897535
tp12082
sS"print os.path.exists('/etc')\nprint os.path.exists('/does/not/exist')"
p12083
(F12.915506998697916
F1.524717771089994
tp12084
ssI510357
(dp12085
S'class _GetchUnix:\n\n    def __init__(self):\n        pass'
p12086
(F12.732036243785512
F3.1205608367919924
tp12087
sS'def _find_getch():\n    pass'
p12088
(F10.598744319035458
F2.8126409530639647
tp12089
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p12090
(F12.54239981515067
F3.080228805541992
tp12091
sS'return self.impl()'
p12092
(F10.802184104919434
F3.2258792877197267
tp12093
sS'def _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p12094
(F11.861920166015626
F3.057796096801758
tp12095
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p12096
(F11.67960713704427
F3.027204704284668
tp12097
sS'return ch\nreturn _getch'
p12098
(F13.183627537318639
F3.0314958572387694
tp12099
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the screen.'"
p12100
(F7.12003411187066
F2.9264650344848633
tp12101
sS'return _getch'
p12102
(F11.944591522216797
F3.0789583206176756
tp12103
sS'return ch'
p12104
(F11.944591522216797
F3.078958511352539
tp12105
sS'sys.stdin.read(1)'
p12106
(F10.984125518798828
F2.934573936462402
tp12107
sS'tty.setraw(fd)'
p12108
(F10.505396842956543
F2.8618465423583985
tp12109
sS'tty.setraw(sys.stdin.fileno())'
p12110
(F11.90965815952846
F2.8998456954956056
tp12111
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p12112
(F14.258031671697443
F3.024627685546875
tp12113
sS'def __call__(self):\n    pass'
p12114
(F12.258058820452009
F3.0885746002197267
tp12115
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p12116
(F13.786083020662007
F3.0785093307495117
tp12117
sS'termios.tcsetattr(fd, termios.TCSADRAIN, old_settings)'
p12118
(F12.970621109008789
F3.2245079040527345
tp12119
sS'ch = sys.stdin.read(1)'
p12120
(F10.879721323649088
F2.8832118988037108
tp12121
sS'old_settings = termios.tcgetattr(fd)'
p12122
(F12.9385986328125
F3.1059471130371095
tp12123
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p12124
(F12.792047238817402
F3.075129508972168
tp12125
sS'def _getch():\n    fd = sys.stdin.fileno()'
p12126
(F9.54293421695107
F3.0486356735229494
tp12127
sS'def __init__(self):\n    import tty, sys'
p12128
(F14.37367966595818
F3.0267120361328126
tp12129
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p12130
(F14.29992206280048
F2.984321403503418
tp12131
sS'class _Getch:\n    pass'
p12132
(F8.598407321506077
F2.9642288208007814
tp12133
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p12134
(F13.38717990451389
F3.074778747558594
tp12135
sS'def __init__(self):\n    import msvcrt'
p12136
(F13.826366170247395
F3.0813983917236327
tp12137
sS'getch = _find_getch()'
p12138
(F10.548531426323784
F2.830023193359375
tp12139
sS'return ch\nreturn _getch\ngetch = _find_getch()'
p12140
(F12.209275309244791
F2.806265640258789
tp12141
sS'return _getch\ngetch = _find_getch()'
p12142
(F11.514934539794922
F2.8009735107421876
tp12143
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the\\nscreen.'\n\ndef __init__(self):\n    pass"
p12144
(F10.883612591287363
F3.0134029388427734
tp12145
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p12146
(F12.818201576791159
F3.0483898162841796
tp12147
sS'return msvcrt.getch'
p12148
(F13.724016825358072
F3.082994270324707
tp12149
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        pass'
p12150
(F12.58390880766369
F3.195872497558594
tp12151
sS'import sys, tty\n\ndef _getch():\n    pass'
p12152
(F10.85878080480239
F2.9850257873535155
tp12153
sS'import termios'
p12154
(F14.849913597106934
F2.8857858657836912
tp12155
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p12156
(F14.00673986364294
F2.977880859375
tp12157
sS'class _GetchWindows:\n\n    def __init__(self):\n        pass'
p12158
(F12.732036243785512
F3.1205608367919924
tp12159
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p12160
(F13.655664688501602
F3.0533578872680662
tp12161
sS'self.impl = _GetchWindows()'
p12162
(F9.88655776977539
F3.221780776977539
tp12163
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p12164
(F12.8935107421875
F3.084053611755371
tp12165
sS'return ch\n\n\nclass _GetchWindows:\n    pass'
p12166
(F9.765935262044271
F3.091537094116211
tp12167
sS'getch = _Getch()'
p12168
(F6.495019640241351
F3.0693859100341796
tp12169
sS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p12170
(F11.656451633998326
F3.0400630950927736
tp12171
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt\nreturn msvcrt.getch()\ngetch = _Getch()'
p12172
(F12.415069580078125
F3.0830814361572267
tp12173
sS'self.impl = _GetchUnix()'
p12174
(F9.88655776977539
F3.221780776977539
tp12175
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p12176
(F13.818523092830882
F3.0780202865600588
tp12177
sS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p12178
(F14.019876098632812
F3.0567228317260744
tp12179
sS'class _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p12180
(F13.821361083984375
F3.0332870483398438
tp12181
sS'fd = sys.stdin.fileno()'
p12182
(F10.728279113769531
F3.0474822998046873
tp12183
sS'def __call__(self):\n    import sys, tty, termios'
p12184
(F13.984346088610197
F3.0318025588989257
tp12185
sS'return msvcrt.getch\nimport sys, tty\n\ndef _getch():\n    pass'
p12186
(F11.602133317427201
F2.9727298736572267
tp12187
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    import msvcrt'
p12188
(F13.174855786700581
F3.0874164581298826
tp12189
sS'fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p12190
(F12.790621670809658
F3.0325763702392576
tp12191
sS'import sys, tty'
p12192
(F16.357012430826824
F2.9206838607788086
tp12193
sS'def __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p12194
(F13.485054805360992
F3.039508819580078
tp12195
sS'return msvcrt.getch\nimport sys, tty'
p12196
(F15.430275656960227
F2.9345685958862306
tp12197
sS'def __call__(self):\n    return self.impl()'
p12198
(F11.960564061215049
F3.131442070007324
tp12199
sS'return msvcrt.getch()'
p12200
(F9.31899642944336
F3.0945066452026366
tp12201
sS'import tty, sys'
p12202
(F16.832308451334637
F2.789090156555176
tp12203
sS'def __call__(self):\n    import msvcrt\nreturn msvcrt.getch()'
p12204
(F12.63768144087358
F3.0403385162353516
tp12205
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p12206
(F12.819949195498513
F3.115010452270508
tp12207
sS'class _GetchUnix:\n    pass'
p12208
(F10.253294372558594
F3.0569835662841798
tp12209
sS"'Gets a single character from standard input.  Does not echo to the\\nscreen.'"
p12210
(F3.0343856811523438
F2.8406131744384764
tp12211
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys'
p12212
(F13.178902180989583
F3.1528072357177734
tp12213
sS'class _GetchWindows:\n    pass'
p12214
(F10.253294372558594
F3.0569835662841798
tp12215
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt\n\ndef __call__(self):\n    pass'
p12216
(F13.394855396167651
F3.1095439910888674
tp12217
sS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()\nold_settings = termios.tcgetattr(fd)'
p12218
(F12.589803907606337
F3.0619598388671876
tp12219
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios\nfd = sys.stdin.fileno()'
p12220
(F13.49745054502745
F3.0853527069091795
tp12221
sS'def __init__(self):\n    pass'
p12222
(F12.738632202148438
F3.152682304382324
tp12223
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the\\nscreen.'"
p12224
(F7.12003411187066
F2.9264650344848633
tp12225
sS'import msvcrt'
p12226
(F14.849913597106934
F2.8857858657836912
tp12227
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    pass'
p12228
(F13.171188095868644
F3.151676368713379
tp12229
sS"class _Getch:\n    'Gets a single character from standard input.  Does not echo to the screen.'\n\ndef __init__(self):\n    pass"
p12230
(F10.883612591287363
F3.0134029388427734
tp12231
sS'return ch\n\n\nclass _GetchWindows:\n\n    def __init__(self):\n        pass'
p12232
(F12.032991762514468
F3.1257625579833985
tp12233
sS'def __call__(self):\n    import msvcrt'
p12234
(F13.363197835286458
F3.0402578353881835
tp12235
sS'def _getch():\n    pass'
p12236
(F7.794980135830966
F2.996030807495117
tp12237
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n    pass'
p12238
(F11.44259033203125
F3.173822784423828
tp12239
sS'return msvcrt.getch()\ngetch = _Getch()'
p12240
(F8.674442836216517
F3.075975799560547
tp12241
sS"'Gets a single character from standard input.  Does not echo to the screen.'"
p12242
(F3.0343856811523438
F2.8406131744384764
tp12243
sS'import sys, tty\n\ndef _getch():\n    fd = sys.stdin.fileno()'
p12244
(F11.207044677734375
F3.0476831436157226
tp12245
sS'import sys, tty, termios'
p12246
(F15.886201858520508
F2.9039894104003907
tp12247
sS'def __call__(self):\n    return self.impl()\n\n\nclass _GetchUnix:\n\n    def __init__(self):\n        import tty, sys\n\ndef __call__(self):\n    import sys, tty, termios'
p12248
(F13.611115455627441
F3.1326391220092775
tp12249
sS'class _GetchWindows:\n\n    def __init__(self):\n        import msvcrt'
p12250
(F13.357051683508832
F3.0630449295043944
tp12251
ssI1450393
(dp12252
S'for line in fileinput.input():\n    pass'
p12253
(F12.23909912109375
F2.0028669183904473
tp12254
sS'for line in sys.stdin:\n    print line'
p12255
(F13.050350734165736
F1.9787647940895774
tp12256
sS'import sys'
p12257
(F15.417939186096191
F2.0829552737149326
tp12258
sS'print line'
p12259
(F11.394742965698242
F1.8757535761052913
tp12260
sS'for line in sys.stdin:\n    pass'
p12261
(F13.12151630108173
F2.0536670684814453
tp12262
sS'import fileinput\nfor line in fileinput.input():\n    pass'
p12263
(F13.174536810980904
F1.917292681607333
tp12264
sS'import fileinput'
p12265
(F17.030410766601562
F1.999211224642667
tp12266
sS'pass'
p12267
(F9.458547592163086
F2.1854979775168677
tp12268
sS'import sys\nfor line in sys.stdin:\n    pass'
p12269
(F13.867076873779297
F2.0413856506347656
tp12270
sS'import sys\nfor line in sys.stdin:\n    print line'
p12271
(F13.79312941607307
F1.9860267639160156
tp12272
ssI15411107
(dp12273
S'for key in keys_to_remove:\n    pass'
p12274
(F15.757167561848958
F3.794876480102539
tp12275
sS'try:\n    del mydict[key]\nexcept KeyError:\n    pass'
p12276
(F9.225922357468377
F3.9097644805908205
tp12277
sS'new_dict = {k: mydict[k] for k in keys_to_keep}'
p12278
(F16.20778309215199
F3.6406383514404297
tp12279
sS'keys_to_keep = (set(mydict.keys()) - set(keys))\nnew_dict = {k: v for (k, v) in mydict.iteritems() if (k in keys_to_keep)}'
p12280
(F14.678001819957386
F3.7830123901367188
tp12281
sS'for key in keys_to_remove:\n    del mydict[key]'
p12282
(F14.880367881373354
F3.704815673828125
tp12283
sS'pass'
p12284
(F10.24246088663737
F4.388597869873047
tp12285
sS'new_dict = {k: v for (k, v) in mydict.iteritems() if (k in keys_to_keep)}'
p12286
(F15.425234707919033
F3.7011459350585936
tp12287
sS'keys_to_keep = (set(mydict.keys()) - set(keys))'
p12288
(F12.589051619819973
F3.920001983642578
tp12289
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    pass'
p12290
(F14.823667827405428
F3.8276592254638673
tp12291
sS'del mydict[key]'
p12292
(F10.266978672572545
F3.7349281311035156
tp12293
sS'keys_to_keep = (set(mydict.keys()) - set(keys))\nnew_dict = {k: mydict[k] for k in keys_to_keep}'
p12294
(F14.800359552556818
F3.7625991821289064
tp12295
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))'
p12296
(F13.259282430013021
F3.845470428466797
tp12297
sS'keys_to_remove = set(keys).intersection(set(mydict.keys()))\nfor key in keys_to_remove:\n    del mydict[key]'
p12298
(F14.553910028366815
F3.8114692687988283
tp12299
sS"mydict.pop('key', None)"
p12300
(F9.255781555175782
F3.916427230834961
tp12301
ssI466345
(dp12302
S"dt = parser.parse('Aug 28 1999 12:00AM')"
p12303
(F9.720438385009766
F2.565080483754476
tp12304
sS'from dateutil import parser'
p12305
(F19.2810796101888
F2.8575528462727866
tp12306
sS'from datetime import datetime'
p12307
(F18.343393961588543
F2.5183959007263184
tp12308
sS"from datetime import datetime\ndate_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p12309
(F13.81070267526727
F2.4720741907755532
tp12310
sS"date_object = datetime.strptime('Jun 1 2005  1:33PM', '%b %d %Y %I:%M%p')"
p12311
(F11.257223946707589
F2.5291051864624023
tp12312
sS"from dateutil import parser\ndt = parser.parse('Aug 28 1999 12:00AM')"
p12313
(F13.603253173828126
F2.538240591684977
tp12314
ssI8177079
(dp12315
S'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p12316
(F10.758627640573602
F2.6048543453216553
tp12317
sS'del list1'
p12318
(F16.28998565673828
F2.1799607276916504
tp12319
sS'c.extend(a)'
p12320
(F11.481042861938477
F2.454669237136841
tp12321
sS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p12322
(F9.920586395263673
F2.1692700386047363
tp12323
sS'a = range(5)'
p12324
(F8.914802551269531
F2.604625940322876
tp12325
sS"if any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)\ndel list1"
p12326
(F14.655104637145996
F2.158121109008789
tp12327
sS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)'
p12328
(F11.009568737399194
F2.562082290649414
tp12329
sS'pass'
p12330
(F10.098386764526367
F2.7084145545959473
tp12331
sS'for logs in mydir:\n    for line in mylog:\n        list1.append(line)'
p12332
(F13.366831461588541
F2.1147208213806152
tp12333
sS'list1.append(line)'
p12334
(F11.14173412322998
F2.1544320583343506
tp12335
sS'c.extend(a)\nc'
p12336
(F13.022311401367187
F2.447186231613159
tp12337
sS'b\nc.extend(a)'
p12338
(F12.146493530273437
F2.424687623977661
tp12339
sS"import itertools\np = ['a', 'b', 'c']"
p12340
(F8.362737383161273
F2.191011428833008
tp12341
sS'for logs in mydir:\n    pass'
p12342
(F12.69822138006037
F2.2181010246276855
tp12343
sS'b = range(3)\nc = range(2)\nb.append(a)'
p12344
(F10.1547983342951
F2.557720899581909
tp12345
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p12346
(F5.665790188697077
F2.1698999404907227
tp12347
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)'
p12348
(F10.034406990840518
F2.610506534576416
tp12349
sS'for line in mylog:\n    pass'
p12350
(F12.056425614790482
F2.2426929473876953
tp12351
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb'
p12352
(F10.58446281186996
F2.6029531955718994
tp12353
sS'b.append(a)\nb\nc.extend(a)'
p12354
(F12.214797973632812
F2.429988145828247
tp12355
sS'c = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p12356
(F11.792710524338942
F2.523193836212158
tp12357
sS'for x in itertools.chain(p, q, r):\n    pass'
p12358
(F13.654135131835938
F2.3893487453460693
tp12359
sS"r = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p12360
(F11.202498372395834
F2.2271265983581543
tp12361
sS'c = range(2)\nb.append(a)'
p12362
(F10.337851969401042
F2.525656223297119
tp12363
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    pass"
p12364
(F14.018717015043219
F2.157196044921875
tp12365
sS'a = range(5)\nb = range(3)'
p12366
(F9.310213216145833
F2.6301915645599365
tp12367
sS"p = ['a', 'b', 'c']"
p12368
(F5.28923242742365
F2.220255136489868
tp12369
sS'list1.extend(mylog)'
p12370
(F11.116631507873535
F2.2390148639678955
tp12371
sS'for line in mylog:\n    list1.append(line)'
p12372
(F12.43857192993164
F2.1155154705047607
tp12373
sS'b\nc.extend(a)\nc'
p12374
(F13.070935567220053
F2.425827980041504
tp12375
sS'a = range(5)\nb = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p12376
(F11.052281188964844
F2.597921848297119
tp12377
sS'c = range(2)\nb.append(a)\nb\nc.extend(a)'
p12378
(F11.395741780598959
F2.527711868286133
tp12379
sS'list2.extend(list1)'
p12380
(F11.164312362670898
F2.2208023071289062
tp12381
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p12382
(F9.535885792858195
F2.1948466300964355
tp12383
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']\nfor x in itertools.chain(p, q, r):\n    pass"
p12384
(F9.026113891601563
F2.159883975982666
tp12385
sS'list2.append(list1)'
p12386
(F10.658719062805176
F2.242493152618408
tp12387
sS'c = range(2)\nb.append(a)\nb'
p12388
(F11.360552619485293
F2.518918514251709
tp12389
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)\ndel list1"
p12390
(F14.468486993963069
F2.1528396606445312
tp12391
sS'b = range(3)\nc = range(2)\nb.append(a)\nb'
p12392
(F10.850018819173178
F2.5522780418395996
tp12393
sS"for logs in mydir:\n    for line in mylog:\n        list1.append(line)\nif any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)"
p12394
(F14.120071411132812
F2.150444746017456
tp12395
sS"if any((True for line in list1 if ('string' in line))):\n    list2.extend(list1)"
p12396
(F13.845313762796335
F2.1633851528167725
tp12397
sS'b.append(a)\nb'
p12398
(F12.675372314453124
F2.382624626159668
tp12399
sS'b.append(a)'
p12400
(F10.92494010925293
F2.3949131965637207
tp12401
sS'import itertools'
p12402
(F15.9495210647583
F2.259639024734497
tp12403
sS"if any((True for line in list1 if ('string' in line))):\n    pass"
p12404
(F13.564645131429037
F2.2068777084350586
tp12405
sS"r = ['g', 'h', 'i']"
p12406
(F5.375688726251775
F2.2924699783325195
tp12407
sS'c'
p12408
(F14.293469746907553
F2.5526223182678223
tp12409
sS'b'
p12410
(F14.563482920328775
F2.525907516479492
tp12411
sS'b = range(3)'
p12412
(F8.979324340820312
F2.5695059299468994
tp12413
sS'c = range(2)'
p12414
(F8.704558372497559
F2.613098382949829
tp12415
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p12416
(F7.2058149973551435
F2.1876838207244873
tp12417
sS'b = range(3)\nc = range(2)'
p12418
(F9.210721842447917
F2.617696762084961
tp12419
sS'b.append(a)\nb\nc.extend(a)\nc'
p12420
(F12.609534012643914
F2.4306857585906982
tp12421
sS"q = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p12422
(F5.774670555478051
F2.1884639263153076
tp12423
sS"p = ['a', 'b', 'c']\nq = ['d', 'e', 'f']"
p12424
(F5.588864281063988
F2.176492929458618
tp12425
sS"q = ['d', 'e', 'f']"
p12426
(F5.404019442471591
F2.2194831371307373
tp12427
sS'a = range(5)\nb = range(3)\nc = range(2)'
p12428
(F9.333539789373225
F2.6582627296447754
tp12429
sS"import itertools\np = ['a', 'b', 'c']\nq = ['d', 'e', 'f']\nr = ['g', 'h', 'i']"
p12430
(F6.81849266501034
F2.1927788257598877
tp12431
sS'for logs in mydir:\n    for line in mylog:\n        pass'
p12432
(F13.360115452816611
F2.166630744934082
tp12433
sS'b = range(3)\nc = range(2)\nb.append(a)\nb\nc.extend(a)\nc'
p12434
(F11.331641919685133
F2.5564842224121094
tp12435
ssI455612
(dp12436
S"print(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))"
p12437
(F9.85353125595465
F4.884878158569336
tp12438
sS"from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12439
(F10.493507875215023
F4.986116409301758
tp12440
sS"print(('%.2f' % a))"
p12441
(F7.864210510253907
F5.063260078430176
tp12442
sS'print(a)'
p12443
(F8.701347986857096
F5.1083984375
tp12444
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng"
p12445
(F11.107926141648065
F4.912376403808594
tp12446
sS'g\n(x == g)\nh = round(x, 2)\nh\n(x == h)'
p12447
(F11.054789616511417
F5.060418128967285
tp12448
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))'
p12449
(F6.612497965494792
F5.365924835205078
tp12450
sS"print(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))"
p12451
(F9.620601806640625
F4.905158996582031
tp12452
sS"(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12453
(F9.906460910373264
F4.9256978034973145
tp12454
sS"(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12455
(F9.726062825520833
F4.936948776245117
tp12456
sS"a = 13.946\nprint(a)\nprint(('%.2f' % a))"
p12457
(F9.016200015419408
F5.074191093444824
tp12458
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946'
p12459
(F7.161488037109375
F5.332945823669434
tp12460
sS"a = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))"
p12461
(F9.9249267578125
F4.912792205810547
tp12462
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12463
(F10.912866592407227
F4.9119486808776855
tp12464
sS"('%.2f' % 3.14159)\n('%.2f' % 13.9499999)"
p12465
(F4.940039414625901
F5.1711649894714355
tp12466
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)"
p12467
(F8.470780745796535
F5.091279029846191
tp12468
sS'(234042163 / (2 ** 24))\na = 13.946'
p12469
(F7.3124231974283855
F5.307797431945801
tp12470
sS'h'
p12471
(F14.592545827229818
F5.53996467590332
tp12472
sS'h\n(x == h)'
p12473
(F10.64976586235894
F5.5247721672058105
tp12474
sS'from __future__ import print_function'
p12475
(F18.35985870361328
F5.4821343421936035
tp12476
sS"print(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))"
p12477
(F10.078565514605978
F4.89768123626709
tp12478
sS'(x == g)'
p12479
(F9.741245814732142
F5.244016647338867
tp12480
sS'x'
p12481
(F14.21747080485026
F5.231598854064941
tp12482
sS"(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))"
p12483
(F9.220786743164062
F4.950123310089111
tp12484
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))"
p12485
(F9.967924419202303
F4.9054765701293945
tp12486
sS"g = float('{0:.2f}'.format(x))\ng"
p12487
(F11.501732381184896
F4.915936470031738
tp12488
sS"a = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))"
p12489
(F9.914630889892578
F4.893849849700928
tp12490
sS"print(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12491
(F10.487478915127841
F4.873156547546387
tp12492
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12493
(F10.836802164713541
F4.9091691970825195
tp12494
sS"round(a, 2)\nprint(('%.2f' % round(a, 2)))"
p12495
(F9.954448353160512
F4.8053998947143555
tp12496
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12497
(F9.64853759765625
F4.947786331176758
tp12498
sS'(x == g)\nh = round(x, 2)'
p12499
(F10.322871208190918
F4.963616371154785
tp12500
sS"print('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12501
(F10.590206239281631
F4.906074523925781
tp12502
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12503
(F11.40622329711914
F4.917821884155273
tp12504
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))"
p12505
(F8.883970133463542
F5.000427722930908
tp12506
sS"print(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12507
(F10.449409592319542
F4.871680736541748
tp12508
sS"print(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12509
(F10.432124903944672
F4.88934850692749
tp12510
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))"
p12511
(F9.074196079799107
F4.9875922203063965
tp12512
sS'from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)'
p12513
(F10.501742631961138
F5.334588050842285
tp12514
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12515
(F11.423580394071692
F4.919931411743164
tp12516
sS"print(a)\nprint(('%.2f' % a))"
p12517
(F9.056624348958334
F5.053620338439941
tp12518
sS"a = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)"
p12519
(F9.66183119553786
F4.931633949279785
tp12520
sS"print('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12521
(F10.360119235131048
F4.856479644775391
tp12522
sS'g'
p12523
(F14.58169428507487
F5.444713115692139
tp12524
sS'x = 13.95\nx'
p12525
(F10.88219233921596
F5.206258296966553
tp12526
sS'(234042163 / (2 ** 24))\na = 13.946\nprint(a)'
p12527
(F7.8529205322265625
F5.245364189147949
tp12528
sS'h = round(x, 2)\nh\n(x == h)'
p12529
(F10.581843058268229
F4.98138427734375
tp12530
sS'g\n(x == g)'
p12531
(F10.71097903781467
F5.344440937042236
tp12532
sS"print(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12533
(F10.307388305664062
F4.8769426345825195
tp12534
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh"
p12535
(F11.11946025647615
F4.920368671417236
tp12536
sS'x = 13.95'
p12537
(F8.656625366210937
F5.228638648986816
tp12538
sS"round(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12539
(F10.44869410738032
F4.832320213317871
tp12540
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)"
p12541
(F10.644829644097221
F4.913018226623535
tp12542
sS"print(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12543
(F10.537790398848685
F4.883174896240234
tp12544
sS'(125650429603636838 / (2 ** 53))'
p12545
(F5.644048170609907
F5.269397258758545
tp12546
sS"print(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))"
p12547
(F9.78152367376512
F4.855520248413086
tp12548
sS"x\ng = float('{0:.2f}'.format(x))\ng"
p12549
(F11.664552576401654
F4.910540580749512
tp12550
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12551
(F10.840830485026041
F4.914252281188965
tp12552
sS'(x == h)'
p12553
(F9.695263453892299
F5.343127250671387
tp12554
sS'from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))'
p12555
(F10.669422403971355
F5.378605842590332
tp12556
sS"(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)"
p12557
(F8.875087314181858
F5.019492149353027
tp12558
sS"a = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12559
(F10.269248610276442
F4.9035797119140625
tp12560
sS"print('{0:.2f}'.format(round(a, 2)))"
p12561
(F9.834400177001953
F4.875604152679443
tp12562
sS"x\ng = float('{0:.2f}'.format(x))"
p12563
(F10.285716756184895
F4.9011549949646
tp12564
sS"float('{0:.2f}'.format(13.95))"
p12565
(F8.280481511896307
F4.9398956298828125
tp12566
sS"round(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))"
p12567
(F9.9841890335083
F4.831109046936035
tp12568
sS'a = 13.946\nprint(a)'
p12569
(F8.64998779296875
F5.134221076965332
tp12570
sS"print(a)\nprint(('%.2f' % a))\nround(a, 2)"
p12571
(F9.934872713955967
F4.9087233543396
tp12572
sS"from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))"
p12573
(F10.276935577392578
F5.271246910095215
tp12574
sS"g = float('{0:.2f}'.format(x))"
p12575
(F10.035633967472958
F4.90273380279541
tp12576
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p12577
(F11.073213195800781
F4.9417619705200195
tp12578
sS"print('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12579
(F10.334571251502403
F4.9362874031066895
tp12580
sS"a = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12581
(F10.395362854003906
F4.896451950073242
tp12582
sS'(x == g)\nh = round(x, 2)\nh'
p12583
(F11.434878879123264
F4.977386474609375
tp12584
sS"print('{0:.2f}'.format(a))"
p12585
(F9.004838423295455
F5.048962116241455
tp12586
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12587
(F10.554902253327546
F4.9172444343566895
tp12588
sS"g = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p12589
(F11.032798365542764
F4.938372611999512
tp12590
sS"from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))"
p12591
(F10.333858766417572
F5.066864013671875
tp12592
sS'g\n(x == g)\nh = round(x, 2)\nh'
p12593
(F11.593919372558593
F5.019656181335449
tp12594
sS"print(('%.2f' % a))\nround(a, 2)"
p12595
(F9.319605210248161
F4.87893009185791
tp12596
sS"print(('%.2f' % round(a, 2)))"
p12597
(F9.242706298828125
F4.8566389083862305
tp12598
sS"round(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))\nprint('{0:.15f}'.format(round(a, 2)))"
p12599
(F10.54705810546875
F4.834261417388916
tp12600
sS'a = 13.946'
p12601
(F8.376215362548828
F5.202228546142578
tp12602
sS"print(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))"
p12603
(F10.116845024956596
F4.876832008361816
tp12604
sS"('%.2f' % 13.9499999)"
p12605
(F4.6865354265485495
F5.1911211013793945
tp12606
sS'g\n(x == g)\nh = round(x, 2)'
p12607
(F10.731307135687935
F5.006581783294678
tp12608
sS'(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)'
p12609
(F7.563838704427083
F5.284566879272461
tp12610
sS"(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))"
p12611
(F8.293168692753232
F5.148924827575684
tp12612
sS'h = round(x, 2)'
p12613
(F9.83206787109375
F4.8986663818359375
tp12614
sS"from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12615
(F10.441162109375
F5.008779525756836
tp12616
sS'from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946'
p12617
(F10.707797779756433
F5.3565263748168945
tp12618
sS"from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)"
p12619
(F10.407972301136363
F5.168735980987549
tp12620
sS"x\ng = float('{0:.2f}'.format(x))\ng\n(x == g)"
p12621
(F10.899134096891984
F4.913967609405518
tp12622
sS"print('{0:.15f}'.format(round(a, 2)))"
p12623
(F9.834400177001953
F4.875604152679443
tp12624
sS'(234042163 / (2 ** 24))'
p12625
(F6.254629655317827
F5.371089935302734
tp12626
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12627
(F9.445258645450368
F4.9639787673950195
tp12628
sS"'{0:.2f}'.format(13.95)"
p12629
(F7.018736362457275
F5.188510894775391
tp12630
sS'(x == g)\nh = round(x, 2)\nh\n(x == h)'
p12631
(F10.843669891357422
F5.022207260131836
tp12632
sS"x = 13.95\nx\ng = float('{0:.2f}'.format(x))\ng\n(x == g)\nh = round(x, 2)\nh\n(x == h)"
p12633
(F10.837851784446023
F4.9409942626953125
tp12634
sS'from __future__ import print_function\n(125650429603636838 / (2 ** 53))'
p12635
(F12.250572204589844
F5.370720863342285
tp12636
sS"(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))"
p12637
(F9.35252176920573
F4.952343940734863
tp12638
sS'round(a, 2)'
p12639
(F9.052967071533203
F4.829855918884277
tp12640
sS"(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))"
p12641
(F7.9502117450420675
F5.2003583908081055
tp12642
sS"from __future__ import print_function\n(125650429603636838 / (2 ** 53))\n(234042163 / (2 ** 24))\na = 13.946\nprint(a)\nprint(('%.2f' % a))\nround(a, 2)\nprint(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))"
p12643
(F10.288887120500396
F5.043308258056641
tp12644
sS'h = round(x, 2)\nh'
p12645
(F11.672444661458334
F4.926138877868652
tp12646
sS"('%.2f' % 3.14159)"
p12647
(F4.6865354265485495
F5.1911211013793945
tp12648
sS"print(('%.2f' % round(a, 2)))\nprint('{0:.2f}'.format(a))\nprint('{0:.2f}'.format(round(a, 2)))"
p12649
(F10.322047424316406
F4.8829193115234375
tp12650
ssI73663
(dp12651
S'sys.exit()'
p12652
(F9.262385777064733
F3.2111021677652993
tp12653
sS'if (this == that):\n    pass'
p12654
(F9.953792865459736
F3.689755121866862
tp12655
sS'import sys'
p12656
(F15.194439888000488
F3.00614865620931
tp12657
sS'if (this == that):\n    quit()'
p12658
(F9.183704630533855
F3.7981300354003906
tp12659
sS'import sys\nsys.exit()'
p12660
(F11.589154052734376
F3.0634822845458984
tp12661
sS'quit()'
p12662
(F6.478925323486328
F3.499678293863932
tp12663
sS'raise SystemExit'
p12664
(F14.571917724609374
F3.4084479014078775
tp12665
ssI1476
(dp12666
S"print int('01010101111', 2)"
p12667
(F9.090527004665798
F2.4426085732199927
tp12668
sS'21'
p12669
(F3.5226608912150064
F2.5836726101962
tp12670
sS"int('10101', 0)\nint('0b10101', 0)"
p12671
(F7.524918619791666
F2.4556149569424717
tp12672
sS'bin(21)'
p12673
(F7.174222310384114
F2.5272306962446733
tp12674
sS'47'
p12675
(F3.5226608912150064
F2.5836726101962
tp12676
sS"int('0b10101', 0)"
p12677
(F6.828094005584717
F2.461862737482244
tp12678
sS"int('010101', 2)"
p12679
(F7.026210308074951
F2.4653065421364526
tp12680
sS"int('0b0010101010', 2)"
p12681
(F7.026210308074951
F2.465306195345792
tp12682
sS"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))\nformat(int('010101', 2), '010b')"
p12683
(F9.796110365125868
F2.457131125710227
tp12684
sS'170\n21'
p12685
(F4.26951904296875
F2.5538447986949575
tp12686
sS"print int('01010101111', 2)\nprint int('11111111', 2)"
p12687
(F9.679182164809284
F2.45981181751598
tp12688
sS'bin(173)'
p12689
(F7.174222310384114
F2.5272306962446733
tp12690
sS"int('10101', 0)"
p12691
(F6.828094005584717
F2.461862737482244
tp12692
sS"format(int('010101', 2), '010b')"
p12693
(F8.396897536057692
F2.477378498424183
tp12694
sS"bin(int('010101', 2))"
p12695
(F8.526589827104049
F2.4858887412331323
tp12696
sS"format(int('010101', 2), '{fill}{width}b'.format(width=10, fill=0))"
p12697
(F9.862789789835611
F2.4647083282470703
tp12698
sS"print int('11111111', 2)"
p12699
(F9.090527004665798
F2.4426085732199927
tp12700
sS'170'
p12701
(F3.5226608912150064
F2.5836726101962
tp12702
ssI761804
(dp12703
S"'          Hello        '.strip()"
p12704
(F7.136821746826172
F1.5641606194632394
tp12705
sS"strip_one_space('   Hello ')"
p12706
(F13.662565612792969
F1.5145657403128487
tp12707
sS"'Bob has a cat'.strip()"
p12708
(F7.136821746826172
F1.5641606194632394
tp12709
sS"' Hello'.strip()\n'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12710
(F8.287952623869243
F1.5608575003487724
tp12711
sS"title = title.strip(',.-')"
p12712
(F10.546902465820313
F2.047967093331473
tp12713
sS"' Hello'.strip()"
p12714
(F7.136821746826172
F1.5641606194632394
tp12715
sS'myString.strip()'
p12716
(F12.14448070526123
F1.6861697605678014
tp12717
sS"' Hello '.strip()\n' Hello'.strip()\n'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12718
(F8.390065307617187
F1.5658807754516602
tp12719
sS"'Bob has a cat'.strip()\n'          Hello        '.strip()"
p12720
(F8.053692744328426
F1.5551861354282923
tp12721
sS"' Hello '.strip()\n' Hello'.strip()"
p12722
(F8.053692744328426
F1.5551861354282923
tp12723
sS"' Hello '.strip()\n' Hello'.strip()\n'Bob has a cat'.strip()"
p12724
(F8.287952623869243
F1.5608575003487724
tp12725
sS"' Hello'.strip()\n'Bob has a cat'.strip()"
p12726
(F8.053692744328426
F1.5551861354282923
tp12727
sS"' Hello '.strip()"
p12728
(F7.136821746826172
F1.5641606194632394
tp12729
sS"'  Hello\\n'.strip(' ')"
p12730
(F7.825927734375
F1.6050736563546317
tp12731
ssI4476373
(dp12732
S"payload = {'key1': 'value1', 'key2': 'value2', }"
p12733
(F5.216836111886161
F3.8954158782958985
tp12734
sS'return urllib2.Request(url, data=urllib.urlencode(params))'
p12735
(F13.148070441351997
F3.8197269439697266
tp12736
sS'r = requests.post(url, data=payload)\nimport json'
p12737
(F13.538306741153493
F3.8379589080810548
tp12738
sS'resp'
p12739
(F12.032618204752604
F4.042562866210938
tp12740
sS"return urllib2.Request(((url + '?') + urllib.urlencode(params)))"
p12741
(F11.843338012695312
F3.7841827392578127
tp12742
sS"(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12743
(F10.016168503534226
F3.894866943359375
tp12744
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12745
(F10.255005730523003
F3.8218765258789062
tp12746
sS"def URLRequest(url, params, method='GET'):\n    if (method == 'POST'):\n        return urllib2.Request(url, data=urllib.urlencode(params))"
p12747
(F12.333898370916193
F3.7601902008056642
tp12748
sS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12749
(F14.140228271484375
F3.8855941772460936
tp12750
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p12751
(F13.571536333133013
F3.844438171386719
tp12752
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12753
(F12.415566580636161
F3.844091796875
tp12754
sS"post_data = {'username': 'joeb', 'password': 'foobar', }"
p12755
(F7.295797824859619
F3.92968864440918
tp12756
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12757
(F13.701729910714286
F3.8531078338623046
tp12758
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12759
(F11.37289537702288
F3.830449676513672
tp12760
sS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))"
p12761
(F14.436733790806361
F3.8574493408203123
tp12762
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12763
(F10.422037523846294
F3.819307327270508
tp12764
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12765
(F13.750258127848307
F3.8489608764648438
tp12766
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12767
(F11.711983313927284
F3.8323429107666014
tp12768
sS'from httplib2 import Http\nfrom urllib import urlencode\nh = Http()'
p12769
(F15.99568625057445
F3.8910072326660154
tp12770
sS'import requests'
p12771
(F16.159189224243164
F3.7549205780029298
tp12772
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12773
(F10.878697809183373
F3.8412502288818358
tp12774
sS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12775
(F12.537821451822916
F3.835283660888672
tp12776
sS"import requests\nurl = 'https://...'"
p12777
(F11.116540908813477
F3.801586151123047
tp12778
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12779
(F12.249467250279018
F3.8411128997802733
tp12780
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12781
(F14.099853515625
F3.865381622314453
tp12782
sS"url = 'https://...'"
p12783
(F7.27416763305664
F3.9101234436035157
tp12784
sS'r.status_code'
p12785
(F14.59882572719029
F4.033326721191406
tp12786
sS'from httplib2 import Http'
p12787
(F18.00884755452474
F4.012109375
tp12788
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p12789
(F13.020590322989005
F3.8603286743164062
tp12790
sS'r = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12791
(F14.189049353966347
F3.8608055114746094
tp12792
sS'r = requests.get(url, params=payload)'
p12793
(F12.405725751604352
F3.8646896362304686
tp12794
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json"
p12795
(F11.66878703489142
F3.828643798828125
tp12796
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)"
p12797
(F9.93921127319336
F3.827336883544922
tp12798
sS'r = requests.post(url, data=payload)'
p12799
(F12.300079345703125
F3.8650646209716797
tp12800
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12801
(F11.681791178385417
F3.8752456665039063
tp12802
sS"def URLRequest(url, params, method='GET'):\n    pass"
p12803
(F12.481895045230264
F3.8934814453125
tp12804
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12805
(F8.364494655443275
F3.8001956939697266
tp12806
sS'from urllib import urlencode\nh = Http()'
p12807
(F14.148523966471354
F3.9066421508789064
tp12808
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12809
(F12.217696533203124
F3.887320709228516
tp12810
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12811
(F10.707793462844123
F3.969359588623047
tp12812
sS'r = requests.get(url)\nr = requests.get(url, params=payload)'
p12813
(F12.573374872622283
F3.85431022644043
tp12814
sS"post_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12815
(F11.289324079241071
F3.8823909759521484
tp12816
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12817
(F11.960668615392736
F3.8381168365478517
tp12818
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12819
(F12.493603515625
F3.872064971923828
tp12820
sS'r.text\nr.status_code'
p12821
(F13.73417802290483
F4.049049758911133
tp12822
sS"post_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12823
(F13.64025421142578
F3.849598693847656
tp12824
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12825
(F13.968437820184427
F3.8529434204101562
tp12826
sS"import requests\nget_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }"
p12827
(F11.2510986328125
F3.8285953521728517
tp12828
sS"if (method == 'POST'):\n    return urllib2.Request(url, data=urllib.urlencode(params))"
p12829
(F11.907442365373884
F3.756632614135742
tp12830
sS"post_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12831
(F13.869828796386718
F3.8363792419433596
tp12832
sS'r = requests.post(url, data=json.dumps(payload))\nr.text'
p12833
(F13.59852003014606
F3.857596588134766
tp12834
sS"import json\npost_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12835
(F14.97249132521609
F3.863780212402344
tp12836
sS"post_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))"
p12837
(F13.9049755859375
F3.8257514953613283
tp12838
sS"data = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12839
(F10.224609375
F3.9584426879882812
tp12840
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12841
(F8.205814502857349
F3.816572570800781
tp12842
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12843
(F14.116494985727163
F3.854486083984375
tp12844
sS'r.text'
p12845
(F12.929959106445313
F4.069440841674805
tp12846
sS"import requests\nget_response = requests.get(url='http://google.com')"
p12847
(F13.777172313017005
F3.821482467651367
tp12848
sS'from httplib2 import Http\nfrom urllib import urlencode'
p12849
(F19.498468572443183
F3.8288612365722656
tp12850
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12851
(F14.052816456761853
F3.8577171325683595
tp12852
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12853
(F11.197454958545919
F3.8428382873535156
tp12854
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))"
p12855
(F10.405661010742188
F3.9741546630859377
tp12856
sS'import json\nr = requests.post(url, data=json.dumps(payload))'
p12857
(F13.487804066051137
F3.8518638610839844
tp12858
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))"
p12859
(F12.152877213118913
F3.8395904541015624
tp12860
sS'r = requests.post(url, data=json.dumps(payload))'
p12861
(F12.740827058490954
F3.842293930053711
tp12862
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12863
(F12.694442749023438
F3.84716911315918
tp12864
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12865
(F13.925083445079292
F3.855440139770508
tp12866
sS'import json\nr = requests.post(url, data=json.dumps(payload))\nr.text'
p12867
(F14.237376286433292
F3.872136688232422
tp12868
sS"if (method == 'POST'):\n    pass"
p12869
(F8.226823073167067
F4.006239700317383
tp12870
sS"data = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12871
(F10.503812154134115
F3.953958511352539
tp12872
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)'
p12873
(F13.028481377495659
F3.855609893798828
tp12874
sS'import json'
p12875
(F15.63394832611084
F3.8377147674560548
tp12876
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12877
(F13.55344950358073
F3.8800514221191404
tp12878
sS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }\npost_response = requests.post(url='http://httpbin.org/post', data=post_data)"
p12879
(F12.187731424967447
F3.8592498779296873
tp12880
sS'r = requests.get(url)'
p12881
(F11.4808837890625
F3.852191925048828
tp12882
sS"get_response = requests.get(url='http://google.com')"
p12883
(F13.158185686383929
F3.884654998779297
tp12884
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)"
p12885
(F9.029684448242188
F3.8009918212890623
tp12886
sS"payload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12887
(F12.605147903029984
F3.8449378967285157
tp12888
sS"h = Http()\ndata = dict(name='Joe', comment='A test comment')"
p12889
(F9.697394561767577
F4.0496162414550785
tp12890
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)"
p12891
(F11.217027936662946
F3.8337940216064452
tp12892
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12893
(F12.316456330128204
F3.8418212890625
tp12894
sS'r = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))'
p12895
(F13.651008472108005
F3.848563385009766
tp12896
sS"get_response = requests.get(url='http://google.com')\npost_data = {'username': 'joeb', 'password': 'foobar', }"
p12897
(F10.56072892813847
F3.8968647003173826
tp12898
sS'h = Http()'
p12899
(F7.895573207310268
F4.128081893920898
tp12900
sS"from httplib2 import Http\nfrom urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12901
(F12.77776630108173
F3.87262077331543
tp12902
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }"
p12903
(F7.412097022646949
F3.7862171173095702
tp12904
sS'from urllib import urlencode'
p12905
(F18.958485921223957
F3.822536849975586
tp12906
sS"def URLRequest(url, params, method='GET'):\n    if (method == 'POST'):\n        pass"
p12907
(F11.085800697063577
F3.9368209838867188
tp12908
sS"(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12909
(F10.47851098102072
F3.890454864501953
tp12910
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text"
p12911
(F12.479645905671296
F3.8437881469726562
tp12912
sS"data = dict(name='Joe', comment='A test comment')"
p12913
(F8.83437728881836
F4.050352478027344
tp12914
sS"from urllib import urlencode\nh = Http()\ndata = dict(name='Joe', comment='A test comment')\n(resp, content) = h.request('http://bitworking.org/news/223/Meet-Ares', 'POST', urlencode(data))\nresp"
p12915
(F11.99723523728391
F3.874950408935547
tp12916
sS"url = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }"
p12917
(F5.808839162190755
F3.8734241485595704
tp12918
sS"import requests\nurl = 'https://...'\npayload = {'key1': 'value1', 'key2': 'value2', }\nr = requests.get(url)\nr = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json\nr = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code"
p12919
(F12.561206335308908
F3.8462554931640627
tp12920
sS"post_response = requests.post(url='http://httpbin.org/post', data=json.dumps(post_data))\npost_response = requests.post(url='http://httpbin.org/post', json=post_data)"
p12921
(F14.624561656605113
F3.829294204711914
tp12922
sS'r = requests.post(url, data=json.dumps(payload))\nr.text\nr.status_code'
p12923
(F13.649692930024246
F3.8658798217773436
tp12924
sS'r = requests.get(url, params=payload)\nr = requests.post(url, data=payload)\nimport json'
p12925
(F13.71189676920573
F3.8424339294433594
tp12926
ssI247770
(dp12927
S'import inspect\ninspect.getfile(os)'
p12928
(F14.57210887562145
F4.299096743265788
tp12929
sS'os.path.dirname(inspect.getfile(inspect))'
p12930
(F13.039483642578125
F4.169363975524902
tp12931
sS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p12932
(F14.369735717773438
F4.368801752726237
tp12933
sS'print os.getcwd()'
p12934
(F10.551824569702148
F4.145335833231608
tp12935
sS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)'
p12936
(F14.791897728329612
F4.107728322347005
tp12937
sS'path = os.path.abspath(amodule.__file__)'
p12938
(F13.64698600769043
F4.060566584269206
tp12939
sS'inspect.getfile(os)'
p12940
(F12.271905899047852
F4.36566956837972
tp12941
sS'import inspect'
p12942
(F15.751962661743164
F4.208241780598958
tp12943
sS'print __file__'
p12944
(F12.632898966471354
F4.278993606567383
tp12945
sS'print bar.__file__'
p12946
(F14.47097396850586
F4.231634775797526
tp12947
sS'import bar\nprint bar.__file__'
p12948
(F15.6977802623402
F4.189629236857097
tp12949
sS'inspect.getfile(os)\ninspect.getfile(inspect)'
p12950
(F13.079482014973959
F4.385913848876953
tp12951
sS'import inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12952
(F14.325682640075684
F4.272027333577474
tp12953
sS'import os\nimport inspect\ninspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12954
(F14.607448032924108
F4.066697756449382
tp12955
sS'import bar'
p12956
(F15.004105567932129
F4.195800145467122
tp12957
sS'path = os.path.dirname(amodule.__file__)'
p12958
(F13.64698600769043
F4.060566584269206
tp12959
sS'import a_module'
p12960
(F14.631904602050781
F4.268852869669597
tp12961
sS'import os'
p12962
(F14.760560989379883
F3.9276625315348306
tp12963
sS'import os\nimport inspect'
p12964
(F16.51504625592913
F3.9423866271972656
tp12965
sS'inspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12966
(F13.525942715731533
F4.2939027150472
tp12967
sS'import a_module\nprint a_module.__file__'
p12968
(F15.906439208984375
F4.240610122680664
tp12969
sS'import os\nprint os.getcwd()\nprint __file__'
p12970
(F12.837797164916992
F4.019602457682292
tp12971
sS'print a_module.__file__'
p12972
(F14.604739379882812
F4.207403500874837
tp12973
sS'import os\npath = os.path.dirname(amodule.__file__)'
p12974
(F14.400734349300986
F3.9415903091430664
tp12975
sS'import os\nprint os.getcwd()'
p12976
(F11.967199152166193
F3.983778635660807
tp12977
sS'inspect.getfile(inspect)'
p12978
(F12.277132987976074
F4.543720245361328
tp12979
sS'import os\nimport inspect\ninspect.getfile(os)'
p12980
(F15.16898672921317
F4.028177579243978
tp12981
sS'inspect.getfile(os)\ninspect.getfile(inspect)\nos.path.dirname(inspect.getfile(inspect))'
p12982
(F13.436161435883621
F4.243461926778157
tp12983
sS'print os.getcwd()\nprint __file__'
p12984
(F12.01138657789964
F4.159531911214192
tp12985
ssI4906977
(dp12986
S'print os.environ'
p12987
(F14.31854502360026
F2.917252404349191
tp12988
sS"print os.environ.get('KEY_THAT_MIGHT_EXIST')\nprint os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p12989
(F12.464315663213315
F3.051744188581194
tp12990
sS'import sys'
p12991
(F14.702789306640625
F3.0635781969342912
tp12992
sS"print os.environ.get('KEY_THAT_MIGHT_EXIST')"
p12993
(F11.313905195756393
F3.016270773751395
tp12994
sS"os.environ.has_key('HOME')"
p12995
(F12.995015462239584
F3.1923888070242747
tp12996
sS"print os.environ.get('HOME', '/home/username/')"
p12997
(F10.179800180288462
F3.024418694632394
tp12998
sS"('HOME' in os.environ)"
p12999
(F10.601069132486979
F3.0487709045410156
tp13000
sS"import os\nprint os.environ['HOME']"
p13001
(F11.96996815999349
F2.8741065434047153
tp13002
sS'import sys\nprint sys.prefix'
p13003
(F14.419308132595486
F3.012223379952567
tp13004
sS'import os\nprint os.environ'
p13005
(F15.194015502929688
F2.8162711007254466
tp13006
sS'import os'
p13007
(F15.400960922241211
F2.838594709123884
tp13008
sS"print os.getenv('KEY_THAT_MIGHT_EXIST', default_value)"
p13009
(F12.414726844200722
F3.213754108973912
tp13010
sS'print sys.prefix'
p13011
(F13.523658752441406
F3.046466827392578
tp13012
sS"print os.environ['HOME']"
p13013
(F10.506150987413195
F3.0139732360839844
tp13014
sS'os.environ'
p13015
(F12.153401184082032
F2.958856855119978
tp13016
ssI1186789
(dp13017
S"if (__name__ == '__main__'):\n    service_func()"
p13018
(F11.075592844109787
F1.6770795934340532
tp13019
sS"print 'test1.py'"
p13020
(F7.02918815612793
F1.660673926858341
tp13021
sS"def service_func():\n    print 'service func'"
p13022
(F10.556771414620536
F1.7026860854204964
tp13023
sS'def service_func():\n    pass'
p13024
(F11.366917536808895
F1.7064644308651196
tp13025
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()"
p13026
(F11.296088218688965
F1.7246175653794233
tp13027
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p13028
(F12.096538196910512
F1.6970837536980123
tp13029
sS'service_func()'
p13030
(F12.015012468610491
F1.7194887049057905
tp13031
sS'def some_func():\n    pass'
p13032
(F11.131473247821514
F1.7052982554716223
tp13033
sS"def some_func():\n    print 'in test 1, unproductive'\nif (__name__ == '__main__'):\n    pass"
p13034
(F10.846542358398438
F1.6973315968232996
tp13035
sS"print 'in test 1, unproductive'"
p13036
(F7.02918815612793
F1.660673926858341
tp13037
sS'import test1'
p13038
(F14.555089950561523
F1.6241820840274586
tp13039
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    pass"
p13040
(F10.972278050013951
F1.7060025159050436
tp13041
sS"subprocess.call('test1.py', shell=True)"
p13042
(F10.540160497029623
F1.6087914635153377
tp13043
sS"execfile('test2.py')"
p13044
(F5.6884918212890625
F1.7087067996754366
tp13045
sS"import test1\n\ndef service_func():\n    print 'service func'"
p13046
(F11.370168897840712
F1.6604594062356388
tp13047
sS'import subprocess'
p13048
(F15.622714042663574
F1.5510499617632698
tp13049
sS'import test1\n\ndef service_func():\n    pass'
p13050
(F12.01722807042739
F1.6656175501206343
tp13051
sS"print 'service func'"
p13052
(F7.02918815612793
F1.660673926858341
tp13053
sS"def some_func():\n    print 'in test 1, unproductive'\nif (__name__ == '__main__'):\n    some_func()"
p13054
(F11.112948417663574
F1.7211092780618107
tp13055
sS"if (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p13056
(F12.043566668475115
F1.6992593653061812
tp13057
sS"import subprocess\nsubprocess.call('test1.py', shell=True)"
p13058
(F11.832557169596354
F1.5940715565400965
tp13059
sS'some_func()'
p13060
(F11.631364004952568
F1.7356147766113281
tp13061
sS'test1.some_func()'
p13062
(F12.010294596354166
F1.7199022629681755
tp13063
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    pass"
p13064
(F11.306158065795898
F1.668020585004021
tp13065
sS"if (__name__ == '__main__'):\n    some_func()"
p13066
(F10.925254420230264
F1.6781964021570541
tp13067
sS"def service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()\ntest1.some_func()"
p13068
(F11.883393096923829
F1.7232815237606274
tp13069
sS"import test1\n\ndef service_func():\n    print 'service func'\nif (__name__ == '__main__'):\n    service_func()"
p13070
(F11.597324795193142
F1.6899202010210823
tp13071
sS"if (__name__ == '__main__'):\n    pass"
p13072
(F10.232386271158854
F1.6253722695743336
tp13073
sS"def some_func():\n    print 'in test 1, unproductive'"
p13074
(F10.333169119698661
F1.701645907233743
tp13075
ssI2407398
(dp13076
S'zip(list_a, list_b)'
p13077
(F14.338467915852865
F1.3434758867536272
tp13078
sS'list_b = [5, 6, 7, 8]'
p13079
(F8.776148478190104
F1.4606342315673828
tp13080
sS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]'
p13081
(F8.653608650996768
F1.397820200238909
tp13082
sS'list_a = [1, 2, 3, 4]\nlist_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p13083
(F10.58648223876953
F1.3386963435581751
tp13084
sS'list_a = [1, 2, 3, 4]'
p13085
(F8.277831013997396
F1.4532908030918665
tp13086
sS'list_b = [5, 6, 7, 8]\nzip(list_a, list_b)'
p13087
(F11.835852989783653
F1.334615843636649
tp13088
ssI19602931
(dp13089
S'testfile = urllib.URLopener()'
p13090
(F11.264009857177735
F3.826690967266376
tp13091
sS'file_name = wget.download(file_url)'
p13092
(F15.61464364188058
F3.7733791057880106
tp13093
sS'import urllib\ntestfile = urllib.URLopener()'
p13094
(F12.603145892803486
F3.7955765357384315
tp13095
sS"testfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p13096
(F10.818238107781662
F3.81131832416241
tp13097
sS"import wget\nfile_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p13098
(F16.01747463060462
F3.7742620614858775
tp13099
sS"urllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p13100
(F8.876128387451171
F3.8195577768179088
tp13101
sS"file_url = 'http://johndoe.com/download.zip'"
p13102
(F12.555714198521205
F3.7893987802358775
tp13103
sS'import wget'
p13104
(F18.276535034179688
F3.9677596459021935
tp13105
sS"testfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p13106
(F8.505013275146485
F3.859603294959435
tp13107
sS"file_url = 'http://johndoe.com/download.zip'\nfile_name = wget.download(file_url)"
p13108
(F15.276861572265625
F3.790043464073768
tp13109
sS"import wget\nfile_url = 'http://johndoe.com/download.zip'"
p13110
(F15.411160278320313
F3.8151280329777646
tp13111
sS'import urllib'
p13112
(F15.688822746276855
F3.797364455003005
tp13113
sS"import urllib\nurllib.urlretrieve('http://randomsite.com/file.gz', 'file.gz')"
p13114
(F10.74642122708834
F3.7697199307955227
tp13115
sS"import urllib\ntestfile = urllib.URLopener()\ntestfile.retrieve('http://randomsite.com/file.gz', 'file.gz')"
p13116
(F11.392022566361861
F3.777435302734375
tp13117
ssI4588628
(dp13118
S'(a == 0)'
p13119
(F7.898464747837612
F4.239838282267253
tp13120
sS'numpy.where((x == 0))[0]'
p13121
(F9.721371459960938
F3.620168368021647
tp13122
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\nnumpy.where((x == 0))[0]'
p13123
(F8.578304788340693
F3.632612864176432
tp13124
sS'a = np.asarray([0, 1, 2, 3, 4])\n(a == 0)'
p13125
(F8.562562208909254
F3.648909250895182
tp13126
sS'(x == 0)\nnumpy.nonzero((x == 0))[0]'
p13127
(F9.365905035109748
F3.717461903889974
tp13128
sS'numpy.nonzero((x == 0))[0]'
p13129
(F9.660421752929688
F3.6385135650634766
tp13130
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\n(x == 0)\nnumpy.nonzero((x == 0))[0]'
p13131
(F8.455133291391226
F3.673136075337728
tp13132
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])'
p13133
(F7.599628448486328
F3.6714795430501304
tp13134
sS'(x == 0)'
p13135
(F7.751091548374721
F4.277807871500651
tp13136
sS'x = numpy.array([1, 0, 2, 0, 3, 0, 4, 5, 6, 7, 8])\n(x == 0)'
p13137
(F7.760551051089638
F3.7043469746907554
tp13138
sS'a = np.asarray([0, 1, 2, 3, 4])'
p13139
(F8.547941589355469
F3.617417653401693
tp13140
ss.